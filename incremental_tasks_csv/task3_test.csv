cve_id,cwe_ids,cvss_vector,cvss_is_v3,repo_name,commit_msg,commit_hash,git_url,file_path,func_name,func_before,abstract_func_before,func_graph_path_before,func,abstract_func,func_graph_path,diff_func,diff_line_info,is_vul,description,Base Score,Base Severity,severity,source,commit_time,task
CVE-2019-16350,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,rockcarry/ffjpeg,"modify huffman.c jfif.c

fix github issue #10, #11, and #12",b3039ae8022da67078c130bd19bc3008a037adb3,https://github.com/rockcarry/ffjpeg/commit/b3039ae8022da67078c130bd19bc3008a037adb3,huffman.c,huffman_decode_step,"int huffman_decode_step(HUFCODEC *phc)
{
int bit;
int code = 0;
int len  = 0;
int idx  = 0;
if (!phc->input) return EOF;
while (1) {
bit = bitstr_getb(phc->input);
if ( bit == EOF) return EOF;
code <<= 1; code |= bit;
if (code - phc->first[len] < phc->huftab[len]) break;
if (++len == MAX_HUFFMAN_CODE_LEN) return EOF;
}
idx = phc->index[len] + (code - phc->first[len]);
return idx < MAX_HUFFMAN_CODE_LEN + 256 ? phc->huftab[idx] : EOF;
}","int huffman_decode_step(HUFCODEC *VAR_0)
{
int VAR_1;
int VAR_2 = 0;
int VAR_3  = 0;
int VAR_4  = 0;
if (!VAR_0->input) return VAR_5;
while (1) {
VAR_1 = bitstr_getb(VAR_0->input);
if ( VAR_1 == VAR_5) return VAR_5;
VAR_2 <<= 1; VAR_2 |= VAR_1;
if (VAR_2 - VAR_0->first[VAR_3] < VAR_0->huftab[VAR_3]) break;
if (++VAR_3 == VAR_6) return VAR_5;
}
VAR_4 = VAR_0->index[VAR_3] + (VAR_2 - VAR_0->first[VAR_3]);
return VAR_4 < VAR_6 + 256 ? VAR_0->huftab[VAR_4] : VAR_5;
}",rockcarry/ffjpeg/b3039ae8022da67078c130bd19bc3008a037adb3/huffman.c/vul/before/0.json,"int huffman_decode_step(HUFCODEC *phc)
{
    int bit;
    int code = 0;
    int len  = 0;
    int idx  = 0;

    /* 检查输入输出数据流的有效性 */
    if (!phc || !phc->input) return EOF;

    /* 从输入流读取码字 */
    while (1) {
        bit = bitstr_getb(phc->input);
        if ( bit == EOF) return EOF;
//      printf(""%d, first = %d, len = %d\n"", bit ? 1 : 0, phc->first[len], len);
        code <<= 1; code |= bit;
        if (code - phc->first[len] < phc->huftab[len]) break;
        if (++len == MAX_HUFFMAN_CODE_LEN) return EOF;
    }

    idx = phc->index[len] + (code - phc->first[len]);
//  printf(""get code:%c len:%d, idx:%d\n\n"", phc->huftab[idx], len, idx);
    return idx < MAX_HUFFMAN_CODE_LEN + 256 ? phc->huftab[idx] : EOF;
}","int huffman_decode_step(HUFCODEC *VAR_0)
{
    int VAR_1;
    int VAR_2 = 0;
    int VAR_3  = 0;
    int VAR_4  = 0;

    /* COMMENT_0 */
    if (!VAR_0 || !VAR_0->input) return VAR_5;

    /* COMMENT_1 */
    while (1) {
        VAR_1 = bitstr_getb(VAR_0->input);
        if ( VAR_1 == VAR_5) return VAR_5;
/* COMMENT_2 */
        VAR_2 <<= 1; VAR_2 |= VAR_1;
        if (VAR_2 - VAR_0->first[VAR_3] < VAR_0->huftab[VAR_3]) break;
        if (++VAR_3 == VAR_6) return VAR_5;
    }

    VAR_4 = VAR_0->index[VAR_3] + (VAR_2 - VAR_0->first[VAR_3]);
/* COMMENT_3 */
    return VAR_4 < VAR_6 + 256 ? VAR_0->huftab[VAR_4] : VAR_5;
}",rockcarry/ffjpeg/b3039ae8022da67078c130bd19bc3008a037adb3/huffman.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
     int idx  = 0;
 
     /* 检查输入输出数据流的有效性 */
-    if (!phc->input) return EOF;
+    if (!phc || !phc->input) return EOF;
 
     /* 从输入流读取码字 */
     while (1) {","{'deleted_lines': ['    if (!phc->input) return EOF;'], 'added_lines': ['    if (!phc || !phc->input) return EOF;']}",True,ffjpeg before 2019-08-18 has a NULL pointer dereference in idct2d8x8() at dct.c.,6.5,MEDIUM,1,test,2019-08-19T01:32:59Z,3
CVE-2019-16350,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,rockcarry/ffjpeg,"modify huffman.c jfif.c

fix github issue #10, #11, and #12",b3039ae8022da67078c130bd19bc3008a037adb3,https://github.com/rockcarry/ffjpeg/commit/b3039ae8022da67078c130bd19bc3008a037adb3,jfif.c,jfif_load,"void* jfif_load(char *file)
{
JFIF *jfif   = NULL;
FILE *fp     = NULL;
int   header = 0;
int   type   = 0;
WORD  size   = 0;
BYTE *buf    = NULL;
int   ret    =-1;
long  offset = 0;
int   i;
jfif = calloc(1, sizeof(JFIF));
buf  = calloc(1, 0x10000);
if (!jfif || !buf) goto done;
fp = fopen(file, ""rb"");
if (!fp) goto done;
while (1) {
do { header = fgetc(fp); } while (header != EOF && header != 0xff);         do { type   = fgetc(fp); } while (type   != EOF && type   == 0xff);         if (header == EOF || type == EOF) {
printf(""file eof !\n"");
break;
}
if ((type == 0xd8) || (type == 0xd9) || (type == 0x01) || (type >= 0xd0 && type <= 0xd7)) {
size = 0;
} else {
size  = fgetc(fp) << 8;
size |= fgetc(fp) << 0;
size -= 2;
}
fread(buf, size, 1, fp);
switch (type) {
case 0xc0:             jfif->width    = (buf[3] << 8) | (buf[4] << 0);
jfif->height   = (buf[1] << 8) | (buf[2] << 0);
jfif->comp_num = buf[5];
for (i=0; i<jfif->comp_num; i++) {
jfif->comp_info[i].id = buf[6 + i * 3];
jfif->comp_info[i].samp_factor_v = (buf[7 + i * 3] >> 0) & 0x0f;
jfif->comp_info[i].samp_factor_h = (buf[7 + i * 3] >> 4) & 0x0f;
jfif->comp_info[i].qtab_idx      =  buf[8 + i * 3];
}
break;
case 0xda:             jfif->comp_num = buf[0];
for (i=0; i<jfif->comp_num; i++) {
jfif->comp_info[i].id = buf[1 + i * 2];
jfif->comp_info[i].htab_idx_ac = (buf[2 + i * 2] >> 0) & 0x0f;
jfif->comp_info[i].htab_idx_dc = (buf[2 + i * 2] >> 4) & 0x0f;
}
offset = ftell(fp);
ret    = 0;
goto read_data;
break;
case 0xdb: {                 BYTE *dqt = buf;
while (size >= 65) {
int idx = dqt[0] & 0x0f;
int f16 = dqt[0] & 0xf0;
if (!jfif->pqtab[idx]) jfif->pqtab[idx] = malloc(64 * sizeof(int));
if (!jfif->pqtab[idx]) break;
if (f16) {                         for (i=0; i<64; i++) {
jfif->pqtab[idx][ZIGZAG[i]] = (dqt[1 + i * 2] << 8) | (dqt[2 + i * 2] << 0);
}
} else {                         for (i=0; i<64; i++) {
jfif->pqtab[idx][ZIGZAG[i]] = dqt[1 + i];
}
}
size -= 1 + 64 * (f16 ? 2 : 1);
dqt  += 1 + 64 * (f16 ? 2 : 1);
}
}
break;
case 0xc4: {                 BYTE *dht = buf;
while (size >= 17) {
int idx  = dht[0] & 0x0f;
int fac  = dht[0] & 0xf0;
int len  = 0;
for (i=1; i<1+16; i++) len += dht[i];
if (fac) {
if (!jfif->phcac[idx]) jfif->phcac[idx] = calloc(1, sizeof(HUFCODEC));
if ( jfif->phcac[idx]) memcpy(jfif->phcac[idx]->huftab, &dht[1], 16 + len);
} else {
if (!jfif->phcdc[idx]) jfif->phcdc[idx] = calloc(1, sizeof(HUFCODEC));
if ( jfif->phcdc[idx]) memcpy(jfif->phcdc[idx]->huftab, &dht[1], 16 + len);
}
size -= 17 + len;
dht  += 17 + len;
}
}
break;
}
}
read_data:
fseek(fp, 0, SEEK_END);
jfif->datalen = ftell(fp) - offset;
jfif->databuf = malloc(jfif->datalen);
if (jfif->databuf) {
fseek(fp, offset, SEEK_SET);
fread(jfif->databuf, jfif->datalen, 1, fp);
}
done:
if (buf) free  (buf);
if (fp ) fclose(fp );
if (ret == -1) {
jfif_free(jfif);
jfif = NULL;
}
return jfif;
}","void* jfif_load(char *VAR_0)
{
JFIF *VAR_1   = NULL;
FILE *VAR_2     = NULL;
int   VAR_3 = 0;
int   VAR_4   = 0;
WORD  VAR_5   = 0;
BYTE *VAR_6    = NULL;
int   VAR_7    =-1;
long  VAR_8 = 0;
int   VAR_9;
VAR_1 = calloc(1, sizeof(JFIF));
VAR_6  = calloc(1, 0x10000);
if (!VAR_1 || !VAR_6) goto done;
VAR_2 = fopen(VAR_0, ""rb"");
if (!VAR_2) goto done;
while (1) {
do { VAR_3 = fgetc(VAR_2); } while (VAR_3 != VAR_10 && VAR_3 != 0xff); 
do { VAR_4   = fgetc(VAR_2); } while (VAR_4   != VAR_10 && VAR_4   == 0xff); 
if (VAR_3 == VAR_10 || VAR_4 == VAR_10) {
printf(""file eof !\n"");
break;
}
if ((VAR_4 == 0xd8) || (VAR_4 == 0xd9) || (VAR_4 == 0x01) || (VAR_4 >= 0xd0 && VAR_4 <= 0xd7)) {
VAR_5 = 0;
} else {
VAR_5  = fgetc(VAR_2) << 8;
VAR_5 |= fgetc(VAR_2) << 0;
VAR_5 -= 2;
}
fread(VAR_6, VAR_5, 1, VAR_2);
switch (VAR_4) {
case 0xc0: 
VAR_1->width    = (VAR_6[3] << 8) | (VAR_6[4] << 0);
VAR_1->height   = (VAR_6[1] << 8) | (VAR_6[2] << 0);
VAR_1->comp_num = VAR_6[5];
for (VAR_9=0; VAR_9<VAR_1->comp_num; VAR_9++) {
VAR_1->comp_info[VAR_9].id = VAR_6[6 + VAR_9 * 3];
VAR_1->comp_info[VAR_9].samp_factor_v = (VAR_6[7 + VAR_9 * 3] >> 0) & 0x0f;
VAR_1->comp_info[VAR_9].samp_factor_h = (VAR_6[7 + VAR_9 * 3] >> 4) & 0x0f;
VAR_1->comp_info[VAR_9].qtab_idx      =  VAR_6[8 + VAR_9 * 3];
}
break;
case 0xda: 
VAR_1->comp_num = VAR_6[0];
for (VAR_9=0; VAR_9<VAR_1->comp_num; VAR_9++) {
VAR_1->comp_info[VAR_9].id = VAR_6[1 + VAR_9 * 2];
VAR_1->comp_info[VAR_9].htab_idx_ac = (VAR_6[2 + VAR_9 * 2] >> 0) & 0x0f;
VAR_1->comp_info[VAR_9].htab_idx_dc = (VAR_6[2 + VAR_9 * 2] >> 4) & 0x0f;
}
VAR_8 = ftell(VAR_2);
VAR_7    = 0;
goto read_data;
break;
case 0xdb: { 
BYTE *VAR_11 = VAR_6;
while (VAR_5 >= 65) {
int VAR_12 = VAR_11[0] & 0x0f;
int VAR_13 = VAR_11[0] & 0xf0;
if (!VAR_1->pqtab[VAR_12]) VAR_1->pqtab[VAR_12] = malloc(64 * sizeof(int));
if (!VAR_1->pqtab[VAR_12]) break;
if (VAR_13) { 
for (VAR_9=0; VAR_9<64; VAR_9++) {
VAR_1->pqtab[VAR_12][VAR_14[VAR_9]] = (VAR_11[1 + VAR_9 * 2] << 8) | (VAR_11[2 + VAR_9 * 2] << 0);
}
} else { 
for (VAR_9=0; VAR_9<64; VAR_9++) {
VAR_1->pqtab[VAR_12][VAR_14[VAR_9]] = VAR_11[1 + VAR_9];
}
}
VAR_5 -= 1 + 64 * (VAR_13 ? 2 : 1);
VAR_11  += 1 + 64 * (VAR_13 ? 2 : 1);
}
}
break;
case 0xc4: { 
BYTE *VAR_15 = VAR_6;
while (VAR_5 >= 17) {
int VAR_12  = VAR_15[0] & 0x0f;
int VAR_16  = VAR_15[0] & 0xf0;
int VAR_17  = 0;
for (VAR_9=1; VAR_9<1+16; VAR_9++) VAR_17 += VAR_15[VAR_9];
if (VAR_16) {
if (!VAR_1->phcac[VAR_12]) VAR_1->phcac[VAR_12] = calloc(1, sizeof(VAR_18));
if ( VAR_1->phcac[VAR_12]) memcpy(VAR_1->phcac[VAR_12]->huftab, &VAR_15[1], 16 + VAR_17);
} else {
if (!VAR_1->phcdc[VAR_12]) VAR_1->phcdc[VAR_12] = calloc(1, sizeof(VAR_18));
if ( VAR_1->phcdc[VAR_12]) memcpy(VAR_1->phcdc[VAR_12]->huftab, &VAR_15[1], 16 + VAR_17);
}
VAR_5 -= 17 + VAR_17;
VAR_15  += 17 + VAR_17;
}
}
break;
}
}
read_data:
fseek(VAR_2, 0, VAR_19);
VAR_1->datalen = ftell(VAR_2) - VAR_8;
VAR_1->databuf = malloc(VAR_1->datalen);
if (VAR_1->databuf) {
fseek(VAR_2, VAR_8, VAR_20);
fread(VAR_1->databuf, VAR_1->datalen, 1, VAR_2);
}
done:
if (VAR_6) free  (VAR_6);
if (VAR_2 ) fclose(VAR_2 );
if (VAR_7 == -1) {
jfif_free(VAR_1);
VAR_1 = NULL;
}
return VAR_1;
}",rockcarry/ffjpeg/b3039ae8022da67078c130bd19bc3008a037adb3/jfif.c/vul/before/0.json,"void* jfif_load(char *file)
{
    JFIF *jfif   = NULL;
    FILE *fp     = NULL;
    int   header = 0;
    int   type   = 0;
    WORD  size   = 0;
    BYTE *buf    = NULL;
    int   ret    =-1;
    long  offset = 0;
    int   i;

    jfif = calloc(1, sizeof(JFIF));
    buf  = calloc(1, 0x10000);
    if (!jfif || !buf) goto done;

    fp = fopen(file, ""rb"");
    if (!fp) goto done;

    while (1) {
        do { header = fgetc(fp); } while (header != EOF && header != 0xff); // get header
        do { type   = fgetc(fp); } while (type   != EOF && type   == 0xff); // get type
        if (header == EOF || type == EOF) {
            printf(""file eof !\n"");
            break;
        }

        if ((type == 0xd8) || (type == 0xd9) || (type == 0x01) || (type >= 0xd0 && type <= 0xd7)) {
            size = 0;
        } else {
            size  = fgetc(fp) << 8;
            size |= fgetc(fp) << 0;
            size -= 2;
        }

        fread(buf, size, 1, fp);
        switch (type) {
        case 0xc0: // SOF0
            jfif->width    = (buf[3] << 8) | (buf[4] << 0);
            jfif->height   = (buf[1] << 8) | (buf[2] << 0);
            jfif->comp_num =  buf[5] < 4 ? buf[5] : 4;
            for (i=0; i<jfif->comp_num; i++) {
                jfif->comp_info[i].id = buf[6 + i * 3];
                jfif->comp_info[i].samp_factor_v = (buf[7 + i * 3] >> 0) & 0x0f;
                jfif->comp_info[i].samp_factor_h = (buf[7 + i * 3] >> 4) & 0x0f;
                jfif->comp_info[i].qtab_idx      =  buf[8 + i * 3] & 0x0f;
            }
            break;

        case 0xda: // SOS
            jfif->comp_num = buf[0];
            for (i=0; i<jfif->comp_num; i++) {
                jfif->comp_info[i].id = buf[1 + i * 2];
                jfif->comp_info[i].htab_idx_ac = (buf[2 + i * 2] >> 0) & 0x0f;
                jfif->comp_info[i].htab_idx_dc = (buf[2 + i * 2] >> 4) & 0x0f;
            }
            offset = ftell(fp);
            ret    = 0;
            goto read_data;
            break;

        case 0xdb: { // DQT
                BYTE *dqt = buf;
                while (size >= 65) {
                    int idx = dqt[0] & 0x0f;
                    int f16 = dqt[0] & 0xf0;
                    if (!jfif->pqtab[idx]) jfif->pqtab[idx] = malloc(64 * sizeof(int));
                    if (!jfif->pqtab[idx]) break;
                    if (f16) { // 16bit
                        for (i=0; i<64; i++) {
                            jfif->pqtab[idx][ZIGZAG[i]] = (dqt[1 + i * 2] << 8) | (dqt[2 + i * 2] << 0);
                        }
                    } else { // 8bit
                        for (i=0; i<64; i++) {
                            jfif->pqtab[idx][ZIGZAG[i]] = dqt[1 + i];
                        }
                    }
                    size -= 1 + 64 * (f16 ? 2 : 1);
                    dqt  += 1 + 64 * (f16 ? 2 : 1);
                }
            }
            break;

        case 0xc4: { // DHT
                BYTE *dht = buf;
                while (size >= 17) {
                    int idx  = dht[0] & 0x0f;
                    int fac  = dht[0] & 0xf0;
                    int len  = 0;
                    for (i=1; i<1+16; i++) len += dht[i];
                    if (fac) {
                        if (!jfif->phcac[idx]) jfif->phcac[idx] = calloc(1, sizeof(HUFCODEC));
                        if ( jfif->phcac[idx]) memcpy(jfif->phcac[idx]->huftab, &dht[1], 16 + len);
                    } else {
                        if (!jfif->phcdc[idx]) jfif->phcdc[idx] = calloc(1, sizeof(HUFCODEC));
                        if ( jfif->phcdc[idx]) memcpy(jfif->phcdc[idx]->huftab, &dht[1], 16 + len);
                    }
                    size -= 17 + len;
                    dht  += 17 + len;
                }
            }
            break;
        }
    }

read_data:
    fseek(fp, 0, SEEK_END);
    jfif->datalen = ftell(fp) - offset;
    jfif->databuf = malloc(jfif->datalen);
    if (jfif->databuf) {
        fseek(fp, offset, SEEK_SET);
        fread(jfif->databuf, jfif->datalen, 1, fp);
    }

done:
    if (buf) free  (buf);
    if (fp ) fclose(fp );
    if (ret == -1) {
        jfif_free(jfif);
        jfif = NULL;
    }
    return jfif;
}","void* jfif_load(char *VAR_0)
{
    JFIF *VAR_1   = NULL;
    FILE *VAR_2     = NULL;
    int   VAR_3 = 0;
    int   VAR_4   = 0;
    WORD  VAR_5   = 0;
    BYTE *VAR_6    = NULL;
    int   VAR_7    =-1;
    long  VAR_8 = 0;
    int   VAR_9;

    VAR_1 = calloc(1, sizeof(JFIF));
    VAR_6  = calloc(1, 0x10000);
    if (!VAR_1 || !VAR_6) goto done;

    VAR_2 = fopen(VAR_0, ""rb"");
    if (!VAR_2) goto done;

    while (1) {
        do { VAR_3 = fgetc(VAR_2); } while (VAR_3 != VAR_10 && VAR_3 != 0xff); /* COMMENT_0 */
        do { VAR_4   = fgetc(VAR_2); } while (VAR_4   != VAR_10 && VAR_4   == 0xff); /* COMMENT_1 */
        if (VAR_3 == VAR_10 || VAR_4 == VAR_10) {
            printf(""file eof !\n"");
            break;
        }

        if ((VAR_4 == 0xd8) || (VAR_4 == 0xd9) || (VAR_4 == 0x01) || (VAR_4 >= 0xd0 && VAR_4 <= 0xd7)) {
            VAR_5 = 0;
        } else {
            VAR_5  = fgetc(VAR_2) << 8;
            VAR_5 |= fgetc(VAR_2) << 0;
            VAR_5 -= 2;
        }

        fread(VAR_6, VAR_5, 1, VAR_2);
        switch (VAR_4) {
        case 0xc0: /* COMMENT_2 */
            VAR_1->width    = (VAR_6[3] << 8) | (VAR_6[4] << 0);
            VAR_1->height   = (VAR_6[1] << 8) | (VAR_6[2] << 0);
            VAR_1->comp_num =  VAR_6[5] < 4 ? VAR_6[5] : 4;
            for (VAR_9=0; VAR_9<VAR_1->comp_num; VAR_9++) {
                VAR_1->comp_info[VAR_9].id = VAR_6[6 + VAR_9 * 3];
                VAR_1->comp_info[VAR_9].samp_factor_v = (VAR_6[7 + VAR_9 * 3] >> 0) & 0x0f;
                VAR_1->comp_info[VAR_9].samp_factor_h = (VAR_6[7 + VAR_9 * 3] >> 4) & 0x0f;
                VAR_1->comp_info[VAR_9].qtab_idx      =  VAR_6[8 + VAR_9 * 3] & 0x0f;
            }
            break;

        case 0xda: /* COMMENT_3 */
            VAR_1->comp_num = VAR_6[0];
            for (VAR_9=0; VAR_9<VAR_1->comp_num; VAR_9++) {
                VAR_1->comp_info[VAR_9].id = VAR_6[1 + VAR_9 * 2];
                VAR_1->comp_info[VAR_9].htab_idx_ac = (VAR_6[2 + VAR_9 * 2] >> 0) & 0x0f;
                VAR_1->comp_info[VAR_9].htab_idx_dc = (VAR_6[2 + VAR_9 * 2] >> 4) & 0x0f;
            }
            VAR_8 = ftell(VAR_2);
            VAR_7    = 0;
            goto read_data;
            break;

        case 0xdb: { /* COMMENT_4 */
                BYTE *VAR_11 = VAR_6;
                while (VAR_5 >= 65) {
                    int VAR_12 = VAR_11[0] & 0x0f;
                    int VAR_13 = VAR_11[0] & 0xf0;
                    if (!VAR_1->pqtab[VAR_12]) VAR_1->pqtab[VAR_12] = malloc(64 * sizeof(int));
                    if (!VAR_1->pqtab[VAR_12]) break;
                    if (VAR_13) { /* COMMENT_5 */
                        for (VAR_9=0; VAR_9<64; VAR_9++) {
                            VAR_1->pqtab[VAR_12][VAR_14[VAR_9]] = (VAR_11[1 + VAR_9 * 2] << 8) | (VAR_11[2 + VAR_9 * 2] << 0);
                        }
                    } else { /* COMMENT_6 */
                        for (VAR_9=0; VAR_9<64; VAR_9++) {
                            VAR_1->pqtab[VAR_12][VAR_14[VAR_9]] = VAR_11[1 + VAR_9];
                        }
                    }
                    VAR_5 -= 1 + 64 * (VAR_13 ? 2 : 1);
                    VAR_11  += 1 + 64 * (VAR_13 ? 2 : 1);
                }
            }
            break;

        case 0xc4: { /* COMMENT_7 */
                BYTE *VAR_15 = VAR_6;
                while (VAR_5 >= 17) {
                    int VAR_12  = VAR_15[0] & 0x0f;
                    int VAR_16  = VAR_15[0] & 0xf0;
                    int VAR_17  = 0;
                    for (VAR_9=1; VAR_9<1+16; VAR_9++) VAR_17 += VAR_15[VAR_9];
                    if (VAR_16) {
                        if (!VAR_1->phcac[VAR_12]) VAR_1->phcac[VAR_12] = calloc(1, sizeof(VAR_18));
                        if ( VAR_1->phcac[VAR_12]) memcpy(VAR_1->phcac[VAR_12]->huftab, &VAR_15[1], 16 + VAR_17);
                    } else {
                        if (!VAR_1->phcdc[VAR_12]) VAR_1->phcdc[VAR_12] = calloc(1, sizeof(VAR_18));
                        if ( VAR_1->phcdc[VAR_12]) memcpy(VAR_1->phcdc[VAR_12]->huftab, &VAR_15[1], 16 + VAR_17);
                    }
                    VAR_5 -= 17 + VAR_17;
                    VAR_15  += 17 + VAR_17;
                }
            }
            break;
        }
    }

read_data:
    fseek(VAR_2, 0, VAR_19);
    VAR_1->datalen = ftell(VAR_2) - VAR_8;
    VAR_1->databuf = malloc(VAR_1->datalen);
    if (VAR_1->databuf) {
        fseek(VAR_2, VAR_8, VAR_20);
        fread(VAR_1->databuf, VAR_1->datalen, 1, VAR_2);
    }

done:
    if (VAR_6) free  (VAR_6);
    if (VAR_2 ) fclose(VAR_2 );
    if (VAR_7 == -1) {
        jfif_free(VAR_1);
        VAR_1 = NULL;
    }
    return VAR_1;
}",rockcarry/ffjpeg/b3039ae8022da67078c130bd19bc3008a037adb3/jfif.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -38,12 +38,12 @@
         case 0xc0: // SOF0
             jfif->width    = (buf[3] << 8) | (buf[4] << 0);
             jfif->height   = (buf[1] << 8) | (buf[2] << 0);
-            jfif->comp_num = buf[5];
+            jfif->comp_num =  buf[5] < 4 ? buf[5] : 4;
             for (i=0; i<jfif->comp_num; i++) {
                 jfif->comp_info[i].id = buf[6 + i * 3];
                 jfif->comp_info[i].samp_factor_v = (buf[7 + i * 3] >> 0) & 0x0f;
                 jfif->comp_info[i].samp_factor_h = (buf[7 + i * 3] >> 4) & 0x0f;
-                jfif->comp_info[i].qtab_idx      =  buf[8 + i * 3];
+                jfif->comp_info[i].qtab_idx      =  buf[8 + i * 3] & 0x0f;
             }
             break;
 ","{'deleted_lines': ['            jfif->comp_num = buf[5];', '                jfif->comp_info[i].qtab_idx      =  buf[8 + i * 3];'], 'added_lines': ['            jfif->comp_num =  buf[5] < 4 ? buf[5] : 4;', '                jfif->comp_info[i].qtab_idx      =  buf[8 + i * 3] & 0x0f;']}",True,ffjpeg before 2019-08-18 has a NULL pointer dereference in idct2d8x8() at dct.c.,6.5,MEDIUM,1,test,2019-08-19T01:32:59Z,3
CVE-2019-15651,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,wolfSSL/wolfssl,sanity check on buffer size,c6e4aebcdff4e774c94953ffe9de7ce287c54f4f,https://github.com/wolfSSL/wolfssl/commit/c6e4aebcdff4e774c94953ffe9de7ce287c54f4f,wolfcrypt/src/asn.c,DecodeOcspRespExtensions,"static int DecodeOcspRespExtensions(byte* source,
word32* ioIndex, OcspResponse* resp, word32 sz)
{
word32 idx = *ioIndex;
int length;
int ext_bound; 
word32 oid;
int ret;
WOLFSSL_ENTER(""DecodeOcspRespExtensions"");
if ((idx + 1) > sz)
return BUFFER_E;
if (source[idx++] != (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 1))
return ASN_PARSE_E;
if (GetLength(source, &idx, &length, sz) < 0)
return ASN_PARSE_E;
if (GetSequence(source, &idx, &length, sz) < 0)
return ASN_PARSE_E;
ext_bound = idx + length;
while (idx < (word32)ext_bound) {
if (GetSequence(source, &idx, &length, sz) < 0) {
WOLFSSL_MSG(""\tfail: should be a SEQUENCE"");
return ASN_PARSE_E;
}
oid = 0;
if (GetObjectId(source, &idx, &oid, oidOcspType, sz) < 0) {
WOLFSSL_MSG(""\tfail: OBJECT ID"");
return ASN_PARSE_E;
}
if (source[idx] == ASN_BOOLEAN) {
WOLFSSL_MSG(""\tfound optional critical flag, moving past"");
ret = GetBoolean(source, &idx, sz);
if (ret < 0)
return ret;
}
ret = GetOctetString(source, &idx, &length, sz);
if (ret < 0)
return ret;
if (oid == OCSP_NONCE_OID) {
ret = GetOctetString(source, &idx, &length, sz);
if (ret < 0)
return ret;
resp->nonce = source + idx;
resp->nonceSz = length;
}
idx += length;
}
*ioIndex = idx;
return 0;
}","static int DecodeOcspRespExtensions(byte* VAR_0,
word32* VAR_1, OcspResponse* VAR_2, word32 VAR_3)
{
word32 VAR_4 = *VAR_1;
int VAR_5;
int VAR_6; 
word32 VAR_7;
int VAR_8;
WOLFSSL_ENTER(""DecodeOcspRespExtensions"");
if ((VAR_4 + 1) > VAR_3)
return VAR_9;
if (VAR_0[VAR_4++] != (VAR_10 | VAR_11 | 1))
return VAR_12;
if (GetLength(VAR_0, &VAR_4, &VAR_5, VAR_3) < 0)
return VAR_12;
if (GetSequence(VAR_0, &VAR_4, &VAR_5, VAR_3) < 0)
return VAR_12;
VAR_6 = VAR_4 + VAR_5;
while (VAR_4 < (word32)VAR_6) {
if (GetSequence(VAR_0, &VAR_4, &VAR_5, VAR_3) < 0) {
WOLFSSL_MSG(""\tfail: should be a SEQUENCE"");
return VAR_12;
}
VAR_7 = 0;
if (GetObjectId(VAR_0, &VAR_4, &VAR_7, VAR_13, VAR_3) < 0) {
WOLFSSL_MSG(""\tfail: OBJECT ID"");
return VAR_12;
}
if (VAR_0[VAR_4] == VAR_14) {
WOLFSSL_MSG(""\tfound optional critical flag, moving past"");
VAR_8 = GetBoolean(VAR_0, &VAR_4, VAR_3);
if (VAR_8 < 0)
return VAR_8;
}
VAR_8 = GetOctetString(VAR_0, &VAR_4, &VAR_5, VAR_3);
if (VAR_8 < 0)
return VAR_8;
if (VAR_7 == VAR_15) {
VAR_8 = GetOctetString(VAR_0, &VAR_4, &VAR_5, VAR_3);
if (VAR_8 < 0)
return VAR_8;
VAR_2->nonce = VAR_0 + VAR_4;
VAR_2->nonceSz = VAR_5;
}
VAR_4 += VAR_5;
}
*VAR_1 = VAR_4;
return 0;
}",wolfSSL/wolfssl/c6e4aebcdff4e774c94953ffe9de7ce287c54f4f/asn.c/vul/before/0.json,"static int DecodeOcspRespExtensions(byte* source,
                            word32* ioIndex, OcspResponse* resp, word32 sz)
{
    word32 idx = *ioIndex;
    int length;
    int ext_bound; /* boundary index for the sequence of extensions */
    word32 oid;
    int ret;

    WOLFSSL_ENTER(""DecodeOcspRespExtensions"");

    if ((idx + 1) > sz)
        return BUFFER_E;

    if (source[idx++] != (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 1))
        return ASN_PARSE_E;

    if (GetLength(source, &idx, &length, sz) < 0)
        return ASN_PARSE_E;

    if (GetSequence(source, &idx, &length, sz) < 0)
        return ASN_PARSE_E;

    ext_bound = idx + length;

    while (idx < (word32)ext_bound) {
        if (GetSequence(source, &idx, &length, sz) < 0) {
            WOLFSSL_MSG(""\tfail: should be a SEQUENCE"");
            return ASN_PARSE_E;
        }

        oid = 0;
        if (GetObjectId(source, &idx, &oid, oidOcspType, sz) < 0) {
            WOLFSSL_MSG(""\tfail: OBJECT ID"");
            return ASN_PARSE_E;
        }

        /* check for critical flag */
        if ((idx + 1) > (word32)sz) {
            WOLFSSL_MSG(""\tfail: malformed buffer"");
            return BUFFER_E;
        }

        if (source[idx] == ASN_BOOLEAN) {
            WOLFSSL_MSG(""\tfound optional critical flag, moving past"");
            ret = GetBoolean(source, &idx, sz);
            if (ret < 0)
                return ret;
        }

        ret = GetOctetString(source, &idx, &length, sz);
        if (ret < 0)
            return ret;

        if (oid == OCSP_NONCE_OID) {
            /* get data inside extra OCTET_STRING */
            ret = GetOctetString(source, &idx, &length, sz);
            if (ret < 0)
                return ret;

            resp->nonce = source + idx;
            resp->nonceSz = length;
        }

        idx += length;
    }

    *ioIndex = idx;
    return 0;
}","static int DecodeOcspRespExtensions(byte* VAR_0,
                            word32* VAR_1, OcspResponse* VAR_2, word32 VAR_3)
{
    word32 VAR_4 = *VAR_1;
    int VAR_5;
    int VAR_6; /* COMMENT_0 */
    word32 VAR_7;
    int VAR_8;

    WOLFSSL_ENTER(""DecodeOcspRespExtensions"");

    if ((VAR_4 + 1) > VAR_3)
        return VAR_9;

    if (VAR_0[VAR_4++] != (VAR_10 | VAR_11 | 1))
        return VAR_12;

    if (GetLength(VAR_0, &VAR_4, &VAR_5, VAR_3) < 0)
        return VAR_12;

    if (GetSequence(VAR_0, &VAR_4, &VAR_5, VAR_3) < 0)
        return VAR_12;

    VAR_6 = VAR_4 + VAR_5;

    while (VAR_4 < (word32)VAR_6) {
        if (GetSequence(VAR_0, &VAR_4, &VAR_5, VAR_3) < 0) {
            WOLFSSL_MSG(""\tfail: should be a SEQUENCE"");
            return VAR_12;
        }

        VAR_7 = 0;
        if (GetObjectId(VAR_0, &VAR_4, &VAR_7, VAR_13, VAR_3) < 0) {
            WOLFSSL_MSG(""\tfail: OBJECT ID"");
            return VAR_12;
        }

        /* COMMENT_1 */
        if ((VAR_4 + 1) > (word32)VAR_3) {
            WOLFSSL_MSG(""\tfail: malformed buffer"");
            return VAR_9;
        }

        if (VAR_0[VAR_4] == VAR_14) {
            WOLFSSL_MSG(""\tfound optional critical flag, moving past"");
            VAR_8 = GetBoolean(VAR_0, &VAR_4, VAR_3);
            if (VAR_8 < 0)
                return VAR_8;
        }

        VAR_8 = GetOctetString(VAR_0, &VAR_4, &VAR_5, VAR_3);
        if (VAR_8 < 0)
            return VAR_8;

        if (VAR_7 == VAR_15) {
            /* COMMENT_2 */
            VAR_8 = GetOctetString(VAR_0, &VAR_4, &VAR_5, VAR_3);
            if (VAR_8 < 0)
                return VAR_8;

            VAR_2->nonce = VAR_0 + VAR_4;
            VAR_2->nonceSz = VAR_5;
        }

        VAR_4 += VAR_5;
    }

    *VAR_1 = VAR_4;
    return 0;
}",wolfSSL/wolfssl/c6e4aebcdff4e774c94953ffe9de7ce287c54f4f/asn.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -36,6 +36,11 @@
         }
 
         /* check for critical flag */
+        if ((idx + 1) > (word32)sz) {
+            WOLFSSL_MSG(""\tfail: malformed buffer"");
+            return BUFFER_E;
+        }
+
         if (source[idx] == ASN_BOOLEAN) {
             WOLFSSL_MSG(""\tfound optional critical flag, moving past"");
             ret = GetBoolean(source, &idx, sz);","{'deleted_lines': [], 'added_lines': ['        if ((idx + 1) > (word32)sz) {', '            WOLFSSL_MSG(""\\tfail: malformed buffer"");', '            return BUFFER_E;', '        }', '']}",True,wolfSSL 4.1.0 has a one-byte heap-based buffer over-read in DecodeCertExtensions in wolfcrypt/src/asn.c because reading the ASN_BOOLEAN byte is mishandled for a crafted DER certificate in GetLength_ex.,9.8,CRITICAL,3,test,2019-08-22T15:23:02Z,3
CVE-2019-15651,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,wolfSSL/wolfssl,sanity check on buffer size,c6e4aebcdff4e774c94953ffe9de7ce287c54f4f,https://github.com/wolfSSL/wolfssl/commit/c6e4aebcdff4e774c94953ffe9de7ce287c54f4f,wolfcrypt/src/asn.c,DecodeCertExtensions,"static int DecodeCertExtensions(DecodedCert* cert)
{
int ret = 0;
word32 idx = 0;
int sz = cert->extensionsSz;
const byte* input = cert->extensions;
int length;
word32 oid;
byte critical = 0;
byte criticalFail = 0;
WOLFSSL_ENTER(""DecodeCertExtensions"");
if (input == NULL || sz == 0)
return BAD_FUNC_ARG;
if (input[idx++] != ASN_EXTENSIONS) {
WOLFSSL_MSG(""\tfail: should be an EXTENSIONS"");
return ASN_PARSE_E;
}
if (GetLength(input, &idx, &length, sz) < 0) {
WOLFSSL_MSG(""\tfail: invalid length"");
return ASN_PARSE_E;
}
if (GetSequence(input, &idx, &length, sz) < 0) {
WOLFSSL_MSG(""\tfail: should be a SEQUENCE (1)"");
return ASN_PARSE_E;
}
while (idx < (word32)sz) {
if (GetSequence(input, &idx, &length, sz) < 0) {
WOLFSSL_MSG(""\tfail: should be a SEQUENCE"");
return ASN_PARSE_E;
}
oid = 0;
if ((ret = GetObjectId(input, &idx, &oid, oidCertExtType, sz)) < 0) {
WOLFSSL_MSG(""\tfail: OBJECT ID"");
return ret;
}
critical = 0;
if (input[idx] == ASN_BOOLEAN) {
ret = GetBoolean(input, &idx, sz);
if (ret < 0) {
WOLFSSL_MSG(""\tfail: critical boolean"");
return ret;
}
critical = (byte)ret;
}
ret = GetOctetString(input, &idx, &length, sz);
if (ret < 0) {
WOLFSSL_MSG(""\tfail: bad OCTET STRING"");
return ret;
}
switch (oid) {
case BASIC_CA_OID:
VERIFY_AND_SET_OID(cert->extBasicConstSet);
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
cert->extBasicConstCrit = critical;
#endif
if (DecodeBasicCaConstraint(&input[idx], length, cert) < 0)
return ASN_PARSE_E;
break;
case CRL_DIST_OID:
VERIFY_AND_SET_OID(cert->extCRLdistSet);
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
cert->extCRLdistCrit = critical;
#endif
if (DecodeCrlDist(&input[idx], length, cert) < 0)
return ASN_PARSE_E;
break;
case AUTH_INFO_OID:
VERIFY_AND_SET_OID(cert->extAuthInfoSet);
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
cert->extAuthInfoCrit = critical;
#endif
if (DecodeAuthInfo(&input[idx], length, cert) < 0)
return ASN_PARSE_E;
break;
case ALT_NAMES_OID:
VERIFY_AND_SET_OID(cert->extSubjAltNameSet);
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
cert->extSubjAltNameCrit = critical;
#endif
ret = DecodeAltNames(&input[idx], length, cert);
if (ret < 0)
return ret;
break;
case AUTH_KEY_OID:
VERIFY_AND_SET_OID(cert->extAuthKeyIdSet);
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
cert->extAuthKeyIdCrit = critical;
#endif
#ifndef WOLFSSL_ALLOW_CRIT_SKID
if (critical) {
WOLFSSL_MSG(""Critical Auth Key ID is not allowed"");
WOLFSSL_MSG(""Use macro WOLFSSL_ALLOW_CRIT_SKID if wanted"");
return ASN_CRIT_EXT_E;
}
#endif
if (DecodeAuthKeyId(&input[idx], length, cert) < 0)
return ASN_PARSE_E;
break;
case SUBJ_KEY_OID:
VERIFY_AND_SET_OID(cert->extSubjKeyIdSet);
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
cert->extSubjKeyIdCrit = critical;
#endif
#ifndef WOLFSSL_ALLOW_CRIT_SKID
if (critical) {
WOLFSSL_MSG(""Critical Subject Key ID is not allowed"");
WOLFSSL_MSG(""Use macro WOLFSSL_ALLOW_CRIT_SKID if wanted"");
return ASN_CRIT_EXT_E;
}
#endif
if (DecodeSubjKeyId(&input[idx], length, cert) < 0)
return ASN_PARSE_E;
break;
case CERT_POLICY_OID:
#ifdef WOLFSSL_SEP
VERIFY_AND_SET_OID(cert->extCertPolicySet);
#if defined(OPENSSL_EXTRA) || \
defined(OPENSSL_EXTRA_X509_SMALL)
cert->extCertPolicyCrit = critical;
#endif
#endif
#if defined(WOLFSSL_SEP) || defined(WOLFSSL_CERT_EXT)
if (DecodeCertPolicy(&input[idx], length, cert) < 0) {
return ASN_PARSE_E;
}
#else
WOLFSSL_MSG(""Certificate Policy extension not supported yet."");
#endif
break;
case KEY_USAGE_OID:
VERIFY_AND_SET_OID(cert->extKeyUsageSet);
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
cert->extKeyUsageCrit = critical;
#endif
if (DecodeKeyUsage(&input[idx], length, cert) < 0)
return ASN_PARSE_E;
break;
case EXT_KEY_USAGE_OID:
VERIFY_AND_SET_OID(cert->extExtKeyUsageSet);
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
cert->extExtKeyUsageCrit = critical;
#endif
if (DecodeExtKeyUsage(&input[idx], length, cert) < 0)
return ASN_PARSE_E;
break;
#ifndef IGNORE_NAME_CONSTRAINTS
case NAME_CONS_OID:
#ifndef WOLFSSL_NO_ASN_STRICT
if (!cert->isCA) {
WOLFSSL_MSG(""Name constraints allowed only for CA certs"");
return ASN_NAME_INVALID_E;
}
#endif
VERIFY_AND_SET_OID(cert->extNameConstraintSet);
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
cert->extNameConstraintCrit = critical;
#endif
if (DecodeNameConstraints(&input[idx], length, cert) < 0)
return ASN_PARSE_E;
break;
#endif 
case INHIBIT_ANY_OID:
VERIFY_AND_SET_OID(cert->inhibitAnyOidSet);
WOLFSSL_MSG(""Inhibit anyPolicy extension not supported yet."");
break;
default:
#ifndef WOLFSSL_NO_ASN_STRICT
if (critical)
criticalFail = 1;
#endif
break;
}
idx += length;
}
return criticalFail ? ASN_CRIT_EXT_E : 0;
}","static int DecodeCertExtensions(DecodedCert* VAR_0)
{
int VAR_1 = 0;
word32 VAR_2 = 0;
int VAR_3 = VAR_0->extensionsSz;
const byte* VAR_4 = VAR_0->extensions;
int VAR_5;
word32 VAR_6;
byte VAR_7 = 0;
byte VAR_8 = 0;
WOLFSSL_ENTER(""DecodeCertExtensions"");
if (VAR_4 == NULL || VAR_3 == 0)
return VAR_9;
if (VAR_4[VAR_2++] != VAR_10) {
WOLFSSL_MSG(""\tfail: should be an EXTENSIONS"");
return VAR_11;
}
if (GetLength(VAR_4, &VAR_2, &VAR_5, VAR_3) < 0) {
WOLFSSL_MSG(""\tfail: invalid length"");
return VAR_11;
}
if (GetSequence(VAR_4, &VAR_2, &VAR_5, VAR_3) < 0) {
WOLFSSL_MSG(""\tfail: should be a SEQUENCE (1)"");
return VAR_11;
}
while (VAR_2 < (word32)VAR_3) {
if (GetSequence(VAR_4, &VAR_2, &VAR_5, VAR_3) < 0) {
WOLFSSL_MSG(""\tfail: should be a SEQUENCE"");
return VAR_11;
}
VAR_6 = 0;
if ((VAR_1 = GetObjectId(VAR_4, &VAR_2, &VAR_6, VAR_12, VAR_3)) < 0) {
WOLFSSL_MSG(""\tfail: OBJECT ID"");
return VAR_1;
}
VAR_7 = 0;
if (VAR_4[VAR_2] == VAR_13) {
VAR_1 = GetBoolean(VAR_4, &VAR_2, VAR_3);
if (VAR_1 < 0) {
WOLFSSL_MSG(""\tfail: critical boolean"");
return VAR_1;
}
VAR_7 = (byte)VAR_1;
}
VAR_1 = GetOctetString(VAR_4, &VAR_2, &VAR_5, VAR_3);
if (VAR_1 < 0) {
WOLFSSL_MSG(""\tfail: bad OCTET STRING"");
return VAR_1;
}
switch (VAR_6) {
case VAR_14:
VERIFY_AND_SET_OID(VAR_0->extBasicConstSet);
#if defined(VAR_15) || defined(VAR_16)
VAR_0->extBasicConstCrit = VAR_7;
#endif
if (DecodeBasicCaConstraint(&VAR_4[VAR_2], VAR_5, VAR_0) < 0)
return VAR_11;
break;
case VAR_17:
VERIFY_AND_SET_OID(VAR_0->extCRLdistSet);
#if defined(VAR_15) || defined(VAR_16)
VAR_0->extCRLdistCrit = VAR_7;
#endif
if (DecodeCrlDist(&VAR_4[VAR_2], VAR_5, VAR_0) < 0)
return VAR_11;
break;
case VAR_18:
VERIFY_AND_SET_OID(VAR_0->extAuthInfoSet);
#if defined(VAR_15) || defined(VAR_16)
VAR_0->extAuthInfoCrit = VAR_7;
#endif
if (DecodeAuthInfo(&VAR_4[VAR_2], VAR_5, VAR_0) < 0)
return VAR_11;
break;
case VAR_19:
VERIFY_AND_SET_OID(VAR_0->extSubjAltNameSet);
#if defined(VAR_15) || defined(VAR_16)
VAR_0->extSubjAltNameCrit = VAR_7;
#endif
VAR_1 = DecodeAltNames(&VAR_4[VAR_2], VAR_5, VAR_0);
if (VAR_1 < 0)
return VAR_1;
break;
case VAR_20:
VERIFY_AND_SET_OID(VAR_0->extAuthKeyIdSet);
#if defined(VAR_15) || defined(VAR_16)
VAR_0->extAuthKeyIdCrit = VAR_7;
#endif
#ifndef VAR_21
if (VAR_7) {
WOLFSSL_MSG(""Critical Auth Key ID is not allowed"");
WOLFSSL_MSG(""Use macro WOLFSSL_ALLOW_CRIT_SKID if wanted"");
return VAR_22;
}
#endif
if (DecodeAuthKeyId(&VAR_4[VAR_2], VAR_5, VAR_0) < 0)
return VAR_11;
break;
case VAR_23:
VERIFY_AND_SET_OID(VAR_0->extSubjKeyIdSet);
#if defined(VAR_15) || defined(VAR_16)
VAR_0->extSubjKeyIdCrit = VAR_7;
#endif
#ifndef VAR_21
if (VAR_7) {
WOLFSSL_MSG(""Critical Subject Key ID is not allowed"");
WOLFSSL_MSG(""Use macro WOLFSSL_ALLOW_CRIT_SKID if wanted"");
return VAR_22;
}
#endif
if (DecodeSubjKeyId(&VAR_4[VAR_2], VAR_5, VAR_0) < 0)
return VAR_11;
break;
case VAR_24:
#ifdef VAR_25
VERIFY_AND_SET_OID(VAR_0->extCertPolicySet);
#if defined(VAR_15) || \
defined(VAR_16)
VAR_0->extCertPolicyCrit = VAR_7;
#endif
#endif
#if defined(VAR_25) || defined(VAR_26)
if (DecodeCertPolicy(&VAR_4[VAR_2], VAR_5, VAR_0) < 0) {
return VAR_11;
}
#else
WOLFSSL_MSG(""Certificate Policy extension not supported yet."");
#endif
break;
case VAR_27:
VERIFY_AND_SET_OID(VAR_0->extKeyUsageSet);
#if defined(VAR_15) || defined(VAR_16)
VAR_0->extKeyUsageCrit = VAR_7;
#endif
if (DecodeKeyUsage(&VAR_4[VAR_2], VAR_5, VAR_0) < 0)
return VAR_11;
break;
case VAR_28:
VERIFY_AND_SET_OID(VAR_0->extExtKeyUsageSet);
#if defined(VAR_15) || defined(VAR_16)
VAR_0->extExtKeyUsageCrit = VAR_7;
#endif
if (DecodeExtKeyUsage(&VAR_4[VAR_2], VAR_5, VAR_0) < 0)
return VAR_11;
break;
#ifndef VAR_29
case VAR_30:
#ifndef VAR_31
if (!VAR_0->isCA) {
WOLFSSL_MSG(""Name constraints allowed only for CA certs"");
return VAR_32;
}
#endif
VERIFY_AND_SET_OID(VAR_0->extNameConstraintSet);
#if defined(VAR_15) || defined(VAR_16)
VAR_0->extNameConstraintCrit = VAR_7;
#endif
if (DecodeNameConstraints(&VAR_4[VAR_2], VAR_5, VAR_0) < 0)
return VAR_11;
break;
#endif 
case VAR_33:
VERIFY_AND_SET_OID(VAR_0->inhibitAnyOidSet);
WOLFSSL_MSG(""Inhibit anyPolicy extension not supported yet."");
break;
default:
#ifndef VAR_31
if (VAR_7)
VAR_8 = 1;
#endif
break;
}
VAR_2 += VAR_5;
}
return VAR_8 ? VAR_22 : 0;
}",wolfSSL/wolfssl/c6e4aebcdff4e774c94953ffe9de7ce287c54f4f/asn.c/vul/before/1.json,"static int DecodeCertExtensions(DecodedCert* cert)
/*
 *  Processing the Certificate Extensions. This does not modify the current
 *  index. It is works starting with the recorded extensions pointer.
 */
{
    int ret = 0;
    word32 idx = 0;
    int sz = cert->extensionsSz;
    const byte* input = cert->extensions;
    int length;
    word32 oid;
    byte critical = 0;
    byte criticalFail = 0;

    WOLFSSL_ENTER(""DecodeCertExtensions"");

    if (input == NULL || sz == 0)
        return BAD_FUNC_ARG;

    if (input[idx++] != ASN_EXTENSIONS) {
        WOLFSSL_MSG(""\tfail: should be an EXTENSIONS"");
        return ASN_PARSE_E;
    }

    if (GetLength(input, &idx, &length, sz) < 0) {
        WOLFSSL_MSG(""\tfail: invalid length"");
        return ASN_PARSE_E;
    }

    if (GetSequence(input, &idx, &length, sz) < 0) {
        WOLFSSL_MSG(""\tfail: should be a SEQUENCE (1)"");
        return ASN_PARSE_E;
    }

    while (idx < (word32)sz) {
        if (GetSequence(input, &idx, &length, sz) < 0) {
            WOLFSSL_MSG(""\tfail: should be a SEQUENCE"");
            return ASN_PARSE_E;
        }

        oid = 0;
        if ((ret = GetObjectId(input, &idx, &oid, oidCertExtType, sz)) < 0) {
            WOLFSSL_MSG(""\tfail: OBJECT ID"");
            return ret;
        }

        /* check for critical flag */
        critical = 0;
        if ((idx + 1) > (word32)sz) {
            WOLFSSL_MSG(""\tfail: malformed buffer"");
            return BUFFER_E;
        }

        if (input[idx] == ASN_BOOLEAN) {
            ret = GetBoolean(input, &idx, sz);
            if (ret < 0) {
                WOLFSSL_MSG(""\tfail: critical boolean"");
                return ret;
            }

            critical = (byte)ret;
        }

        /* process the extension based on the OID */
        ret = GetOctetString(input, &idx, &length, sz);
        if (ret < 0) {
            WOLFSSL_MSG(""\tfail: bad OCTET STRING"");
            return ret;
        }

        switch (oid) {
            case BASIC_CA_OID:
                VERIFY_AND_SET_OID(cert->extBasicConstSet);
                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                    cert->extBasicConstCrit = critical;
                #endif
                if (DecodeBasicCaConstraint(&input[idx], length, cert) < 0)
                    return ASN_PARSE_E;
                break;

            case CRL_DIST_OID:
                VERIFY_AND_SET_OID(cert->extCRLdistSet);
                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                    cert->extCRLdistCrit = critical;
                #endif
                if (DecodeCrlDist(&input[idx], length, cert) < 0)
                    return ASN_PARSE_E;
                break;

            case AUTH_INFO_OID:
                VERIFY_AND_SET_OID(cert->extAuthInfoSet);
                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                    cert->extAuthInfoCrit = critical;
                #endif
                if (DecodeAuthInfo(&input[idx], length, cert) < 0)
                    return ASN_PARSE_E;
                break;

            case ALT_NAMES_OID:
                VERIFY_AND_SET_OID(cert->extSubjAltNameSet);
                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                    cert->extSubjAltNameCrit = critical;
                #endif
                ret = DecodeAltNames(&input[idx], length, cert);
                if (ret < 0)
                    return ret;
                break;

            case AUTH_KEY_OID:
                VERIFY_AND_SET_OID(cert->extAuthKeyIdSet);
                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                    cert->extAuthKeyIdCrit = critical;
                #endif
                #ifndef WOLFSSL_ALLOW_CRIT_SKID
                    /* This check is added due to RFC 5280 section 4.2.1.1
                     * stating that conforming CA's must mark this extension
                     * as non-critical. When parsing extensions check that
                     * certificate was made in compliance with this. */
                    if (critical) {
                        WOLFSSL_MSG(""Critical Auth Key ID is not allowed"");
                        WOLFSSL_MSG(""Use macro WOLFSSL_ALLOW_CRIT_SKID if wanted"");
                        return ASN_CRIT_EXT_E;
                    }
                #endif
                if (DecodeAuthKeyId(&input[idx], length, cert) < 0)
                    return ASN_PARSE_E;
                break;

            case SUBJ_KEY_OID:
                VERIFY_AND_SET_OID(cert->extSubjKeyIdSet);
                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                    cert->extSubjKeyIdCrit = critical;
                #endif
                #ifndef WOLFSSL_ALLOW_CRIT_SKID
                    /* This check is added due to RFC 5280 section 4.2.1.2
                     * stating that conforming CA's must mark this extension
                     * as non-critical. When parsing extensions check that
                     * certificate was made in compliance with this. */
                    if (critical) {
                        WOLFSSL_MSG(""Critical Subject Key ID is not allowed"");
                        WOLFSSL_MSG(""Use macro WOLFSSL_ALLOW_CRIT_SKID if wanted"");
                        return ASN_CRIT_EXT_E;
                    }
                #endif

                if (DecodeSubjKeyId(&input[idx], length, cert) < 0)
                    return ASN_PARSE_E;
                break;

            case CERT_POLICY_OID:
                #ifdef WOLFSSL_SEP
                    VERIFY_AND_SET_OID(cert->extCertPolicySet);
                    #if defined(OPENSSL_EXTRA) || \
                        defined(OPENSSL_EXTRA_X509_SMALL)
                        cert->extCertPolicyCrit = critical;
                    #endif
                #endif
                #if defined(WOLFSSL_SEP) || defined(WOLFSSL_CERT_EXT)
                    if (DecodeCertPolicy(&input[idx], length, cert) < 0) {
                        return ASN_PARSE_E;
                    }
                #else
                    WOLFSSL_MSG(""Certificate Policy extension not supported yet."");
                #endif
                break;

            case KEY_USAGE_OID:
                VERIFY_AND_SET_OID(cert->extKeyUsageSet);
                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                    cert->extKeyUsageCrit = critical;
                #endif
                if (DecodeKeyUsage(&input[idx], length, cert) < 0)
                    return ASN_PARSE_E;
                break;

            case EXT_KEY_USAGE_OID:
                VERIFY_AND_SET_OID(cert->extExtKeyUsageSet);
                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                    cert->extExtKeyUsageCrit = critical;
                #endif
                if (DecodeExtKeyUsage(&input[idx], length, cert) < 0)
                    return ASN_PARSE_E;
                break;

            #ifndef IGNORE_NAME_CONSTRAINTS
            case NAME_CONS_OID:
            #ifndef WOLFSSL_NO_ASN_STRICT
                /* Verify RFC 5280 Sec 4.2.1.10 rule:
                    ""The name constraints extension,
                    which MUST be used only in a CA certificate"" */
                if (!cert->isCA) {
                    WOLFSSL_MSG(""Name constraints allowed only for CA certs"");
                    return ASN_NAME_INVALID_E;
                }
            #endif
                VERIFY_AND_SET_OID(cert->extNameConstraintSet);
                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                    cert->extNameConstraintCrit = critical;
                #endif
                if (DecodeNameConstraints(&input[idx], length, cert) < 0)
                    return ASN_PARSE_E;
                break;
            #endif /* IGNORE_NAME_CONSTRAINTS */

            case INHIBIT_ANY_OID:
                VERIFY_AND_SET_OID(cert->inhibitAnyOidSet);
                WOLFSSL_MSG(""Inhibit anyPolicy extension not supported yet."");
                break;

            default:
            #ifndef WOLFSSL_NO_ASN_STRICT
                /* While it is a failure to not support critical extensions,
                 * still parse the certificate ignoring the unsupported
                 * extension to allow caller to accept it with the verify
                 * callback. */
                if (critical)
                    criticalFail = 1;
            #endif
            break;
        }
        idx += length;
    }

    return criticalFail ? ASN_CRIT_EXT_E : 0;
}","static int DecodeCertExtensions(DecodedCert* VAR_0)
/* COMMENT_0 */
                                                                           
                                                                     
   
{
    int VAR_1 = 0;
    word32 VAR_2 = 0;
    int VAR_3 = VAR_0->extensionsSz;
    const byte* VAR_4 = VAR_0->extensions;
    int VAR_5;
    word32 VAR_6;
    byte VAR_7 = 0;
    byte VAR_8 = 0;

    WOLFSSL_ENTER(""DecodeCertExtensions"");

    if (VAR_4 == NULL || VAR_3 == 0)
        return VAR_9;

    if (VAR_4[VAR_2++] != VAR_10) {
        WOLFSSL_MSG(""\tfail: should be an EXTENSIONS"");
        return VAR_11;
    }

    if (GetLength(VAR_4, &VAR_2, &VAR_5, VAR_3) < 0) {
        WOLFSSL_MSG(""\tfail: invalid length"");
        return VAR_11;
    }

    if (GetSequence(VAR_4, &VAR_2, &VAR_5, VAR_3) < 0) {
        WOLFSSL_MSG(""\tfail: should be a SEQUENCE (1)"");
        return VAR_11;
    }

    while (VAR_2 < (word32)VAR_3) {
        if (GetSequence(VAR_4, &VAR_2, &VAR_5, VAR_3) < 0) {
            WOLFSSL_MSG(""\tfail: should be a SEQUENCE"");
            return VAR_11;
        }

        VAR_6 = 0;
        if ((VAR_1 = GetObjectId(VAR_4, &VAR_2, &VAR_6, VAR_12, VAR_3)) < 0) {
            WOLFSSL_MSG(""\tfail: OBJECT ID"");
            return VAR_1;
        }

        /* COMMENT_4 */
        VAR_7 = 0;
        if ((VAR_2 + 1) > (word32)VAR_3) {
            WOLFSSL_MSG(""\tfail: malformed buffer"");
            return VAR_13;
        }

        if (VAR_4[VAR_2] == VAR_14) {
            VAR_1 = GetBoolean(VAR_4, &VAR_2, VAR_3);
            if (VAR_1 < 0) {
                WOLFSSL_MSG(""\tfail: critical boolean"");
                return VAR_1;
            }

            VAR_7 = (byte)VAR_1;
        }

        /* COMMENT_5 */
        VAR_1 = GetOctetString(VAR_4, &VAR_2, &VAR_5, VAR_3);
        if (VAR_1 < 0) {
            WOLFSSL_MSG(""\tfail: bad OCTET STRING"");
            return VAR_1;
        }

        switch (VAR_6) {
            case VAR_15:
                VERIFY_AND_SET_OID(VAR_0->extBasicConstSet);
                #if defined(VAR_16) || defined(VAR_17)
                    VAR_0->extBasicConstCrit = VAR_7;
                #endif
                if (DecodeBasicCaConstraint(&VAR_4[VAR_2], VAR_5, VAR_0) < 0)
                    return VAR_11;
                break;

            case VAR_18:
                VERIFY_AND_SET_OID(VAR_0->extCRLdistSet);
                #if defined(VAR_16) || defined(VAR_17)
                    VAR_0->extCRLdistCrit = VAR_7;
                #endif
                if (DecodeCrlDist(&VAR_4[VAR_2], VAR_5, VAR_0) < 0)
                    return VAR_11;
                break;

            case VAR_19:
                VERIFY_AND_SET_OID(VAR_0->extAuthInfoSet);
                #if defined(VAR_16) || defined(VAR_17)
                    VAR_0->extAuthInfoCrit = VAR_7;
                #endif
                if (DecodeAuthInfo(&VAR_4[VAR_2], VAR_5, VAR_0) < 0)
                    return VAR_11;
                break;

            case VAR_20:
                VERIFY_AND_SET_OID(VAR_0->extSubjAltNameSet);
                #if defined(VAR_16) || defined(VAR_17)
                    VAR_0->extSubjAltNameCrit = VAR_7;
                #endif
                VAR_1 = DecodeAltNames(&VAR_4[VAR_2], VAR_5, VAR_0);
                if (VAR_1 < 0)
                    return VAR_1;
                break;

            case VAR_21:
                VERIFY_AND_SET_OID(VAR_0->extAuthKeyIdSet);
                #if defined(VAR_16) || defined(VAR_17)
                    VAR_0->extAuthKeyIdCrit = VAR_7;
                #endif
                #ifndef VAR_22
                    /* COMMENT_6 */
                                                                            
                                                                          
                                                                       
                    if (VAR_7) {
                        WOLFSSL_MSG(""Critical Auth Key ID is not allowed"");
                        WOLFSSL_MSG(""Use macro WOLFSSL_ALLOW_CRIT_SKID if wanted"");
                        return VAR_23;
                    }
                #endif
                if (DecodeAuthKeyId(&VAR_4[VAR_2], VAR_5, VAR_0) < 0)
                    return VAR_11;
                break;

            case VAR_24:
                VERIFY_AND_SET_OID(VAR_0->extSubjKeyIdSet);
                #if defined(VAR_16) || defined(VAR_17)
                    VAR_0->extSubjKeyIdCrit = VAR_7;
                #endif
                #ifndef VAR_22
                    /* COMMENT_10 */
                                                                            
                                                                          
                                                                       
                    if (VAR_7) {
                        WOLFSSL_MSG(""Critical Subject Key ID is not allowed"");
                        WOLFSSL_MSG(""Use macro WOLFSSL_ALLOW_CRIT_SKID if wanted"");
                        return VAR_23;
                    }
                #endif

                if (DecodeSubjKeyId(&VAR_4[VAR_2], VAR_5, VAR_0) < 0)
                    return VAR_11;
                break;

            case VAR_25:
                #ifdef VAR_26
                    VERIFY_AND_SET_OID(VAR_0->extCertPolicySet);
                    #if defined(VAR_16) || \
                        defined(VAR_17)
                        VAR_0->extCertPolicyCrit = VAR_7;
                    #endif
                #endif
                #if defined(VAR_26) || defined(VAR_27)
                    if (DecodeCertPolicy(&VAR_4[VAR_2], VAR_5, VAR_0) < 0) {
                        return VAR_11;
                    }
                #else
                    WOLFSSL_MSG(""Certificate Policy extension not supported yet."");
                #endif
                break;

            case VAR_28:
                VERIFY_AND_SET_OID(VAR_0->extKeyUsageSet);
                #if defined(VAR_16) || defined(VAR_17)
                    VAR_0->extKeyUsageCrit = VAR_7;
                #endif
                if (DecodeKeyUsage(&VAR_4[VAR_2], VAR_5, VAR_0) < 0)
                    return VAR_11;
                break;

            case VAR_29:
                VERIFY_AND_SET_OID(VAR_0->extExtKeyUsageSet);
                #if defined(VAR_16) || defined(VAR_17)
                    VAR_0->extExtKeyUsageCrit = VAR_7;
                #endif
                if (DecodeExtKeyUsage(&VAR_4[VAR_2], VAR_5, VAR_0) < 0)
                    return VAR_11;
                break;

            #ifndef VAR_30
            case VAR_31:
            #ifndef VAR_32
                /* COMMENT_14 */
                                                    
                                                                   
                if (!VAR_0->isCA) {
                    WOLFSSL_MSG(""Name constraints allowed only for CA certs"");
                    return VAR_33;
                }
            #endif
                VERIFY_AND_SET_OID(VAR_0->extNameConstraintSet);
                #if defined(VAR_16) || defined(VAR_17)
                    VAR_0->extNameConstraintCrit = VAR_7;
                #endif
                if (DecodeNameConstraints(&VAR_4[VAR_2], VAR_5, VAR_0) < 0)
                    return VAR_11;
                break;
            #endif /* COMMENT_17 */

            case VAR_34:
                VERIFY_AND_SET_OID(VAR_0->inhibitAnyOidSet);
                WOLFSSL_MSG(""Inhibit anyPolicy extension not supported yet."");
                break;

            default:
            #ifndef VAR_32
                /* COMMENT_18 */
                                                                       
                                                                         
                               
                if (VAR_7)
                    VAR_8 = 1;
            #endif
            break;
        }
        VAR_2 += VAR_5;
    }

    return VAR_8 ? VAR_23 : 0;
}",wolfSSL/wolfssl/c6e4aebcdff4e774c94953ffe9de7ce287c54f4f/asn.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -47,6 +47,11 @@
 
         /* check for critical flag */
         critical = 0;
+        if ((idx + 1) > (word32)sz) {
+            WOLFSSL_MSG(""\tfail: malformed buffer"");
+            return BUFFER_E;
+        }
+
         if (input[idx] == ASN_BOOLEAN) {
             ret = GetBoolean(input, &idx, sz);
             if (ret < 0) {","{'deleted_lines': [], 'added_lines': ['        if ((idx + 1) > (word32)sz) {', '            WOLFSSL_MSG(""\\tfail: malformed buffer"");', '            return BUFFER_E;', '        }', '']}",True,wolfSSL 4.1.0 has a one-byte heap-based buffer over-read in DecodeCertExtensions in wolfcrypt/src/asn.c because reading the ASN_BOOLEAN byte is mishandled for a crafted DER certificate in GetLength_ex.,9.8,CRITICAL,3,test,2019-08-22T15:23:02Z,3
CVE-2019-15683,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,TurboVNC/turbovnc,"Server: Fix two issues identified by ASan

1. If the TLSPlain and X509Plain security types were both disabled, then
   rfbOptPamAuth() would overflow the name field in the secTypes
   structure when testing the ""none"" security type, since the name of
   that security type has less than five characters.  This issue was
   innocuous, since the overflow was fully contained within the secTypes
   structure, but the ASan error caused Xvnc to abort, which made it
   difficult to detect other errors.

2. If an ill-behaved RFB client sent the TurboVNC Server a fence
   message with more than 64 bytes, then the TurboVNC Server would
   try to read that message and subsequently overflow the stack before
   it detected that the payload was too large.  This could never have
   occurred with any of the VNC viewers that currently support the RFB
   flow control extensions (TigerVNC and TurboVNC, namely.)  This issue
   was also innocuous, since the stack overflow affected two variables
   (newScreens and errMsg) that were never accessed before the function
   returned.",cea98166008301e614e0d36776bf9435a536136e,https://github.com/TurboVNC/turbovnc/commit/cea98166008301e614e0d36776bf9435a536136e,unix/Xvnc/programs/Xserver/hw/vnc/auth.c,rfbOptPamAuth,"Bool rfbOptPamAuth(void)
{
SecTypeData *s;
for (s = secTypes; s->name != NULL; s++) {
if ((!strcmp(s->name, ""unixlogin"") ||
!strcmp(&s->name[strlen(s->name) - 5], ""plain"")) && s->enabled)
return TRUE;
}
return FALSE;
}","Bool rfbOptPamAuth(void)
{
SecTypeData *VAR_0;
for (VAR_0 = VAR_1; VAR_0->name != NULL; VAR_0++) {
if ((!strcmp(VAR_0->name, ""unixlogin"") ||
!strcmp(&VAR_0->name[strlen(VAR_0->name) - 5], ""plain"")) && VAR_0->enabled)
return TRUE;
}
return FALSE;
}",TurboVNC/turbovnc/cea98166008301e614e0d36776bf9435a536136e/auth.c/vul/before/0.json,"Bool rfbOptPamAuth(void)
{
  SecTypeData *s;

  for (s = secTypes; s->name != NULL; s++) {
    if ((!strcmp(s->name, ""unixlogin"") ||
         strstr(s->name, ""plain"")) && s->enabled)
      return TRUE;
  }

  return FALSE;
}","Bool rfbOptPamAuth(void)
{
  SecTypeData *VAR_0;

  for (VAR_0 = VAR_1; VAR_0->name != NULL; VAR_0++) {
    if ((!strcmp(VAR_0->name, ""unixlogin"") ||
         strstr(VAR_0->name, ""plain"")) && VAR_0->enabled)
      return TRUE;
  }

  return FALSE;
}",TurboVNC/turbovnc/cea98166008301e614e0d36776bf9435a536136e/auth.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
 
   for (s = secTypes; s->name != NULL; s++) {
     if ((!strcmp(s->name, ""unixlogin"") ||
-         !strcmp(&s->name[strlen(s->name) - 5], ""plain"")) && s->enabled)
+         strstr(s->name, ""plain"")) && s->enabled)
       return TRUE;
   }
 ","{'deleted_lines': ['         !strcmp(&s->name[strlen(s->name) - 5], ""plain"")) && s->enabled)'], 'added_lines': ['         strstr(s->name, ""plain"")) && s->enabled)']}",True,"TurboVNC server code contains stack buffer overflow vulnerability in commit prior to cea98166008301e614e0d36776bf9435a536136e. This could possibly result into remote code execution, since stack frame is not protected with stack canary. This attack appear to be exploitable via network connectivity. To exploit this vulnerability authorization on server is required. These issues have been fixed in commit cea98166008301e614e0d36776bf9435a536136e.",9.8,CRITICAL,3,test,2019-08-23T14:54:21Z,3
CVE-2019-13617,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,nginx/njs,"Fixed heap-buffer-overflow while parsing regexp literals.

This closes #174 issue on Github.",ee400ea880dc46bb02c4be2564b183c114d4cd42,https://github.com/nginx/njs/commit/ee400ea880dc46bb02c4be2564b183c114d4cd42,src/njs_regexp.c,njs_regexp_literal,"njs_token_t
njs_regexp_literal(njs_vm_t *vm, njs_parser_t *parser, njs_value_t *value)
{
u_char                *p;
njs_str_t             text;
njs_lexer_t           *lexer;
njs_regexp_flags_t    flags;
njs_regexp_pattern_t  *pattern;
lexer = parser->lexer;
for (p = lexer->start; p < lexer->end; p++) {
switch (*p) {
case '\n':
case '\r':
goto failed;
case '[':
while (++p < lexer->end && *p != ']') {
switch (*p) {
case '\n':
case '\r':
goto failed;
case '\\':
if (++p < lexer->end && (*p == '\n' || *p == '\r')) {
goto failed;
}
break;
}
}
break;
case '\\':
if (++p < lexer->end && (*p == '\n' || *p == '\r')) {
goto failed;
}
break;
case '/':
text.start = lexer->start;
text.length = p - text.start;
p++;
lexer->start = p;
flags = njs_regexp_flags(&p, lexer->end, 0);
if (njs_slow_path(flags < 0)) {
njs_parser_syntax_error(vm, parser,
""Invalid RegExp flags \""%*s\"""",
p - lexer->start, lexer->start);
return NJS_TOKEN_ILLEGAL;
}
lexer->start = p;
pattern = njs_regexp_pattern_create(vm, text.start, text.length,
flags);
if (njs_slow_path(pattern == NULL)) {
return NJS_TOKEN_ILLEGAL;
}
value->data.u.data = pattern;
return NJS_TOKEN_REGEXP;
}
}
failed:
njs_parser_syntax_error(vm, parser, ""Unterminated RegExp \""%*s\"""",
p - (lexer->start - 1), lexer->start - 1);
return NJS_TOKEN_ILLEGAL;
}","njs_token_t
njs_regexp_literal(njs_vm_t *VAR_0, njs_parser_t *VAR_1, njs_value_t *VAR_2)
{
u_char                *VAR_3;
njs_str_t             VAR_4;
njs_lexer_t           *VAR_5;
njs_regexp_flags_t    VAR_6;
njs_regexp_pattern_t  *VAR_7;
VAR_5 = VAR_1->lexer;
for (VAR_3 = VAR_5->start; VAR_3 < VAR_5->end; VAR_3++) {
switch (*VAR_3) {
case '\n':
case '\r':
goto failed;
case '[':
while (++VAR_3 < VAR_5->end && *VAR_3 != ']') {
switch (*VAR_3) {
case '\n':
case '\r':
goto failed;
case '\\':
if (++VAR_3 < VAR_5->end && (*VAR_3 == '\n' || *VAR_3 == '\r')) {
goto failed;
}
break;
}
}
break;
case '\\':
if (++VAR_3 < VAR_5->end && (*VAR_3 == '\n' || *VAR_3 == '\r')) {
goto failed;
}
break;
case '/':
VAR_4.start = VAR_5->start;
VAR_4.length = VAR_3 - VAR_4.start;
VAR_3++;
VAR_5->start = VAR_3;
VAR_6 = njs_regexp_flags(&VAR_3, VAR_5->end, 0);
if (njs_slow_path(VAR_6 < 0)) {
njs_parser_syntax_error(VAR_0, VAR_1,
""Invalid RegExp flags \""%*s\"""",
VAR_3 - VAR_5->start, VAR_5->start);
return VAR_8;
}
VAR_5->start = VAR_3;
VAR_7 = njs_regexp_pattern_create(VAR_0, VAR_4.start, VAR_4.length,
VAR_6);
if (njs_slow_path(VAR_7 == NULL)) {
return VAR_8;
}
VAR_2->data.u.data = VAR_7;
return VAR_9;
}
}
failed:
njs_parser_syntax_error(VAR_0, VAR_1, ""Unterminated RegExp \""%*s\"""",
VAR_3 - (VAR_5->start - 1), VAR_5->start - 1);
return VAR_8;
}",nginx/njs/ee400ea880dc46bb02c4be2564b183c114d4cd42/njs_regexp.c/vul/before/0.json,"njs_token_t
njs_regexp_literal(njs_vm_t *vm, njs_parser_t *parser, njs_value_t *value)
{
    u_char                *p;
    njs_str_t             text;
    njs_lexer_t           *lexer;
    njs_regexp_flags_t    flags;
    njs_regexp_pattern_t  *pattern;

    lexer = parser->lexer;

    for (p = lexer->start; p < lexer->end; p++) {

        switch (*p) {
        case '\n':
        case '\r':
            goto failed;

        case '[':
            while (1) {
                if (++p >= lexer->end) {
                    goto failed;
                }

                if (*p == ']') {
                    break;
                }

                switch (*p) {
                case '\n':
                case '\r':
                    goto failed;

                case '\\':
                    if (++p >= lexer->end || *p == '\n' || *p == '\r') {
                        goto failed;
                    }

                    break;
                }
            }

            break;

        case '\\':
            if (++p >= lexer->end || *p == '\n' || *p == '\r') {
                goto failed;
            }

            break;

        case '/':
            text.start = lexer->start;
            text.length = p - text.start;
            p++;
            lexer->start = p;

            flags = njs_regexp_flags(&p, lexer->end, 0);

            if (njs_slow_path(flags < 0)) {
                njs_parser_syntax_error(vm, parser,
                                        ""Invalid RegExp flags \""%*s\"""",
                                        p - lexer->start, lexer->start);

                return NJS_TOKEN_ILLEGAL;
            }

            lexer->start = p;

            pattern = njs_regexp_pattern_create(vm, text.start, text.length,
                                                flags);

            if (njs_slow_path(pattern == NULL)) {
                return NJS_TOKEN_ILLEGAL;
            }

            value->data.u.data = pattern;

            return NJS_TOKEN_REGEXP;
        }
    }

failed:

    njs_parser_syntax_error(vm, parser, ""Unterminated RegExp \""%*s\"""",
                            p - (lexer->start - 1), lexer->start - 1);

    return NJS_TOKEN_ILLEGAL;
}","njs_token_t
njs_regexp_literal(njs_vm_t *VAR_0, njs_parser_t *VAR_1, njs_value_t *VAR_2)
{
    u_char                *VAR_3;
    njs_str_t             VAR_4;
    njs_lexer_t           *VAR_5;
    njs_regexp_flags_t    VAR_6;
    njs_regexp_pattern_t  *VAR_7;

    VAR_5 = VAR_1->lexer;

    for (VAR_3 = VAR_5->start; VAR_3 < VAR_5->end; VAR_3++) {

        switch (*VAR_3) {
        case '\n':
        case '\r':
            goto failed;

        case '[':
            while (1) {
                if (++VAR_3 >= VAR_5->end) {
                    goto failed;
                }

                if (*VAR_3 == ']') {
                    break;
                }

                switch (*VAR_3) {
                case '\n':
                case '\r':
                    goto failed;

                case '\\':
                    if (++VAR_3 >= VAR_5->end || *VAR_3 == '\n' || *VAR_3 == '\r') {
                        goto failed;
                    }

                    break;
                }
            }

            break;

        case '\\':
            if (++VAR_3 >= VAR_5->end || *VAR_3 == '\n' || *VAR_3 == '\r') {
                goto failed;
            }

            break;

        case '/':
            VAR_4.start = VAR_5->start;
            VAR_4.length = VAR_3 - VAR_4.start;
            VAR_3++;
            VAR_5->start = VAR_3;

            VAR_6 = njs_regexp_flags(&VAR_3, VAR_5->end, 0);

            if (njs_slow_path(VAR_6 < 0)) {
                njs_parser_syntax_error(VAR_0, VAR_1,
                                        ""Invalid RegExp flags \""%*s\"""",
                                        VAR_3 - VAR_5->start, VAR_5->start);

                return VAR_8;
            }

            VAR_5->start = VAR_3;

            VAR_7 = njs_regexp_pattern_create(VAR_0, VAR_4.start, VAR_4.length,
                                                VAR_6);

            if (njs_slow_path(VAR_7 == NULL)) {
                return VAR_8;
            }

            VAR_2->data.u.data = VAR_7;

            return VAR_9;
        }
    }

failed:

    njs_parser_syntax_error(VAR_0, VAR_1, ""Unterminated RegExp \""%*s\"""",
                            VAR_3 - (VAR_5->start - 1), VAR_5->start - 1);

    return VAR_8;
}",nginx/njs/ee400ea880dc46bb02c4be2564b183c114d4cd42/njs_regexp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,14 +17,22 @@
             goto failed;
 
         case '[':
-            while (++p < lexer->end && *p != ']') {
+            while (1) {
+                if (++p >= lexer->end) {
+                    goto failed;
+                }
+
+                if (*p == ']') {
+                    break;
+                }
+
                 switch (*p) {
                 case '\n':
                 case '\r':
                     goto failed;
 
                 case '\\':
-                    if (++p < lexer->end && (*p == '\n' || *p == '\r')) {
+                    if (++p >= lexer->end || *p == '\n' || *p == '\r') {
                         goto failed;
                     }
 
@@ -35,7 +43,7 @@
             break;
 
         case '\\':
-            if (++p < lexer->end && (*p == '\n' || *p == '\r')) {
+            if (++p >= lexer->end || *p == '\n' || *p == '\r') {
                 goto failed;
             }
 ","{'deleted_lines': [""            while (++p < lexer->end && *p != ']') {"", ""                    if (++p < lexer->end && (*p == '\\n' || *p == '\\r')) {"", ""            if (++p < lexer->end && (*p == '\\n' || *p == '\\r')) {""], 'added_lines': ['            while (1) {', '                if (++p >= lexer->end) {', '                    goto failed;', '                }', '', ""                if (*p == ']') {"", '                    break;', '                }', '', ""                    if (++p >= lexer->end || *p == '\\n' || *p == '\\r') {"", ""            if (++p >= lexer->end || *p == '\\n' || *p == '\\r') {""]}",True,"njs through 0.3.3, used in NGINX, has a heap-based buffer over-read in nxt_vsprintf in nxt/nxt_sprintf.c during error handling, as demonstrated by an njs_regexp_literal call that leads to an njs_parser_lexer_error call and then an njs_parser_scope_error call.",6.5,MEDIUM,1,test,2019-08-26T16:00:13Z,3
CVE-2019-3573,"['CWE-835', 'CWE-125']",AV:N/AC:M/Au:N/C:N/I:N/A:P,0,saitoha/libsixel,"check size, fix issue #83",9c013f23661370a5ece2f0c9c1acfd342e2efebb,https://github.com/saitoha/libsixel/commit/9c013f23661370a5ece2f0c9c1acfd342e2efebb,src/fromsixel.c,sixel_decode_raw_impl,"SIXELAPI SIXELSTATUS
sixel_decode_raw_impl(
unsigned char     *p,         
int                len,       
image_buffer_t    *image,
parser_context_t  *context,
sixel_allocator_t *allocator) 
{
SIXELSTATUS status = SIXEL_FALSE;
int n;
int i;
int y;
int bits;
int sixel_vertical_mask;
int sx;
int sy;
int c;
int pos;
unsigned char *p0 = p;
while (p < p0 + len) {
switch (context->state) {
case PS_GROUND:
switch (*p) {
case 0x1b:
context->state = PS_ESC;
p++;
break;
case 0x90:
context->state = PS_DCS;
p++;
break;
case 0x9c:
p++;
goto finalize;
default:
p++;
break;
}
break;
case PS_ESC:
switch (*p) {
case '\\':
case 0x9c:
p++;
goto finalize;
case 'P':
context->param = -1;
context->state = PS_DCS;
p++;
break;
default:
p++;
break;
}
break;
case PS_DCS:
switch (*p) {
case 0x1b:
context->state = PS_ESC;
p++;
break;
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
if (context->param < 0) {
context->param = 0;
}
context->param = context->param * 10 + *p - '0';
p++;
break;
case ';':
if (context->param < 0) {
context->param = 0;
}
if (context->nparams < DECSIXEL_PARAMS_MAX) {
context->params[context->nparams++] = context->param;
}
context->param = 0;
p++;
break;
case 'q':
if (context->param >= 0 && context->nparams < DECSIXEL_PARAMS_MAX) {
context->params[context->nparams++] = context->param;
}
if (context->nparams > 0) {
switch (context->params[0]) {
case 0:
case 1:
context->attributed_pad = 2;
break;
case 2:
context->attributed_pad = 5;
break;
case 3:
case 4:
context->attributed_pad = 4;
break;
case 5:
case 6:
context->attributed_pad = 3;
break;
case 7:
case 8:
context->attributed_pad = 2;
break;
case 9:
context->attributed_pad = 1;
break;
default:
context->attributed_pad = 2;
break;
}
}
if (context->nparams > 2) {
if (context->params[2] == 0) {
context->params[2] = 10;
}
context->attributed_pan = context->attributed_pan * context->params[2] / 10;
context->attributed_pad = context->attributed_pad * context->params[2] / 10;
if (context->attributed_pan <= 0) {
context->attributed_pan = 1;
}
if (context->attributed_pad <= 0) {
context->attributed_pad = 1;
}
}
context->nparams = 0;
context->state = PS_DECSIXEL;
p++;
break;
default:
p++;
break;
}
break;
case PS_DECSIXEL:
switch (*p) {
case '\x1b':
context->state = PS_ESC;
p++;
break;
case '""':
context->param = 0;
context->nparams = 0;
context->state = PS_DECGRA;
p++;
break;
case '!':
context->param = 0;
context->nparams = 0;
context->state = PS_DECGRI;
p++;
break;
case '#':
context->param = 0;
context->nparams = 0;
context->state = PS_DECGCI;
p++;
break;
case '$':
context->pos_x = 0;
p++;
break;
case '-':
context->pos_x = 0;
context->pos_y += 6;
p++;
break;
default:
if (*p >= '?' && *p <= '~') {  
if (image->width < (context->pos_x + context->repeat_count) || image->height < (context->pos_y + 6)) {
sx = image->width * 2;
sy = image->height * 2;
while (sx < (context->pos_x + context->repeat_count) || sy < (context->pos_y + 6)) {
sx *= 2;
sy *= 2;
}
status = image_buffer_resize(image, sx, sy, context->bgindex, allocator);
if (SIXEL_FAILED(status)) {
goto end;
}
}
if (context->color_index > image->ncolors) {
image->ncolors = context->color_index;
}
bits = *p - '?';
if (bits == 0) {
context->pos_x += context->repeat_count;
} else {
sixel_vertical_mask = 0x01;
if (context->repeat_count <= 1) {
for (i = 0; i < 6; i++) {
if ((bits & sixel_vertical_mask) != 0) {
pos = image->width * (context->pos_y + i) + context->pos_x;
image->data[pos] = context->color_index;
if (context->max_x < context->pos_x) {
context->max_x = context->pos_x;
}
if (context->max_y < (context->pos_y + i)) {
context->max_y = context->pos_y + i;
}
}
sixel_vertical_mask <<= 1;
}
context->pos_x += 1;
} else {
for (i = 0; i < 6; i++) {
if ((bits & sixel_vertical_mask) != 0) {
c = sixel_vertical_mask << 1;
for (n = 1; (i + n) < 6; n++) {
if ((bits & c) == 0) {
break;
}
c <<= 1;
}
for (y = context->pos_y + i; y < context->pos_y + i + n; ++y) {
memset(image->data + image->width * y + context->pos_x,
context->color_index,
(size_t)context->repeat_count);
}
if (context->max_x < (context->pos_x + context->repeat_count - 1)) {
context->max_x = context->pos_x + context->repeat_count - 1;
}
if (context->max_y < (context->pos_y + i + n - 1)) {
context->max_y = context->pos_y + i + n - 1;
}
i += (n - 1);
sixel_vertical_mask <<= (n - 1);
}
sixel_vertical_mask <<= 1;
}
context->pos_x += context->repeat_count;
}
}
context->repeat_count = 1;
}
p++;
break;
}
break;
case PS_DECGRA:
switch (*p) {
case '\x1b':
context->state = PS_ESC;
p++;
break;
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
context->param = context->param * 10 + *p - '0';
p++;
break;
case ';':
if (context->nparams < DECSIXEL_PARAMS_MAX) {
context->params[context->nparams++] = context->param;
}
context->param = 0;
p++;
break;
default:
if (context->nparams < DECSIXEL_PARAMS_MAX) {
context->params[context->nparams++] = context->param;
}
if (context->nparams > 0) {
context->attributed_pad = context->params[0];
}
if (context->nparams > 1) {
context->attributed_pan = context->params[1];
}
if (context->nparams > 2 && context->params[2] > 0) {
context->attributed_ph = context->params[2];
}
if (context->nparams > 3 && context->params[3] > 0) {
context->attributed_pv = context->params[3];
}
if (context->attributed_pan <= 0) {
context->attributed_pan = 1;
}
if (context->attributed_pad <= 0) {
context->attributed_pad = 1;
}
if (image->width < context->attributed_ph ||
image->height < context->attributed_pv) {
sx = context->attributed_ph;
if (image->width > context->attributed_ph) {
sx = image->width;
}
sy = context->attributed_pv;
if (image->height > context->attributed_pv) {
sy = image->height;
}
status = image_buffer_resize(image, sx, sy, context->bgindex, allocator);
if (SIXEL_FAILED(status)) {
goto end;
}
}
context->state = PS_DECSIXEL;
context->param = 0;
context->nparams = 0;
}
break;
case PS_DECGRI:
switch (*p) {
case '\x1b':
context->state = PS_ESC;
p++;
break;
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
context->param = context->param * 10 + *p - '0';
p++;
break;
default:
context->repeat_count = context->param;
if (context->repeat_count == 0) {
context->repeat_count = 1;
}
context->state = PS_DECSIXEL;
context->param = 0;
context->nparams = 0;
break;
}
break;
case PS_DECGCI:
switch (*p) {
case '\x1b':
context->state = PS_ESC;
p++;
break;
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
context->param = context->param * 10 + *p - '0';
p++;
break;
case ';':
if (context->nparams < DECSIXEL_PARAMS_MAX) {
context->params[context->nparams++] = context->param;
}
context->param = 0;
p++;
break;
default:
context->state = PS_DECSIXEL;
if (context->nparams < DECSIXEL_PARAMS_MAX) {
context->params[context->nparams++] = context->param;
}
context->param = 0;
if (context->nparams > 0) {
context->color_index = context->params[0];
if (context->color_index < 0) {
context->color_index = 0;
} else if (context->color_index >= SIXEL_PALETTE_MAX) {
context->color_index = SIXEL_PALETTE_MAX - 1;
}
}
if (context->nparams > 4) {
if (context->params[1] == 1) {
if (context->params[2] > 360) {
context->params[2] = 360;
}
if (context->params[3] > 100) {
context->params[3] = 100;
}
if (context->params[4] > 100) {
context->params[4] = 100;
}
image->palette[context->color_index]
= hls_to_rgb(context->params[2], context->params[3], context->params[4]);
} else if (context->params[1] == 2) {
if (context->params[2] > 100) {
context->params[2] = 100;
}
if (context->params[3] > 100) {
context->params[3] = 100;
}
if (context->params[4] > 100) {
context->params[4] = 100;
}
image->palette[context->color_index]
= SIXEL_XRGB(context->params[2], context->params[3], context->params[4]);
}
}
break;
}
break;
default:
break;
}
}
finalize:
if (++context->max_x < context->attributed_ph) {
context->max_x = context->attributed_ph;
}
if (++context->max_y < context->attributed_pv) {
context->max_y = context->attributed_pv;
}
if (image->width > context->max_x || image->height > context->max_y) {
status = image_buffer_resize(image, context->max_x, context->max_y, context->bgindex, allocator);
if (SIXEL_FAILED(status)) {
goto end;
}
}
status = SIXEL_OK;
end:
return status;
}","SIXELAPI VAR_0
sixel_decode_raw_impl(
unsigned char     *VAR_1,         
int                VAR_2,       
image_buffer_t    *VAR_3,
parser_context_t  *VAR_4,
sixel_allocator_t *VAR_5) 
{
SIXELSTATUS VAR_6 = VAR_7;
int VAR_8;
int VAR_9;
int VAR_10;
int VAR_11;
int VAR_12;
int VAR_13;
int VAR_14;
int VAR_15;
int VAR_16;
unsigned char *VAR_17 = VAR_1;
while (VAR_1 < VAR_17 + VAR_2) {
switch (VAR_4->state) {
case VAR_18:
switch (*VAR_1) {
case 0x1b:
VAR_4->state = VAR_19;
VAR_1++;
break;
case 0x90:
VAR_4->state = VAR_20;
VAR_1++;
break;
case 0x9c:
VAR_1++;
goto finalize;
default:
VAR_1++;
break;
}
break;
case VAR_19:
switch (*VAR_1) {
case '\\':
case 0x9c:
VAR_1++;
goto finalize;
case 'P':
VAR_4->param = -1;
VAR_4->state = VAR_20;
VAR_1++;
break;
default:
VAR_1++;
break;
}
break;
case VAR_20:
switch (*VAR_1) {
case 0x1b:
VAR_4->state = VAR_19;
VAR_1++;
break;
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
if (VAR_4->param < 0) {
VAR_4->param = 0;
}
VAR_4->param = VAR_4->param * 10 + *VAR_1 - '0';
VAR_1++;
break;
case ';':
if (VAR_4->param < 0) {
VAR_4->param = 0;
}
if (VAR_4->nparams < VAR_21) {
VAR_4->params[VAR_4->nparams++] = VAR_4->param;
}
VAR_4->param = 0;
VAR_1++;
break;
case 'q':
if (VAR_4->param >= 0 && VAR_4->nparams < VAR_21) {
VAR_4->params[VAR_4->nparams++] = VAR_4->param;
}
if (VAR_4->nparams > 0) {
switch (VAR_4->params[0]) {
case 0:
case 1:
VAR_4->attributed_pad = 2;
break;
case 2:
VAR_4->attributed_pad = 5;
break;
case 3:
case 4:
VAR_4->attributed_pad = 4;
break;
case 5:
case 6:
VAR_4->attributed_pad = 3;
break;
case 7:
case 8:
VAR_4->attributed_pad = 2;
break;
case 9:
VAR_4->attributed_pad = 1;
break;
default:
VAR_4->attributed_pad = 2;
break;
}
}
if (VAR_4->nparams > 2) {
if (VAR_4->params[2] == 0) {
VAR_4->params[2] = 10;
}
VAR_4->attributed_pan = VAR_4->attributed_pan * VAR_4->params[2] / 10;
VAR_4->attributed_pad = VAR_4->attributed_pad * VAR_4->params[2] / 10;
if (VAR_4->attributed_pan <= 0) {
VAR_4->attributed_pan = 1;
}
if (VAR_4->attributed_pad <= 0) {
VAR_4->attributed_pad = 1;
}
}
VAR_4->nparams = 0;
VAR_4->state = VAR_22;
VAR_1++;
break;
default:
VAR_1++;
break;
}
break;
case VAR_22:
switch (*VAR_1) {
case '\x1b':
VAR_4->state = VAR_19;
VAR_1++;
break;
case '""':
VAR_4->param = 0;
VAR_4->nparams = 0;
VAR_4->state = VAR_23;
VAR_1++;
break;
case '!':
VAR_4->param = 0;
VAR_4->nparams = 0;
VAR_4->state = VAR_24;
VAR_1++;
break;
case '#':
VAR_4->param = 0;
VAR_4->nparams = 0;
VAR_4->state = VAR_25;
VAR_1++;
break;
case '$':
VAR_4->pos_x = 0;
VAR_1++;
break;
case '-':
VAR_4->pos_x = 0;
VAR_4->pos_y += 6;
VAR_1++;
break;
default:
if (*VAR_1 >= '?' && *VAR_1 <= '~') {  
if (VAR_3->width < (VAR_4->pos_x + VAR_4->repeat_count) || VAR_3->height < (VAR_4->pos_y + 6)) {
VAR_13 = VAR_3->width * 2;
VAR_14 = VAR_3->height * 2;
while (VAR_13 < (VAR_4->pos_x + VAR_4->repeat_count) || VAR_14 < (VAR_4->pos_y + 6)) {
VAR_13 *= 2;
VAR_14 *= 2;
}
VAR_6 = image_buffer_resize(VAR_3, VAR_13, VAR_14, VAR_4->bgindex, VAR_5);
if (SIXEL_FAILED(VAR_6)) {
goto end;
}
}
if (VAR_4->color_index > VAR_3->ncolors) {
VAR_3->ncolors = VAR_4->color_index;
}
VAR_11 = *VAR_1 - '?';
if (VAR_11 == 0) {
VAR_4->pos_x += VAR_4->repeat_count;
} else {
VAR_12 = 0x01;
if (VAR_4->repeat_count <= 1) {
for (VAR_9 = 0; VAR_9 < 6; VAR_9++) {
if ((VAR_11 & VAR_12) != 0) {
VAR_16 = VAR_3->width * (VAR_4->pos_y + VAR_9) + VAR_4->pos_x;
VAR_3->data[VAR_16] = VAR_4->color_index;
if (VAR_4->max_x < VAR_4->pos_x) {
VAR_4->max_x = VAR_4->pos_x;
}
if (VAR_4->max_y < (VAR_4->pos_y + VAR_9)) {
VAR_4->max_y = VAR_4->pos_y + VAR_9;
}
}
VAR_12 <<= 1;
}
VAR_4->pos_x += 1;
} else {
for (VAR_9 = 0; VAR_9 < 6; VAR_9++) {
if ((VAR_11 & VAR_12) != 0) {
VAR_15 = VAR_12 << 1;
for (VAR_8 = 1; (VAR_9 + VAR_8) < 6; VAR_8++) {
if ((VAR_11 & VAR_15) == 0) {
break;
}
VAR_15 <<= 1;
}
for (VAR_10 = VAR_4->pos_y + VAR_9; VAR_10 < VAR_4->pos_y + VAR_9 + VAR_8; ++VAR_10) {
memset(VAR_3->data + VAR_3->width * VAR_10 + VAR_4->pos_x,
VAR_4->color_index,
(size_t)VAR_4->repeat_count);
}
if (VAR_4->max_x < (VAR_4->pos_x + VAR_4->repeat_count - 1)) {
VAR_4->max_x = VAR_4->pos_x + VAR_4->repeat_count - 1;
}
if (VAR_4->max_y < (VAR_4->pos_y + VAR_9 + VAR_8 - 1)) {
VAR_4->max_y = VAR_4->pos_y + VAR_9 + VAR_8 - 1;
}
VAR_9 += (VAR_8 - 1);
VAR_12 <<= (VAR_8 - 1);
}
VAR_12 <<= 1;
}
VAR_4->pos_x += VAR_4->repeat_count;
}
}
VAR_4->repeat_count = 1;
}
VAR_1++;
break;
}
break;
case VAR_23:
switch (*VAR_1) {
case '\x1b':
VAR_4->state = VAR_19;
VAR_1++;
break;
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
VAR_4->param = VAR_4->param * 10 + *VAR_1 - '0';
VAR_1++;
break;
case ';':
if (VAR_4->nparams < VAR_21) {
VAR_4->params[VAR_4->nparams++] = VAR_4->param;
}
VAR_4->param = 0;
VAR_1++;
break;
default:
if (VAR_4->nparams < VAR_21) {
VAR_4->params[VAR_4->nparams++] = VAR_4->param;
}
if (VAR_4->nparams > 0) {
VAR_4->attributed_pad = VAR_4->params[0];
}
if (VAR_4->nparams > 1) {
VAR_4->attributed_pan = VAR_4->params[1];
}
if (VAR_4->nparams > 2 && VAR_4->params[2] > 0) {
VAR_4->attributed_ph = VAR_4->params[2];
}
if (VAR_4->nparams > 3 && VAR_4->params[3] > 0) {
VAR_4->attributed_pv = VAR_4->params[3];
}
if (VAR_4->attributed_pan <= 0) {
VAR_4->attributed_pan = 1;
}
if (VAR_4->attributed_pad <= 0) {
VAR_4->attributed_pad = 1;
}
if (VAR_3->width < VAR_4->attributed_ph ||
VAR_3->height < VAR_4->attributed_pv) {
VAR_13 = VAR_4->attributed_ph;
if (VAR_3->width > VAR_4->attributed_ph) {
VAR_13 = VAR_3->width;
}
VAR_14 = VAR_4->attributed_pv;
if (VAR_3->height > VAR_4->attributed_pv) {
VAR_14 = VAR_3->height;
}
VAR_6 = image_buffer_resize(VAR_3, VAR_13, VAR_14, VAR_4->bgindex, VAR_5);
if (SIXEL_FAILED(VAR_6)) {
goto end;
}
}
VAR_4->state = VAR_22;
VAR_4->param = 0;
VAR_4->nparams = 0;
}
break;
case VAR_24:
switch (*VAR_1) {
case '\x1b':
VAR_4->state = VAR_19;
VAR_1++;
break;
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
VAR_4->param = VAR_4->param * 10 + *VAR_1 - '0';
VAR_1++;
break;
default:
VAR_4->repeat_count = VAR_4->param;
if (VAR_4->repeat_count == 0) {
VAR_4->repeat_count = 1;
}
VAR_4->state = VAR_22;
VAR_4->param = 0;
VAR_4->nparams = 0;
break;
}
break;
case VAR_25:
switch (*VAR_1) {
case '\x1b':
VAR_4->state = VAR_19;
VAR_1++;
break;
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
VAR_4->param = VAR_4->param * 10 + *VAR_1 - '0';
VAR_1++;
break;
case ';':
if (VAR_4->nparams < VAR_21) {
VAR_4->params[VAR_4->nparams++] = VAR_4->param;
}
VAR_4->param = 0;
VAR_1++;
break;
default:
VAR_4->state = VAR_22;
if (VAR_4->nparams < VAR_21) {
VAR_4->params[VAR_4->nparams++] = VAR_4->param;
}
VAR_4->param = 0;
if (VAR_4->nparams > 0) {
VAR_4->color_index = VAR_4->params[0];
if (VAR_4->color_index < 0) {
VAR_4->color_index = 0;
} else if (VAR_4->color_index >= VAR_26) {
VAR_4->color_index = VAR_26 - 1;
}
}
if (VAR_4->nparams > 4) {
if (VAR_4->params[1] == 1) {
if (VAR_4->params[2] > 360) {
VAR_4->params[2] = 360;
}
if (VAR_4->params[3] > 100) {
VAR_4->params[3] = 100;
}
if (VAR_4->params[4] > 100) {
VAR_4->params[4] = 100;
}
VAR_3->palette[VAR_4->color_index]
= hls_to_rgb(VAR_4->params[2], VAR_4->params[3], VAR_4->params[4]);
} else if (VAR_4->params[1] == 2) {
if (VAR_4->params[2] > 100) {
VAR_4->params[2] = 100;
}
if (VAR_4->params[3] > 100) {
VAR_4->params[3] = 100;
}
if (VAR_4->params[4] > 100) {
VAR_4->params[4] = 100;
}
VAR_3->palette[VAR_4->color_index]
= SIXEL_XRGB(VAR_4->params[2], VAR_4->params[3], VAR_4->params[4]);
}
}
break;
}
break;
default:
break;
}
}
finalize:
if (++VAR_4->max_x < VAR_4->attributed_ph) {
VAR_4->max_x = VAR_4->attributed_ph;
}
if (++VAR_4->max_y < VAR_4->attributed_pv) {
VAR_4->max_y = VAR_4->attributed_pv;
}
if (VAR_3->width > VAR_4->max_x || VAR_3->height > VAR_4->max_y) {
VAR_6 = image_buffer_resize(VAR_3, VAR_4->max_x, VAR_4->max_y, VAR_4->bgindex, VAR_5);
if (SIXEL_FAILED(VAR_6)) {
goto end;
}
}
VAR_6 = VAR_27;
end:
return VAR_6;
}",,"SIXELAPI SIXELSTATUS
sixel_decode_raw_impl(
    unsigned char     *p,         /* sixel bytes */
    int                len,       /* size of sixel bytes */
    image_buffer_t    *image,
    parser_context_t  *context,
    sixel_allocator_t *allocator) /* allocator object */
{
    SIXELSTATUS status = SIXEL_FALSE;
    int n;
    int i;
    int y;
    int bits;
    int sixel_vertical_mask;
    int sx;
    int sy;
    int c;
    int pos;
    unsigned char *p0 = p;

    while (p < p0 + len) {
        switch (context->state) {
        case PS_GROUND:
            switch (*p) {
            case 0x1b:
                context->state = PS_ESC;
                p++;
                break;
            case 0x90:
                context->state = PS_DCS;
                p++;
                break;
            case 0x9c:
                p++;
                goto finalize;
            default:
                p++;
                break;
            }
            break;

        case PS_ESC:
            switch (*p) {
            case '\\':
            case 0x9c:
                p++;
                goto finalize;
            case 'P':
                context->param = -1;
                context->state = PS_DCS;
                p++;
                break;
            default:
                p++;
                break;
            }
            break;

        case PS_DCS:
            switch (*p) {
            case 0x1b:
                context->state = PS_ESC;
                p++;
                break;
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                if (context->param < 0) {
                    context->param = 0;
                }
                context->param = context->param * 10 + *p - '0';
                p++;
                break;
            case ';':
                if (context->param < 0) {
                    context->param = 0;
                }
                if (context->nparams < DECSIXEL_PARAMS_MAX) {
                    context->params[context->nparams++] = context->param;
                }
                context->param = 0;
                p++;
                break;
            case 'q':
                if (context->param >= 0 && context->nparams < DECSIXEL_PARAMS_MAX) {
                    context->params[context->nparams++] = context->param;
                }
                if (context->nparams > 0) {
                    /* Pn1 */
                    switch (context->params[0]) {
                    case 0:
                    case 1:
                        context->attributed_pad = 2;
                        break;
                    case 2:
                        context->attributed_pad = 5;
                        break;
                    case 3:
                    case 4:
                        context->attributed_pad = 4;
                        break;
                    case 5:
                    case 6:
                        context->attributed_pad = 3;
                        break;
                    case 7:
                    case 8:
                        context->attributed_pad = 2;
                        break;
                    case 9:
                        context->attributed_pad = 1;
                        break;
                    default:
                        context->attributed_pad = 2;
                        break;
                    }
                }

                if (context->nparams > 2) {
                    /* Pn3 */
                    if (context->params[2] == 0) {
                        context->params[2] = 10;
                    }
                    context->attributed_pan = context->attributed_pan * context->params[2] / 10;
                    context->attributed_pad = context->attributed_pad * context->params[2] / 10;
                    if (context->attributed_pan <= 0) {
                        context->attributed_pan = 1;
                    }
                    if (context->attributed_pad <= 0) {
                        context->attributed_pad = 1;
                    }
                }
                context->nparams = 0;
                context->state = PS_DECSIXEL;
                p++;
                break;
            default:
                p++;
                break;
            }
            break;

        case PS_DECSIXEL:
            switch (*p) {
            case '\x1b':
                context->state = PS_ESC;
                p++;
                break;
            case '""':
                context->param = 0;
                context->nparams = 0;
                context->state = PS_DECGRA;
                p++;
                break;
            case '!':
                context->param = 0;
                context->nparams = 0;
                context->state = PS_DECGRI;
                p++;
                break;
            case '#':
                context->param = 0;
                context->nparams = 0;
                context->state = PS_DECGCI;
                p++;
                break;
            case '$':
                /* DECGCR Graphics Carriage Return */
                context->pos_x = 0;
                p++;
                break;
            case '-':
                /* DECGNL Graphics Next Line */
                context->pos_x = 0;
                context->pos_y += 6;
                p++;
                break;
            default:
                if (*p >= '?' && *p <= '~') {  /* sixel characters */
                    if (image->width < (context->pos_x + context->repeat_count) || image->height < (context->pos_y + 6)) {
                        sx = image->width * 2;
                        sy = image->height * 2;
                        while (sx < (context->pos_x + context->repeat_count) || sy < (context->pos_y + 6)) {
                            sx *= 2;
                            sy *= 2;
                        }
                        status = image_buffer_resize(image, sx, sy, context->bgindex, allocator);
                        if (SIXEL_FAILED(status)) {
                            goto end;
                        }
                    }

                    if (context->color_index > image->ncolors) {
                        image->ncolors = context->color_index;
                    }

                    bits = *p - '?';

                    if (bits == 0) {
                        context->pos_x += context->repeat_count;
                    } else {
                        sixel_vertical_mask = 0x01;
                        if (context->repeat_count <= 1) {
                            for (i = 0; i < 6; i++) {
                                if ((bits & sixel_vertical_mask) != 0) {
                                    pos = image->width * (context->pos_y + i) + context->pos_x;
                                    image->data[pos] = context->color_index;
                                    if (context->max_x < context->pos_x) {
                                        context->max_x = context->pos_x;
                                    }
                                    if (context->max_y < (context->pos_y + i)) {
                                        context->max_y = context->pos_y + i;
                                    }
                                }
                                sixel_vertical_mask <<= 1;
                            }
                            context->pos_x += 1;
                        } else {
                            /* context->repeat_count > 1 */
                            for (i = 0; i < 6; i++) {
                                if ((bits & sixel_vertical_mask) != 0) {
                                    c = sixel_vertical_mask << 1;
                                    for (n = 1; (i + n) < 6; n++) {
                                        if ((bits & c) == 0) {
                                            break;
                                        }
                                        c <<= 1;
                                    }
                                    for (y = context->pos_y + i; y < context->pos_y + i + n; ++y) {
                                        memset(image->data + image->width * y + context->pos_x,
                                               context->color_index,
                                               (size_t)context->repeat_count);
                                    }
                                    if (context->max_x < (context->pos_x + context->repeat_count - 1)) {
                                        context->max_x = context->pos_x + context->repeat_count - 1;
                                    }
                                    if (context->max_y < (context->pos_y + i + n - 1)) {
                                        context->max_y = context->pos_y + i + n - 1;
                                    }
                                    i += (n - 1);
                                    sixel_vertical_mask <<= (n - 1);
                                }
                                sixel_vertical_mask <<= 1;
                            }
                            context->pos_x += context->repeat_count;
                        }
                    }
                    context->repeat_count = 1;
                }
                p++;
                break;
            }
            break;

        case PS_DECGRA:
            /* DECGRA Set Raster Attributes "" Pan; Pad; Ph; Pv */
            switch (*p) {
            case '\x1b':
                context->state = PS_ESC;
                p++;
                break;
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                context->param = context->param * 10 + *p - '0';
                p++;
                break;
            case ';':
                if (context->nparams < DECSIXEL_PARAMS_MAX) {
                    context->params[context->nparams++] = context->param;
                }
                context->param = 0;
                p++;
                break;
            default:
                if (context->nparams < DECSIXEL_PARAMS_MAX) {
                    context->params[context->nparams++] = context->param;
                }
                if (context->nparams > 0) {
                    context->attributed_pad = context->params[0];
                }
                if (context->nparams > 1) {
                    context->attributed_pan = context->params[1];
                }
                if (context->nparams > 2 && context->params[2] > 0) {
                    context->attributed_ph = context->params[2];
                }
                if (context->nparams > 3 && context->params[3] > 0) {
                    context->attributed_pv = context->params[3];
                }

                if (context->attributed_pan <= 0) {
                    context->attributed_pan = 1;
                }
                if (context->attributed_pad <= 0) {
                    context->attributed_pad = 1;
                }

                if (image->width < context->attributed_ph ||
                        image->height < context->attributed_pv) {
                    sx = context->attributed_ph;
                    if (image->width > context->attributed_ph) {
                        sx = image->width;
                    }

                    sy = context->attributed_pv;
                    if (image->height > context->attributed_pv) {
                        sy = image->height;
                    }

                    status = image_buffer_resize(image, sx, sy, context->bgindex, allocator);
                    if (SIXEL_FAILED(status)) {
                        goto end;
                    }
                }
                context->state = PS_DECSIXEL;
                context->param = 0;
                context->nparams = 0;
            }
            break;

        case PS_DECGRI:
            /* DECGRI Graphics Repeat Introducer ! Pn Ch */
            switch (*p) {
            case '\x1b':
                context->state = PS_ESC;
                p++;
                break;
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                context->param = context->param * 10 + *p - '0';
                p++;
                break;
            default:
                context->repeat_count = context->param;
                if (context->repeat_count == 0) {
                    context->repeat_count = 1;
                }
                if (context->repeat_count > 0xffff) { /* check too huge number */
                    status = SIXEL_BAD_INPUT;
                    goto end;
                }
                context->state = PS_DECSIXEL;
                context->param = 0;
                context->nparams = 0;
                break;
            }
            break;

        case PS_DECGCI:
            /* DECGCI Graphics Color Introducer # Pc; Pu; Px; Py; Pz */
            switch (*p) {
            case '\x1b':
                context->state = PS_ESC;
                p++;
                break;
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                context->param = context->param * 10 + *p - '0';
                p++;
                break;
            case ';':
                if (context->nparams < DECSIXEL_PARAMS_MAX) {
                    context->params[context->nparams++] = context->param;
                }
                context->param = 0;
                p++;
                break;
            default:
                context->state = PS_DECSIXEL;
                if (context->nparams < DECSIXEL_PARAMS_MAX) {
                    context->params[context->nparams++] = context->param;
                }
                context->param = 0;

                if (context->nparams > 0) {
                    context->color_index = context->params[0];
                    if (context->color_index < 0) {
                        context->color_index = 0;
                    } else if (context->color_index >= SIXEL_PALETTE_MAX) {
                        context->color_index = SIXEL_PALETTE_MAX - 1;
                    }
                }

                if (context->nparams > 4) {
                    if (context->params[1] == 1) {
                        /* HLS */
                        if (context->params[2] > 360) {
                            context->params[2] = 360;
                        }
                        if (context->params[3] > 100) {
                            context->params[3] = 100;
                        }
                        if (context->params[4] > 100) {
                            context->params[4] = 100;
                        }
                        image->palette[context->color_index]
                            = hls_to_rgb(context->params[2], context->params[3], context->params[4]);
                    } else if (context->params[1] == 2) {
                        /* RGB */
                        if (context->params[2] > 100) {
                            context->params[2] = 100;
                        }
                        if (context->params[3] > 100) {
                            context->params[3] = 100;
                        }
                        if (context->params[4] > 100) {
                            context->params[4] = 100;
                        }
                        image->palette[context->color_index]
                            = SIXEL_XRGB(context->params[2], context->params[3], context->params[4]);
                    }
                }
                break;
            }
            break;
        default:
            break;
        }
    }

finalize:
    if (++context->max_x < context->attributed_ph) {
        context->max_x = context->attributed_ph;
    }

    if (++context->max_y < context->attributed_pv) {
        context->max_y = context->attributed_pv;
    }

    if (image->width > context->max_x || image->height > context->max_y) {
        status = image_buffer_resize(image, context->max_x, context->max_y, context->bgindex, allocator);
        if (SIXEL_FAILED(status)) {
            goto end;
        }
    }

    status = SIXEL_OK;

end:
    return status;
}","SIXELAPI VAR_0
sixel_decode_raw_impl(
    unsigned char     *VAR_1,         /* COMMENT_0 */
    int                VAR_2,       /* COMMENT_1 */
    image_buffer_t    *VAR_3,
    parser_context_t  *VAR_4,
    sixel_allocator_t *VAR_5) /* COMMENT_2 */
{
    SIXELSTATUS VAR_6 = VAR_7;
    int VAR_8;
    int VAR_9;
    int VAR_10;
    int VAR_11;
    int VAR_12;
    int VAR_13;
    int VAR_14;
    int VAR_15;
    int VAR_16;
    unsigned char *VAR_17 = VAR_1;

    while (VAR_1 < VAR_17 + VAR_2) {
        switch (VAR_4->state) {
        case VAR_18:
            switch (*VAR_1) {
            case 0x1b:
                VAR_4->state = VAR_19;
                VAR_1++;
                break;
            case 0x90:
                VAR_4->state = VAR_20;
                VAR_1++;
                break;
            case 0x9c:
                VAR_1++;
                goto finalize;
            default:
                VAR_1++;
                break;
            }
            break;

        case VAR_19:
            switch (*VAR_1) {
            case '\\':
            case 0x9c:
                VAR_1++;
                goto finalize;
            case 'P':
                VAR_4->param = -1;
                VAR_4->state = VAR_20;
                VAR_1++;
                break;
            default:
                VAR_1++;
                break;
            }
            break;

        case VAR_20:
            switch (*VAR_1) {
            case 0x1b:
                VAR_4->state = VAR_19;
                VAR_1++;
                break;
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                if (VAR_4->param < 0) {
                    VAR_4->param = 0;
                }
                VAR_4->param = VAR_4->param * 10 + *VAR_1 - '0';
                VAR_1++;
                break;
            case ';':
                if (VAR_4->param < 0) {
                    VAR_4->param = 0;
                }
                if (VAR_4->nparams < VAR_21) {
                    VAR_4->params[VAR_4->nparams++] = VAR_4->param;
                }
                VAR_4->param = 0;
                VAR_1++;
                break;
            case 'q':
                if (VAR_4->param >= 0 && VAR_4->nparams < VAR_21) {
                    VAR_4->params[VAR_4->nparams++] = VAR_4->param;
                }
                if (VAR_4->nparams > 0) {
                    /* COMMENT_3 */
                    switch (VAR_4->params[0]) {
                    case 0:
                    case 1:
                        VAR_4->attributed_pad = 2;
                        break;
                    case 2:
                        VAR_4->attributed_pad = 5;
                        break;
                    case 3:
                    case 4:
                        VAR_4->attributed_pad = 4;
                        break;
                    case 5:
                    case 6:
                        VAR_4->attributed_pad = 3;
                        break;
                    case 7:
                    case 8:
                        VAR_4->attributed_pad = 2;
                        break;
                    case 9:
                        VAR_4->attributed_pad = 1;
                        break;
                    default:
                        VAR_4->attributed_pad = 2;
                        break;
                    }
                }

                if (VAR_4->nparams > 2) {
                    /* COMMENT_4 */
                    if (VAR_4->params[2] == 0) {
                        VAR_4->params[2] = 10;
                    }
                    VAR_4->attributed_pan = VAR_4->attributed_pan * VAR_4->params[2] / 10;
                    VAR_4->attributed_pad = VAR_4->attributed_pad * VAR_4->params[2] / 10;
                    if (VAR_4->attributed_pan <= 0) {
                        VAR_4->attributed_pan = 1;
                    }
                    if (VAR_4->attributed_pad <= 0) {
                        VAR_4->attributed_pad = 1;
                    }
                }
                VAR_4->nparams = 0;
                VAR_4->state = VAR_22;
                VAR_1++;
                break;
            default:
                VAR_1++;
                break;
            }
            break;

        case VAR_22:
            switch (*VAR_1) {
            case '\x1b':
                VAR_4->state = VAR_19;
                VAR_1++;
                break;
            case '""':
                VAR_4->param = 0;
                VAR_4->nparams = 0;
                VAR_4->state = VAR_23;
                VAR_1++;
                break;
            case '!':
                VAR_4->param = 0;
                VAR_4->nparams = 0;
                VAR_4->state = VAR_24;
                VAR_1++;
                break;
            case '#':
                VAR_4->param = 0;
                VAR_4->nparams = 0;
                VAR_4->state = VAR_25;
                VAR_1++;
                break;
            case '$':
                /* COMMENT_5 */
                VAR_4->pos_x = 0;
                VAR_1++;
                break;
            case '-':
                /* COMMENT_6 */
                VAR_4->pos_x = 0;
                VAR_4->pos_y += 6;
                VAR_1++;
                break;
            default:
                if (*VAR_1 >= '?' && *VAR_1 <= '~') {  /* COMMENT_7 */
                    if (VAR_3->width < (VAR_4->pos_x + VAR_4->repeat_count) || VAR_3->height < (VAR_4->pos_y + 6)) {
                        VAR_13 = VAR_3->width * 2;
                        VAR_14 = VAR_3->height * 2;
                        while (VAR_13 < (VAR_4->pos_x + VAR_4->repeat_count) || VAR_14 < (VAR_4->pos_y + 6)) {
                            VAR_13 *= 2;
                            VAR_14 *= 2;
                        }
                        VAR_6 = image_buffer_resize(VAR_3, VAR_13, VAR_14, VAR_4->bgindex, VAR_5);
                        if (SIXEL_FAILED(VAR_6)) {
                            goto end;
                        }
                    }

                    if (VAR_4->color_index > VAR_3->ncolors) {
                        VAR_3->ncolors = VAR_4->color_index;
                    }

                    VAR_11 = *VAR_1 - '?';

                    if (VAR_11 == 0) {
                        VAR_4->pos_x += VAR_4->repeat_count;
                    } else {
                        VAR_12 = 0x01;
                        if (VAR_4->repeat_count <= 1) {
                            for (VAR_9 = 0; VAR_9 < 6; VAR_9++) {
                                if ((VAR_11 & VAR_12) != 0) {
                                    VAR_16 = VAR_3->width * (VAR_4->pos_y + VAR_9) + VAR_4->pos_x;
                                    VAR_3->data[VAR_16] = VAR_4->color_index;
                                    if (VAR_4->max_x < VAR_4->pos_x) {
                                        VAR_4->max_x = VAR_4->pos_x;
                                    }
                                    if (VAR_4->max_y < (VAR_4->pos_y + VAR_9)) {
                                        VAR_4->max_y = VAR_4->pos_y + VAR_9;
                                    }
                                }
                                VAR_12 <<= 1;
                            }
                            VAR_4->pos_x += 1;
                        } else {
                            /* COMMENT_8 */
                            for (VAR_9 = 0; VAR_9 < 6; VAR_9++) {
                                if ((VAR_11 & VAR_12) != 0) {
                                    VAR_15 = VAR_12 << 1;
                                    for (VAR_8 = 1; (VAR_9 + VAR_8) < 6; VAR_8++) {
                                        if ((VAR_11 & VAR_15) == 0) {
                                            break;
                                        }
                                        VAR_15 <<= 1;
                                    }
                                    for (VAR_10 = VAR_4->pos_y + VAR_9; VAR_10 < VAR_4->pos_y + VAR_9 + VAR_8; ++VAR_10) {
                                        memset(VAR_3->data + VAR_3->width * VAR_10 + VAR_4->pos_x,
                                               VAR_4->color_index,
                                               (size_t)VAR_4->repeat_count);
                                    }
                                    if (VAR_4->max_x < (VAR_4->pos_x + VAR_4->repeat_count - 1)) {
                                        VAR_4->max_x = VAR_4->pos_x + VAR_4->repeat_count - 1;
                                    }
                                    if (VAR_4->max_y < (VAR_4->pos_y + VAR_9 + VAR_8 - 1)) {
                                        VAR_4->max_y = VAR_4->pos_y + VAR_9 + VAR_8 - 1;
                                    }
                                    VAR_9 += (VAR_8 - 1);
                                    VAR_12 <<= (VAR_8 - 1);
                                }
                                VAR_12 <<= 1;
                            }
                            VAR_4->pos_x += VAR_4->repeat_count;
                        }
                    }
                    VAR_4->repeat_count = 1;
                }
                VAR_1++;
                break;
            }
            break;

        case VAR_23:
            /* COMMENT_9 */
            switch (*VAR_1) {
            case '\x1b':
                VAR_4->state = VAR_19;
                VAR_1++;
                break;
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                VAR_4->param = VAR_4->param * 10 + *VAR_1 - '0';
                VAR_1++;
                break;
            case ';':
                if (VAR_4->nparams < VAR_21) {
                    VAR_4->params[VAR_4->nparams++] = VAR_4->param;
                }
                VAR_4->param = 0;
                VAR_1++;
                break;
            default:
                if (VAR_4->nparams < VAR_21) {
                    VAR_4->params[VAR_4->nparams++] = VAR_4->param;
                }
                if (VAR_4->nparams > 0) {
                    VAR_4->attributed_pad = VAR_4->params[0];
                }
                if (VAR_4->nparams > 1) {
                    VAR_4->attributed_pan = VAR_4->params[1];
                }
                if (VAR_4->nparams > 2 && VAR_4->params[2] > 0) {
                    VAR_4->attributed_ph = VAR_4->params[2];
                }
                if (VAR_4->nparams > 3 && VAR_4->params[3] > 0) {
                    VAR_4->attributed_pv = VAR_4->params[3];
                }

                if (VAR_4->attributed_pan <= 0) {
                    VAR_4->attributed_pan = 1;
                }
                if (VAR_4->attributed_pad <= 0) {
                    VAR_4->attributed_pad = 1;
                }

                if (VAR_3->width < VAR_4->attributed_ph ||
                        VAR_3->height < VAR_4->attributed_pv) {
                    VAR_13 = VAR_4->attributed_ph;
                    if (VAR_3->width > VAR_4->attributed_ph) {
                        VAR_13 = VAR_3->width;
                    }

                    VAR_14 = VAR_4->attributed_pv;
                    if (VAR_3->height > VAR_4->attributed_pv) {
                        VAR_14 = VAR_3->height;
                    }

                    VAR_6 = image_buffer_resize(VAR_3, VAR_13, VAR_14, VAR_4->bgindex, VAR_5);
                    if (SIXEL_FAILED(VAR_6)) {
                        goto end;
                    }
                }
                VAR_4->state = VAR_22;
                VAR_4->param = 0;
                VAR_4->nparams = 0;
            }
            break;

        case VAR_24:
            /* COMMENT_10 */
            switch (*VAR_1) {
            case '\x1b':
                VAR_4->state = VAR_19;
                VAR_1++;
                break;
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                VAR_4->param = VAR_4->param * 10 + *VAR_1 - '0';
                VAR_1++;
                break;
            default:
                VAR_4->repeat_count = VAR_4->param;
                if (VAR_4->repeat_count == 0) {
                    VAR_4->repeat_count = 1;
                }
                if (VAR_4->repeat_count > 0xffff) { /* COMMENT_11 */
                    VAR_6 = VAR_26;
                    goto end;
                }
                VAR_4->state = VAR_22;
                VAR_4->param = 0;
                VAR_4->nparams = 0;
                break;
            }
            break;

        case VAR_25:
            /* COMMENT_12 */
            switch (*VAR_1) {
            case '\x1b':
                VAR_4->state = VAR_19;
                VAR_1++;
                break;
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                VAR_4->param = VAR_4->param * 10 + *VAR_1 - '0';
                VAR_1++;
                break;
            case ';':
                if (VAR_4->nparams < VAR_21) {
                    VAR_4->params[VAR_4->nparams++] = VAR_4->param;
                }
                VAR_4->param = 0;
                VAR_1++;
                break;
            default:
                VAR_4->state = VAR_22;
                if (VAR_4->nparams < VAR_21) {
                    VAR_4->params[VAR_4->nparams++] = VAR_4->param;
                }
                VAR_4->param = 0;

                if (VAR_4->nparams > 0) {
                    VAR_4->color_index = VAR_4->params[0];
                    if (VAR_4->color_index < 0) {
                        VAR_4->color_index = 0;
                    } else if (VAR_4->color_index >= VAR_27) {
                        VAR_4->color_index = VAR_27 - 1;
                    }
                }

                if (VAR_4->nparams > 4) {
                    if (VAR_4->params[1] == 1) {
                        /* COMMENT_13 */
                        if (VAR_4->params[2] > 360) {
                            VAR_4->params[2] = 360;
                        }
                        if (VAR_4->params[3] > 100) {
                            VAR_4->params[3] = 100;
                        }
                        if (VAR_4->params[4] > 100) {
                            VAR_4->params[4] = 100;
                        }
                        VAR_3->palette[VAR_4->color_index]
                            = hls_to_rgb(VAR_4->params[2], VAR_4->params[3], VAR_4->params[4]);
                    } else if (VAR_4->params[1] == 2) {
                        /* COMMENT_14 */
                        if (VAR_4->params[2] > 100) {
                            VAR_4->params[2] = 100;
                        }
                        if (VAR_4->params[3] > 100) {
                            VAR_4->params[3] = 100;
                        }
                        if (VAR_4->params[4] > 100) {
                            VAR_4->params[4] = 100;
                        }
                        VAR_3->palette[VAR_4->color_index]
                            = SIXEL_XRGB(VAR_4->params[2], VAR_4->params[3], VAR_4->params[4]);
                    }
                }
                break;
            }
            break;
        default:
            break;
        }
    }

finalize:
    if (++VAR_4->max_x < VAR_4->attributed_ph) {
        VAR_4->max_x = VAR_4->attributed_ph;
    }

    if (++VAR_4->max_y < VAR_4->attributed_pv) {
        VAR_4->max_y = VAR_4->attributed_pv;
    }

    if (VAR_3->width > VAR_4->max_x || VAR_3->height > VAR_4->max_y) {
        VAR_6 = image_buffer_resize(VAR_3, VAR_4->max_x, VAR_4->max_y, VAR_4->bgindex, VAR_5);
        if (SIXEL_FAILED(VAR_6)) {
            goto end;
        }
    }

    VAR_6 = VAR_28;

end:
    return VAR_6;
}",,"--- func_before
+++ func_after
@@ -358,6 +358,10 @@
                 if (context->repeat_count == 0) {
                     context->repeat_count = 1;
                 }
+                if (context->repeat_count > 0xffff) { /* check too huge number */
+                    status = SIXEL_BAD_INPUT;
+                    goto end;
+                }
                 context->state = PS_DECSIXEL;
                 context->param = 0;
                 context->nparams = 0;","{'deleted_lines': [], 'added_lines': ['                if (context->repeat_count > 0xffff) { /* check too huge number */', '                    status = SIXEL_BAD_INPUT;', '                    goto end;', '                }']}",True,"In libsixel v1.8.2, there is an infinite loop in the function sixel_decode_raw_impl() in the file fromsixel.c, as demonstrated by sixel2png.",5.5,MEDIUM,1,test,2019-08-29T07:47:05Z,3
CVE-2019-3573,"['CWE-835', 'CWE-125']",AV:N/AC:M/Au:N/C:N/I:N/A:P,0,saitoha/libsixel,check jpeg decoder error,68ecbc1fec8772ddaace1cb2ddd0ab04eb1d1ac1,https://github.com/saitoha/libsixel/commit/68ecbc1fec8772ddaace1cb2ddd0ab04eb1d1ac1,src/loader.c,load_jpeg,"static SIXELSTATUS
load_jpeg(unsigned char **result,
unsigned char *data,
size_t datasize,
int *pwidth,
int *pheight,
int *ppixelformat,
sixel_allocator_t *allocator)
{
SIXELSTATUS status = SIXEL_JPEG_ERROR;
JDIMENSION row_stride;
size_t size;
JSAMPARRAY buffer;
struct jpeg_decompress_struct cinfo;
struct jpeg_error_mgr pub;
cinfo.err = jpeg_std_error(&pub);
jpeg_create_decompress(&cinfo);
jpeg_mem_src(&cinfo, data, datasize);
jpeg_read_header(&cinfo, TRUE);
cinfo.quantize_colors = FALSE;
cinfo.out_color_space = JCS_RGB;
jpeg_start_decompress(&cinfo);
if (cinfo.output_components != 3) {
sixel_helper_set_additional_message(
""load_jpeg: unknown pixel format."");
status = SIXEL_BAD_INPUT;
goto end;
}
*ppixelformat = SIXEL_PIXELFORMAT_RGB888;
*pwidth = (int)cinfo.output_width;
*pheight = (int)cinfo.output_height;
size = (size_t)(*pwidth * *pheight * cinfo.output_components);
*result = (unsigned char *)sixel_allocator_malloc(allocator, size);
if (*result == NULL) {
sixel_helper_set_additional_message(
""load_jpeg: sixel_allocator_malloc() failed."");
status = SIXEL_BAD_ALLOCATION;
goto end;
}
row_stride = cinfo.output_width * (unsigned int)cinfo.output_components;
buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, row_stride, 1);
while (cinfo.output_scanline < cinfo.output_height) {
jpeg_read_scanlines(&cinfo, buffer, 1);
memcpy(*result + (cinfo.output_scanline - 1) * row_stride, buffer[0], row_stride);
}
status = SIXEL_OK;
end:
jpeg_finish_decompress(&cinfo);
jpeg_destroy_decompress(&cinfo);
return status;
}","static SIXELSTATUS
load_jpeg(unsigned char **VAR_0,
unsigned char *VAR_1,
size_t VAR_2,
int *VAR_3,
int *VAR_4,
int *VAR_5,
sixel_allocator_t *VAR_6)
{
SIXELSTATUS VAR_7 = VAR_8;
JDIMENSION VAR_9;
size_t VAR_10;
JSAMPARRAY VAR_11;
struct jpeg_decompress_struct VAR_12;
struct jpeg_error_mgr VAR_13;
VAR_12.err = jpeg_std_error(&VAR_13);
jpeg_create_decompress(&VAR_12);
jpeg_mem_src(&VAR_12, VAR_1, VAR_2);
jpeg_read_header(&VAR_12, TRUE);
VAR_12.quantize_colors = FALSE;
VAR_12.out_color_space = VAR_14;
jpeg_start_decompress(&VAR_12);
if (VAR_12.output_components != 3) {
sixel_helper_set_additional_message(
""load_jpeg: unknown pixel format."");
VAR_7 = VAR_15;
goto end;
}
*VAR_5 = VAR_16;
*VAR_3 = (int)VAR_12.output_width;
*VAR_4 = (int)VAR_12.output_height;
VAR_10 = (size_t)(*VAR_3 * *VAR_4 * VAR_12.output_components);
*VAR_0 = (unsigned char *)sixel_allocator_malloc(VAR_6, VAR_10);
if (*VAR_0 == NULL) {
sixel_helper_set_additional_message(
""load_jpeg: sixel_allocator_malloc() failed."");
VAR_7 = VAR_17;
goto end;
}
VAR_9 = VAR_12.output_width * (unsigned int)VAR_12.output_components;
VAR_11 = (*VAR_12.mem->alloc_sarray)((VAR_18)&VAR_12, VAR_19, VAR_9, 1);
while (VAR_12.output_scanline < VAR_12.output_height) {
jpeg_read_scanlines(&VAR_12, VAR_11, 1);
memcpy(*VAR_0 + (VAR_12.output_scanline - 1) * VAR_9, VAR_11[0], VAR_9);
}
VAR_7 = VAR_20;
end:
jpeg_finish_decompress(&VAR_12);
jpeg_destroy_decompress(&VAR_12);
return VAR_7;
}",saitoha/libsixel/68ecbc1fec8772ddaace1cb2ddd0ab04eb1d1ac1/loader.c/vul/before/0.json,"static SIXELSTATUS
load_jpeg(unsigned char **result,
          unsigned char *data,
          size_t datasize,
          int *pwidth,
          int *pheight,
          int *ppixelformat,
          sixel_allocator_t *allocator)
{
    SIXELSTATUS status = SIXEL_JPEG_ERROR;
    JDIMENSION row_stride;
    size_t size;
    JSAMPARRAY buffer;
    struct jpeg_decompress_struct cinfo;
    struct jpeg_error_mgr pub;

    cinfo.err = jpeg_std_error(&pub);

    jpeg_create_decompress(&cinfo);
    jpeg_mem_src(&cinfo, data, datasize);
    jpeg_read_header(&cinfo, TRUE);

    /* disable colormap (indexed color), grayscale -> rgb */
    cinfo.quantize_colors = FALSE;
    cinfo.out_color_space = JCS_RGB;
    jpeg_start_decompress(&cinfo);

    if (cinfo.output_components != 3) {
        sixel_helper_set_additional_message(
            ""load_jpeg: unknown pixel format."");
        status = SIXEL_BAD_INPUT;
        goto end;
    }

    *ppixelformat = SIXEL_PIXELFORMAT_RGB888;
    *pwidth = (int)cinfo.output_width;
    *pheight = (int)cinfo.output_height;

    size = (size_t)(*pwidth * *pheight * cinfo.output_components);
    *result = (unsigned char *)sixel_allocator_malloc(allocator, size);
    if (*result == NULL) {
        sixel_helper_set_additional_message(
            ""load_jpeg: sixel_allocator_malloc() failed."");
        status = SIXEL_BAD_ALLOCATION;
        goto end;
    }
    row_stride = cinfo.output_width * (unsigned int)cinfo.output_components;
    buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, row_stride, 1);

    while (cinfo.output_scanline < cinfo.output_height) {
        jpeg_read_scanlines(&cinfo, buffer, 1);
        if (cinfo.err->num_warnings > 0) {
            sixel_helper_set_additional_message(
                ""jpeg_read_scanlines: error/warining occuered."");
            status = SIXEL_BAD_INPUT;
            goto end;
        }
        memcpy(*result + (cinfo.output_scanline - 1) * row_stride, buffer[0], row_stride);
    }

    status = SIXEL_OK;

end:
    jpeg_finish_decompress(&cinfo);
    jpeg_destroy_decompress(&cinfo);

    return status;
}","static SIXELSTATUS
load_jpeg(unsigned char **VAR_0,
          unsigned char *VAR_1,
          size_t VAR_2,
          int *VAR_3,
          int *VAR_4,
          int *VAR_5,
          sixel_allocator_t *VAR_6)
{
    SIXELSTATUS VAR_7 = VAR_8;
    JDIMENSION VAR_9;
    size_t VAR_10;
    JSAMPARRAY VAR_11;
    struct jpeg_decompress_struct VAR_12;
    struct jpeg_error_mgr VAR_13;

    VAR_12.err = jpeg_std_error(&VAR_13);

    jpeg_create_decompress(&VAR_12);
    jpeg_mem_src(&VAR_12, VAR_1, VAR_2);
    jpeg_read_header(&VAR_12, TRUE);

    /* COMMENT_0 */
    VAR_12.quantize_colors = FALSE;
    VAR_12.out_color_space = VAR_14;
    jpeg_start_decompress(&VAR_12);

    if (VAR_12.output_components != 3) {
        sixel_helper_set_additional_message(
            ""load_jpeg: unknown pixel format."");
        VAR_7 = VAR_15;
        goto end;
    }

    *VAR_5 = VAR_16;
    *VAR_3 = (int)VAR_12.output_width;
    *VAR_4 = (int)VAR_12.output_height;

    VAR_10 = (size_t)(*VAR_3 * *VAR_4 * VAR_12.output_components);
    *VAR_0 = (unsigned char *)sixel_allocator_malloc(VAR_6, VAR_10);
    if (*VAR_0 == NULL) {
        sixel_helper_set_additional_message(
            ""load_jpeg: sixel_allocator_malloc() failed."");
        VAR_7 = VAR_17;
        goto end;
    }
    VAR_9 = VAR_12.output_width * (unsigned int)VAR_12.output_components;
    VAR_11 = (*VAR_12.mem->alloc_sarray)((VAR_18)&VAR_12, VAR_19, VAR_9, 1);

    while (VAR_12.output_scanline < VAR_12.output_height) {
        jpeg_read_scanlines(&VAR_12, VAR_11, 1);
        if (VAR_12.err->num_warnings > 0) {
            sixel_helper_set_additional_message(
                ""jpeg_read_scanlines: error/warining occuered."");
            VAR_7 = VAR_15;
            goto end;
        }
        memcpy(*VAR_0 + (VAR_12.output_scanline - 1) * VAR_9, VAR_11[0], VAR_9);
    }

    VAR_7 = VAR_20;

end:
    jpeg_finish_decompress(&VAR_12);
    jpeg_destroy_decompress(&VAR_12);

    return VAR_7;
}",saitoha/libsixel/68ecbc1fec8772ddaace1cb2ddd0ab04eb1d1ac1/loader.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -49,6 +49,12 @@
 
     while (cinfo.output_scanline < cinfo.output_height) {
         jpeg_read_scanlines(&cinfo, buffer, 1);
+        if (cinfo.err->num_warnings > 0) {
+            sixel_helper_set_additional_message(
+                ""jpeg_read_scanlines: error/warining occuered."");
+            status = SIXEL_BAD_INPUT;
+            goto end;
+        }
         memcpy(*result + (cinfo.output_scanline - 1) * row_stride, buffer[0], row_stride);
     }
 ","{'deleted_lines': [], 'added_lines': ['        if (cinfo.err->num_warnings > 0) {', '            sixel_helper_set_additional_message(', '                ""jpeg_read_scanlines: error/warining occuered."");', '            status = SIXEL_BAD_INPUT;', '            goto end;', '        }']}",True,"In libsixel v1.8.2, there is an infinite loop in the function sixel_decode_raw_impl() in the file fromsixel.c, as demonstrated by sixel2png.",5.5,MEDIUM,1,test,2019-08-29T08:05:15Z,3
CVE-2019-17498,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,libssh2,"packet.c: improve message parsing (#402)

* packet.c: improve parsing of packets

file: packet.c

notes:
Use _libssh2_get_string API in SSH_MSG_DEBUG/SSH_MSG_DISCONNECT. Additional uint32 bounds check in SSH_MSG_GLOBAL_REQUEST.",dedcbd106f8e52d5586b0205bc7677e4c9868f9c,https://github.com/libssh2/libssh2/commit/dedcbd106f8e52d5586b0205bc7677e4c9868f9c,src/packet.c,_libssh2_packet_add,"int
_libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data,
size_t datalen, int macstate)
{
int rc = 0;
char *message = NULL;
char *language = NULL;
size_t message_len = 0;
size_t language_len = 0;
LIBSSH2_CHANNEL *channelp = NULL;
size_t data_head = 0;
unsigned char msg = data[0];
switch(session->packAdd_state) {
case libssh2_NB_state_idle:
_libssh2_debug(session, LIBSSH2_TRACE_TRANS,
""Packet type %d received, length=%d"",
(int) msg, (int) datalen);
if((macstate == LIBSSH2_MAC_INVALID) &&
(!session->macerror ||
LIBSSH2_MACERROR(session, (char *) data, datalen))) {
LIBSSH2_FREE(session, data);
return _libssh2_error(session, LIBSSH2_ERROR_INVALID_MAC,
""Invalid MAC received"");
}
session->packAdd_state = libssh2_NB_state_allocated;
break;
case libssh2_NB_state_jump1:
goto libssh2_packet_add_jump_point1;
case libssh2_NB_state_jump2:
goto libssh2_packet_add_jump_point2;
case libssh2_NB_state_jump3:
goto libssh2_packet_add_jump_point3;
case libssh2_NB_state_jump4:
goto libssh2_packet_add_jump_point4;
case libssh2_NB_state_jump5:
goto libssh2_packet_add_jump_point5;
default: 
break;
}
if(session->packAdd_state == libssh2_NB_state_allocated) {
switch(msg) {
case SSH_MSG_DISCONNECT:
if(datalen >= 5) {
size_t reason = _libssh2_ntohu32(data + 1);
if(datalen >= 9) {
message_len = _libssh2_ntohu32(data + 5);
if(message_len < datalen-13) {
message = (char *) data + 9;
language_len =
_libssh2_ntohu32(data + 9 + message_len);
language = (char *) data + 9 + message_len + 4;
if(language_len > (datalen-13-message_len)) {
language = message = NULL;
language_len = message_len = 0;
}
}
else
message_len = 0;
}
if(session->ssh_msg_disconnect) {
LIBSSH2_DISCONNECT(session, reason, message,
message_len, language, language_len);
}
_libssh2_debug(session, LIBSSH2_TRACE_TRANS,
""Disconnect(%d): %s(%s)"", reason,
message, language);
}
LIBSSH2_FREE(session, data);
session->socket_state = LIBSSH2_SOCKET_DISCONNECTED;
session->packAdd_state = libssh2_NB_state_idle;
return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_DISCONNECT,
""socket disconnect"");
case SSH_MSG_IGNORE:
if(datalen >= 2) {
if(session->ssh_msg_ignore) {
LIBSSH2_IGNORE(session, (char *) data + 1, datalen - 1);
}
}
else if(session->ssh_msg_ignore) {
LIBSSH2_IGNORE(session, """", 0);
}
LIBSSH2_FREE(session, data);
session->packAdd_state = libssh2_NB_state_idle;
return 0;
case SSH_MSG_DEBUG:
if(datalen >= 2) {
int always_display = data[1];
if(datalen >= 6) {
message_len = _libssh2_ntohu32(data + 2);
if(message_len <= (datalen - 10)) {
message = (char *) data + 6;
language_len = _libssh2_ntohu32(data + 6 +
message_len);
if(language_len <= (datalen - 10 - message_len))
language = (char *) data + 10 + message_len;
}
}
if(session->ssh_msg_debug) {
LIBSSH2_DEBUG(session, always_display, message,
message_len, language, language_len);
}
}
_libssh2_debug(session, LIBSSH2_TRACE_TRANS,
""Debug Packet: %s"", message);
LIBSSH2_FREE(session, data);
session->packAdd_state = libssh2_NB_state_idle;
return 0;
case SSH_MSG_GLOBAL_REQUEST:
if(datalen >= 5) {
uint32_t len = 0;
unsigned char want_reply = 0;
len = _libssh2_ntohu32(data + 1);
if(datalen >= (6 + len)) {
want_reply = data[5 + len];
_libssh2_debug(session,
LIBSSH2_TRACE_CONN,
""Received global request type %.*s (wr %X)"",
len, data + 5, want_reply);
}
if(want_reply) {
static const unsigned char packet =
SSH_MSG_REQUEST_FAILURE;
libssh2_packet_add_jump_point5:
session->packAdd_state = libssh2_NB_state_jump5;
rc = _libssh2_transport_send(session, &packet, 1, NULL, 0);
if(rc == LIBSSH2_ERROR_EAGAIN)
return rc;
}
}
LIBSSH2_FREE(session, data);
session->packAdd_state = libssh2_NB_state_idle;
return 0;
case SSH_MSG_CHANNEL_EXTENDED_DATA:
data_head += 4;
case SSH_MSG_CHANNEL_DATA:
data_head += 9;
if(datalen >= data_head)
channelp =
_libssh2_channel_locate(session,
_libssh2_ntohu32(data + 1));
if(!channelp) {
_libssh2_error(session, LIBSSH2_ERROR_CHANNEL_UNKNOWN,
""Packet received for unknown channel"");
LIBSSH2_FREE(session, data);
session->packAdd_state = libssh2_NB_state_idle;
return 0;
}
#ifdef LIBSSH2DEBUG
{
uint32_t stream_id = 0;
if(msg == SSH_MSG_CHANNEL_EXTENDED_DATA)
stream_id = _libssh2_ntohu32(data + 5);
_libssh2_debug(session, LIBSSH2_TRACE_CONN,
""%d bytes packet_add() for %lu/%lu/%lu"",
(int) (datalen - data_head),
channelp->local.id,
channelp->remote.id,
stream_id);
}
#endif
if((channelp->remote.extended_data_ignore_mode ==
LIBSSH2_CHANNEL_EXTENDED_DATA_IGNORE) &&
(msg == SSH_MSG_CHANNEL_EXTENDED_DATA)) {
LIBSSH2_FREE(session, data);
_libssh2_debug(session, LIBSSH2_TRACE_CONN,
""Ignoring extended data and refunding %d bytes"",
(int) (datalen - 13));
if(channelp->read_avail + datalen - data_head >=
channelp->remote.window_size)
datalen = channelp->remote.window_size -
channelp->read_avail + data_head;
channelp->remote.window_size -= datalen - data_head;
_libssh2_debug(session, LIBSSH2_TRACE_CONN,
""shrinking window size by %lu bytes to %lu, ""
""read_avail %lu"",
datalen - data_head,
channelp->remote.window_size,
channelp->read_avail);
session->packAdd_channelp = channelp;
libssh2_packet_add_jump_point1:
session->packAdd_state = libssh2_NB_state_jump1;
rc = _libssh2_channel_receive_window_adjust(session->
packAdd_channelp,
datalen - 13,
1, NULL);
if(rc == LIBSSH2_ERROR_EAGAIN)
return rc;
session->packAdd_state = libssh2_NB_state_idle;
return 0;
}
if(channelp->remote.packet_size < (datalen - data_head)) {
_libssh2_error(session,
LIBSSH2_ERROR_CHANNEL_PACKET_EXCEEDED,
""Packet contains more data than we offered""
"" to receive, truncating"");
datalen = channelp->remote.packet_size + data_head;
}
if(channelp->remote.window_size <= channelp->read_avail) {
_libssh2_error(session,
LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,
""The current receive window is full,""
"" data ignored"");
LIBSSH2_FREE(session, data);
session->packAdd_state = libssh2_NB_state_idle;
return 0;
}
channelp->remote.eof = 0;
if(channelp->read_avail + datalen - data_head >
channelp->remote.window_size) {
_libssh2_error(session,
LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,
""Remote sent more data than current ""
""window allows, truncating"");
datalen = channelp->remote.window_size -
channelp->read_avail + data_head;
}
channelp->read_avail += datalen - data_head;
_libssh2_debug(session, LIBSSH2_TRACE_CONN,
""increasing read_avail by %lu bytes to %lu/%lu"",
(long)(datalen - data_head),
(long)channelp->read_avail,
(long)channelp->remote.window_size);
break;
case SSH_MSG_CHANNEL_EOF:
if(datalen >= 5)
channelp =
_libssh2_channel_locate(session,
_libssh2_ntohu32(data + 1));
if(!channelp)
;
else {
_libssh2_debug(session,
LIBSSH2_TRACE_CONN,
""EOF received for channel %lu/%lu"",
channelp->local.id,
channelp->remote.id);
channelp->remote.eof = 1;
}
LIBSSH2_FREE(session, data);
session->packAdd_state = libssh2_NB_state_idle;
return 0;
case SSH_MSG_CHANNEL_REQUEST:
if(datalen >= 9) {
uint32_t channel = _libssh2_ntohu32(data + 1);
uint32_t len = _libssh2_ntohu32(data + 5);
unsigned char want_reply = 1;
if((len + 9) < datalen)
want_reply = data[len + 9];
_libssh2_debug(session,
LIBSSH2_TRACE_CONN,
""Channel %d received request type %.*s (wr %X)"",
channel, len, data + 9, want_reply);
if(len == sizeof(""exit-status"") - 1
&& (sizeof(""exit-status"") - 1 + 9) <= datalen
&& !memcmp(""exit-status"", data + 9,
sizeof(""exit-status"") - 1)) {
if(datalen >= 20)
channelp =
_libssh2_channel_locate(session, channel);
if(channelp && (sizeof(""exit-status"") + 13) <= datalen) {
channelp->exit_status =
_libssh2_ntohu32(data + 9 + sizeof(""exit-status""));
_libssh2_debug(session, LIBSSH2_TRACE_CONN,
""Exit status %lu received for ""
""channel %lu/%lu"",
channelp->exit_status,
channelp->local.id,
channelp->remote.id);
}
}
else if(len == sizeof(""exit-signal"") - 1
&& (sizeof(""exit-signal"") - 1 + 9) <= datalen
&& !memcmp(""exit-signal"", data + 9,
sizeof(""exit-signal"") - 1)) {
if(datalen >= 20)
channelp = _libssh2_channel_locate(session, channel);
if(channelp && (sizeof(""exit-signal"") + 13) <= datalen) {
uint32_t namelen =
_libssh2_ntohu32(data + 9 + sizeof(""exit-signal""));
if(namelen <= UINT_MAX - 1) {
channelp->exit_signal =
LIBSSH2_ALLOC(session, namelen + 1);
}
else {
channelp->exit_signal = NULL;
}
if(!channelp->exit_signal)
rc = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,
""memory for signal name"");
else if((sizeof(""exit-signal"") + 13 + namelen <=
datalen)) {
memcpy(channelp->exit_signal,
data + 13 + sizeof(""exit-signal""), namelen);
channelp->exit_signal[namelen] = '\0';
_libssh2_debug(session, LIBSSH2_TRACE_CONN,
""Exit signal %s received for ""
""channel %lu/%lu"",
channelp->exit_signal,
channelp->local.id,
channelp->remote.id);
}
}
}
if(want_reply) {
unsigned char packet[5];
libssh2_packet_add_jump_point4:
session->packAdd_state = libssh2_NB_state_jump4;
packet[0] = SSH_MSG_CHANNEL_FAILURE;
memcpy(&packet[1], data + 1, 4);
rc = _libssh2_transport_send(session, packet, 5, NULL, 0);
if(rc == LIBSSH2_ERROR_EAGAIN)
return rc;
}
}
LIBSSH2_FREE(session, data);
session->packAdd_state = libssh2_NB_state_idle;
return rc;
case SSH_MSG_CHANNEL_CLOSE:
if(datalen >= 5)
channelp =
_libssh2_channel_locate(session,
_libssh2_ntohu32(data + 1));
if(!channelp) {
LIBSSH2_FREE(session, data);
session->packAdd_state = libssh2_NB_state_idle;
return 0;
}
_libssh2_debug(session, LIBSSH2_TRACE_CONN,
""Close received for channel %lu/%lu"",
channelp->local.id,
channelp->remote.id);
channelp->remote.close = 1;
channelp->remote.eof = 1;
LIBSSH2_FREE(session, data);
session->packAdd_state = libssh2_NB_state_idle;
return 0;
case SSH_MSG_CHANNEL_OPEN:
if(datalen < 17)
;
else if((datalen >= (sizeof(""forwarded-tcpip"") + 4)) &&
((sizeof(""forwarded-tcpip"") - 1) ==
_libssh2_ntohu32(data + 1))
&&
(memcmp(data + 5, ""forwarded-tcpip"",
sizeof(""forwarded-tcpip"") - 1) == 0)) {
memset(&session->packAdd_Qlstn_state, 0,
sizeof(session->packAdd_Qlstn_state));
libssh2_packet_add_jump_point2:
session->packAdd_state = libssh2_NB_state_jump2;
rc = packet_queue_listener(session, data, datalen,
&session->packAdd_Qlstn_state);
}
else if((datalen >= (sizeof(""x11"") + 4)) &&
((sizeof(""x11"") - 1) == _libssh2_ntohu32(data + 1)) &&
(memcmp(data + 5, ""x11"", sizeof(""x11"") - 1) == 0)) {
memset(&session->packAdd_x11open_state, 0,
sizeof(session->packAdd_x11open_state));
libssh2_packet_add_jump_point3:
session->packAdd_state = libssh2_NB_state_jump3;
rc = packet_x11_open(session, data, datalen,
&session->packAdd_x11open_state);
}
if(rc == LIBSSH2_ERROR_EAGAIN)
return rc;
LIBSSH2_FREE(session, data);
session->packAdd_state = libssh2_NB_state_idle;
return rc;
case SSH_MSG_CHANNEL_WINDOW_ADJUST:
if(datalen < 9)
;
else {
uint32_t bytestoadd = _libssh2_ntohu32(data + 5);
channelp =
_libssh2_channel_locate(session,
_libssh2_ntohu32(data + 1));
if(channelp) {
channelp->local.window_size += bytestoadd;
_libssh2_debug(session, LIBSSH2_TRACE_CONN,
""Window adjust for channel %lu/%lu, ""
""adding %lu bytes, new window_size=%lu"",
channelp->local.id,
channelp->remote.id,
bytestoadd,
channelp->local.window_size);
}
}
LIBSSH2_FREE(session, data);
session->packAdd_state = libssh2_NB_state_idle;
return 0;
default:
break;
}
session->packAdd_state = libssh2_NB_state_sent;
}
if(session->packAdd_state == libssh2_NB_state_sent) {
LIBSSH2_PACKET *packetp =
LIBSSH2_ALLOC(session, sizeof(LIBSSH2_PACKET));
if(!packetp) {
_libssh2_debug(session, LIBSSH2_ERROR_ALLOC,
""memory for packet"");
LIBSSH2_FREE(session, data);
session->packAdd_state = libssh2_NB_state_idle;
return LIBSSH2_ERROR_ALLOC;
}
packetp->data = data;
packetp->data_len = datalen;
packetp->data_head = data_head;
_libssh2_list_add(&session->packets, &packetp->node);
session->packAdd_state = libssh2_NB_state_sent1;
}
if((msg == SSH_MSG_KEXINIT &&
!(session->state & LIBSSH2_STATE_EXCHANGING_KEYS)) ||
(session->packAdd_state == libssh2_NB_state_sent2)) {
if(session->packAdd_state == libssh2_NB_state_sent1) {
_libssh2_debug(session, LIBSSH2_TRACE_TRANS, ""Renegotiating Keys"");
session->packAdd_state = libssh2_NB_state_sent2;
}
session->readPack_state = libssh2_NB_state_idle;
session->packet.total_num = 0;
session->packAdd_state = libssh2_NB_state_idle;
session->fullpacket_state = libssh2_NB_state_idle;
memset(&session->startup_key_state, 0, sizeof(key_exchange_state_t));
rc = _libssh2_kex_exchange(session, 1, &session->startup_key_state);
if(rc == LIBSSH2_ERROR_EAGAIN)
return rc;
}
session->packAdd_state = libssh2_NB_state_idle;
return 0;
}","int
_libssh2_packet_add(LIBSSH2_SESSION * VAR_0, unsigned char *VAR_1,
size_t VAR_2, int VAR_3)
{
int VAR_4 = 0;
char *VAR_5 = NULL;
char *VAR_6 = NULL;
size_t VAR_7 = 0;
size_t VAR_8 = 0;
LIBSSH2_CHANNEL *VAR_9 = NULL;
size_t VAR_10 = 0;
unsigned char VAR_11 = VAR_1[0];
switch(VAR_0->packAdd_state) {
case VAR_12:
_libssh2_debug(VAR_0, VAR_13,
""Packet type %d received, length=%d"",
(int) VAR_11, (int) VAR_2);
if((VAR_3 == VAR_14) &&
(!VAR_0->macerror ||
LIBSSH2_MACERROR(VAR_0, (char *) VAR_1, VAR_2))) {
LIBSSH2_FREE(VAR_0, VAR_1);
return _libssh2_error(VAR_0, VAR_15,
""Invalid MAC received"");
}
VAR_0->packAdd_state = VAR_16;
break;
case VAR_17:
goto libssh2_packet_add_jump_point1;
case VAR_18:
goto libssh2_packet_add_jump_point2;
case VAR_19:
goto libssh2_packet_add_jump_point3;
case VAR_20:
goto libssh2_packet_add_jump_point4;
case VAR_21:
goto libssh2_packet_add_jump_point5;
default: 
break;
}
if(VAR_0->packAdd_state == VAR_16) {
switch(VAR_11) {
case VAR_22:
if(VAR_2 >= 5) {
size_t VAR_23 = _libssh2_ntohu32(VAR_1 + 1);
if(VAR_2 >= 9) {
VAR_7 = _libssh2_ntohu32(VAR_1 + 5);
if(VAR_7 < VAR_2-13) {
VAR_5 = (char *) VAR_1 + 9;
VAR_8 =
_libssh2_ntohu32(VAR_1 + 9 + VAR_7);
VAR_6 = (char *) VAR_1 + 9 + VAR_7 + 4;
if(VAR_8 > (VAR_2-13-VAR_7)) {
VAR_6 = VAR_5 = NULL;
VAR_8 = VAR_7 = 0;
}
}
else
VAR_7 = 0;
}
if(VAR_0->ssh_msg_disconnect) {
LIBSSH2_DISCONNECT(VAR_0, VAR_23, VAR_5,
VAR_7, VAR_6, VAR_8);
}
_libssh2_debug(VAR_0, VAR_13,
""Disconnect(%d): %s(%s)"", VAR_23,
VAR_5, VAR_6);
}
LIBSSH2_FREE(VAR_0, VAR_1);
VAR_0->socket_state = VAR_24;
VAR_0->packAdd_state = VAR_12;
return _libssh2_error(VAR_0, VAR_25,
""socket disconnect"");
case VAR_26:
if(VAR_2 >= 2) {
if(VAR_0->ssh_msg_ignore) {
LIBSSH2_IGNORE(VAR_0, (char *) VAR_1 + 1, VAR_2 - 1);
}
}
else if(VAR_0->ssh_msg_ignore) {
LIBSSH2_IGNORE(VAR_0, """", 0);
}
LIBSSH2_FREE(VAR_0, VAR_1);
VAR_0->packAdd_state = VAR_12;
return 0;
case VAR_27:
if(VAR_2 >= 2) {
int VAR_28 = VAR_1[1];
if(VAR_2 >= 6) {
VAR_7 = _libssh2_ntohu32(VAR_1 + 2);
if(VAR_7 <= (VAR_2 - 10)) {
VAR_5 = (char *) VAR_1 + 6;
VAR_8 = _libssh2_ntohu32(VAR_1 + 6 +
VAR_7);
if(VAR_8 <= (VAR_2 - 10 - VAR_7))
VAR_6 = (char *) VAR_1 + 10 + VAR_7;
}
}
if(VAR_0->ssh_msg_debug) {
LIBSSH2_DEBUG(VAR_0, VAR_28, VAR_5,
VAR_7, VAR_6, VAR_8);
}
}
_libssh2_debug(VAR_0, VAR_13,
""Debug Packet: %s"", VAR_5);
LIBSSH2_FREE(VAR_0, VAR_1);
VAR_0->packAdd_state = VAR_12;
return 0;
case VAR_29:
if(VAR_2 >= 5) {
uint32_t VAR_30 = 0;
unsigned char VAR_31 = 0;
VAR_30 = _libssh2_ntohu32(VAR_1 + 1);
if(VAR_2 >= (6 + VAR_30)) {
VAR_31 = VAR_1[5 + VAR_30];
_libssh2_debug(VAR_0,
VAR_32,
""Received global request type %.*s (wr %X)"",
VAR_30, VAR_1 + 5, VAR_31);
}
if(VAR_31) {
static const unsigned char VAR_33 =
VAR_34;
libssh2_packet_add_jump_point5:
VAR_0->packAdd_state = VAR_21;
VAR_4 = _libssh2_transport_send(VAR_0, &VAR_33, 1, NULL, 0);
if(VAR_4 == VAR_35)
return VAR_4;
}
}
LIBSSH2_FREE(VAR_0, VAR_1);
VAR_0->packAdd_state = VAR_12;
return 0;
case VAR_36:
VAR_10 += 4;
case VAR_37:
VAR_10 += 9;
if(VAR_2 >= VAR_10)
VAR_9 =
_libssh2_channel_locate(VAR_0,
_libssh2_ntohu32(VAR_1 + 1));
if(!VAR_9) {
_libssh2_error(VAR_0, VAR_38,
""Packet received for unknown channel"");
LIBSSH2_FREE(VAR_0, VAR_1);
VAR_0->packAdd_state = VAR_12;
return 0;
}
#ifdef VAR_39
{
uint32_t VAR_40 = 0;
if(VAR_11 == VAR_36)
VAR_40 = _libssh2_ntohu32(VAR_1 + 5);
_libssh2_debug(VAR_0, VAR_32,
""%d bytes packet_add() for %lu/%lu/%lu"",
(int) (VAR_2 - VAR_10),
VAR_9->local.id,
VAR_9->remote.id,
VAR_40);
}
#endif
if((VAR_9->remote.extended_data_ignore_mode ==
VAR_41) &&
(VAR_11 == VAR_36)) {
LIBSSH2_FREE(VAR_0, VAR_1);
_libssh2_debug(VAR_0, VAR_32,
""Ignoring extended data and refunding %d bytes"",
(int) (VAR_2 - 13));
if(VAR_9->read_avail + VAR_2 - VAR_10 >=
VAR_9->remote.window_size)
VAR_2 = VAR_9->remote.window_size -
VAR_9->read_avail + VAR_10;
VAR_9->remote.window_size -= VAR_2 - VAR_10;
_libssh2_debug(VAR_0, VAR_32,
""shrinking window size by %lu bytes to %lu, ""
""read_avail %lu"",
VAR_2 - VAR_10,
VAR_9->remote.window_size,
VAR_9->read_avail);
VAR_0->packAdd_channelp = VAR_9;
libssh2_packet_add_jump_point1:
VAR_0->packAdd_state = VAR_17;
VAR_4 = _libssh2_channel_receive_window_adjust(VAR_0->
packAdd_channelp,
VAR_2 - 13,
1, NULL);
if(VAR_4 == VAR_35)
return VAR_4;
VAR_0->packAdd_state = VAR_12;
return 0;
}
if(VAR_9->remote.packet_size < (VAR_2 - VAR_10)) {
_libssh2_error(VAR_0,
VAR_42,
""Packet contains more data than we offered""
"" to receive, truncating"");
VAR_2 = VAR_9->remote.packet_size + VAR_10;
}
if(VAR_9->remote.window_size <= VAR_9->read_avail) {
_libssh2_error(VAR_0,
VAR_43,
""The current receive window is full,""
"" data ignored"");
LIBSSH2_FREE(VAR_0, VAR_1);
VAR_0->packAdd_state = VAR_12;
return 0;
}
VAR_9->remote.eof = 0;
if(VAR_9->read_avail + VAR_2 - VAR_10 >
VAR_9->remote.window_size) {
_libssh2_error(VAR_0,
VAR_43,
""Remote sent more data than current ""
""window allows, truncating"");
VAR_2 = VAR_9->remote.window_size -
VAR_9->read_avail + VAR_10;
}
VAR_9->read_avail += VAR_2 - VAR_10;
_libssh2_debug(VAR_0, VAR_32,
""increasing read_avail by %lu bytes to %lu/%lu"",
(long)(VAR_2 - VAR_10),
(long)VAR_9->read_avail,
(long)VAR_9->remote.window_size);
break;
case VAR_44:
if(VAR_2 >= 5)
VAR_9 =
_libssh2_channel_locate(VAR_0,
_libssh2_ntohu32(VAR_1 + 1));
if(!VAR_9)
;
else {
_libssh2_debug(VAR_0,
VAR_32,
""EOF received for channel %lu/%lu"",
VAR_9->local.id,
VAR_9->remote.id);
VAR_9->remote.eof = 1;
}
LIBSSH2_FREE(VAR_0, VAR_1);
VAR_0->packAdd_state = VAR_12;
return 0;
case VAR_45:
if(VAR_2 >= 9) {
uint32_t VAR_46 = _libssh2_ntohu32(VAR_1 + 1);
uint32_t VAR_30 = _libssh2_ntohu32(VAR_1 + 5);
unsigned char VAR_31 = 1;
if((VAR_30 + 9) < VAR_2)
VAR_31 = VAR_1[VAR_30 + 9];
_libssh2_debug(VAR_0,
VAR_32,
""Channel %d received request type %.*s (wr %X)"",
VAR_46, VAR_30, VAR_1 + 9, VAR_31);
if(VAR_30 == sizeof(""exit-status"") - 1
&& (sizeof(""exit-status"") - 1 + 9) <= VAR_2
&& !memcmp(""exit-status"", VAR_1 + 9,
sizeof(""exit-status"") - 1)) {
if(VAR_2 >= 20)
VAR_9 =
_libssh2_channel_locate(VAR_0, VAR_46);
if(VAR_9 && (sizeof(""exit-status"") + 13) <= VAR_2) {
VAR_9->exit_status =
_libssh2_ntohu32(VAR_1 + 9 + sizeof(""exit-status""));
_libssh2_debug(VAR_0, VAR_32,
""Exit status %lu received for ""
""channel %lu/%lu"",
VAR_9->exit_status,
VAR_9->local.id,
VAR_9->remote.id);
}
}
else if(VAR_30 == sizeof(""exit-signal"") - 1
&& (sizeof(""exit-signal"") - 1 + 9) <= VAR_2
&& !memcmp(""exit-signal"", VAR_1 + 9,
sizeof(""exit-signal"") - 1)) {
if(VAR_2 >= 20)
VAR_9 = _libssh2_channel_locate(VAR_0, VAR_46);
if(VAR_9 && (sizeof(""exit-signal"") + 13) <= VAR_2) {
uint32_t VAR_47 =
_libssh2_ntohu32(VAR_1 + 9 + sizeof(""exit-signal""));
if(VAR_47 <= VAR_48 - 1) {
VAR_9->exit_signal =
LIBSSH2_ALLOC(VAR_0, VAR_47 + 1);
}
else {
VAR_9->exit_signal = NULL;
}
if(!VAR_9->exit_signal)
VAR_4 = _libssh2_error(VAR_0, VAR_49,
""memory for signal name"");
else if((sizeof(""exit-signal"") + 13 + VAR_47 <=
VAR_2)) {
memcpy(VAR_9->exit_signal,
VAR_1 + 13 + sizeof(""exit-signal""), VAR_47);
VAR_9->exit_signal[VAR_47] = '\0';
_libssh2_debug(VAR_0, VAR_32,
""Exit signal %s received for ""
""channel %lu/%lu"",
VAR_9->exit_signal,
VAR_9->local.id,
VAR_9->remote.id);
}
}
}
if(VAR_31) {
unsigned char VAR_33[5];
libssh2_packet_add_jump_point4:
VAR_0->packAdd_state = VAR_20;
VAR_33[0] = VAR_50;
memcpy(&VAR_33[1], VAR_1 + 1, 4);
VAR_4 = _libssh2_transport_send(VAR_0, VAR_33, 5, NULL, 0);
if(VAR_4 == VAR_35)
return VAR_4;
}
}
LIBSSH2_FREE(VAR_0, VAR_1);
VAR_0->packAdd_state = VAR_12;
return VAR_4;
case VAR_51:
if(VAR_2 >= 5)
VAR_9 =
_libssh2_channel_locate(VAR_0,
_libssh2_ntohu32(VAR_1 + 1));
if(!VAR_9) {
LIBSSH2_FREE(VAR_0, VAR_1);
VAR_0->packAdd_state = VAR_12;
return 0;
}
_libssh2_debug(VAR_0, VAR_32,
""Close received for channel %lu/%lu"",
VAR_9->local.id,
VAR_9->remote.id);
VAR_9->remote.close = 1;
VAR_9->remote.eof = 1;
LIBSSH2_FREE(VAR_0, VAR_1);
VAR_0->packAdd_state = VAR_12;
return 0;
case VAR_52:
if(VAR_2 < 17)
;
else if((VAR_2 >= (sizeof(""forwarded-tcpip"") + 4)) &&
((sizeof(""forwarded-tcpip"") - 1) ==
_libssh2_ntohu32(VAR_1 + 1))
&&
(memcmp(VAR_1 + 5, ""forwarded-tcpip"",
sizeof(""forwarded-tcpip"") - 1) == 0)) {
memset(&VAR_0->packAdd_Qlstn_state, 0,
sizeof(VAR_0->packAdd_Qlstn_state));
libssh2_packet_add_jump_point2:
VAR_0->packAdd_state = VAR_18;
VAR_4 = packet_queue_listener(VAR_0, VAR_1, VAR_2,
&VAR_0->packAdd_Qlstn_state);
}
else if((VAR_2 >= (sizeof(""x11"") + 4)) &&
((sizeof(""x11"") - 1) == _libssh2_ntohu32(VAR_1 + 1)) &&
(memcmp(VAR_1 + 5, ""x11"", sizeof(""x11"") - 1) == 0)) {
memset(&VAR_0->packAdd_x11open_state, 0,
sizeof(VAR_0->packAdd_x11open_state));
libssh2_packet_add_jump_point3:
VAR_0->packAdd_state = VAR_19;
VAR_4 = packet_x11_open(VAR_0, VAR_1, VAR_2,
&VAR_0->packAdd_x11open_state);
}
if(VAR_4 == VAR_35)
return VAR_4;
LIBSSH2_FREE(VAR_0, VAR_1);
VAR_0->packAdd_state = VAR_12;
return VAR_4;
case VAR_53:
if(VAR_2 < 9)
;
else {
uint32_t VAR_54 = _libssh2_ntohu32(VAR_1 + 5);
VAR_9 =
_libssh2_channel_locate(VAR_0,
_libssh2_ntohu32(VAR_1 + 1));
if(VAR_9) {
VAR_9->local.window_size += VAR_54;
_libssh2_debug(VAR_0, VAR_32,
""Window adjust for channel %lu/%lu, ""
""adding %lu bytes, new window_size=%lu"",
VAR_9->local.id,
VAR_9->remote.id,
VAR_54,
VAR_9->local.window_size);
}
}
LIBSSH2_FREE(VAR_0, VAR_1);
VAR_0->packAdd_state = VAR_12;
return 0;
default:
break;
}
VAR_0->packAdd_state = VAR_55;
}
if(VAR_0->packAdd_state == VAR_55) {
LIBSSH2_PACKET *VAR_56 =
LIBSSH2_ALLOC(VAR_0, sizeof(LIBSSH2_PACKET));
if(!VAR_56) {
_libssh2_debug(VAR_0, VAR_49,
""memory for packet"");
LIBSSH2_FREE(VAR_0, VAR_1);
VAR_0->packAdd_state = VAR_12;
return VAR_49;
}
VAR_56->data = VAR_1;
VAR_56->data_len = VAR_2;
VAR_56->data_head = VAR_10;
_libssh2_list_add(&VAR_0->packets, &VAR_56->node);
VAR_0->packAdd_state = VAR_57;
}
if((VAR_11 == VAR_58 &&
!(VAR_0->state & VAR_59)) ||
(VAR_0->packAdd_state == VAR_60)) {
if(VAR_0->packAdd_state == VAR_57) {
_libssh2_debug(VAR_0, VAR_13, ""Renegotiating Keys"");
VAR_0->packAdd_state = VAR_60;
}
VAR_0->readPack_state = VAR_12;
VAR_0->packet.total_num = 0;
VAR_0->packAdd_state = VAR_12;
VAR_0->fullpacket_state = VAR_12;
memset(&VAR_0->startup_key_state, 0, sizeof(VAR_61));
VAR_4 = _libssh2_kex_exchange(VAR_0, 1, &VAR_0->startup_key_state);
if(VAR_4 == VAR_35)
return VAR_4;
}
VAR_0->packAdd_state = VAR_12;
return 0;
}",libssh2/dedcbd106f8e52d5586b0205bc7677e4c9868f9c/packet.c/vul/before/0.json,"int
_libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data,
                    size_t datalen, int macstate)
{
    int rc = 0;
    unsigned char *message = NULL;
    unsigned char *language = NULL;
    size_t message_len = 0;
    size_t language_len = 0;
    LIBSSH2_CHANNEL *channelp = NULL;
    size_t data_head = 0;
    unsigned char msg = data[0];

    switch(session->packAdd_state) {
    case libssh2_NB_state_idle:
        _libssh2_debug(session, LIBSSH2_TRACE_TRANS,
                       ""Packet type %d received, length=%d"",
                       (int) msg, (int) datalen);

        if((macstate == LIBSSH2_MAC_INVALID) &&
            (!session->macerror ||
             LIBSSH2_MACERROR(session, (char *) data, datalen))) {
            /* Bad MAC input, but no callback set or non-zero return from the
               callback */

            LIBSSH2_FREE(session, data);
            return _libssh2_error(session, LIBSSH2_ERROR_INVALID_MAC,
                                  ""Invalid MAC received"");
        }
        session->packAdd_state = libssh2_NB_state_allocated;
        break;
    case libssh2_NB_state_jump1:
        goto libssh2_packet_add_jump_point1;
    case libssh2_NB_state_jump2:
        goto libssh2_packet_add_jump_point2;
    case libssh2_NB_state_jump3:
        goto libssh2_packet_add_jump_point3;
    case libssh2_NB_state_jump4:
        goto libssh2_packet_add_jump_point4;
    case libssh2_NB_state_jump5:
        goto libssh2_packet_add_jump_point5;
    default: /* nothing to do */
        break;
    }

    if(session->packAdd_state == libssh2_NB_state_allocated) {
        /* A couple exceptions to the packet adding rule: */
        switch(msg) {

            /*
              byte      SSH_MSG_DISCONNECT
              uint32    reason code
              string    description in ISO-10646 UTF-8 encoding [RFC3629]
              string    language tag [RFC3066]
            */

        case SSH_MSG_DISCONNECT:
            if(datalen >= 5) {
                uint32_t reason = 0;
                struct string_buf buf;
                buf.data = (unsigned char *)data;
                buf.dataptr = buf.data;
                buf.len = datalen;
                buf.dataptr++; /* advance past type */

                _libssh2_get_u32(&buf, &reason);
                _libssh2_get_string(&buf, &message, &message_len);
                _libssh2_get_string(&buf, &language, &language_len);

                if(session->ssh_msg_disconnect) {
                    LIBSSH2_DISCONNECT(session, reason, (const char *)message,
                                       message_len, (const char *)language,
                                       language_len);
                }

                _libssh2_debug(session, LIBSSH2_TRACE_TRANS,
                               ""Disconnect(%d): %s(%s)"", reason,
                               message, language);
            }

            LIBSSH2_FREE(session, data);
            session->socket_state = LIBSSH2_SOCKET_DISCONNECTED;
            session->packAdd_state = libssh2_NB_state_idle;
            return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_DISCONNECT,
                                  ""socket disconnect"");
            /*
              byte      SSH_MSG_IGNORE
              string    data
            */

        case SSH_MSG_IGNORE:
            if(datalen >= 2) {
                if(session->ssh_msg_ignore) {
                    LIBSSH2_IGNORE(session, (char *) data + 1, datalen - 1);
                }
            }
            else if(session->ssh_msg_ignore) {
                LIBSSH2_IGNORE(session, """", 0);
            }
            LIBSSH2_FREE(session, data);
            session->packAdd_state = libssh2_NB_state_idle;
            return 0;

            /*
              byte      SSH_MSG_DEBUG
              boolean   always_display
              string    message in ISO-10646 UTF-8 encoding [RFC3629]
              string    language tag [RFC3066]
            */

        case SSH_MSG_DEBUG:
            if(datalen >= 2) {
                int always_display = data[1];

                if(datalen >= 6) {
                    struct string_buf buf;
                    buf.data = (unsigned char *)data;
                    buf.dataptr = buf.data;
                    buf.len = datalen;
                    buf.dataptr += 2; /* advance past type & always display */

                    _libssh2_get_string(&buf, &message, &message_len);
                    _libssh2_get_string(&buf, &language, &language_len);
                }

                if(session->ssh_msg_debug) {
                    LIBSSH2_DEBUG(session, always_display,
                                  (const char *)message,
                                  message_len, (const char *)language,
                                  language_len);
                }
            }

            /*
             * _libssh2_debug will actually truncate this for us so
             * that it's not an inordinate about of data
             */
            _libssh2_debug(session, LIBSSH2_TRACE_TRANS,
                           ""Debug Packet: %s"", message);
            LIBSSH2_FREE(session, data);
            session->packAdd_state = libssh2_NB_state_idle;
            return 0;

            /*
              byte      SSH_MSG_GLOBAL_REQUEST
              string    request name in US-ASCII only
              boolean   want reply
              ....      request-specific data follows
            */

        case SSH_MSG_GLOBAL_REQUEST:
            if(datalen >= 5) {
                uint32_t len = 0;
                unsigned char want_reply = 0;
                len = _libssh2_ntohu32(data + 1);
                if((len <= (UINT_MAX - 6)) && (datalen >= (6 + len))) {
                    want_reply = data[5 + len];
                    _libssh2_debug(session,
                                   LIBSSH2_TRACE_CONN,
                                   ""Received global request type %.*s (wr %X)"",
                                   len, data + 5, want_reply);
                }


                if(want_reply) {
                    static const unsigned char packet =
                        SSH_MSG_REQUEST_FAILURE;
                  libssh2_packet_add_jump_point5:
                    session->packAdd_state = libssh2_NB_state_jump5;
                    rc = _libssh2_transport_send(session, &packet, 1, NULL, 0);
                    if(rc == LIBSSH2_ERROR_EAGAIN)
                        return rc;
                }
            }
            LIBSSH2_FREE(session, data);
            session->packAdd_state = libssh2_NB_state_idle;
            return 0;

            /*
              byte      SSH_MSG_CHANNEL_EXTENDED_DATA
              uint32    recipient channel
              uint32    data_type_code
              string    data
            */

        case SSH_MSG_CHANNEL_EXTENDED_DATA:
            /* streamid(4) */
            data_head += 4;

            /* fall-through */

            /*
              byte      SSH_MSG_CHANNEL_DATA
              uint32    recipient channel
              string    data
            */

        case SSH_MSG_CHANNEL_DATA:
            /* packet_type(1) + channelno(4) + datalen(4) */
            data_head += 9;

            if(datalen >= data_head)
                channelp =
                    _libssh2_channel_locate(session,
                                            _libssh2_ntohu32(data + 1));

            if(!channelp) {
                _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_UNKNOWN,
                               ""Packet received for unknown channel"");
                LIBSSH2_FREE(session, data);
                session->packAdd_state = libssh2_NB_state_idle;
                return 0;
            }
#ifdef LIBSSH2DEBUG
            {
                uint32_t stream_id = 0;
                if(msg == SSH_MSG_CHANNEL_EXTENDED_DATA)
                    stream_id = _libssh2_ntohu32(data + 5);

                _libssh2_debug(session, LIBSSH2_TRACE_CONN,
                               ""%d bytes packet_add() for %lu/%lu/%lu"",
                               (int) (datalen - data_head),
                               channelp->local.id,
                               channelp->remote.id,
                               stream_id);
            }
#endif
            if((channelp->remote.extended_data_ignore_mode ==
                 LIBSSH2_CHANNEL_EXTENDED_DATA_IGNORE) &&
                (msg == SSH_MSG_CHANNEL_EXTENDED_DATA)) {
                /* Pretend we didn't receive this */
                LIBSSH2_FREE(session, data);

                _libssh2_debug(session, LIBSSH2_TRACE_CONN,
                               ""Ignoring extended data and refunding %d bytes"",
                               (int) (datalen - 13));
                if(channelp->read_avail + datalen - data_head >=
                    channelp->remote.window_size)
                    datalen = channelp->remote.window_size -
                        channelp->read_avail + data_head;

                channelp->remote.window_size -= datalen - data_head;
                _libssh2_debug(session, LIBSSH2_TRACE_CONN,
                               ""shrinking window size by %lu bytes to %lu, ""
                               ""read_avail %lu"",
                               datalen - data_head,
                               channelp->remote.window_size,
                               channelp->read_avail);

                session->packAdd_channelp = channelp;

                /* Adjust the window based on the block we just freed */
              libssh2_packet_add_jump_point1:
                session->packAdd_state = libssh2_NB_state_jump1;
                rc = _libssh2_channel_receive_window_adjust(session->
                                                            packAdd_channelp,
                                                            datalen - 13,
                                                            1, NULL);
                if(rc == LIBSSH2_ERROR_EAGAIN)
                    return rc;

                session->packAdd_state = libssh2_NB_state_idle;
                return 0;
            }

            /*
             * REMEMBER! remote means remote as source of data,
             * NOT remote window!
             */
            if(channelp->remote.packet_size < (datalen - data_head)) {
                /*
                 * Spec says we MAY ignore bytes sent beyond
                 * packet_size
                 */
                _libssh2_error(session,
                               LIBSSH2_ERROR_CHANNEL_PACKET_EXCEEDED,
                               ""Packet contains more data than we offered""
                               "" to receive, truncating"");
                datalen = channelp->remote.packet_size + data_head;
            }
            if(channelp->remote.window_size <= channelp->read_avail) {
                /*
                 * Spec says we MAY ignore bytes sent beyond
                 * window_size
                 */
                _libssh2_error(session,
                               LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,
                               ""The current receive window is full,""
                               "" data ignored"");
                LIBSSH2_FREE(session, data);
                session->packAdd_state = libssh2_NB_state_idle;
                return 0;
            }
            /* Reset EOF status */
            channelp->remote.eof = 0;

            if(channelp->read_avail + datalen - data_head >
                channelp->remote.window_size) {
                _libssh2_error(session,
                               LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,
                               ""Remote sent more data than current ""
                               ""window allows, truncating"");
                datalen = channelp->remote.window_size -
                    channelp->read_avail + data_head;
            }

            /* Update the read_avail counter. The window size will be
             * updated once the data is actually read from the queue
             * from an upper layer */
            channelp->read_avail += datalen - data_head;

            _libssh2_debug(session, LIBSSH2_TRACE_CONN,
                           ""increasing read_avail by %lu bytes to %lu/%lu"",
                           (long)(datalen - data_head),
                           (long)channelp->read_avail,
                           (long)channelp->remote.window_size);

            break;

            /*
              byte      SSH_MSG_CHANNEL_EOF
              uint32    recipient channel
            */

        case SSH_MSG_CHANNEL_EOF:
            if(datalen >= 5)
                channelp =
                    _libssh2_channel_locate(session,
                                            _libssh2_ntohu32(data + 1));
            if(!channelp)
                /* We may have freed already, just quietly ignore this... */
                ;
            else {
                _libssh2_debug(session,
                               LIBSSH2_TRACE_CONN,
                               ""EOF received for channel %lu/%lu"",
                               channelp->local.id,
                               channelp->remote.id);
                channelp->remote.eof = 1;
            }
            LIBSSH2_FREE(session, data);
            session->packAdd_state = libssh2_NB_state_idle;
            return 0;

            /*
              byte      SSH_MSG_CHANNEL_REQUEST
              uint32    recipient channel
              string    request type in US-ASCII characters only
              boolean   want reply
              ....      type-specific data follows
            */

        case SSH_MSG_CHANNEL_REQUEST:
            if(datalen >= 9) {
                uint32_t channel = _libssh2_ntohu32(data + 1);
                uint32_t len = _libssh2_ntohu32(data + 5);
                unsigned char want_reply = 1;

                if((len + 9) < datalen)
                    want_reply = data[len + 9];

                _libssh2_debug(session,
                               LIBSSH2_TRACE_CONN,
                               ""Channel %d received request type %.*s (wr %X)"",
                               channel, len, data + 9, want_reply);

                if(len == sizeof(""exit-status"") - 1
                    && (sizeof(""exit-status"") - 1 + 9) <= datalen
                    && !memcmp(""exit-status"", data + 9,
                               sizeof(""exit-status"") - 1)) {

                    /* we've got ""exit-status"" packet. Set the session value */
                    if(datalen >= 20)
                        channelp =
                            _libssh2_channel_locate(session, channel);

                    if(channelp && (sizeof(""exit-status"") + 13) <= datalen) {
                        channelp->exit_status =
                            _libssh2_ntohu32(data + 9 + sizeof(""exit-status""));
                        _libssh2_debug(session, LIBSSH2_TRACE_CONN,
                                       ""Exit status %lu received for ""
                                       ""channel %lu/%lu"",
                                       channelp->exit_status,
                                       channelp->local.id,
                                       channelp->remote.id);
                    }

                }
                else if(len == sizeof(""exit-signal"") - 1
                         && (sizeof(""exit-signal"") - 1 + 9) <= datalen
                         && !memcmp(""exit-signal"", data + 9,
                                    sizeof(""exit-signal"") - 1)) {
                    /* command terminated due to signal */
                    if(datalen >= 20)
                        channelp = _libssh2_channel_locate(session, channel);

                    if(channelp && (sizeof(""exit-signal"") + 13) <= datalen) {
                        /* set signal name (without SIG prefix) */
                        uint32_t namelen =
                            _libssh2_ntohu32(data + 9 + sizeof(""exit-signal""));

                        if(namelen <= UINT_MAX - 1) {
                            channelp->exit_signal =
                                LIBSSH2_ALLOC(session, namelen + 1);
                        }
                        else {
                            channelp->exit_signal = NULL;
                        }

                        if(!channelp->exit_signal)
                            rc = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,
                                                ""memory for signal name"");
                        else if((sizeof(""exit-signal"") + 13 + namelen <=
                                 datalen)) {
                            memcpy(channelp->exit_signal,
                                   data + 13 + sizeof(""exit-signal""), namelen);
                            channelp->exit_signal[namelen] = '\0';
                            /* TODO: save error message and language tag */
                            _libssh2_debug(session, LIBSSH2_TRACE_CONN,
                                           ""Exit signal %s received for ""
                                           ""channel %lu/%lu"",
                                           channelp->exit_signal,
                                           channelp->local.id,
                                           channelp->remote.id);
                        }
                    }
                }


                if(want_reply) {
                    unsigned char packet[5];
                  libssh2_packet_add_jump_point4:
                    session->packAdd_state = libssh2_NB_state_jump4;
                    packet[0] = SSH_MSG_CHANNEL_FAILURE;
                    memcpy(&packet[1], data + 1, 4);
                    rc = _libssh2_transport_send(session, packet, 5, NULL, 0);
                    if(rc == LIBSSH2_ERROR_EAGAIN)
                        return rc;
                }
            }
            LIBSSH2_FREE(session, data);
            session->packAdd_state = libssh2_NB_state_idle;
            return rc;

            /*
              byte      SSH_MSG_CHANNEL_CLOSE
              uint32    recipient channel
            */

        case SSH_MSG_CHANNEL_CLOSE:
            if(datalen >= 5)
                channelp =
                    _libssh2_channel_locate(session,
                                            _libssh2_ntohu32(data + 1));
            if(!channelp) {
                /* We may have freed already, just quietly ignore this... */
                LIBSSH2_FREE(session, data);
                session->packAdd_state = libssh2_NB_state_idle;
                return 0;
            }
            _libssh2_debug(session, LIBSSH2_TRACE_CONN,
                           ""Close received for channel %lu/%lu"",
                           channelp->local.id,
                           channelp->remote.id);

            channelp->remote.close = 1;
            channelp->remote.eof = 1;

            LIBSSH2_FREE(session, data);
            session->packAdd_state = libssh2_NB_state_idle;
            return 0;

            /*
              byte      SSH_MSG_CHANNEL_OPEN
              string    ""session""
              uint32    sender channel
              uint32    initial window size
              uint32    maximum packet size
            */

        case SSH_MSG_CHANNEL_OPEN:
            if(datalen < 17)
                ;
            else if((datalen >= (sizeof(""forwarded-tcpip"") + 4)) &&
                     ((sizeof(""forwarded-tcpip"") - 1) ==
                      _libssh2_ntohu32(data + 1))
                     &&
                     (memcmp(data + 5, ""forwarded-tcpip"",
                             sizeof(""forwarded-tcpip"") - 1) == 0)) {

                /* init the state struct */
                memset(&session->packAdd_Qlstn_state, 0,
                       sizeof(session->packAdd_Qlstn_state));

              libssh2_packet_add_jump_point2:
                session->packAdd_state = libssh2_NB_state_jump2;
                rc = packet_queue_listener(session, data, datalen,
                                           &session->packAdd_Qlstn_state);
            }
            else if((datalen >= (sizeof(""x11"") + 4)) &&
                     ((sizeof(""x11"") - 1) == _libssh2_ntohu32(data + 1)) &&
                     (memcmp(data + 5, ""x11"", sizeof(""x11"") - 1) == 0)) {

                /* init the state struct */
                memset(&session->packAdd_x11open_state, 0,
                       sizeof(session->packAdd_x11open_state));

              libssh2_packet_add_jump_point3:
                session->packAdd_state = libssh2_NB_state_jump3;
                rc = packet_x11_open(session, data, datalen,
                                     &session->packAdd_x11open_state);
            }
            if(rc == LIBSSH2_ERROR_EAGAIN)
                return rc;

            LIBSSH2_FREE(session, data);
            session->packAdd_state = libssh2_NB_state_idle;
            return rc;

            /*
              byte      SSH_MSG_CHANNEL_WINDOW_ADJUST
              uint32    recipient channel
              uint32    bytes to add
            */
        case SSH_MSG_CHANNEL_WINDOW_ADJUST:
            if(datalen < 9)
                ;
            else {
                uint32_t bytestoadd = _libssh2_ntohu32(data + 5);
                channelp =
                    _libssh2_channel_locate(session,
                                            _libssh2_ntohu32(data + 1));
                if(channelp) {
                    channelp->local.window_size += bytestoadd;

                    _libssh2_debug(session, LIBSSH2_TRACE_CONN,
                                   ""Window adjust for channel %lu/%lu, ""
                                   ""adding %lu bytes, new window_size=%lu"",
                                   channelp->local.id,
                                   channelp->remote.id,
                                   bytestoadd,
                                   channelp->local.window_size);
                }
            }
            LIBSSH2_FREE(session, data);
            session->packAdd_state = libssh2_NB_state_idle;
            return 0;
        default:
            break;
        }

        session->packAdd_state = libssh2_NB_state_sent;
    }

    if(session->packAdd_state == libssh2_NB_state_sent) {
        LIBSSH2_PACKET *packetp =
            LIBSSH2_ALLOC(session, sizeof(LIBSSH2_PACKET));
        if(!packetp) {
            _libssh2_debug(session, LIBSSH2_ERROR_ALLOC,
                           ""memory for packet"");
            LIBSSH2_FREE(session, data);
            session->packAdd_state = libssh2_NB_state_idle;
            return LIBSSH2_ERROR_ALLOC;
        }
        packetp->data = data;
        packetp->data_len = datalen;
        packetp->data_head = data_head;

        _libssh2_list_add(&session->packets, &packetp->node);

        session->packAdd_state = libssh2_NB_state_sent1;
    }

    if((msg == SSH_MSG_KEXINIT &&
         !(session->state & LIBSSH2_STATE_EXCHANGING_KEYS)) ||
        (session->packAdd_state == libssh2_NB_state_sent2)) {
        if(session->packAdd_state == libssh2_NB_state_sent1) {
            /*
             * Remote wants new keys
             * Well, it's already in the brigade,
             * let's just call back into ourselves
             */
            _libssh2_debug(session, LIBSSH2_TRACE_TRANS, ""Renegotiating Keys"");

            session->packAdd_state = libssh2_NB_state_sent2;
        }

        /*
         * The KEXINIT message has been added to the queue.  The packAdd and
         * readPack states need to be reset because _libssh2_kex_exchange
         * (eventually) calls upon _libssh2_transport_read to read the rest of
         * the key exchange conversation.
         */
        session->readPack_state = libssh2_NB_state_idle;
        session->packet.total_num = 0;
        session->packAdd_state = libssh2_NB_state_idle;
        session->fullpacket_state = libssh2_NB_state_idle;

        memset(&session->startup_key_state, 0, sizeof(key_exchange_state_t));

        /*
         * If there was a key reexchange failure, let's just hope we didn't
         * send NEWKEYS yet, otherwise remote will drop us like a rock
         */
        rc = _libssh2_kex_exchange(session, 1, &session->startup_key_state);
        if(rc == LIBSSH2_ERROR_EAGAIN)
            return rc;
    }

    session->packAdd_state = libssh2_NB_state_idle;
    return 0;
}","int
_libssh2_packet_add(LIBSSH2_SESSION * VAR_0, unsigned char *VAR_1,
                    size_t VAR_2, int VAR_3)
{
    int VAR_4 = 0;
    unsigned char *VAR_5 = NULL;
    unsigned char *VAR_6 = NULL;
    size_t VAR_7 = 0;
    size_t VAR_8 = 0;
    LIBSSH2_CHANNEL *VAR_9 = NULL;
    size_t VAR_10 = 0;
    unsigned char VAR_11 = VAR_1[0];

    switch(VAR_0->packAdd_state) {
    case VAR_12:
        _libssh2_debug(VAR_0, VAR_13,
                       ""Packet type %d received, length=%d"",
                       (int) VAR_11, (int) VAR_2);

        if((VAR_3 == VAR_14) &&
            (!VAR_0->macerror ||
             LIBSSH2_MACERROR(VAR_0, (char *) VAR_1, VAR_2))) {
            /* COMMENT_0 */
                          

            LIBSSH2_FREE(VAR_0, VAR_1);
            return _libssh2_error(VAR_0, VAR_15,
                                  ""Invalid MAC received"");
        }
        VAR_0->packAdd_state = VAR_16;
        break;
    case VAR_17:
        goto libssh2_packet_add_jump_point1;
    case VAR_18:
        goto libssh2_packet_add_jump_point2;
    case VAR_19:
        goto libssh2_packet_add_jump_point3;
    case VAR_20:
        goto libssh2_packet_add_jump_point4;
    case VAR_21:
        goto libssh2_packet_add_jump_point5;
    default: /* COMMENT_2 */
        break;
    }

    if(VAR_0->packAdd_state == VAR_16) {
        /* COMMENT_3 */
        switch(VAR_11) {

            /* COMMENT_4 */
                                          
                                   
                                                                         
                                              
              

        case VAR_22:
            if(VAR_2 >= 5) {
                uint32_t VAR_23 = 0;
                struct string_buf VAR_24;
                VAR_24.data = (unsigned char *)VAR_1;
                VAR_24.dataptr = VAR_24.data;
                VAR_24.len = VAR_2;
                VAR_24.dataptr++; /* COMMENT_10 */

                _libssh2_get_u32(&VAR_24, &VAR_23);
                _libssh2_get_string(&VAR_24, &VAR_5, &VAR_7);
                _libssh2_get_string(&VAR_24, &VAR_6, &VAR_8);

                if(VAR_0->ssh_msg_disconnect) {
                    LIBSSH2_DISCONNECT(VAR_0, VAR_23, (const char *)VAR_5,
                                       VAR_7, (const char *)VAR_6,
                                       VAR_8);
                }

                _libssh2_debug(VAR_0, VAR_13,
                               ""Disconnect(%d): %s(%s)"", VAR_23,
                               VAR_5, VAR_6);
            }

            LIBSSH2_FREE(VAR_0, VAR_1);
            VAR_0->socket_state = VAR_25;
            VAR_0->packAdd_state = VAR_12;
            return _libssh2_error(VAR_0, VAR_26,
                                  ""socket disconnect"");
            /* COMMENT_11 */
                                      
                            
              

        case VAR_27:
            if(VAR_2 >= 2) {
                if(VAR_0->ssh_msg_ignore) {
                    LIBSSH2_IGNORE(VAR_0, (char *) VAR_1 + 1, VAR_2 - 1);
                }
            }
            else if(VAR_0->ssh_msg_ignore) {
                LIBSSH2_IGNORE(VAR_0, """", 0);
            }
            LIBSSH2_FREE(VAR_0, VAR_1);
            VAR_0->packAdd_state = VAR_12;
            return 0;

            /* COMMENT_15 */
                                     
                                      
                                                                     
                                              
              

        case VAR_28:
            if(VAR_2 >= 2) {
                int VAR_29 = VAR_1[1];

                if(VAR_2 >= 6) {
                    struct string_buf VAR_24;
                    VAR_24.data = (unsigned char *)VAR_1;
                    VAR_24.dataptr = VAR_24.data;
                    VAR_24.len = VAR_2;
                    VAR_24.dataptr += 2; /* COMMENT_21 */

                    _libssh2_get_string(&VAR_24, &VAR_5, &VAR_7);
                    _libssh2_get_string(&VAR_24, &VAR_6, &VAR_8);
                }

                if(VAR_0->ssh_msg_debug) {
                    LIBSSH2_DEBUG(VAR_0, VAR_29,
                                  (const char *)VAR_5,
                                  VAR_7, (const char *)VAR_6,
                                  VAR_8);
                }
            }

            /* COMMENT_22 */
                                                                   
                                                        
               
            _libssh2_debug(VAR_0, VAR_13,
                           ""Debug Packet: %s"", VAR_5);
            LIBSSH2_FREE(VAR_0, VAR_1);
            VAR_0->packAdd_state = VAR_12;
            return 0;

            /* COMMENT_26 */
                                              
                                                     
                                  
                                                     
              

        case VAR_30:
            if(VAR_2 >= 5) {
                uint32_t VAR_31 = 0;
                unsigned char VAR_32 = 0;
                VAR_31 = _libssh2_ntohu32(VAR_1 + 1);
                if((VAR_31 <= (VAR_33 - 6)) && (VAR_2 >= (6 + VAR_31))) {
                    VAR_32 = VAR_1[5 + VAR_31];
                    _libssh2_debug(VAR_0,
                                   VAR_34,
                                   ""Received global request type %.*s (wr %X)"",
                                   VAR_31, VAR_1 + 5, VAR_32);
                }


                if(VAR_32) {
                    static const unsigned char VAR_35 =
                        VAR_36;
                  libssh2_packet_add_jump_point5:
                    VAR_0->packAdd_state = VAR_21;
                    VAR_4 = _libssh2_transport_send(VAR_0, &VAR_35, 1, NULL, 0);
                    if(VAR_4 == VAR_37)
                        return VAR_4;
                }
            }
            LIBSSH2_FREE(VAR_0, VAR_1);
            VAR_0->packAdd_state = VAR_12;
            return 0;

            /* COMMENT_32 */
                                                     
                                         
                                      
                            
              

        case VAR_38:
            /* COMMENT_38 */
            VAR_10 += 4;

            /* COMMENT_39 */

            /* COMMENT_40 */
                                            
                                         
                            
              

        case VAR_39:
            /* COMMENT_45 */
            VAR_10 += 9;

            if(VAR_2 >= VAR_10)
                VAR_9 =
                    _libssh2_channel_locate(VAR_0,
                                            _libssh2_ntohu32(VAR_1 + 1));

            if(!VAR_9) {
                _libssh2_error(VAR_0, VAR_40,
                               ""Packet received for unknown channel"");
                LIBSSH2_FREE(VAR_0, VAR_1);
                VAR_0->packAdd_state = VAR_12;
                return 0;
            }
#ifdef VAR_41
            {
                uint32_t VAR_42 = 0;
                if(VAR_11 == VAR_38)
                    VAR_42 = _libssh2_ntohu32(VAR_1 + 5);

                _libssh2_debug(VAR_0, VAR_34,
                               ""%d bytes packet_add() for %lu/%lu/%lu"",
                               (int) (VAR_2 - VAR_10),
                               VAR_9->local.id,
                               VAR_9->remote.id,
                               VAR_42);
            }
#endif
            if((VAR_9->remote.extended_data_ignore_mode ==
                 VAR_43) &&
                (VAR_11 == VAR_38)) {
                /* COMMENT_46 */
                LIBSSH2_FREE(VAR_0, VAR_1);

                _libssh2_debug(VAR_0, VAR_34,
                               ""Ignoring extended data and refunding %d bytes"",
                               (int) (VAR_2 - 13));
                if(VAR_9->read_avail + VAR_2 - VAR_10 >=
                    VAR_9->remote.window_size)
                    VAR_2 = VAR_9->remote.window_size -
                        VAR_9->read_avail + VAR_10;

                VAR_9->remote.window_size -= VAR_2 - VAR_10;
                _libssh2_debug(VAR_0, VAR_34,
                               ""shrinking window size by %lu bytes to %lu, ""
                               ""read_avail %lu"",
                               VAR_2 - VAR_10,
                               VAR_9->remote.window_size,
                               VAR_9->read_avail);

                VAR_0->packAdd_channelp = VAR_9;

                /* COMMENT_47 */
              libssh2_packet_add_jump_point1:
                VAR_0->packAdd_state = VAR_17;
                VAR_4 = _libssh2_channel_receive_window_adjust(VAR_0->
                                                            packAdd_channelp,
                                                            VAR_2 - 13,
                                                            1, NULL);
                if(VAR_4 == VAR_37)
                    return VAR_4;

                VAR_0->packAdd_state = VAR_12;
                return 0;
            }

            /* COMMENT_48 */
                                                               
                                 
               
            if(VAR_9->remote.packet_size < (VAR_2 - VAR_10)) {
                /* COMMENT_52 */
                                                            
                              
                   
                _libssh2_error(VAR_0,
                               VAR_44,
                               ""Packet contains more data than we offered""
                               "" to receive, truncating"");
                VAR_2 = VAR_9->remote.packet_size + VAR_10;
            }
            if(VAR_9->remote.window_size <= VAR_9->read_avail) {
                /* COMMENT_56 */
                                                            
                              
                   
                _libssh2_error(VAR_0,
                               VAR_45,
                               ""The current receive window is full,""
                               "" data ignored"");
                LIBSSH2_FREE(VAR_0, VAR_1);
                VAR_0->packAdd_state = VAR_12;
                return 0;
            }
            /* COMMENT_60 */
            VAR_9->remote.eof = 0;

            if(VAR_9->read_avail + VAR_2 - VAR_10 >
                VAR_9->remote.window_size) {
                _libssh2_error(VAR_0,
                               VAR_45,
                               ""Remote sent more data than current ""
                               ""window allows, truncating"");
                VAR_2 = VAR_9->remote.window_size -
                    VAR_9->read_avail + VAR_10;
            }

            /* COMMENT_61 */
                                                                    
                                     
            VAR_9->read_avail += VAR_2 - VAR_10;

            _libssh2_debug(VAR_0, VAR_34,
                           ""increasing read_avail by %lu bytes to %lu/%lu"",
                           (long)(VAR_2 - VAR_10),
                           (long)VAR_9->read_avail,
                           (long)VAR_9->remote.window_size);

            break;

            /* COMMENT_64 */
                                           
                                         
              

        case VAR_46:
            if(VAR_2 >= 5)
                VAR_9 =
                    _libssh2_channel_locate(VAR_0,
                                            _libssh2_ntohu32(VAR_1 + 1));
            if(!VAR_9)
                /* COMMENT_68 */
                ;
            else {
                _libssh2_debug(VAR_0,
                               VAR_34,
                               ""EOF received for channel %lu/%lu"",
                               VAR_9->local.id,
                               VAR_9->remote.id);
                VAR_9->remote.eof = 1;
            }
            LIBSSH2_FREE(VAR_0, VAR_1);
            VAR_0->packAdd_state = VAR_12;
            return 0;

            /* COMMENT_69 */
                                               
                                         
                                                                
                                  
                                                  
              

        case VAR_47:
            if(VAR_2 >= 9) {
                uint32_t VAR_48 = _libssh2_ntohu32(VAR_1 + 1);
                uint32_t VAR_31 = _libssh2_ntohu32(VAR_1 + 5);
                unsigned char VAR_32 = 1;

                if((VAR_31 + 9) < VAR_2)
                    VAR_32 = VAR_1[VAR_31 + 9];

                _libssh2_debug(VAR_0,
                               VAR_34,
                               ""Channel %d received request type %.*s (wr %X)"",
                               VAR_48, VAR_31, VAR_1 + 9, VAR_32);

                if(VAR_31 == sizeof(""exit-status"") - 1
                    && (sizeof(""exit-status"") - 1 + 9) <= VAR_2
                    && !memcmp(""exit-status"", VAR_1 + 9,
                               sizeof(""exit-status"") - 1)) {

                    /* COMMENT_76 */
                    if(VAR_2 >= 20)
                        VAR_9 =
                            _libssh2_channel_locate(VAR_0, VAR_48);

                    if(VAR_9 && (sizeof(""exit-status"") + 13) <= VAR_2) {
                        VAR_9->exit_status =
                            _libssh2_ntohu32(VAR_1 + 9 + sizeof(""exit-status""));
                        _libssh2_debug(VAR_0, VAR_34,
                                       ""Exit status %lu received for ""
                                       ""channel %lu/%lu"",
                                       VAR_9->exit_status,
                                       VAR_9->local.id,
                                       VAR_9->remote.id);
                    }

                }
                else if(VAR_31 == sizeof(""exit-signal"") - 1
                         && (sizeof(""exit-signal"") - 1 + 9) <= VAR_2
                         && !memcmp(""exit-signal"", VAR_1 + 9,
                                    sizeof(""exit-signal"") - 1)) {
                    /* COMMENT_77 */
                    if(VAR_2 >= 20)
                        VAR_9 = _libssh2_channel_locate(VAR_0, VAR_48);

                    if(VAR_9 && (sizeof(""exit-signal"") + 13) <= VAR_2) {
                        /* COMMENT_78 */
                        uint32_t VAR_49 =
                            _libssh2_ntohu32(VAR_1 + 9 + sizeof(""exit-signal""));

                        if(VAR_49 <= VAR_33 - 1) {
                            VAR_9->exit_signal =
                                LIBSSH2_ALLOC(VAR_0, VAR_49 + 1);
                        }
                        else {
                            VAR_9->exit_signal = NULL;
                        }

                        if(!VAR_9->exit_signal)
                            VAR_4 = _libssh2_error(VAR_0, VAR_50,
                                                ""memory for signal name"");
                        else if((sizeof(""exit-signal"") + 13 + VAR_49 <=
                                 VAR_2)) {
                            memcpy(VAR_9->exit_signal,
                                   VAR_1 + 13 + sizeof(""exit-signal""), VAR_49);
                            VAR_9->exit_signal[VAR_49] = '\0';
                            /* COMMENT_79 */
                            _libssh2_debug(VAR_0, VAR_34,
                                           ""Exit signal %s received for ""
                                           ""channel %lu/%lu"",
                                           VAR_9->exit_signal,
                                           VAR_9->local.id,
                                           VAR_9->remote.id);
                        }
                    }
                }


                if(VAR_32) {
                    unsigned char VAR_35[5];
                  libssh2_packet_add_jump_point4:
                    VAR_0->packAdd_state = VAR_20;
                    VAR_35[0] = VAR_51;
                    memcpy(&VAR_35[1], VAR_1 + 1, 4);
                    VAR_4 = _libssh2_transport_send(VAR_0, VAR_35, 5, NULL, 0);
                    if(VAR_4 == VAR_37)
                        return VAR_4;
                }
            }
            LIBSSH2_FREE(VAR_0, VAR_1);
            VAR_0->packAdd_state = VAR_12;
            return VAR_4;

            /* COMMENT_80 */
                                             
                                         
              

        case VAR_52:
            if(VAR_2 >= 5)
                VAR_9 =
                    _libssh2_channel_locate(VAR_0,
                                            _libssh2_ntohu32(VAR_1 + 1));
            if(!VAR_9) {
                /* COMMENT_68 */
                LIBSSH2_FREE(VAR_0, VAR_1);
                VAR_0->packAdd_state = VAR_12;
                return 0;
            }
            _libssh2_debug(VAR_0, VAR_34,
                           ""Close received for channel %lu/%lu"",
                           VAR_9->local.id,
                           VAR_9->remote.id);

            VAR_9->remote.close = 1;
            VAR_9->remote.eof = 1;

            LIBSSH2_FREE(VAR_0, VAR_1);
            VAR_0->packAdd_state = VAR_12;
            return 0;

            /* COMMENT_84 */
                                            
                                 
                                      
                                           
                                           
              

        case VAR_53:
            if(VAR_2 < 17)
                ;
            else if((VAR_2 >= (sizeof(""forwarded-tcpip"") + 4)) &&
                     ((sizeof(""forwarded-tcpip"") - 1) ==
                      _libssh2_ntohu32(VAR_1 + 1))
                     &&
                     (memcmp(VAR_1 + 5, ""forwarded-tcpip"",
                             sizeof(""forwarded-tcpip"") - 1) == 0)) {

                /* COMMENT_91 */
                memset(&VAR_0->packAdd_Qlstn_state, 0,
                       sizeof(VAR_0->packAdd_Qlstn_state));

              libssh2_packet_add_jump_point2:
                VAR_0->packAdd_state = VAR_18;
                VAR_4 = packet_queue_listener(VAR_0, VAR_1, VAR_2,
                                           &VAR_0->packAdd_Qlstn_state);
            }
            else if((VAR_2 >= (sizeof(""x11"") + 4)) &&
                     ((sizeof(""x11"") - 1) == _libssh2_ntohu32(VAR_1 + 1)) &&
                     (memcmp(VAR_1 + 5, ""x11"", sizeof(""x11"") - 1) == 0)) {

                /* COMMENT_91 */
                memset(&VAR_0->packAdd_x11open_state, 0,
                       sizeof(VAR_0->packAdd_x11open_state));

              libssh2_packet_add_jump_point3:
                VAR_0->packAdd_state = VAR_19;
                VAR_4 = packet_x11_open(VAR_0, VAR_1, VAR_2,
                                     &VAR_0->packAdd_x11open_state);
            }
            if(VAR_4 == VAR_37)
                return VAR_4;

            LIBSSH2_FREE(VAR_0, VAR_1);
            VAR_0->packAdd_state = VAR_12;
            return VAR_4;

            /* COMMENT_92 */
                                                     
                                         
                                    
              
        case VAR_54:
            if(VAR_2 < 9)
                ;
            else {
                uint32_t VAR_55 = _libssh2_ntohu32(VAR_1 + 5);
                VAR_9 =
                    _libssh2_channel_locate(VAR_0,
                                            _libssh2_ntohu32(VAR_1 + 1));
                if(VAR_9) {
                    VAR_9->local.window_size += VAR_55;

                    _libssh2_debug(VAR_0, VAR_34,
                                   ""Window adjust for channel %lu/%lu, ""
                                   ""adding %lu bytes, new window_size=%lu"",
                                   VAR_9->local.id,
                                   VAR_9->remote.id,
                                   VAR_55,
                                   VAR_9->local.window_size);
                }
            }
            LIBSSH2_FREE(VAR_0, VAR_1);
            VAR_0->packAdd_state = VAR_12;
            return 0;
        default:
            break;
        }

        VAR_0->packAdd_state = VAR_56;
    }

    if(VAR_0->packAdd_state == VAR_56) {
        LIBSSH2_PACKET *VAR_57 =
            LIBSSH2_ALLOC(VAR_0, sizeof(LIBSSH2_PACKET));
        if(!VAR_57) {
            _libssh2_debug(VAR_0, VAR_50,
                           ""memory for packet"");
            LIBSSH2_FREE(VAR_0, VAR_1);
            VAR_0->packAdd_state = VAR_12;
            return VAR_50;
        }
        VAR_57->data = VAR_1;
        VAR_57->data_len = VAR_2;
        VAR_57->data_head = VAR_10;

        _libssh2_list_add(&VAR_0->packets, &VAR_57->node);

        VAR_0->packAdd_state = VAR_58;
    }

    if((VAR_11 == VAR_59 &&
         !(VAR_0->state & VAR_60)) ||
        (VAR_0->packAdd_state == VAR_61)) {
        if(VAR_0->packAdd_state == VAR_58) {
            /* COMMENT_97 */
                                    
                                                 
                                                  
               
            _libssh2_debug(VAR_0, VAR_13, ""Renegotiating Keys"");

            VAR_0->packAdd_state = VAR_61;
        }

        /* COMMENT_102 */
                                                                            
                                                                         
                                                                              
                                         
           
        VAR_0->readPack_state = VAR_12;
        VAR_0->packet.total_num = 0;
        VAR_0->packAdd_state = VAR_12;
        VAR_0->fullpacket_state = VAR_12;

        memset(&VAR_0->startup_key_state, 0, sizeof(VAR_62));

        /* COMMENT_108 */
                                                                           
                                                                      
           
        VAR_4 = _libssh2_kex_exchange(VAR_0, 1, &VAR_0->startup_key_state);
        if(VAR_4 == VAR_37)
            return VAR_4;
    }

    VAR_0->packAdd_state = VAR_12;
    return 0;
}",libssh2/dedcbd106f8e52d5586b0205bc7677e4c9868f9c/packet.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,8 +3,8 @@
                     size_t datalen, int macstate)
 {
     int rc = 0;
-    char *message = NULL;
-    char *language = NULL;
+    unsigned char *message = NULL;
+    unsigned char *language = NULL;
     size_t message_len = 0;
     size_t language_len = 0;
     LIBSSH2_CHANNEL *channelp = NULL;
@@ -56,33 +56,23 @@
 
         case SSH_MSG_DISCONNECT:
             if(datalen >= 5) {
-                size_t reason = _libssh2_ntohu32(data + 1);
-
-                if(datalen >= 9) {
-                    message_len = _libssh2_ntohu32(data + 5);
-
-                    if(message_len < datalen-13) {
-                        /* 9 = packet_type(1) + reason(4) + message_len(4) */
-                        message = (char *) data + 9;
-
-                        language_len =
-                            _libssh2_ntohu32(data + 9 + message_len);
-                        language = (char *) data + 9 + message_len + 4;
-
-                        if(language_len > (datalen-13-message_len)) {
-                            /* bad input, clear info */
-                            language = message = NULL;
-                            language_len = message_len = 0;
-                        }
-                    }
-                    else
-                        /* bad size, clear it */
-                        message_len = 0;
-                }
+                uint32_t reason = 0;
+                struct string_buf buf;
+                buf.data = (unsigned char *)data;
+                buf.dataptr = buf.data;
+                buf.len = datalen;
+                buf.dataptr++; /* advance past type */
+
+                _libssh2_get_u32(&buf, &reason);
+                _libssh2_get_string(&buf, &message, &message_len);
+                _libssh2_get_string(&buf, &language, &language_len);
+
                 if(session->ssh_msg_disconnect) {
-                    LIBSSH2_DISCONNECT(session, reason, message,
-                                       message_len, language, language_len);
-                }
+                    LIBSSH2_DISCONNECT(session, reason, (const char *)message,
+                                       message_len, (const char *)language,
+                                       language_len);
+                }
+
                 _libssh2_debug(session, LIBSSH2_TRACE_TRANS,
                                ""Disconnect(%d): %s(%s)"", reason,
                                message, language);
@@ -123,24 +113,24 @@
                 int always_display = data[1];
 
                 if(datalen >= 6) {
-                    message_len = _libssh2_ntohu32(data + 2);
-
-                    if(message_len <= (datalen - 10)) {
-                        /* 6 = packet_type(1) + display(1) + message_len(4) */
-                        message = (char *) data + 6;
-                        language_len = _libssh2_ntohu32(data + 6 +
-                                                        message_len);
-
-                        if(language_len <= (datalen - 10 - message_len))
-                            language = (char *) data + 10 + message_len;
-                    }
+                    struct string_buf buf;
+                    buf.data = (unsigned char *)data;
+                    buf.dataptr = buf.data;
+                    buf.len = datalen;
+                    buf.dataptr += 2; /* advance past type & always display */
+
+                    _libssh2_get_string(&buf, &message, &message_len);
+                    _libssh2_get_string(&buf, &language, &language_len);
                 }
 
                 if(session->ssh_msg_debug) {
-                    LIBSSH2_DEBUG(session, always_display, message,
-                                  message_len, language, language_len);
-                }
-            }
+                    LIBSSH2_DEBUG(session, always_display,
+                                  (const char *)message,
+                                  message_len, (const char *)language,
+                                  language_len);
+                }
+            }
+
             /*
              * _libssh2_debug will actually truncate this for us so
              * that it's not an inordinate about of data
@@ -163,7 +153,7 @@
                 uint32_t len = 0;
                 unsigned char want_reply = 0;
                 len = _libssh2_ntohu32(data + 1);
-                if(datalen >= (6 + len)) {
+                if((len <= (UINT_MAX - 6)) && (datalen >= (6 + len))) {
                     want_reply = data[5 + len];
                     _libssh2_debug(session,
                                    LIBSSH2_TRACE_CONN,","{'deleted_lines': ['    char *message = NULL;', '    char *language = NULL;', '                size_t reason = _libssh2_ntohu32(data + 1);', '', '                if(datalen >= 9) {', '                    message_len = _libssh2_ntohu32(data + 5);', '', '                    if(message_len < datalen-13) {', '                        /* 9 = packet_type(1) + reason(4) + message_len(4) */', '                        message = (char *) data + 9;', '', '                        language_len =', '                            _libssh2_ntohu32(data + 9 + message_len);', '                        language = (char *) data + 9 + message_len + 4;', '', '                        if(language_len > (datalen-13-message_len)) {', '                            /* bad input, clear info */', '                            language = message = NULL;', '                            language_len = message_len = 0;', '                        }', '                    }', '                    else', '                        /* bad size, clear it */', '                        message_len = 0;', '                }', '                    LIBSSH2_DISCONNECT(session, reason, message,', '                                       message_len, language, language_len);', '                }', '                    message_len = _libssh2_ntohu32(data + 2);', '', '                    if(message_len <= (datalen - 10)) {', '                        /* 6 = packet_type(1) + display(1) + message_len(4) */', '                        message = (char *) data + 6;', '                        language_len = _libssh2_ntohu32(data + 6 +', '                                                        message_len);', '', '                        if(language_len <= (datalen - 10 - message_len))', '                            language = (char *) data + 10 + message_len;', '                    }', '                    LIBSSH2_DEBUG(session, always_display, message,', '                                  message_len, language, language_len);', '                }', '            }', '                if(datalen >= (6 + len)) {'], 'added_lines': ['    unsigned char *message = NULL;', '    unsigned char *language = NULL;', '                uint32_t reason = 0;', '                struct string_buf buf;', '                buf.data = (unsigned char *)data;', '                buf.dataptr = buf.data;', '                buf.len = datalen;', '                buf.dataptr++; /* advance past type */', '', '                _libssh2_get_u32(&buf, &reason);', '                _libssh2_get_string(&buf, &message, &message_len);', '                _libssh2_get_string(&buf, &language, &language_len);', '', '                    LIBSSH2_DISCONNECT(session, reason, (const char *)message,', '                                       message_len, (const char *)language,', '                                       language_len);', '                }', '', '                    struct string_buf buf;', '                    buf.data = (unsigned char *)data;', '                    buf.dataptr = buf.data;', '                    buf.len = datalen;', '                    buf.dataptr += 2; /* advance past type & always display */', '', '                    _libssh2_get_string(&buf, &message, &message_len);', '                    _libssh2_get_string(&buf, &language, &language_len);', '                    LIBSSH2_DEBUG(session, always_display,', '                                  (const char *)message,', '                                  message_len, (const char *)language,', '                                  language_len);', '                }', '            }', '', '                if((len <= (UINT_MAX - 6)) && (datalen >= (6 + len))) {']}",True,"In libssh2 v1.9.0 and earlier versions, the SSH_MSG_DISCONNECT logic in packet.c has an integer overflow in a bounds check, enabling an attacker to specify an arbitrary (out-of-bounds) offset for a subsequent memory read. A crafted SSH server may be able to disclose sensitive information or cause a denial of service condition on the client system when a user connects to the server.",8.1,HIGH,2,test,2019-08-30T16:57:38Z,3
CVE-2019-19074,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"ath9k: release allocated buffer if timed out

In ath9k_wmi_cmd, the allocated network buffer needs to be released
if timeout happens. Otherwise memory will be leaked.

Signed-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>
Signed-off-by: Kalle Valo <kvalo@codeaurora.org>",728c1e2a05e4b5fc52fab3421dce772a806612a2,https://github.com/torvalds/linux/commit/728c1e2a05e4b5fc52fab3421dce772a806612a2,drivers/net/wireless/ath/ath9k/wmi.c,ath9k_wmi_cmd,"int ath9k_wmi_cmd(struct wmi *wmi, enum wmi_cmd_id cmd_id,
u8 *cmd_buf, u32 cmd_len,
u8 *rsp_buf, u32 rsp_len,
u32 timeout)
{
struct ath_hw *ah = wmi->drv_priv->ah;
struct ath_common *common = ath9k_hw_common(ah);
u16 headroom = sizeof(struct htc_frame_hdr) +
sizeof(struct wmi_cmd_hdr);
struct sk_buff *skb;
unsigned long time_left;
int ret = 0;
if (ah->ah_flags & AH_UNPLUGGED)
return 0;
skb = alloc_skb(headroom + cmd_len, GFP_ATOMIC);
if (!skb)
return -ENOMEM;
skb_reserve(skb, headroom);
if (cmd_len != 0 && cmd_buf != NULL) {
skb_put_data(skb, cmd_buf, cmd_len);
}
mutex_lock(&wmi->op_mutex);
if (unlikely(wmi->stopped)) {
ret = -EPROTO;
goto out;
}
wmi->cmd_rsp_buf = rsp_buf;
wmi->cmd_rsp_len = rsp_len;
ret = ath9k_wmi_cmd_issue(wmi, skb, cmd_id, cmd_len);
if (ret)
goto out;
time_left = wait_for_completion_timeout(&wmi->cmd_wait, timeout);
if (!time_left) {
ath_dbg(common, WMI, ""Timeout waiting for WMI command: %s\n"",
wmi_cmd_to_name(cmd_id));
mutex_unlock(&wmi->op_mutex);
return -ETIMEDOUT;
}
mutex_unlock(&wmi->op_mutex);
return 0;
out:
ath_dbg(common, WMI, ""WMI failure for: %s\n"", wmi_cmd_to_name(cmd_id));
mutex_unlock(&wmi->op_mutex);
kfree_skb(skb);
return ret;
}","int ath9k_wmi_cmd(struct wmi *wmi, enum wmi_cmd_id VAR_0,
u8 *VAR_1, u32 VAR_2,
u8 *VAR_3, u32 VAR_4,
u32 VAR_5)
{
struct ath_hw *VAR_6 = wmi->drv_priv->ah;
struct ath_common *VAR_7 = ath9k_hw_common(VAR_6);
u16 VAR_8 = sizeof(struct htc_frame_hdr) +
sizeof(struct wmi_cmd_hdr);
struct sk_buff *VAR_9;
unsigned long VAR_10;
int VAR_11 = 0;
if (VAR_6->ah_flags & VAR_12)
return 0;
VAR_9 = alloc_skb(VAR_8 + VAR_2, VAR_13);
if (!VAR_9)
return -VAR_14;
skb_reserve(VAR_9, VAR_8);
if (VAR_2 != 0 && VAR_1 != NULL) {
skb_put_data(VAR_9, VAR_1, VAR_2);
}
mutex_lock(&wmi->op_mutex);
if (unlikely(wmi->stopped)) {
VAR_11 = -VAR_15;
goto out;
}
wmi->cmd_rsp_buf = VAR_3;
wmi->cmd_rsp_len = VAR_4;
VAR_11 = ath9k_wmi_cmd_issue(wmi, VAR_9, VAR_0, VAR_2);
if (VAR_11)
goto out;
VAR_10 = wait_for_completion_timeout(&wmi->cmd_wait, VAR_5);
if (!VAR_10) {
ath_dbg(VAR_7, VAR_16, ""Timeout waiting for WMI command: %s\n"",
wmi_cmd_to_name(VAR_0));
mutex_unlock(&wmi->op_mutex);
return -VAR_17;
}
mutex_unlock(&wmi->op_mutex);
return 0;
out:
ath_dbg(VAR_7, VAR_16, ""WMI failure for: %s\n"", wmi_cmd_to_name(VAR_0));
mutex_unlock(&wmi->op_mutex);
kfree_skb(VAR_9);
return VAR_11;
}",torvalds/linux/728c1e2a05e4b5fc52fab3421dce772a806612a2/wmi.c/vul/before/0.json,"int ath9k_wmi_cmd(struct wmi *wmi, enum wmi_cmd_id cmd_id,
		  u8 *cmd_buf, u32 cmd_len,
		  u8 *rsp_buf, u32 rsp_len,
		  u32 timeout)
{
	struct ath_hw *ah = wmi->drv_priv->ah;
	struct ath_common *common = ath9k_hw_common(ah);
	u16 headroom = sizeof(struct htc_frame_hdr) +
		       sizeof(struct wmi_cmd_hdr);
	struct sk_buff *skb;
	unsigned long time_left;
	int ret = 0;

	if (ah->ah_flags & AH_UNPLUGGED)
		return 0;

	skb = alloc_skb(headroom + cmd_len, GFP_ATOMIC);
	if (!skb)
		return -ENOMEM;

	skb_reserve(skb, headroom);

	if (cmd_len != 0 && cmd_buf != NULL) {
		skb_put_data(skb, cmd_buf, cmd_len);
	}

	mutex_lock(&wmi->op_mutex);

	/* check if wmi stopped flag is set */
	if (unlikely(wmi->stopped)) {
		ret = -EPROTO;
		goto out;
	}

	/* record the rsp buffer and length */
	wmi->cmd_rsp_buf = rsp_buf;
	wmi->cmd_rsp_len = rsp_len;

	ret = ath9k_wmi_cmd_issue(wmi, skb, cmd_id, cmd_len);
	if (ret)
		goto out;

	time_left = wait_for_completion_timeout(&wmi->cmd_wait, timeout);
	if (!time_left) {
		ath_dbg(common, WMI, ""Timeout waiting for WMI command: %s\n"",
			wmi_cmd_to_name(cmd_id));
		mutex_unlock(&wmi->op_mutex);
		kfree_skb(skb);
		return -ETIMEDOUT;
	}

	mutex_unlock(&wmi->op_mutex);

	return 0;

out:
	ath_dbg(common, WMI, ""WMI failure for: %s\n"", wmi_cmd_to_name(cmd_id));
	mutex_unlock(&wmi->op_mutex);
	kfree_skb(skb);

	return ret;
}","int ath9k_wmi_cmd(struct wmi *wmi, enum wmi_cmd_id VAR_0,
		  u8 *VAR_1, u32 VAR_2,
		  u8 *VAR_3, u32 VAR_4,
		  u32 VAR_5)
{
	struct ath_hw *VAR_6 = wmi->drv_priv->ah;
	struct ath_common *VAR_7 = ath9k_hw_common(VAR_6);
	u16 VAR_8 = sizeof(struct htc_frame_hdr) +
		       sizeof(struct wmi_cmd_hdr);
	struct sk_buff *VAR_9;
	unsigned long VAR_10;
	int VAR_11 = 0;

	if (VAR_6->ah_flags & VAR_12)
		return 0;

	VAR_9 = alloc_skb(VAR_8 + VAR_2, VAR_13);
	if (!VAR_9)
		return -VAR_14;

	skb_reserve(VAR_9, VAR_8);

	if (VAR_2 != 0 && VAR_1 != NULL) {
		skb_put_data(VAR_9, VAR_1, VAR_2);
	}

	mutex_lock(&wmi->op_mutex);

	/* COMMENT_0 */
	if (unlikely(wmi->stopped)) {
		VAR_11 = -VAR_15;
		goto out;
	}

	/* COMMENT_1 */
	wmi->cmd_rsp_buf = VAR_3;
	wmi->cmd_rsp_len = VAR_4;

	VAR_11 = ath9k_wmi_cmd_issue(wmi, VAR_9, VAR_0, VAR_2);
	if (VAR_11)
		goto out;

	VAR_10 = wait_for_completion_timeout(&wmi->cmd_wait, VAR_5);
	if (!VAR_10) {
		ath_dbg(VAR_7, VAR_16, ""Timeout waiting for WMI command: %s\n"",
			wmi_cmd_to_name(VAR_0));
		mutex_unlock(&wmi->op_mutex);
		kfree_skb(VAR_9);
		return -VAR_17;
	}

	mutex_unlock(&wmi->op_mutex);

	return 0;

out:
	ath_dbg(VAR_7, VAR_16, ""WMI failure for: %s\n"", wmi_cmd_to_name(VAR_0));
	mutex_unlock(&wmi->op_mutex);
	kfree_skb(VAR_9);

	return VAR_11;
}",torvalds/linux/728c1e2a05e4b5fc52fab3421dce772a806612a2/wmi.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -45,6 +45,7 @@
 		ath_dbg(common, WMI, ""Timeout waiting for WMI command: %s\n"",
 			wmi_cmd_to_name(cmd_id));
 		mutex_unlock(&wmi->op_mutex);
+		kfree_skb(skb);
 		return -ETIMEDOUT;
 	}
 ","{'deleted_lines': [], 'added_lines': ['\t\tkfree_skb(skb);']}",True,"A memory leak in the ath9k_wmi_cmd() function in drivers/net/wireless/ath/ath9k/wmi.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption), aka CID-728c1e2a05e4.",7.5,HIGH,2,test,2019-09-06T18:59:30Z,3
CVE-2019-18671,['CWE-787'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,keepkey/keepkey-firmware,"board: factor out tiny_dispatch

And add stronger checks on what tiny_msg's are allowed to be decoded.",b222c66cdd7c3203d917c80ba615082d309d80c3,https://github.com/keepkey/keepkey-firmware/commit/b222c66cdd7c3203d917c80ba615082d309d80c3,lib/board/messages.c,handle_usb_rx,"void handle_usb_rx(const void *msg, size_t len)
{
if (msg_tiny_flag) {
uint8_t buf[64];
memcpy(buf, msg, sizeof(buf));
uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;
uint32_t msgSize = buf[8]        |
((uint32_t)buf[7]) <<  8 |
((uint32_t)buf[6]) << 16 |
((uint32_t)buf[5]) << 24;
if (msgSize > 64 - 9) {
(*msg_failure)(FailureType_Failure_UnexpectedMessage, ""Malformed tiny packet"");
return;
}
const MessagesMap_t *entry = message_map_entry(NORMAL_MSG, msgId, IN_MSG);
if (!entry) {
(*msg_failure)(FailureType_Failure_UnexpectedMessage, ""Unknown message"");
return;
}
tiny_dispatch(entry, buf + 9, msgSize);
} else {
usb_rx_helper(msg, len, NORMAL_MSG);
}
}","void handle_usb_rx(const void *VAR_0, size_t VAR_1)
{
if (VAR_2) {
uint8_t VAR_3[64];
memcpy(VAR_3, VAR_0, sizeof(VAR_3));
uint16_t VAR_4 = VAR_3[4] | ((uint16_t)VAR_3[3]) << 8;
uint32_t VAR_5 = VAR_3[8]        |
((uint32_t)VAR_3[7]) <<  8 |
((uint32_t)VAR_3[6]) << 16 |
((uint32_t)VAR_3[5]) << 24;
if (VAR_5 > 64 - 9) {
(*VAR_6)(VAR_7, ""Malformed tiny packet"");
return;
}
const MessagesMap_t *VAR_8 = message_map_entry(VAR_9, VAR_4, VAR_10);
if (!VAR_8) {
(*VAR_6)(VAR_7, ""Unknown message"");
return;
}
tiny_dispatch(VAR_8, VAR_3 + 9, VAR_5);
} else {
usb_rx_helper(VAR_0, VAR_1, VAR_9);
}
}",keepkey/keepkey-firmware/b222c66cdd7c3203d917c80ba615082d309d80c3/messages.c/vul/before/0.json,"void handle_usb_rx(const void *msg, size_t len)
{
    if (msg_tiny_flag) {
        msg_read_tiny(msg, len);
    } else {
        usb_rx_helper(msg, len, NORMAL_MSG);
    }
}","void handle_usb_rx(const void *VAR_0, size_t VAR_1)
{
    if (VAR_2) {
        msg_read_tiny(VAR_0, VAR_1);
    } else {
        usb_rx_helper(VAR_0, VAR_1, VAR_3);
    }
}",keepkey/keepkey-firmware/b222c66cdd7c3203d917c80ba615082d309d80c3/messages.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,28 +1,7 @@
 void handle_usb_rx(const void *msg, size_t len)
 {
     if (msg_tiny_flag) {
-        uint8_t buf[64];
-        memcpy(buf, msg, sizeof(buf));
-
-        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;
-        uint32_t msgSize = buf[8]        |
-                ((uint32_t)buf[7]) <<  8 |
-                ((uint32_t)buf[6]) << 16 |
-                ((uint32_t)buf[5]) << 24;
-
-        if (msgSize > 64 - 9) {
-            (*msg_failure)(FailureType_Failure_UnexpectedMessage, ""Malformed tiny packet"");
-            return;
-        }
-
-        // Determine callback handler and message map type.
-        const MessagesMap_t *entry = message_map_entry(NORMAL_MSG, msgId, IN_MSG);
-        if (!entry) {
-            (*msg_failure)(FailureType_Failure_UnexpectedMessage, ""Unknown message"");
-            return;
-        }
-
-        tiny_dispatch(entry, buf + 9, msgSize);
+        msg_read_tiny(msg, len);
     } else {
         usb_rx_helper(msg, len, NORMAL_MSG);
     }","{'deleted_lines': ['        uint8_t buf[64];', '        memcpy(buf, msg, sizeof(buf));', '', '        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;', '        uint32_t msgSize = buf[8]        |', '                ((uint32_t)buf[7]) <<  8 |', '                ((uint32_t)buf[6]) << 16 |', '                ((uint32_t)buf[5]) << 24;', '', '        if (msgSize > 64 - 9) {', '            (*msg_failure)(FailureType_Failure_UnexpectedMessage, ""Malformed tiny packet"");', '            return;', '        }', '', '        // Determine callback handler and message map type.', '        const MessagesMap_t *entry = message_map_entry(NORMAL_MSG, msgId, IN_MSG);', '        if (!entry) {', '            (*msg_failure)(FailureType_Failure_UnexpectedMessage, ""Unknown message"");', '            return;', '        }', '', '        tiny_dispatch(entry, buf + 9, msgSize);'], 'added_lines': ['        msg_read_tiny(msg, len);']}",True,Insufficient checks in the USB packet handling of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow out-of-bounds writes in the .bss segment via crafted messages. The vulnerability could allow code execution or other forms of impact. It can be triggered by unauthenticated attackers and the interface is reachable via WebUSB.,9.8,CRITICAL,3,test,2019-09-11T19:20:00Z,3
CVE-2019-18671,['CWE-787'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,keepkey/keepkey-firmware,"board: factor out tiny_dispatch

And add stronger checks on what tiny_msg's are allowed to be decoded.",b222c66cdd7c3203d917c80ba615082d309d80c3,https://github.com/keepkey/keepkey-firmware/commit/b222c66cdd7c3203d917c80ba615082d309d80c3,lib/board/messages.c,handle_debug_usb_rx,"void handle_debug_usb_rx(const void *msg, size_t len)
{
if (msg_tiny_flag) {
uint8_t buf[64];
memcpy(buf, msg, sizeof(buf));
uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;
uint32_t msgSize = buf[8]        |
((uint32_t)buf[7]) <<  8 |
((uint32_t)buf[6]) << 16 |
((uint32_t)buf[5]) << 24;
if (msgSize > 64 - 9) {
(*msg_failure)(FailureType_Failure_UnexpectedMessage, ""Malformed tiny packet"");
return;
}
const MessagesMap_t *entry = message_map_entry(DEBUG_MSG, msgId, IN_MSG);
if (!entry) {
(*msg_failure)(FailureType_Failure_UnexpectedMessage, ""Unknown message"");
return;
}
tiny_dispatch(entry, buf + 9, msgSize);
} else {
usb_rx_helper(msg, len, DEBUG_MSG);
}
}","void handle_debug_usb_rx(const void *VAR_0, size_t VAR_1)
{
if (VAR_2) {
uint8_t VAR_3[64];
memcpy(VAR_3, VAR_0, sizeof(VAR_3));
uint16_t VAR_4 = VAR_3[4] | ((uint16_t)VAR_3[3]) << 8;
uint32_t VAR_5 = VAR_3[8]        |
((uint32_t)VAR_3[7]) <<  8 |
((uint32_t)VAR_3[6]) << 16 |
((uint32_t)VAR_3[5]) << 24;
if (VAR_5 > 64 - 9) {
(*VAR_6)(VAR_7, ""Malformed tiny packet"");
return;
}
const MessagesMap_t *VAR_8 = message_map_entry(VAR_9, VAR_4, VAR_10);
if (!VAR_8) {
(*VAR_6)(VAR_7, ""Unknown message"");
return;
}
tiny_dispatch(VAR_8, VAR_3 + 9, VAR_5);
} else {
usb_rx_helper(VAR_0, VAR_1, VAR_9);
}
}",keepkey/keepkey-firmware/b222c66cdd7c3203d917c80ba615082d309d80c3/messages.c/vul/before/1.json,"void handle_debug_usb_rx(const void *msg, size_t len)
{
    if (msg_tiny_flag) {
        msg_read_tiny(msg, len);
    } else {
        usb_rx_helper(msg, len, DEBUG_MSG);
    }
}","void handle_debug_usb_rx(const void *VAR_0, size_t VAR_1)
{
    if (VAR_2) {
        msg_read_tiny(VAR_0, VAR_1);
    } else {
        usb_rx_helper(VAR_0, VAR_1, VAR_3);
    }
}",keepkey/keepkey-firmware/b222c66cdd7c3203d917c80ba615082d309d80c3/messages.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,28 +1,7 @@
 void handle_debug_usb_rx(const void *msg, size_t len)
 {
     if (msg_tiny_flag) {
-        uint8_t buf[64];
-        memcpy(buf, msg, sizeof(buf));
-
-        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;
-        uint32_t msgSize = buf[8]        |
-                ((uint32_t)buf[7]) <<  8 |
-                ((uint32_t)buf[6]) << 16 |
-                ((uint32_t)buf[5]) << 24;
-
-        if (msgSize > 64 - 9) {
-            (*msg_failure)(FailureType_Failure_UnexpectedMessage, ""Malformed tiny packet"");
-            return;
-        }
-
-        // Determine callback handler and message map type.
-        const MessagesMap_t *entry = message_map_entry(DEBUG_MSG, msgId, IN_MSG);
-        if (!entry) {
-            (*msg_failure)(FailureType_Failure_UnexpectedMessage, ""Unknown message"");
-            return;
-        }
-
-        tiny_dispatch(entry, buf + 9, msgSize);
+        msg_read_tiny(msg, len);
     } else {
         usb_rx_helper(msg, len, DEBUG_MSG);
     }","{'deleted_lines': ['        uint8_t buf[64];', '        memcpy(buf, msg, sizeof(buf));', '', '        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;', '        uint32_t msgSize = buf[8]        |', '                ((uint32_t)buf[7]) <<  8 |', '                ((uint32_t)buf[6]) << 16 |', '                ((uint32_t)buf[5]) << 24;', '', '        if (msgSize > 64 - 9) {', '            (*msg_failure)(FailureType_Failure_UnexpectedMessage, ""Malformed tiny packet"");', '            return;', '        }', '', '        // Determine callback handler and message map type.', '        const MessagesMap_t *entry = message_map_entry(DEBUG_MSG, msgId, IN_MSG);', '        if (!entry) {', '            (*msg_failure)(FailureType_Failure_UnexpectedMessage, ""Unknown message"");', '            return;', '        }', '', '        tiny_dispatch(entry, buf + 9, msgSize);'], 'added_lines': ['        msg_read_tiny(msg, len);']}",True,Insufficient checks in the USB packet handling of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow out-of-bounds writes in the .bss segment via crafted messages. The vulnerability could allow code execution or other forms of impact. It can be triggered by unauthenticated attackers and the interface is reachable via WebUSB.,9.8,CRITICAL,3,test,2019-09-11T19:20:00Z,3
CVE-2019-19061,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"iio: imu: adis16400: fix memory leak

In adis_update_scan_mode_burst, if adis->buffer allocation fails release
the adis->xfer.

Signed-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>
Reviewed-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>",9c0530e898f384c5d279bfcebd8bb17af1105873,https://github.com/torvalds/linux/commit/9c0530e898f384c5d279bfcebd8bb17af1105873,drivers/iio/imu/adis_buffer.c,adis_update_scan_mode_burst,"static int adis_update_scan_mode_burst(struct iio_dev *indio_dev,
const unsigned long *scan_mask)
{
struct adis *adis = iio_device_get_drvdata(indio_dev);
unsigned int burst_length;
u8 *tx;
burst_length = (indio_dev->num_channels - 1) * sizeof(u16);
burst_length += adis->burst->extra_len;
adis->xfer = kcalloc(2, sizeof(*adis->xfer), GFP_KERNEL);
if (!adis->xfer)
return -ENOMEM;
adis->buffer = kzalloc(burst_length + sizeof(u16), GFP_KERNEL);
if (!adis->buffer)
return -ENOMEM;
tx = adis->buffer + burst_length;
tx[0] = ADIS_READ_REG(adis->burst->reg_cmd);
tx[1] = 0;
adis->xfer[0].tx_buf = tx;
adis->xfer[0].bits_per_word = 8;
adis->xfer[0].len = 2;
adis->xfer[1].rx_buf = adis->buffer;
adis->xfer[1].bits_per_word = 8;
adis->xfer[1].len = burst_length;
spi_message_init(&adis->msg);
spi_message_add_tail(&adis->xfer[0], &adis->msg);
spi_message_add_tail(&adis->xfer[1], &adis->msg);
return 0;
}","static int adis_update_scan_mode_burst(struct iio_dev *VAR_0,
const unsigned long *VAR_1)
{
struct adis *adis = iio_device_get_drvdata(VAR_0);
unsigned int VAR_2;
u8 *VAR_3;
VAR_2 = (VAR_0->num_channels - 1) * sizeof(VAR_4);
VAR_2 += adis->burst->extra_len;
adis->xfer = kcalloc(2, sizeof(*adis->xfer), VAR_5);
if (!adis->xfer)
return -VAR_6;
adis->buffer = kzalloc(VAR_2 + sizeof(VAR_4), VAR_5);
if (!adis->buffer)
return -VAR_6;
VAR_3 = adis->buffer + VAR_2;
VAR_3[0] = ADIS_READ_REG(adis->burst->reg_cmd);
VAR_3[1] = 0;
adis->xfer[0].tx_buf = VAR_3;
adis->xfer[0].bits_per_word = 8;
adis->xfer[0].len = 2;
adis->xfer[1].rx_buf = adis->buffer;
adis->xfer[1].bits_per_word = 8;
adis->xfer[1].len = VAR_2;
spi_message_init(&adis->msg);
spi_message_add_tail(&adis->xfer[0], &adis->msg);
spi_message_add_tail(&adis->xfer[1], &adis->msg);
return 0;
}",torvalds/linux/9c0530e898f384c5d279bfcebd8bb17af1105873/adis_buffer.c/vul/before/0.json,"static int adis_update_scan_mode_burst(struct iio_dev *indio_dev,
	const unsigned long *scan_mask)
{
	struct adis *adis = iio_device_get_drvdata(indio_dev);
	unsigned int burst_length;
	u8 *tx;

	/* All but the timestamp channel */
	burst_length = (indio_dev->num_channels - 1) * sizeof(u16);
	burst_length += adis->burst->extra_len;

	adis->xfer = kcalloc(2, sizeof(*adis->xfer), GFP_KERNEL);
	if (!adis->xfer)
		return -ENOMEM;

	adis->buffer = kzalloc(burst_length + sizeof(u16), GFP_KERNEL);
	if (!adis->buffer) {
		kfree(adis->xfer);
		adis->xfer = NULL;
		return -ENOMEM;
	}

	tx = adis->buffer + burst_length;
	tx[0] = ADIS_READ_REG(adis->burst->reg_cmd);
	tx[1] = 0;

	adis->xfer[0].tx_buf = tx;
	adis->xfer[0].bits_per_word = 8;
	adis->xfer[0].len = 2;
	adis->xfer[1].rx_buf = adis->buffer;
	adis->xfer[1].bits_per_word = 8;
	adis->xfer[1].len = burst_length;

	spi_message_init(&adis->msg);
	spi_message_add_tail(&adis->xfer[0], &adis->msg);
	spi_message_add_tail(&adis->xfer[1], &adis->msg);

	return 0;
}","static int adis_update_scan_mode_burst(struct iio_dev *VAR_0,
	const unsigned long *VAR_1)
{
	struct adis *adis = iio_device_get_drvdata(VAR_0);
	unsigned int VAR_2;
	u8 *VAR_3;

	/* COMMENT_0 */
	VAR_2 = (VAR_0->num_channels - 1) * sizeof(VAR_4);
	VAR_2 += adis->burst->extra_len;

	adis->xfer = kcalloc(2, sizeof(*adis->xfer), VAR_5);
	if (!adis->xfer)
		return -VAR_6;

	adis->buffer = kzalloc(VAR_2 + sizeof(VAR_4), VAR_5);
	if (!adis->buffer) {
		kfree(adis->xfer);
		adis->xfer = NULL;
		return -VAR_6;
	}

	VAR_3 = adis->buffer + VAR_2;
	VAR_3[0] = ADIS_READ_REG(adis->burst->reg_cmd);
	VAR_3[1] = 0;

	adis->xfer[0].tx_buf = VAR_3;
	adis->xfer[0].bits_per_word = 8;
	adis->xfer[0].len = 2;
	adis->xfer[1].rx_buf = adis->buffer;
	adis->xfer[1].bits_per_word = 8;
	adis->xfer[1].len = VAR_2;

	spi_message_init(&adis->msg);
	spi_message_add_tail(&adis->xfer[0], &adis->msg);
	spi_message_add_tail(&adis->xfer[1], &adis->msg);

	return 0;
}",torvalds/linux/9c0530e898f384c5d279bfcebd8bb17af1105873/adis_buffer.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,8 +14,11 @@
 		return -ENOMEM;
 
 	adis->buffer = kzalloc(burst_length + sizeof(u16), GFP_KERNEL);
-	if (!adis->buffer)
+	if (!adis->buffer) {
+		kfree(adis->xfer);
+		adis->xfer = NULL;
 		return -ENOMEM;
+	}
 
 	tx = adis->buffer + burst_length;
 	tx[0] = ADIS_READ_REG(adis->burst->reg_cmd);","{'deleted_lines': ['\tif (!adis->buffer)'], 'added_lines': ['\tif (!adis->buffer) {', '\t\tkfree(adis->xfer);', '\t\tadis->xfer = NULL;', '\t}']}",True,"A memory leak in the adis_update_scan_mode_burst() function in drivers/iio/imu/adis_buffer.c in the Linux kernel before 5.3.9 allows attackers to cause a denial of service (memory consumption), aka CID-9c0530e898f3.",7.5,HIGH,2,test,2019-09-19T15:56:35Z,3
CVE-2019-18808,['CWE-401'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,torvalds/linux,"crypto: ccp - Release all allocated memory if sha type is invalid

Release all allocated memory if sha type is invalid:
In ccp_run_sha_cmd, if the type of sha is invalid, the allocated
hmac_buf should be released.

v2: fix the goto.

Signed-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>
Acked-by: Gary R Hook <gary.hook@amd.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",128c66429247add5128c03dc1e144ca56f05a4e2,https://github.com/torvalds/linux/commit/128c66429247add5128c03dc1e144ca56f05a4e2,drivers/crypto/ccp/ccp-ops.c,ccp_run_sha_cmd,"static noinline_for_stack int
ccp_run_sha_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)
{
struct ccp_sha_engine *sha = &cmd->u.sha;
struct ccp_dm_workarea ctx;
struct ccp_data src;
struct ccp_op op;
unsigned int ioffset, ooffset;
unsigned int digest_size;
int sb_count;
const void *init;
u64 block_size;
int ctx_size;
int ret;
switch (sha->type) {
case CCP_SHA_TYPE_1:
if (sha->ctx_len < SHA1_DIGEST_SIZE)
return -EINVAL;
block_size = SHA1_BLOCK_SIZE;
break;
case CCP_SHA_TYPE_224:
if (sha->ctx_len < SHA224_DIGEST_SIZE)
return -EINVAL;
block_size = SHA224_BLOCK_SIZE;
break;
case CCP_SHA_TYPE_256:
if (sha->ctx_len < SHA256_DIGEST_SIZE)
return -EINVAL;
block_size = SHA256_BLOCK_SIZE;
break;
case CCP_SHA_TYPE_384:
if (cmd_q->ccp->vdata->version < CCP_VERSION(4, 0)
|| sha->ctx_len < SHA384_DIGEST_SIZE)
return -EINVAL;
block_size = SHA384_BLOCK_SIZE;
break;
case CCP_SHA_TYPE_512:
if (cmd_q->ccp->vdata->version < CCP_VERSION(4, 0)
|| sha->ctx_len < SHA512_DIGEST_SIZE)
return -EINVAL;
block_size = SHA512_BLOCK_SIZE;
break;
default:
return -EINVAL;
}
if (!sha->ctx)
return -EINVAL;
if (!sha->final && (sha->src_len & (block_size - 1)))
return -EINVAL;
if (cmd_q->ccp->vdata->version == CCP_VERSION(3, 0)) {
if (!sha->src_len) {
unsigned int digest_len;
const u8 *sha_zero;
if (!sha->final)
return 0;
if (sha->msg_bits)
return -EINVAL;
switch (sha->type) {
case CCP_SHA_TYPE_1:
sha_zero = sha1_zero_message_hash;
digest_len = SHA1_DIGEST_SIZE;
break;
case CCP_SHA_TYPE_224:
sha_zero = sha224_zero_message_hash;
digest_len = SHA224_DIGEST_SIZE;
break;
case CCP_SHA_TYPE_256:
sha_zero = sha256_zero_message_hash;
digest_len = SHA256_DIGEST_SIZE;
break;
default:
return -EINVAL;
}
scatterwalk_map_and_copy((void *)sha_zero, sha->ctx, 0,
digest_len, 1);
return 0;
}
}
switch (sha->type) {
case CCP_SHA_TYPE_1:
digest_size = SHA1_DIGEST_SIZE;
init = (void *) ccp_sha1_init;
ctx_size = SHA1_DIGEST_SIZE;
sb_count = 1;
if (cmd_q->ccp->vdata->version != CCP_VERSION(3, 0))
ooffset = ioffset = CCP_SB_BYTES - SHA1_DIGEST_SIZE;
else
ooffset = ioffset = 0;
break;
case CCP_SHA_TYPE_224:
digest_size = SHA224_DIGEST_SIZE;
init = (void *) ccp_sha224_init;
ctx_size = SHA256_DIGEST_SIZE;
sb_count = 1;
ioffset = 0;
if (cmd_q->ccp->vdata->version != CCP_VERSION(3, 0))
ooffset = CCP_SB_BYTES - SHA224_DIGEST_SIZE;
else
ooffset = 0;
break;
case CCP_SHA_TYPE_256:
digest_size = SHA256_DIGEST_SIZE;
init = (void *) ccp_sha256_init;
ctx_size = SHA256_DIGEST_SIZE;
sb_count = 1;
ooffset = ioffset = 0;
break;
case CCP_SHA_TYPE_384:
digest_size = SHA384_DIGEST_SIZE;
init = (void *) ccp_sha384_init;
ctx_size = SHA512_DIGEST_SIZE;
sb_count = 2;
ioffset = 0;
ooffset = 2 * CCP_SB_BYTES - SHA384_DIGEST_SIZE;
break;
case CCP_SHA_TYPE_512:
digest_size = SHA512_DIGEST_SIZE;
init = (void *) ccp_sha512_init;
ctx_size = SHA512_DIGEST_SIZE;
sb_count = 2;
ooffset = ioffset = 0;
break;
default:
ret = -EINVAL;
goto e_data;
}
if (sha->src_len && !sha->src)
return -EINVAL;
memset(&op, 0, sizeof(op));
op.cmd_q = cmd_q;
op.jobid = CCP_NEW_JOBID(cmd_q->ccp);
op.sb_ctx = cmd_q->sb_ctx; 
op.u.sha.type = sha->type;
op.u.sha.msg_bits = sha->msg_bits;
ret = ccp_init_dm_workarea(&ctx, cmd_q, sb_count * CCP_SB_BYTES,
DMA_BIDIRECTIONAL);
if (ret)
return ret;
if (sha->first) {
switch (sha->type) {
case CCP_SHA_TYPE_1:
case CCP_SHA_TYPE_224:
case CCP_SHA_TYPE_256:
memcpy(ctx.address + ioffset, init, ctx_size);
break;
case CCP_SHA_TYPE_384:
case CCP_SHA_TYPE_512:
memcpy(ctx.address + ctx_size / 2, init,
ctx_size / 2);
memcpy(ctx.address, init + ctx_size / 2,
ctx_size / 2);
break;
default:
ret = -EINVAL;
goto e_ctx;
}
} else {
ret = ccp_set_dm_area(&ctx, 0, sha->ctx, 0,
sb_count * CCP_SB_BYTES);
if (ret)
goto e_ctx;
}
ret = ccp_copy_to_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,
CCP_PASSTHRU_BYTESWAP_256BIT);
if (ret) {
cmd->engine_error = cmd_q->cmd_error;
goto e_ctx;
}
if (sha->src) {
ret = ccp_init_data(&src, cmd_q, sha->src, sha->src_len,
block_size, DMA_TO_DEVICE);
if (ret)
goto e_ctx;
while (src.sg_wa.bytes_left) {
ccp_prepare_data(&src, NULL, &op, block_size, false);
if (sha->final && !src.sg_wa.bytes_left)
op.eom = 1;
ret = cmd_q->ccp->vdata->perform->sha(&op);
if (ret) {
cmd->engine_error = cmd_q->cmd_error;
goto e_data;
}
ccp_process_data(&src, NULL, &op);
}
} else {
op.eom = 1;
ret = cmd_q->ccp->vdata->perform->sha(&op);
if (ret) {
cmd->engine_error = cmd_q->cmd_error;
goto e_data;
}
}
ret = ccp_copy_from_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,
CCP_PASSTHRU_BYTESWAP_256BIT);
if (ret) {
cmd->engine_error = cmd_q->cmd_error;
goto e_data;
}
if (sha->final) {
switch (sha->type) {
case CCP_SHA_TYPE_1:
case CCP_SHA_TYPE_224:
case CCP_SHA_TYPE_256:
ccp_get_dm_area(&ctx, ooffset,
sha->ctx, 0,
digest_size);
break;
case CCP_SHA_TYPE_384:
case CCP_SHA_TYPE_512:
ccp_get_dm_area(&ctx, 0,
sha->ctx, LSB_ITEM_SIZE - ooffset,
LSB_ITEM_SIZE);
ccp_get_dm_area(&ctx, LSB_ITEM_SIZE + ooffset,
sha->ctx, 0,
LSB_ITEM_SIZE - ooffset);
break;
default:
ret = -EINVAL;
goto e_ctx;
}
} else {
ccp_get_dm_area(&ctx, 0, sha->ctx, 0,
sb_count * CCP_SB_BYTES);
}
if (sha->final && sha->opad) {
struct ccp_cmd hmac_cmd;
struct scatterlist sg;
u8 *hmac_buf;
if (sha->opad_len != block_size) {
ret = -EINVAL;
goto e_data;
}
hmac_buf = kmalloc(block_size + digest_size, GFP_KERNEL);
if (!hmac_buf) {
ret = -ENOMEM;
goto e_data;
}
sg_init_one(&sg, hmac_buf, block_size + digest_size);
scatterwalk_map_and_copy(hmac_buf, sha->opad, 0, block_size, 0);
switch (sha->type) {
case CCP_SHA_TYPE_1:
case CCP_SHA_TYPE_224:
case CCP_SHA_TYPE_256:
memcpy(hmac_buf + block_size,
ctx.address + ooffset,
digest_size);
break;
case CCP_SHA_TYPE_384:
case CCP_SHA_TYPE_512:
memcpy(hmac_buf + block_size,
ctx.address + LSB_ITEM_SIZE + ooffset,
LSB_ITEM_SIZE);
memcpy(hmac_buf + block_size +
(LSB_ITEM_SIZE - ooffset),
ctx.address,
LSB_ITEM_SIZE);
break;
default:
ret = -EINVAL;
goto e_ctx;
}
memset(&hmac_cmd, 0, sizeof(hmac_cmd));
hmac_cmd.engine = CCP_ENGINE_SHA;
hmac_cmd.u.sha.type = sha->type;
hmac_cmd.u.sha.ctx = sha->ctx;
hmac_cmd.u.sha.ctx_len = sha->ctx_len;
hmac_cmd.u.sha.src = &sg;
hmac_cmd.u.sha.src_len = block_size + digest_size;
hmac_cmd.u.sha.opad = NULL;
hmac_cmd.u.sha.opad_len = 0;
hmac_cmd.u.sha.first = 1;
hmac_cmd.u.sha.final = 1;
hmac_cmd.u.sha.msg_bits = (block_size + digest_size) << 3;
ret = ccp_run_sha_cmd(cmd_q, &hmac_cmd);
if (ret)
cmd->engine_error = hmac_cmd.engine_error;
kfree(hmac_buf);
}
e_data:
if (sha->src)
ccp_free_data(&src, cmd_q);
e_ctx:
ccp_dm_free(&ctx);
return ret;
}","static noinline_for_stack VAR_0
ccp_run_sha_cmd(struct ccp_cmd_queue *VAR_1, struct ccp_cmd *VAR_2)
{
struct ccp_sha_engine *VAR_3 = &VAR_2->u.sha;
struct ccp_dm_workarea VAR_4;
struct ccp_data VAR_5;
struct ccp_op VAR_6;
unsigned int VAR_7, VAR_8;
unsigned int VAR_9;
int VAR_10;
const void *VAR_11;
u64 VAR_12;
int VAR_13;
int VAR_14;
switch (VAR_3->type) {
case VAR_15:
if (VAR_3->ctx_len < VAR_16)
return -VAR_17;
VAR_12 = VAR_18;
break;
case VAR_19:
if (VAR_3->ctx_len < VAR_20)
return -VAR_17;
VAR_12 = VAR_21;
break;
case VAR_22:
if (VAR_3->ctx_len < VAR_23)
return -VAR_17;
VAR_12 = VAR_24;
break;
case VAR_25:
if (VAR_1->ccp->vdata->version < CCP_VERSION(4, 0)
|| VAR_3->ctx_len < VAR_26)
return -VAR_17;
VAR_12 = VAR_27;
break;
case VAR_28:
if (VAR_1->ccp->vdata->version < CCP_VERSION(4, 0)
|| VAR_3->ctx_len < VAR_29)
return -VAR_17;
VAR_12 = VAR_30;
break;
default:
return -VAR_17;
}
if (!VAR_3->ctx)
return -VAR_17;
if (!VAR_3->final && (VAR_3->src_len & (VAR_12 - 1)))
return -VAR_17;
if (VAR_1->ccp->vdata->version == CCP_VERSION(3, 0)) {
if (!VAR_3->src_len) {
unsigned int VAR_31;
const u8 *VAR_32;
if (!VAR_3->final)
return 0;
if (VAR_3->msg_bits)
return -VAR_17;
switch (VAR_3->type) {
case VAR_15:
VAR_32 = VAR_33;
VAR_31 = VAR_16;
break;
case VAR_19:
VAR_32 = VAR_34;
VAR_31 = VAR_20;
break;
case VAR_22:
VAR_32 = VAR_35;
VAR_31 = VAR_23;
break;
default:
return -VAR_17;
}
scatterwalk_map_and_copy((void *)VAR_32, VAR_3->ctx, 0,
VAR_31, 1);
return 0;
}
}
switch (VAR_3->type) {
case VAR_15:
VAR_9 = VAR_16;
VAR_11 = (void *) VAR_36;
VAR_13 = VAR_16;
VAR_10 = 1;
if (VAR_1->ccp->vdata->version != CCP_VERSION(3, 0))
VAR_8 = VAR_7 = VAR_37 - VAR_16;
else
VAR_8 = VAR_7 = 0;
break;
case VAR_19:
VAR_9 = VAR_20;
VAR_11 = (void *) VAR_38;
VAR_13 = VAR_23;
VAR_10 = 1;
VAR_7 = 0;
if (VAR_1->ccp->vdata->version != CCP_VERSION(3, 0))
VAR_8 = VAR_37 - VAR_20;
else
VAR_8 = 0;
break;
case VAR_22:
VAR_9 = VAR_23;
VAR_11 = (void *) VAR_39;
VAR_13 = VAR_23;
VAR_10 = 1;
VAR_8 = VAR_7 = 0;
break;
case VAR_25:
VAR_9 = VAR_26;
VAR_11 = (void *) VAR_40;
VAR_13 = VAR_29;
VAR_10 = 2;
VAR_7 = 0;
VAR_8 = 2 * VAR_37 - VAR_26;
break;
case VAR_28:
VAR_9 = VAR_29;
VAR_11 = (void *) VAR_41;
VAR_13 = VAR_29;
VAR_10 = 2;
VAR_8 = VAR_7 = 0;
break;
default:
VAR_14 = -VAR_17;
goto e_data;
}
if (VAR_3->src_len && !VAR_3->src)
return -VAR_17;
memset(&VAR_6, 0, sizeof(VAR_6));
VAR_6.cmd_q = VAR_1;
VAR_6.jobid = CCP_NEW_JOBID(VAR_1->ccp);
VAR_6.sb_ctx = VAR_1->sb_ctx; 
VAR_6.u.sha.type = VAR_3->type;
VAR_6.u.sha.msg_bits = VAR_3->msg_bits;
VAR_14 = ccp_init_dm_workarea(&VAR_4, VAR_1, VAR_10 * VAR_37,
VAR_42);
if (VAR_14)
return VAR_14;
if (VAR_3->first) {
switch (VAR_3->type) {
case VAR_15:
case VAR_19:
case VAR_22:
memcpy(VAR_4.address + VAR_7, VAR_11, VAR_13);
break;
case VAR_25:
case VAR_28:
memcpy(VAR_4.address + VAR_13 / 2, VAR_11,
VAR_13 / 2);
memcpy(VAR_4.address, VAR_11 + VAR_13 / 2,
VAR_13 / 2);
break;
default:
VAR_14 = -VAR_17;
goto e_ctx;
}
} else {
VAR_14 = ccp_set_dm_area(&VAR_4, 0, VAR_3->ctx, 0,
VAR_10 * VAR_37);
if (VAR_14)
goto e_ctx;
}
VAR_14 = ccp_copy_to_sb(VAR_1, &VAR_4, VAR_6.jobid, VAR_6.sb_ctx,
VAR_43);
if (VAR_14) {
VAR_2->engine_error = VAR_1->cmd_error;
goto e_ctx;
}
if (VAR_3->src) {
VAR_14 = ccp_init_data(&VAR_5, VAR_1, VAR_3->src, VAR_3->src_len,
VAR_12, VAR_44);
if (VAR_14)
goto e_ctx;
while (VAR_5.sg_wa.bytes_left) {
ccp_prepare_data(&VAR_5, NULL, &VAR_6, VAR_12, false);
if (VAR_3->final && !VAR_5.sg_wa.bytes_left)
VAR_6.eom = 1;
VAR_14 = VAR_1->ccp->vdata->perform->sha(&VAR_6);
if (VAR_14) {
VAR_2->engine_error = VAR_1->cmd_error;
goto e_data;
}
ccp_process_data(&VAR_5, NULL, &VAR_6);
}
} else {
VAR_6.eom = 1;
VAR_14 = VAR_1->ccp->vdata->perform->sha(&VAR_6);
if (VAR_14) {
VAR_2->engine_error = VAR_1->cmd_error;
goto e_data;
}
}
VAR_14 = ccp_copy_from_sb(VAR_1, &VAR_4, VAR_6.jobid, VAR_6.sb_ctx,
VAR_43);
if (VAR_14) {
VAR_2->engine_error = VAR_1->cmd_error;
goto e_data;
}
if (VAR_3->final) {
switch (VAR_3->type) {
case VAR_15:
case VAR_19:
case VAR_22:
ccp_get_dm_area(&VAR_4, VAR_8,
VAR_3->ctx, 0,
VAR_9);
break;
case VAR_25:
case VAR_28:
ccp_get_dm_area(&VAR_4, 0,
VAR_3->ctx, VAR_45 - VAR_8,
VAR_45);
ccp_get_dm_area(&VAR_4, VAR_45 + VAR_8,
VAR_3->ctx, 0,
VAR_45 - VAR_8);
break;
default:
VAR_14 = -VAR_17;
goto e_ctx;
}
} else {
ccp_get_dm_area(&VAR_4, 0, VAR_3->ctx, 0,
VAR_10 * VAR_37);
}
if (VAR_3->final && VAR_3->opad) {
struct ccp_cmd VAR_46;
struct scatterlist VAR_47;
u8 *VAR_48;
if (VAR_3->opad_len != VAR_12) {
VAR_14 = -VAR_17;
goto e_data;
}
VAR_48 = kmalloc(VAR_12 + VAR_9, VAR_49);
if (!VAR_48) {
VAR_14 = -VAR_50;
goto e_data;
}
sg_init_one(&VAR_47, VAR_48, VAR_12 + VAR_9);
scatterwalk_map_and_copy(VAR_48, VAR_3->opad, 0, VAR_12, 0);
switch (VAR_3->type) {
case VAR_15:
case VAR_19:
case VAR_22:
memcpy(VAR_48 + VAR_12,
VAR_4.address + VAR_8,
VAR_9);
break;
case VAR_25:
case VAR_28:
memcpy(VAR_48 + VAR_12,
VAR_4.address + VAR_45 + VAR_8,
VAR_45);
memcpy(VAR_48 + VAR_12 +
(VAR_45 - VAR_8),
VAR_4.address,
VAR_45);
break;
default:
VAR_14 = -VAR_17;
goto e_ctx;
}
memset(&VAR_46, 0, sizeof(VAR_46));
VAR_46.engine = VAR_51;
VAR_46.u.sha.type = VAR_3->type;
VAR_46.u.sha.ctx = VAR_3->ctx;
VAR_46.u.sha.ctx_len = VAR_3->ctx_len;
VAR_46.u.sha.src = &VAR_47;
VAR_46.u.sha.src_len = VAR_12 + VAR_9;
VAR_46.u.sha.opad = NULL;
VAR_46.u.sha.opad_len = 0;
VAR_46.u.sha.first = 1;
VAR_46.u.sha.final = 1;
VAR_46.u.sha.msg_bits = (VAR_12 + VAR_9) << 3;
VAR_14 = ccp_run_sha_cmd(VAR_1, &VAR_46);
if (VAR_14)
VAR_2->engine_error = VAR_46.engine_error;
kfree(VAR_48);
}
e_data:
if (VAR_3->src)
ccp_free_data(&VAR_5, VAR_1);
e_ctx:
ccp_dm_free(&VAR_4);
return VAR_14;
}",,"static noinline_for_stack int
ccp_run_sha_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)
{
	struct ccp_sha_engine *sha = &cmd->u.sha;
	struct ccp_dm_workarea ctx;
	struct ccp_data src;
	struct ccp_op op;
	unsigned int ioffset, ooffset;
	unsigned int digest_size;
	int sb_count;
	const void *init;
	u64 block_size;
	int ctx_size;
	int ret;

	switch (sha->type) {
	case CCP_SHA_TYPE_1:
		if (sha->ctx_len < SHA1_DIGEST_SIZE)
			return -EINVAL;
		block_size = SHA1_BLOCK_SIZE;
		break;
	case CCP_SHA_TYPE_224:
		if (sha->ctx_len < SHA224_DIGEST_SIZE)
			return -EINVAL;
		block_size = SHA224_BLOCK_SIZE;
		break;
	case CCP_SHA_TYPE_256:
		if (sha->ctx_len < SHA256_DIGEST_SIZE)
			return -EINVAL;
		block_size = SHA256_BLOCK_SIZE;
		break;
	case CCP_SHA_TYPE_384:
		if (cmd_q->ccp->vdata->version < CCP_VERSION(4, 0)
		    || sha->ctx_len < SHA384_DIGEST_SIZE)
			return -EINVAL;
		block_size = SHA384_BLOCK_SIZE;
		break;
	case CCP_SHA_TYPE_512:
		if (cmd_q->ccp->vdata->version < CCP_VERSION(4, 0)
		    || sha->ctx_len < SHA512_DIGEST_SIZE)
			return -EINVAL;
		block_size = SHA512_BLOCK_SIZE;
		break;
	default:
		return -EINVAL;
	}

	if (!sha->ctx)
		return -EINVAL;

	if (!sha->final && (sha->src_len & (block_size - 1)))
		return -EINVAL;

	/* The version 3 device can't handle zero-length input */
	if (cmd_q->ccp->vdata->version == CCP_VERSION(3, 0)) {

		if (!sha->src_len) {
			unsigned int digest_len;
			const u8 *sha_zero;

			/* Not final, just return */
			if (!sha->final)
				return 0;

			/* CCP can't do a zero length sha operation so the
			 * caller must buffer the data.
			 */
			if (sha->msg_bits)
				return -EINVAL;

			/* The CCP cannot perform zero-length sha operations
			 * so the caller is required to buffer data for the
			 * final operation. However, a sha operation for a
			 * message with a total length of zero is valid so
			 * known values are required to supply the result.
			 */
			switch (sha->type) {
			case CCP_SHA_TYPE_1:
				sha_zero = sha1_zero_message_hash;
				digest_len = SHA1_DIGEST_SIZE;
				break;
			case CCP_SHA_TYPE_224:
				sha_zero = sha224_zero_message_hash;
				digest_len = SHA224_DIGEST_SIZE;
				break;
			case CCP_SHA_TYPE_256:
				sha_zero = sha256_zero_message_hash;
				digest_len = SHA256_DIGEST_SIZE;
				break;
			default:
				return -EINVAL;
			}

			scatterwalk_map_and_copy((void *)sha_zero, sha->ctx, 0,
						 digest_len, 1);

			return 0;
		}
	}

	/* Set variables used throughout */
	switch (sha->type) {
	case CCP_SHA_TYPE_1:
		digest_size = SHA1_DIGEST_SIZE;
		init = (void *) ccp_sha1_init;
		ctx_size = SHA1_DIGEST_SIZE;
		sb_count = 1;
		if (cmd_q->ccp->vdata->version != CCP_VERSION(3, 0))
			ooffset = ioffset = CCP_SB_BYTES - SHA1_DIGEST_SIZE;
		else
			ooffset = ioffset = 0;
		break;
	case CCP_SHA_TYPE_224:
		digest_size = SHA224_DIGEST_SIZE;
		init = (void *) ccp_sha224_init;
		ctx_size = SHA256_DIGEST_SIZE;
		sb_count = 1;
		ioffset = 0;
		if (cmd_q->ccp->vdata->version != CCP_VERSION(3, 0))
			ooffset = CCP_SB_BYTES - SHA224_DIGEST_SIZE;
		else
			ooffset = 0;
		break;
	case CCP_SHA_TYPE_256:
		digest_size = SHA256_DIGEST_SIZE;
		init = (void *) ccp_sha256_init;
		ctx_size = SHA256_DIGEST_SIZE;
		sb_count = 1;
		ooffset = ioffset = 0;
		break;
	case CCP_SHA_TYPE_384:
		digest_size = SHA384_DIGEST_SIZE;
		init = (void *) ccp_sha384_init;
		ctx_size = SHA512_DIGEST_SIZE;
		sb_count = 2;
		ioffset = 0;
		ooffset = 2 * CCP_SB_BYTES - SHA384_DIGEST_SIZE;
		break;
	case CCP_SHA_TYPE_512:
		digest_size = SHA512_DIGEST_SIZE;
		init = (void *) ccp_sha512_init;
		ctx_size = SHA512_DIGEST_SIZE;
		sb_count = 2;
		ooffset = ioffset = 0;
		break;
	default:
		ret = -EINVAL;
		goto e_data;
	}

	/* For zero-length plaintext the src pointer is ignored;
	 * otherwise both parts must be valid
	 */
	if (sha->src_len && !sha->src)
		return -EINVAL;

	memset(&op, 0, sizeof(op));
	op.cmd_q = cmd_q;
	op.jobid = CCP_NEW_JOBID(cmd_q->ccp);
	op.sb_ctx = cmd_q->sb_ctx; /* Pre-allocated */
	op.u.sha.type = sha->type;
	op.u.sha.msg_bits = sha->msg_bits;

	/* For SHA1/224/256 the context fits in a single (32-byte) SB entry;
	 * SHA384/512 require 2 adjacent SB slots, with the right half in the
	 * first slot, and the left half in the second. Each portion must then
	 * be in little endian format: use the 256-bit byte swap option.
	 */
	ret = ccp_init_dm_workarea(&ctx, cmd_q, sb_count * CCP_SB_BYTES,
				   DMA_BIDIRECTIONAL);
	if (ret)
		return ret;
	if (sha->first) {
		switch (sha->type) {
		case CCP_SHA_TYPE_1:
		case CCP_SHA_TYPE_224:
		case CCP_SHA_TYPE_256:
			memcpy(ctx.address + ioffset, init, ctx_size);
			break;
		case CCP_SHA_TYPE_384:
		case CCP_SHA_TYPE_512:
			memcpy(ctx.address + ctx_size / 2, init,
			       ctx_size / 2);
			memcpy(ctx.address, init + ctx_size / 2,
			       ctx_size / 2);
			break;
		default:
			ret = -EINVAL;
			goto e_ctx;
		}
	} else {
		/* Restore the context */
		ret = ccp_set_dm_area(&ctx, 0, sha->ctx, 0,
				      sb_count * CCP_SB_BYTES);
		if (ret)
			goto e_ctx;
	}

	ret = ccp_copy_to_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,
			     CCP_PASSTHRU_BYTESWAP_256BIT);
	if (ret) {
		cmd->engine_error = cmd_q->cmd_error;
		goto e_ctx;
	}

	if (sha->src) {
		/* Send data to the CCP SHA engine; block_size is set above */
		ret = ccp_init_data(&src, cmd_q, sha->src, sha->src_len,
				    block_size, DMA_TO_DEVICE);
		if (ret)
			goto e_ctx;

		while (src.sg_wa.bytes_left) {
			ccp_prepare_data(&src, NULL, &op, block_size, false);
			if (sha->final && !src.sg_wa.bytes_left)
				op.eom = 1;

			ret = cmd_q->ccp->vdata->perform->sha(&op);
			if (ret) {
				cmd->engine_error = cmd_q->cmd_error;
				goto e_data;
			}

			ccp_process_data(&src, NULL, &op);
		}
	} else {
		op.eom = 1;
		ret = cmd_q->ccp->vdata->perform->sha(&op);
		if (ret) {
			cmd->engine_error = cmd_q->cmd_error;
			goto e_data;
		}
	}

	/* Retrieve the SHA context - convert from LE to BE using
	 * 32-byte (256-bit) byteswapping to BE
	 */
	ret = ccp_copy_from_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,
			       CCP_PASSTHRU_BYTESWAP_256BIT);
	if (ret) {
		cmd->engine_error = cmd_q->cmd_error;
		goto e_data;
	}

	if (sha->final) {
		/* Finishing up, so get the digest */
		switch (sha->type) {
		case CCP_SHA_TYPE_1:
		case CCP_SHA_TYPE_224:
		case CCP_SHA_TYPE_256:
			ccp_get_dm_area(&ctx, ooffset,
					sha->ctx, 0,
					digest_size);
			break;
		case CCP_SHA_TYPE_384:
		case CCP_SHA_TYPE_512:
			ccp_get_dm_area(&ctx, 0,
					sha->ctx, LSB_ITEM_SIZE - ooffset,
					LSB_ITEM_SIZE);
			ccp_get_dm_area(&ctx, LSB_ITEM_SIZE + ooffset,
					sha->ctx, 0,
					LSB_ITEM_SIZE - ooffset);
			break;
		default:
			ret = -EINVAL;
			goto e_ctx;
		}
	} else {
		/* Stash the context */
		ccp_get_dm_area(&ctx, 0, sha->ctx, 0,
				sb_count * CCP_SB_BYTES);
	}

	if (sha->final && sha->opad) {
		/* HMAC operation, recursively perform final SHA */
		struct ccp_cmd hmac_cmd;
		struct scatterlist sg;
		u8 *hmac_buf;

		if (sha->opad_len != block_size) {
			ret = -EINVAL;
			goto e_data;
		}

		hmac_buf = kmalloc(block_size + digest_size, GFP_KERNEL);
		if (!hmac_buf) {
			ret = -ENOMEM;
			goto e_data;
		}
		sg_init_one(&sg, hmac_buf, block_size + digest_size);

		scatterwalk_map_and_copy(hmac_buf, sha->opad, 0, block_size, 0);
		switch (sha->type) {
		case CCP_SHA_TYPE_1:
		case CCP_SHA_TYPE_224:
		case CCP_SHA_TYPE_256:
			memcpy(hmac_buf + block_size,
			       ctx.address + ooffset,
			       digest_size);
			break;
		case CCP_SHA_TYPE_384:
		case CCP_SHA_TYPE_512:
			memcpy(hmac_buf + block_size,
			       ctx.address + LSB_ITEM_SIZE + ooffset,
			       LSB_ITEM_SIZE);
			memcpy(hmac_buf + block_size +
			       (LSB_ITEM_SIZE - ooffset),
			       ctx.address,
			       LSB_ITEM_SIZE);
			break;
		default:
			kfree(hmac_buf);
			ret = -EINVAL;
			goto e_data;
		}

		memset(&hmac_cmd, 0, sizeof(hmac_cmd));
		hmac_cmd.engine = CCP_ENGINE_SHA;
		hmac_cmd.u.sha.type = sha->type;
		hmac_cmd.u.sha.ctx = sha->ctx;
		hmac_cmd.u.sha.ctx_len = sha->ctx_len;
		hmac_cmd.u.sha.src = &sg;
		hmac_cmd.u.sha.src_len = block_size + digest_size;
		hmac_cmd.u.sha.opad = NULL;
		hmac_cmd.u.sha.opad_len = 0;
		hmac_cmd.u.sha.first = 1;
		hmac_cmd.u.sha.final = 1;
		hmac_cmd.u.sha.msg_bits = (block_size + digest_size) << 3;

		ret = ccp_run_sha_cmd(cmd_q, &hmac_cmd);
		if (ret)
			cmd->engine_error = hmac_cmd.engine_error;

		kfree(hmac_buf);
	}

e_data:
	if (sha->src)
		ccp_free_data(&src, cmd_q);

e_ctx:
	ccp_dm_free(&ctx);

	return ret;
}","static noinline_for_stack VAR_0
ccp_run_sha_cmd(struct ccp_cmd_queue *VAR_1, struct ccp_cmd *VAR_2)
{
	struct ccp_sha_engine *VAR_3 = &VAR_2->u.sha;
	struct ccp_dm_workarea VAR_4;
	struct ccp_data VAR_5;
	struct ccp_op VAR_6;
	unsigned int VAR_7, VAR_8;
	unsigned int VAR_9;
	int VAR_10;
	const void *VAR_11;
	u64 VAR_12;
	int VAR_13;
	int VAR_14;

	switch (VAR_3->type) {
	case VAR_15:
		if (VAR_3->ctx_len < VAR_16)
			return -VAR_17;
		VAR_12 = VAR_18;
		break;
	case VAR_19:
		if (VAR_3->ctx_len < VAR_20)
			return -VAR_17;
		VAR_12 = VAR_21;
		break;
	case VAR_22:
		if (VAR_3->ctx_len < VAR_23)
			return -VAR_17;
		VAR_12 = VAR_24;
		break;
	case VAR_25:
		if (VAR_1->ccp->vdata->version < CCP_VERSION(4, 0)
		    || VAR_3->ctx_len < VAR_26)
			return -VAR_17;
		VAR_12 = VAR_27;
		break;
	case VAR_28:
		if (VAR_1->ccp->vdata->version < CCP_VERSION(4, 0)
		    || VAR_3->ctx_len < VAR_29)
			return -VAR_17;
		VAR_12 = VAR_30;
		break;
	default:
		return -VAR_17;
	}

	if (!VAR_3->ctx)
		return -VAR_17;

	if (!VAR_3->final && (VAR_3->src_len & (VAR_12 - 1)))
		return -VAR_17;

	/* COMMENT_0 */
	if (VAR_1->ccp->vdata->version == CCP_VERSION(3, 0)) {

		if (!VAR_3->src_len) {
			unsigned int VAR_31;
			const u8 *VAR_32;

			/* COMMENT_1 */
			if (!VAR_3->final)
				return 0;

			/* COMMENT_2 */
                                  
      
			if (VAR_3->msg_bits)
				return -VAR_17;

			/* COMMENT_5 */
                                                      
                                                     
                                                     
                                                     
      
			switch (VAR_3->type) {
			case VAR_15:
				VAR_32 = VAR_33;
				VAR_31 = VAR_16;
				break;
			case VAR_19:
				VAR_32 = VAR_34;
				VAR_31 = VAR_20;
				break;
			case VAR_22:
				VAR_32 = VAR_35;
				VAR_31 = VAR_23;
				break;
			default:
				return -VAR_17;
			}

			scatterwalk_map_and_copy((void *)VAR_32, VAR_3->ctx, 0,
						 VAR_31, 1);

			return 0;
		}
	}

	/* COMMENT_11 */
	switch (VAR_3->type) {
	case VAR_15:
		VAR_9 = VAR_16;
		VAR_11 = (void *) VAR_36;
		VAR_13 = VAR_16;
		VAR_10 = 1;
		if (VAR_1->ccp->vdata->version != CCP_VERSION(3, 0))
			VAR_8 = VAR_7 = VAR_37 - VAR_16;
		else
			VAR_8 = VAR_7 = 0;
		break;
	case VAR_19:
		VAR_9 = VAR_20;
		VAR_11 = (void *) VAR_38;
		VAR_13 = VAR_23;
		VAR_10 = 1;
		VAR_7 = 0;
		if (VAR_1->ccp->vdata->version != CCP_VERSION(3, 0))
			VAR_8 = VAR_37 - VAR_20;
		else
			VAR_8 = 0;
		break;
	case VAR_22:
		VAR_9 = VAR_23;
		VAR_11 = (void *) VAR_39;
		VAR_13 = VAR_23;
		VAR_10 = 1;
		VAR_8 = VAR_7 = 0;
		break;
	case VAR_25:
		VAR_9 = VAR_26;
		VAR_11 = (void *) VAR_40;
		VAR_13 = VAR_29;
		VAR_10 = 2;
		VAR_7 = 0;
		VAR_8 = 2 * VAR_37 - VAR_26;
		break;
	case VAR_28:
		VAR_9 = VAR_29;
		VAR_11 = (void *) VAR_41;
		VAR_13 = VAR_29;
		VAR_10 = 2;
		VAR_8 = VAR_7 = 0;
		break;
	default:
		VAR_14 = -VAR_17;
		goto e_data;
	}

	/* COMMENT_12 */
                                      
    
	if (VAR_3->src_len && !VAR_3->src)
		return -VAR_17;

	memset(&VAR_6, 0, sizeof(VAR_6));
	VAR_6.cmd_q = VAR_1;
	VAR_6.jobid = CCP_NEW_JOBID(VAR_1->ccp);
	VAR_6.sb_ctx = VAR_1->sb_ctx; /* COMMENT_15 */
	VAR_6.u.sha.type = VAR_3->type;
	VAR_6.u.sha.msg_bits = VAR_3->msg_bits;

	/* COMMENT_16 */
                                                                      
                                                                       
                                                                 
    
	VAR_14 = ccp_init_dm_workarea(&VAR_4, VAR_1, VAR_10 * VAR_37,
				   VAR_42);
	if (VAR_14)
		return VAR_14;
	if (VAR_3->first) {
		switch (VAR_3->type) {
		case VAR_15:
		case VAR_19:
		case VAR_22:
			memcpy(VAR_4.address + VAR_7, VAR_11, VAR_13);
			break;
		case VAR_25:
		case VAR_28:
			memcpy(VAR_4.address + VAR_13 / 2, VAR_11,
			       VAR_13 / 2);
			memcpy(VAR_4.address, VAR_11 + VAR_13 / 2,
			       VAR_13 / 2);
			break;
		default:
			VAR_14 = -VAR_17;
			goto e_ctx;
		}
	} else {
		/* COMMENT_21 */
		VAR_14 = ccp_set_dm_area(&VAR_4, 0, VAR_3->ctx, 0,
				      VAR_10 * VAR_37);
		if (VAR_14)
			goto e_ctx;
	}

	VAR_14 = ccp_copy_to_sb(VAR_1, &VAR_4, VAR_6.jobid, VAR_6.sb_ctx,
			     VAR_43);
	if (VAR_14) {
		VAR_2->engine_error = VAR_1->cmd_error;
		goto e_ctx;
	}

	if (VAR_3->src) {
		/* COMMENT_22 */
		VAR_14 = ccp_init_data(&VAR_5, VAR_1, VAR_3->src, VAR_3->src_len,
				    VAR_12, VAR_44);
		if (VAR_14)
			goto e_ctx;

		while (VAR_5.sg_wa.bytes_left) {
			ccp_prepare_data(&VAR_5, NULL, &VAR_6, VAR_12, false);
			if (VAR_3->final && !VAR_5.sg_wa.bytes_left)
				VAR_6.eom = 1;

			VAR_14 = VAR_1->ccp->vdata->perform->sha(&VAR_6);
			if (VAR_14) {
				VAR_2->engine_error = VAR_1->cmd_error;
				goto e_data;
			}

			ccp_process_data(&VAR_5, NULL, &VAR_6);
		}
	} else {
		VAR_6.eom = 1;
		VAR_14 = VAR_1->ccp->vdata->perform->sha(&VAR_6);
		if (VAR_14) {
			VAR_2->engine_error = VAR_1->cmd_error;
			goto e_data;
		}
	}

	/* COMMENT_23 */
                                        
    
	VAR_14 = ccp_copy_from_sb(VAR_1, &VAR_4, VAR_6.jobid, VAR_6.sb_ctx,
			       VAR_43);
	if (VAR_14) {
		VAR_2->engine_error = VAR_1->cmd_error;
		goto e_data;
	}

	if (VAR_3->final) {
		/* COMMENT_26 */
		switch (VAR_3->type) {
		case VAR_15:
		case VAR_19:
		case VAR_22:
			ccp_get_dm_area(&VAR_4, VAR_8,
					VAR_3->ctx, 0,
					VAR_9);
			break;
		case VAR_25:
		case VAR_28:
			ccp_get_dm_area(&VAR_4, 0,
					VAR_3->ctx, VAR_45 - VAR_8,
					VAR_45);
			ccp_get_dm_area(&VAR_4, VAR_45 + VAR_8,
					VAR_3->ctx, 0,
					VAR_45 - VAR_8);
			break;
		default:
			VAR_14 = -VAR_17;
			goto e_ctx;
		}
	} else {
		/* COMMENT_27 */
		ccp_get_dm_area(&VAR_4, 0, VAR_3->ctx, 0,
				VAR_10 * VAR_37);
	}

	if (VAR_3->final && VAR_3->opad) {
		/* COMMENT_28 */
		struct ccp_cmd VAR_46;
		struct scatterlist VAR_47;
		u8 *VAR_48;

		if (VAR_3->opad_len != VAR_12) {
			VAR_14 = -VAR_17;
			goto e_data;
		}

		VAR_48 = kmalloc(VAR_12 + VAR_9, VAR_49);
		if (!VAR_48) {
			VAR_14 = -VAR_50;
			goto e_data;
		}
		sg_init_one(&VAR_47, VAR_48, VAR_12 + VAR_9);

		scatterwalk_map_and_copy(VAR_48, VAR_3->opad, 0, VAR_12, 0);
		switch (VAR_3->type) {
		case VAR_15:
		case VAR_19:
		case VAR_22:
			memcpy(VAR_48 + VAR_12,
			       VAR_4.address + VAR_8,
			       VAR_9);
			break;
		case VAR_25:
		case VAR_28:
			memcpy(VAR_48 + VAR_12,
			       VAR_4.address + VAR_45 + VAR_8,
			       VAR_45);
			memcpy(VAR_48 + VAR_12 +
			       (VAR_45 - VAR_8),
			       VAR_4.address,
			       VAR_45);
			break;
		default:
			kfree(VAR_48);
			VAR_14 = -VAR_17;
			goto e_data;
		}

		memset(&VAR_46, 0, sizeof(VAR_46));
		VAR_46.engine = VAR_51;
		VAR_46.u.sha.type = VAR_3->type;
		VAR_46.u.sha.ctx = VAR_3->ctx;
		VAR_46.u.sha.ctx_len = VAR_3->ctx_len;
		VAR_46.u.sha.src = &VAR_47;
		VAR_46.u.sha.src_len = VAR_12 + VAR_9;
		VAR_46.u.sha.opad = NULL;
		VAR_46.u.sha.opad_len = 0;
		VAR_46.u.sha.first = 1;
		VAR_46.u.sha.final = 1;
		VAR_46.u.sha.msg_bits = (VAR_12 + VAR_9) << 3;

		VAR_14 = ccp_run_sha_cmd(VAR_1, &VAR_46);
		if (VAR_14)
			VAR_2->engine_error = VAR_46.engine_error;

		kfree(VAR_48);
	}

e_data:
	if (VAR_3->src)
		ccp_free_data(&VAR_5, VAR_1);

e_ctx:
	ccp_dm_free(&VAR_4);

	return VAR_14;
}",,"--- func_before
+++ func_after
@@ -309,8 +309,9 @@
 			       LSB_ITEM_SIZE);
 			break;
 		default:
+			kfree(hmac_buf);
 			ret = -EINVAL;
-			goto e_ctx;
+			goto e_data;
 		}
 
 		memset(&hmac_cmd, 0, sizeof(hmac_cmd));","{'deleted_lines': ['\t\t\tgoto e_ctx;'], 'added_lines': ['\t\t\tkfree(hmac_buf);', '\t\t\tgoto e_data;']}",True,"A memory leak in the ccp_run_sha_cmd() function in drivers/crypto/ccp/ccp-ops.c in the Linux kernel through 5.3.9 allows attackers to cause a denial of service (memory consumption), aka CID-128c66429247.",5.5,MEDIUM,1,test,2019-09-19T16:04:48Z,3
CVE-2019-19246,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,php/php-src,"Fix #78559: Heap buffer overflow in mb_eregi

We backport kkos/oniguruma@d3e402928b6eb3327f8f7d59a9edfa622fec557b.

(cherry picked from commit 8f949eba8083e34d181c30bcf11aaeef2496bb97)",90a77d87d4b63db29b1051a784e91e7d368a07e1,https://github.com/php/php-src/commit/90a77d87d4b63db29b1051a784e91e7d368a07e1,ext/mbstring/oniguruma/src/regexec.c,str_lower_case_match,"static int
str_lower_case_match(OnigEncoding enc, int case_fold_flag,
const UChar* t, const UChar* tend,
const UChar* p, const UChar* end)
{
int lowlen;
UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];
while (t < tend) {
lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);
q = lowbuf;
while (lowlen > 0) {
if (*t++ != *q++) return 0;
lowlen--;
}
}
return 1;
}","static int
str_lower_case_match(OnigEncoding VAR_0, int VAR_1,
const UChar* VAR_2, const UChar* VAR_3,
const UChar* VAR_4, const UChar* VAR_5)
{
int VAR_6;
UChar *VAR_7, VAR_8[VAR_9];
while (VAR_2 < VAR_3) {
VAR_6 = ONIGENC_MBC_CASE_FOLD(VAR_0, VAR_1, &VAR_4, VAR_5, VAR_8);
VAR_7 = VAR_8;
while (VAR_6 > 0) {
if (*VAR_2++ != *VAR_7++) return 0;
VAR_6--;
}
}
return 1;
}",php/php-src/90a77d87d4b63db29b1051a784e91e7d368a07e1/regexec.c/vul/before/0.json,"static int
str_lower_case_match(OnigEncoding enc, int case_fold_flag,
                     const UChar* t, const UChar* tend,
                     const UChar* p, const UChar* end)
{
  int lowlen;
  UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];

  while (t < tend) {
    lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);
    q = lowbuf;
    while (lowlen > 0) {
      if (t >= tend)    return 0;
      if (*t++ != *q++) return 0;
      lowlen--;
    }
  }

  return 1;
}","static int
str_lower_case_match(OnigEncoding VAR_0, int VAR_1,
                     const UChar* VAR_2, const UChar* VAR_3,
                     const UChar* VAR_4, const UChar* VAR_5)
{
  int VAR_6;
  UChar *VAR_7, VAR_8[VAR_9];

  while (VAR_2 < VAR_3) {
    VAR_6 = ONIGENC_MBC_CASE_FOLD(VAR_0, VAR_1, &VAR_4, VAR_5, VAR_8);
    VAR_7 = VAR_8;
    while (VAR_6 > 0) {
      if (VAR_2 >= VAR_3)    return 0;
      if (*VAR_2++ != *VAR_7++) return 0;
      VAR_6--;
    }
  }

  return 1;
}",php/php-src/90a77d87d4b63db29b1051a784e91e7d368a07e1/regexec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,6 +10,7 @@
     lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);
     q = lowbuf;
     while (lowlen > 0) {
+      if (t >= tend)    return 0;
       if (*t++ != *q++) return 0;
       lowlen--;
     }","{'deleted_lines': [], 'added_lines': ['      if (t >= tend)    return 0;']}",True,"Oniguruma through 6.9.3, as used in PHP 7.3.x and other products, has a heap-based buffer over-read in str_lower_case_match in regexec.c.",7.5,HIGH,2,test,2019-09-20T17:02:22Z,3
CVE-2019-19246,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,php/php-src,"Fix #78559: Heap buffer overflow in mb_eregi

We backport kkos/oniguruma@d3e402928b6eb3327f8f7d59a9edfa622fec557b.",8f949eba8083e34d181c30bcf11aaeef2496bb97,https://github.com/php/php-src/commit/8f949eba8083e34d181c30bcf11aaeef2496bb97,ext/mbstring/oniguruma/src/regexec.c,str_lower_case_match,"static int
str_lower_case_match(OnigEncoding enc, int case_fold_flag,
const UChar* t, const UChar* tend,
const UChar* p, const UChar* end)
{
int lowlen;
UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];
while (t < tend) {
lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);
q = lowbuf;
while (lowlen > 0) {
if (*t++ != *q++) return 0;
lowlen--;
}
}
return 1;
}","static int
str_lower_case_match(OnigEncoding VAR_0, int VAR_1,
const UChar* VAR_2, const UChar* VAR_3,
const UChar* VAR_4, const UChar* VAR_5)
{
int VAR_6;
UChar *VAR_7, VAR_8[VAR_9];
while (VAR_2 < VAR_3) {
VAR_6 = ONIGENC_MBC_CASE_FOLD(VAR_0, VAR_1, &VAR_4, VAR_5, VAR_8);
VAR_7 = VAR_8;
while (VAR_6 > 0) {
if (*VAR_2++ != *VAR_7++) return 0;
VAR_6--;
}
}
return 1;
}",php/php-src/8f949eba8083e34d181c30bcf11aaeef2496bb97/regexec.c/vul/before/0.json,"static int
str_lower_case_match(OnigEncoding enc, int case_fold_flag,
                     const UChar* t, const UChar* tend,
                     const UChar* p, const UChar* end)
{
  int lowlen;
  UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];

  while (t < tend) {
    lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);
    q = lowbuf;
    while (lowlen > 0) {
      if (t >= tend)    return 0;
      if (*t++ != *q++) return 0;
      lowlen--;
    }
  }

  return 1;
}","static int
str_lower_case_match(OnigEncoding VAR_0, int VAR_1,
                     const UChar* VAR_2, const UChar* VAR_3,
                     const UChar* VAR_4, const UChar* VAR_5)
{
  int VAR_6;
  UChar *VAR_7, VAR_8[VAR_9];

  while (VAR_2 < VAR_3) {
    VAR_6 = ONIGENC_MBC_CASE_FOLD(VAR_0, VAR_1, &VAR_4, VAR_5, VAR_8);
    VAR_7 = VAR_8;
    while (VAR_6 > 0) {
      if (VAR_2 >= VAR_3)    return 0;
      if (*VAR_2++ != *VAR_7++) return 0;
      VAR_6--;
    }
  }

  return 1;
}",php/php-src/8f949eba8083e34d181c30bcf11aaeef2496bb97/regexec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,6 +10,7 @@
     lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);
     q = lowbuf;
     while (lowlen > 0) {
+      if (t >= tend)    return 0;
       if (*t++ != *q++) return 0;
       lowlen--;
     }","{'deleted_lines': [], 'added_lines': ['      if (t >= tend)    return 0;']}",True,"Oniguruma through 6.9.3, as used in PHP 7.3.x and other products, has a heap-based buffer over-read in str_lower_case_match in regexec.c.",7.5,HIGH,2,test,2019-09-20T17:02:22Z,3
CVE-2019-19059,['CWE-401'],AV:L/AC:M/Au:N/C:N/I:N/A:C,0,torvalds/linux,"iwlwifi: pcie: fix memory leaks in iwl_pcie_ctxt_info_gen3_init

In iwl_pcie_ctxt_info_gen3_init there are cases that the allocated dma
memory is leaked in case of error.

DMA memories prph_scratch, prph_info, and ctxt_info_gen3 are allocated
and initialized to be later assigned to trans_pcie. But in any error case
before such assignment the allocated memories should be released.

First of such error cases happens when iwl_pcie_init_fw_sec fails.
Current implementation correctly releases prph_scratch. But in two
sunsequent error cases where dma_alloc_coherent may fail, such
releases are missing.

This commit adds release for prph_scratch when allocation for
prph_info fails, and adds releases for prph_scratch and prph_info when
allocation for ctxt_info_gen3 fails.

Fixes: 2ee824026288 (""iwlwifi: pcie: support context information for 22560 devices"")
Signed-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>
Signed-off-by: Luca Coelho <luciano.coelho@intel.com>",0f4f199443faca715523b0659aa536251d8b978f,https://github.com/torvalds/linux/commit/0f4f199443faca715523b0659aa536251d8b978f,drivers/net/wireless/intel/iwlwifi/pcie/ctxt-info-gen3.c,iwl_pcie_ctxt_info_gen3_init,"int iwl_pcie_ctxt_info_gen3_init(struct iwl_trans *trans,
const struct fw_img *fw)
{
struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
struct iwl_context_info_gen3 *ctxt_info_gen3;
struct iwl_prph_scratch *prph_scratch;
struct iwl_prph_scratch_ctrl_cfg *prph_sc_ctrl;
struct iwl_prph_info *prph_info;
void *iml_img;
u32 control_flags = 0;
int ret;
int cmdq_size = max_t(u32, IWL_CMD_QUEUE_SIZE,
trans->cfg->min_txq_size);
prph_scratch = dma_alloc_coherent(trans->dev, sizeof(*prph_scratch),
&trans_pcie->prph_scratch_dma_addr,
GFP_KERNEL);
if (!prph_scratch)
return -ENOMEM;
prph_sc_ctrl = &prph_scratch->ctrl_cfg;
prph_sc_ctrl->version.version = 0;
prph_sc_ctrl->version.mac_id =
cpu_to_le16((u16)iwl_read32(trans, CSR_HW_REV));
prph_sc_ctrl->version.size = cpu_to_le16(sizeof(*prph_scratch) / 4);
control_flags = IWL_PRPH_SCRATCH_RB_SIZE_4K |
IWL_PRPH_SCRATCH_MTR_MODE |
(IWL_PRPH_MTR_FORMAT_256B &
IWL_PRPH_SCRATCH_MTR_FORMAT) |
IWL_PRPH_SCRATCH_EARLY_DEBUG_EN |
IWL_PRPH_SCRATCH_EDBG_DEST_DRAM;
prph_sc_ctrl->control.control_flags = cpu_to_le32(control_flags);
prph_sc_ctrl->rbd_cfg.free_rbd_addr =
cpu_to_le64(trans_pcie->rxq->bd_dma);
if (!iwl_trans_dbg_ini_valid(trans))
iwl_pcie_alloc_fw_monitor(trans, 0);
if (trans->dbg.num_blocks) {
prph_sc_ctrl->hwm_cfg.hwm_base_addr =
cpu_to_le64(trans->dbg.fw_mon[0].physical);
prph_sc_ctrl->hwm_cfg.hwm_size =
cpu_to_le32(trans->dbg.fw_mon[0].size);
}
ret = iwl_pcie_init_fw_sec(trans, fw, &prph_scratch->dram);
if (ret) {
dma_free_coherent(trans->dev,
sizeof(*prph_scratch),
prph_scratch,
trans_pcie->prph_scratch_dma_addr);
return ret;
}
prph_info = dma_alloc_coherent(trans->dev, sizeof(*prph_info),
&trans_pcie->prph_info_dma_addr,
GFP_KERNEL);
if (!prph_info)
return -ENOMEM;
ctxt_info_gen3 = dma_alloc_coherent(trans->dev,
sizeof(*ctxt_info_gen3),
&trans_pcie->ctxt_info_dma_addr,
GFP_KERNEL);
if (!ctxt_info_gen3)
return -ENOMEM;
ctxt_info_gen3->prph_info_base_addr =
cpu_to_le64(trans_pcie->prph_info_dma_addr);
ctxt_info_gen3->prph_scratch_base_addr =
cpu_to_le64(trans_pcie->prph_scratch_dma_addr);
ctxt_info_gen3->prph_scratch_size =
cpu_to_le32(sizeof(*prph_scratch));
ctxt_info_gen3->cr_head_idx_arr_base_addr =
cpu_to_le64(trans_pcie->rxq->rb_stts_dma);
ctxt_info_gen3->tr_tail_idx_arr_base_addr =
cpu_to_le64(trans_pcie->rxq->tr_tail_dma);
ctxt_info_gen3->cr_tail_idx_arr_base_addr =
cpu_to_le64(trans_pcie->rxq->cr_tail_dma);
ctxt_info_gen3->cr_idx_arr_size =
cpu_to_le16(IWL_NUM_OF_COMPLETION_RINGS);
ctxt_info_gen3->tr_idx_arr_size =
cpu_to_le16(IWL_NUM_OF_TRANSFER_RINGS);
ctxt_info_gen3->mtr_base_addr =
cpu_to_le64(trans_pcie->txq[trans_pcie->cmd_queue]->dma_addr);
ctxt_info_gen3->mcr_base_addr =
cpu_to_le64(trans_pcie->rxq->used_bd_dma);
ctxt_info_gen3->mtr_size =
cpu_to_le16(TFD_QUEUE_CB_SIZE(cmdq_size));
ctxt_info_gen3->mcr_size =
cpu_to_le16(RX_QUEUE_CB_SIZE(MQ_RX_TABLE_SIZE));
trans_pcie->ctxt_info_gen3 = ctxt_info_gen3;
trans_pcie->prph_info = prph_info;
trans_pcie->prph_scratch = prph_scratch;
iml_img = dma_alloc_coherent(trans->dev, trans->iml_len,
&trans_pcie->iml_dma_addr, GFP_KERNEL);
if (!iml_img)
return -ENOMEM;
memcpy(iml_img, trans->iml, trans->iml_len);
iwl_enable_fw_load_int_ctx_info(trans);
iwl_write64(trans, CSR_CTXT_INFO_ADDR,
trans_pcie->ctxt_info_dma_addr);
iwl_write64(trans, CSR_IML_DATA_ADDR,
trans_pcie->iml_dma_addr);
iwl_write32(trans, CSR_IML_SIZE_ADDR, trans->iml_len);
iwl_set_bit(trans, CSR_CTXT_INFO_BOOT_CTRL,
CSR_AUTO_FUNC_BOOT_ENA);
if (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210)
iwl_write_umac_prph(trans, UREG_CPU_INIT_RUN, 1);
else
iwl_set_bit(trans, CSR_GP_CNTRL, CSR_AUTO_FUNC_INIT);
return 0;
}","int iwl_pcie_ctxt_info_gen3_init(struct iwl_trans *VAR_0,
const struct fw_img *VAR_1)
{
struct iwl_trans_pcie *VAR_2 = IWL_TRANS_GET_PCIE_TRANS(VAR_0);
struct iwl_context_info_gen3 *VAR_3;
struct iwl_prph_scratch *VAR_4;
struct iwl_prph_scratch_ctrl_cfg *VAR_5;
struct iwl_prph_info *VAR_6;
void *VAR_7;
u32 VAR_8 = 0;
int VAR_9;
int VAR_10 = max_t(u32, VAR_11,
VAR_0->cfg->min_txq_size);
VAR_4 = dma_alloc_coherent(VAR_0->dev, sizeof(*VAR_4),
&VAR_2->prph_scratch_dma_addr,
VAR_12);
if (!VAR_4)
return -VAR_13;
VAR_5 = &VAR_4->ctrl_cfg;
VAR_5->version.version = 0;
VAR_5->version.mac_id =
cpu_to_le16((u16)iwl_read32(VAR_0, VAR_14));
VAR_5->version.size = cpu_to_le16(sizeof(*VAR_4) / 4);
VAR_8 = VAR_15 |
VAR_16 |
(VAR_17 &
VAR_18) |
VAR_19 |
VAR_20;
VAR_5->control.control_flags = cpu_to_le32(VAR_8);
VAR_5->rbd_cfg.free_rbd_addr =
cpu_to_le64(VAR_2->rxq->bd_dma);
if (!iwl_trans_dbg_ini_valid(VAR_0))
iwl_pcie_alloc_fw_monitor(VAR_0, 0);
if (VAR_0->dbg.num_blocks) {
VAR_5->hwm_cfg.hwm_base_addr =
cpu_to_le64(VAR_0->dbg.fw_mon[0].physical);
VAR_5->hwm_cfg.hwm_size =
cpu_to_le32(VAR_0->dbg.fw_mon[0].size);
}
VAR_9 = iwl_pcie_init_fw_sec(VAR_0, VAR_1, &VAR_4->dram);
if (VAR_9) {
dma_free_coherent(VAR_0->dev,
sizeof(*VAR_4),
VAR_4,
VAR_2->prph_scratch_dma_addr);
return VAR_9;
}
VAR_6 = dma_alloc_coherent(VAR_0->dev, sizeof(*VAR_6),
&VAR_2->prph_info_dma_addr,
VAR_12);
if (!VAR_6)
return -VAR_13;
VAR_3 = dma_alloc_coherent(VAR_0->dev,
sizeof(*VAR_3),
&VAR_2->ctxt_info_dma_addr,
VAR_12);
if (!VAR_3)
return -VAR_13;
VAR_3->prph_info_base_addr =
cpu_to_le64(VAR_2->prph_info_dma_addr);
VAR_3->prph_scratch_base_addr =
cpu_to_le64(VAR_2->prph_scratch_dma_addr);
VAR_3->prph_scratch_size =
cpu_to_le32(sizeof(*VAR_4));
VAR_3->cr_head_idx_arr_base_addr =
cpu_to_le64(VAR_2->rxq->rb_stts_dma);
VAR_3->tr_tail_idx_arr_base_addr =
cpu_to_le64(VAR_2->rxq->tr_tail_dma);
VAR_3->cr_tail_idx_arr_base_addr =
cpu_to_le64(VAR_2->rxq->cr_tail_dma);
VAR_3->cr_idx_arr_size =
cpu_to_le16(VAR_21);
VAR_3->tr_idx_arr_size =
cpu_to_le16(VAR_22);
VAR_3->mtr_base_addr =
cpu_to_le64(VAR_2->txq[VAR_2->cmd_queue]->dma_addr);
VAR_3->mcr_base_addr =
cpu_to_le64(VAR_2->rxq->used_bd_dma);
VAR_3->mtr_size =
cpu_to_le16(TFD_QUEUE_CB_SIZE(VAR_10));
VAR_3->mcr_size =
cpu_to_le16(RX_QUEUE_CB_SIZE(VAR_23));
VAR_2->ctxt_info_gen3 = VAR_3;
VAR_2->prph_info = VAR_6;
VAR_2->prph_scratch = VAR_4;
VAR_7 = dma_alloc_coherent(VAR_0->dev, VAR_0->iml_len,
&VAR_2->iml_dma_addr, VAR_12);
if (!VAR_7)
return -VAR_13;
memcpy(VAR_7, VAR_0->iml, VAR_0->iml_len);
iwl_enable_fw_load_int_ctx_info(VAR_0);
iwl_write64(VAR_0, VAR_24,
VAR_2->ctxt_info_dma_addr);
iwl_write64(VAR_0, VAR_25,
VAR_2->iml_dma_addr);
iwl_write32(VAR_0, VAR_26, VAR_0->iml_len);
iwl_set_bit(VAR_0, VAR_27,
VAR_28);
if (VAR_0->trans_cfg->device_family >= VAR_29)
iwl_write_umac_prph(VAR_0, VAR_30, 1);
else
iwl_set_bit(VAR_0, VAR_31, VAR_32);
return 0;
}",torvalds/linux/0f4f199443faca715523b0659aa536251d8b978f/ctxt-info-gen3.c/vul/before/0.json,"int iwl_pcie_ctxt_info_gen3_init(struct iwl_trans *trans,
				 const struct fw_img *fw)
{
	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
	struct iwl_context_info_gen3 *ctxt_info_gen3;
	struct iwl_prph_scratch *prph_scratch;
	struct iwl_prph_scratch_ctrl_cfg *prph_sc_ctrl;
	struct iwl_prph_info *prph_info;
	void *iml_img;
	u32 control_flags = 0;
	int ret;
	int cmdq_size = max_t(u32, IWL_CMD_QUEUE_SIZE,
			      trans->cfg->min_txq_size);

	/* Allocate prph scratch */
	prph_scratch = dma_alloc_coherent(trans->dev, sizeof(*prph_scratch),
					  &trans_pcie->prph_scratch_dma_addr,
					  GFP_KERNEL);
	if (!prph_scratch)
		return -ENOMEM;

	prph_sc_ctrl = &prph_scratch->ctrl_cfg;

	prph_sc_ctrl->version.version = 0;
	prph_sc_ctrl->version.mac_id =
		cpu_to_le16((u16)iwl_read32(trans, CSR_HW_REV));
	prph_sc_ctrl->version.size = cpu_to_le16(sizeof(*prph_scratch) / 4);

	control_flags = IWL_PRPH_SCRATCH_RB_SIZE_4K |
			IWL_PRPH_SCRATCH_MTR_MODE |
			(IWL_PRPH_MTR_FORMAT_256B &
			 IWL_PRPH_SCRATCH_MTR_FORMAT) |
			IWL_PRPH_SCRATCH_EARLY_DEBUG_EN |
			IWL_PRPH_SCRATCH_EDBG_DEST_DRAM;
	prph_sc_ctrl->control.control_flags = cpu_to_le32(control_flags);

	/* initialize RX default queue */
	prph_sc_ctrl->rbd_cfg.free_rbd_addr =
		cpu_to_le64(trans_pcie->rxq->bd_dma);

	/* Configure debug, for integration */
	if (!iwl_trans_dbg_ini_valid(trans))
		iwl_pcie_alloc_fw_monitor(trans, 0);
	if (trans->dbg.num_blocks) {
		prph_sc_ctrl->hwm_cfg.hwm_base_addr =
			cpu_to_le64(trans->dbg.fw_mon[0].physical);
		prph_sc_ctrl->hwm_cfg.hwm_size =
			cpu_to_le32(trans->dbg.fw_mon[0].size);
	}

	/* allocate ucode sections in dram and set addresses */
	ret = iwl_pcie_init_fw_sec(trans, fw, &prph_scratch->dram);
	if (ret)
		goto err_free_prph_scratch;


	/* Allocate prph information
	 * currently we don't assign to the prph info anything, but it would get
	 * assigned later */
	prph_info = dma_alloc_coherent(trans->dev, sizeof(*prph_info),
				       &trans_pcie->prph_info_dma_addr,
				       GFP_KERNEL);
	if (!prph_info) {
		ret = -ENOMEM;
		goto err_free_prph_scratch;
	}

	/* Allocate context info */
	ctxt_info_gen3 = dma_alloc_coherent(trans->dev,
					    sizeof(*ctxt_info_gen3),
					    &trans_pcie->ctxt_info_dma_addr,
					    GFP_KERNEL);
	if (!ctxt_info_gen3) {
		ret = -ENOMEM;
		goto err_free_prph_info;
	}

	ctxt_info_gen3->prph_info_base_addr =
		cpu_to_le64(trans_pcie->prph_info_dma_addr);
	ctxt_info_gen3->prph_scratch_base_addr =
		cpu_to_le64(trans_pcie->prph_scratch_dma_addr);
	ctxt_info_gen3->prph_scratch_size =
		cpu_to_le32(sizeof(*prph_scratch));
	ctxt_info_gen3->cr_head_idx_arr_base_addr =
		cpu_to_le64(trans_pcie->rxq->rb_stts_dma);
	ctxt_info_gen3->tr_tail_idx_arr_base_addr =
		cpu_to_le64(trans_pcie->rxq->tr_tail_dma);
	ctxt_info_gen3->cr_tail_idx_arr_base_addr =
		cpu_to_le64(trans_pcie->rxq->cr_tail_dma);
	ctxt_info_gen3->cr_idx_arr_size =
		cpu_to_le16(IWL_NUM_OF_COMPLETION_RINGS);
	ctxt_info_gen3->tr_idx_arr_size =
		cpu_to_le16(IWL_NUM_OF_TRANSFER_RINGS);
	ctxt_info_gen3->mtr_base_addr =
		cpu_to_le64(trans_pcie->txq[trans_pcie->cmd_queue]->dma_addr);
	ctxt_info_gen3->mcr_base_addr =
		cpu_to_le64(trans_pcie->rxq->used_bd_dma);
	ctxt_info_gen3->mtr_size =
		cpu_to_le16(TFD_QUEUE_CB_SIZE(cmdq_size));
	ctxt_info_gen3->mcr_size =
		cpu_to_le16(RX_QUEUE_CB_SIZE(MQ_RX_TABLE_SIZE));

	trans_pcie->ctxt_info_gen3 = ctxt_info_gen3;
	trans_pcie->prph_info = prph_info;
	trans_pcie->prph_scratch = prph_scratch;

	/* Allocate IML */
	iml_img = dma_alloc_coherent(trans->dev, trans->iml_len,
				     &trans_pcie->iml_dma_addr, GFP_KERNEL);
	if (!iml_img)
		return -ENOMEM;

	memcpy(iml_img, trans->iml, trans->iml_len);

	iwl_enable_fw_load_int_ctx_info(trans);

	/* kick FW self load */
	iwl_write64(trans, CSR_CTXT_INFO_ADDR,
		    trans_pcie->ctxt_info_dma_addr);
	iwl_write64(trans, CSR_IML_DATA_ADDR,
		    trans_pcie->iml_dma_addr);
	iwl_write32(trans, CSR_IML_SIZE_ADDR, trans->iml_len);

	iwl_set_bit(trans, CSR_CTXT_INFO_BOOT_CTRL,
		    CSR_AUTO_FUNC_BOOT_ENA);
	if (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210)
		iwl_write_umac_prph(trans, UREG_CPU_INIT_RUN, 1);
	else
		iwl_set_bit(trans, CSR_GP_CNTRL, CSR_AUTO_FUNC_INIT);

	return 0;

err_free_prph_info:
	dma_free_coherent(trans->dev,
			  sizeof(*prph_info),
			prph_info,
			trans_pcie->prph_info_dma_addr);

err_free_prph_scratch:
	dma_free_coherent(trans->dev,
			  sizeof(*prph_scratch),
			prph_scratch,
			trans_pcie->prph_scratch_dma_addr);
	return ret;

}","int iwl_pcie_ctxt_info_gen3_init(struct iwl_trans *VAR_0,
				 const struct fw_img *VAR_1)
{
	struct iwl_trans_pcie *VAR_2 = IWL_TRANS_GET_PCIE_TRANS(VAR_0);
	struct iwl_context_info_gen3 *VAR_3;
	struct iwl_prph_scratch *VAR_4;
	struct iwl_prph_scratch_ctrl_cfg *VAR_5;
	struct iwl_prph_info *VAR_6;
	void *VAR_7;
	u32 VAR_8 = 0;
	int VAR_9;
	int VAR_10 = max_t(u32, VAR_11,
			      VAR_0->cfg->min_txq_size);

	/* COMMENT_0 */
	VAR_4 = dma_alloc_coherent(VAR_0->dev, sizeof(*VAR_4),
					  &VAR_2->prph_scratch_dma_addr,
					  VAR_12);
	if (!VAR_4)
		return -VAR_13;

	VAR_5 = &VAR_4->ctrl_cfg;

	VAR_5->version.version = 0;
	VAR_5->version.mac_id =
		cpu_to_le16((u16)iwl_read32(VAR_0, VAR_14));
	VAR_5->version.size = cpu_to_le16(sizeof(*VAR_4) / 4);

	VAR_8 = VAR_15 |
			VAR_16 |
			(VAR_17 &
			 VAR_18) |
			VAR_19 |
			VAR_20;
	VAR_5->control.control_flags = cpu_to_le32(VAR_8);

	/* COMMENT_1 */
	VAR_5->rbd_cfg.free_rbd_addr =
		cpu_to_le64(VAR_2->rxq->bd_dma);

	/* COMMENT_2 */
	if (!iwl_trans_dbg_ini_valid(VAR_0))
		iwl_pcie_alloc_fw_monitor(VAR_0, 0);
	if (VAR_0->dbg.num_blocks) {
		VAR_5->hwm_cfg.hwm_base_addr =
			cpu_to_le64(VAR_0->dbg.fw_mon[0].physical);
		VAR_5->hwm_cfg.hwm_size =
			cpu_to_le32(VAR_0->dbg.fw_mon[0].size);
	}

	/* COMMENT_3 */
	VAR_9 = iwl_pcie_init_fw_sec(VAR_0, VAR_1, &VAR_4->dram);
	if (VAR_9)
		goto err_free_prph_scratch;


	/* COMMENT_4 */
                                                                         
                     
	VAR_6 = dma_alloc_coherent(VAR_0->dev, sizeof(*VAR_6),
				       &VAR_2->prph_info_dma_addr,
				       VAR_12);
	if (!VAR_6) {
		VAR_9 = -VAR_13;
		goto err_free_prph_scratch;
	}

	/* COMMENT_7 */
	VAR_3 = dma_alloc_coherent(VAR_0->dev,
					    sizeof(*VAR_3),
					    &VAR_2->ctxt_info_dma_addr,
					    VAR_12);
	if (!VAR_3) {
		VAR_9 = -VAR_13;
		goto err_free_prph_info;
	}

	VAR_3->prph_info_base_addr =
		cpu_to_le64(VAR_2->prph_info_dma_addr);
	VAR_3->prph_scratch_base_addr =
		cpu_to_le64(VAR_2->prph_scratch_dma_addr);
	VAR_3->prph_scratch_size =
		cpu_to_le32(sizeof(*VAR_4));
	VAR_3->cr_head_idx_arr_base_addr =
		cpu_to_le64(VAR_2->rxq->rb_stts_dma);
	VAR_3->tr_tail_idx_arr_base_addr =
		cpu_to_le64(VAR_2->rxq->tr_tail_dma);
	VAR_3->cr_tail_idx_arr_base_addr =
		cpu_to_le64(VAR_2->rxq->cr_tail_dma);
	VAR_3->cr_idx_arr_size =
		cpu_to_le16(VAR_21);
	VAR_3->tr_idx_arr_size =
		cpu_to_le16(VAR_22);
	VAR_3->mtr_base_addr =
		cpu_to_le64(VAR_2->txq[VAR_2->cmd_queue]->dma_addr);
	VAR_3->mcr_base_addr =
		cpu_to_le64(VAR_2->rxq->used_bd_dma);
	VAR_3->mtr_size =
		cpu_to_le16(TFD_QUEUE_CB_SIZE(VAR_10));
	VAR_3->mcr_size =
		cpu_to_le16(RX_QUEUE_CB_SIZE(VAR_23));

	VAR_2->ctxt_info_gen3 = VAR_3;
	VAR_2->prph_info = VAR_6;
	VAR_2->prph_scratch = VAR_4;

	/* COMMENT_8 */
	VAR_7 = dma_alloc_coherent(VAR_0->dev, VAR_0->iml_len,
				     &VAR_2->iml_dma_addr, VAR_12);
	if (!VAR_7)
		return -VAR_13;

	memcpy(VAR_7, VAR_0->iml, VAR_0->iml_len);

	iwl_enable_fw_load_int_ctx_info(VAR_0);

	/* COMMENT_9 */
	iwl_write64(VAR_0, VAR_24,
		    VAR_2->ctxt_info_dma_addr);
	iwl_write64(VAR_0, VAR_25,
		    VAR_2->iml_dma_addr);
	iwl_write32(VAR_0, VAR_26, VAR_0->iml_len);

	iwl_set_bit(VAR_0, VAR_27,
		    VAR_28);
	if (VAR_0->trans_cfg->device_family >= VAR_29)
		iwl_write_umac_prph(VAR_0, VAR_30, 1);
	else
		iwl_set_bit(VAR_0, VAR_31, VAR_32);

	return 0;

err_free_prph_info:
	dma_free_coherent(VAR_0->dev,
			  sizeof(*VAR_6),
			VAR_6,
			VAR_2->prph_info_dma_addr);

err_free_prph_scratch:
	dma_free_coherent(VAR_0->dev,
			  sizeof(*VAR_4),
			VAR_4,
			VAR_2->prph_scratch_dma_addr);
	return VAR_9;

}",torvalds/linux/0f4f199443faca715523b0659aa536251d8b978f/ctxt-info-gen3.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -50,13 +50,9 @@
 
 	/* allocate ucode sections in dram and set addresses */
 	ret = iwl_pcie_init_fw_sec(trans, fw, &prph_scratch->dram);
-	if (ret) {
-		dma_free_coherent(trans->dev,
-				  sizeof(*prph_scratch),
-				  prph_scratch,
-				  trans_pcie->prph_scratch_dma_addr);
-		return ret;
-	}
+	if (ret)
+		goto err_free_prph_scratch;
+
 
 	/* Allocate prph information
 	 * currently we don't assign to the prph info anything, but it would get
@@ -64,16 +60,20 @@
 	prph_info = dma_alloc_coherent(trans->dev, sizeof(*prph_info),
 				       &trans_pcie->prph_info_dma_addr,
 				       GFP_KERNEL);
-	if (!prph_info)
-		return -ENOMEM;
+	if (!prph_info) {
+		ret = -ENOMEM;
+		goto err_free_prph_scratch;
+	}
 
 	/* Allocate context info */
 	ctxt_info_gen3 = dma_alloc_coherent(trans->dev,
 					    sizeof(*ctxt_info_gen3),
 					    &trans_pcie->ctxt_info_dma_addr,
 					    GFP_KERNEL);
-	if (!ctxt_info_gen3)
-		return -ENOMEM;
+	if (!ctxt_info_gen3) {
+		ret = -ENOMEM;
+		goto err_free_prph_info;
+	}
 
 	ctxt_info_gen3->prph_info_base_addr =
 		cpu_to_le64(trans_pcie->prph_info_dma_addr);
@@ -129,4 +129,18 @@
 		iwl_set_bit(trans, CSR_GP_CNTRL, CSR_AUTO_FUNC_INIT);
 
 	return 0;
+
+err_free_prph_info:
+	dma_free_coherent(trans->dev,
+			  sizeof(*prph_info),
+			prph_info,
+			trans_pcie->prph_info_dma_addr);
+
+err_free_prph_scratch:
+	dma_free_coherent(trans->dev,
+			  sizeof(*prph_scratch),
+			prph_scratch,
+			trans_pcie->prph_scratch_dma_addr);
+	return ret;
+
 }","{'deleted_lines': ['\tif (ret) {', '\t\tdma_free_coherent(trans->dev,', '\t\t\t\t  sizeof(*prph_scratch),', '\t\t\t\t  prph_scratch,', '\t\t\t\t  trans_pcie->prph_scratch_dma_addr);', '\t\treturn ret;', '\t}', '\tif (!prph_info)', '\t\treturn -ENOMEM;', '\tif (!ctxt_info_gen3)', '\t\treturn -ENOMEM;'], 'added_lines': ['\tif (ret)', '\t\tgoto err_free_prph_scratch;', '', '\tif (!prph_info) {', '\t\tret = -ENOMEM;', '\t\tgoto err_free_prph_scratch;', '\t}', '\tif (!ctxt_info_gen3) {', '\t\tret = -ENOMEM;', '\t\tgoto err_free_prph_info;', '\t}', '', 'err_free_prph_info:', '\tdma_free_coherent(trans->dev,', '\t\t\t  sizeof(*prph_info),', '\t\t\tprph_info,', '\t\t\ttrans_pcie->prph_info_dma_addr);', '', 'err_free_prph_scratch:', '\tdma_free_coherent(trans->dev,', '\t\t\t  sizeof(*prph_scratch),', '\t\t\tprph_scratch,', '\t\t\ttrans_pcie->prph_scratch_dma_addr);', '\treturn ret;', '']}",True,"Multiple memory leaks in the iwl_pcie_ctxt_info_gen3_init() function in drivers/net/wireless/intel/iwlwifi/pcie/ctxt-info-gen3.c in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption) by triggering iwl_pcie_init_fw_sec() or dma_alloc_coherent() failures, aka CID-0f4f199443fa.",4.7,MEDIUM,1,test,2019-09-27T20:56:04Z,3
CVE-2019-19067,['CWE-401'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"drm/amdgpu: fix multiple memory leaks in acp_hw_init

In acp_hw_init there are some allocations that needs to be released in
case of failure:

1- adev->acp.acp_genpd should be released if any allocation attemp for
adev->acp.acp_cell, adev->acp.acp_res or i2s_pdata fails.
2- all of those allocations should be released if
mfd_add_hotplug_devices or pm_genpd_add_device fail.
3- Release is needed in case of time out values expire.

Reviewed-by: Christian König <christian.koenig@amd.com>
Signed-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>",57be09c6e8747bf48704136d9e3f92bfb93f5725,https://github.com/torvalds/linux/commit/57be09c6e8747bf48704136d9e3f92bfb93f5725,drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c,acp_hw_init,"static int acp_hw_init(void *handle)
{
int r, i;
uint64_t acp_base;
u32 val = 0;
u32 count = 0;
struct device *dev;
struct i2s_platform_data *i2s_pdata;
struct amdgpu_device *adev = (struct amdgpu_device *)handle;
const struct amdgpu_ip_block *ip_block =
amdgpu_device_ip_get_ip_block(adev, AMD_IP_BLOCK_TYPE_ACP);
if (!ip_block)
return -EINVAL;
r = amd_acp_hw_init(adev->acp.cgs_device,
ip_block->version->major, ip_block->version->minor);
if (r == -ENODEV) {
amdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, true);
return 0;
} else if (r) {
return r;
}
if (adev->rmmio_size == 0 || adev->rmmio_size < 0x5289)
return -EINVAL;
acp_base = adev->rmmio_base;
adev->acp.acp_genpd = kzalloc(sizeof(struct acp_pm_domain), GFP_KERNEL);
if (adev->acp.acp_genpd == NULL)
return -ENOMEM;
adev->acp.acp_genpd->gpd.name = ""ACP_AUDIO"";
adev->acp.acp_genpd->gpd.power_off = acp_poweroff;
adev->acp.acp_genpd->gpd.power_on = acp_poweron;
adev->acp.acp_genpd->adev = adev;
pm_genpd_init(&adev->acp.acp_genpd->gpd, NULL, false);
adev->acp.acp_cell = kcalloc(ACP_DEVS, sizeof(struct mfd_cell),
GFP_KERNEL);
if (adev->acp.acp_cell == NULL)
return -ENOMEM;
adev->acp.acp_res = kcalloc(5, sizeof(struct resource), GFP_KERNEL);
if (adev->acp.acp_res == NULL) {
kfree(adev->acp.acp_cell);
return -ENOMEM;
}
i2s_pdata = kcalloc(3, sizeof(struct i2s_platform_data), GFP_KERNEL);
if (i2s_pdata == NULL) {
kfree(adev->acp.acp_res);
kfree(adev->acp.acp_cell);
return -ENOMEM;
}
switch (adev->asic_type) {
case CHIP_STONEY:
i2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |
DW_I2S_QUIRK_16BIT_IDX_OVERRIDE;
break;
default:
i2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET;
}
i2s_pdata[0].cap = DWC_I2S_PLAY;
i2s_pdata[0].snd_rates = SNDRV_PCM_RATE_8000_96000;
i2s_pdata[0].i2s_reg_comp1 = ACP_I2S_COMP1_PLAY_REG_OFFSET;
i2s_pdata[0].i2s_reg_comp2 = ACP_I2S_COMP2_PLAY_REG_OFFSET;
switch (adev->asic_type) {
case CHIP_STONEY:
i2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |
DW_I2S_QUIRK_COMP_PARAM1 |
DW_I2S_QUIRK_16BIT_IDX_OVERRIDE;
break;
default:
i2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |
DW_I2S_QUIRK_COMP_PARAM1;
}
i2s_pdata[1].cap = DWC_I2S_RECORD;
i2s_pdata[1].snd_rates = SNDRV_PCM_RATE_8000_96000;
i2s_pdata[1].i2s_reg_comp1 = ACP_I2S_COMP1_CAP_REG_OFFSET;
i2s_pdata[1].i2s_reg_comp2 = ACP_I2S_COMP2_CAP_REG_OFFSET;
i2s_pdata[2].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET;
switch (adev->asic_type) {
case CHIP_STONEY:
i2s_pdata[2].quirks |= DW_I2S_QUIRK_16BIT_IDX_OVERRIDE;
break;
default:
break;
}
i2s_pdata[2].cap = DWC_I2S_PLAY | DWC_I2S_RECORD;
i2s_pdata[2].snd_rates = SNDRV_PCM_RATE_8000_96000;
i2s_pdata[2].i2s_reg_comp1 = ACP_BT_COMP1_REG_OFFSET;
i2s_pdata[2].i2s_reg_comp2 = ACP_BT_COMP2_REG_OFFSET;
adev->acp.acp_res[0].name = ""acp2x_dma"";
adev->acp.acp_res[0].flags = IORESOURCE_MEM;
adev->acp.acp_res[0].start = acp_base;
adev->acp.acp_res[0].end = acp_base + ACP_DMA_REGS_END;
adev->acp.acp_res[1].name = ""acp2x_dw_i2s_play"";
adev->acp.acp_res[1].flags = IORESOURCE_MEM;
adev->acp.acp_res[1].start = acp_base + ACP_I2S_PLAY_REGS_START;
adev->acp.acp_res[1].end = acp_base + ACP_I2S_PLAY_REGS_END;
adev->acp.acp_res[2].name = ""acp2x_dw_i2s_cap"";
adev->acp.acp_res[2].flags = IORESOURCE_MEM;
adev->acp.acp_res[2].start = acp_base + ACP_I2S_CAP_REGS_START;
adev->acp.acp_res[2].end = acp_base + ACP_I2S_CAP_REGS_END;
adev->acp.acp_res[3].name = ""acp2x_dw_bt_i2s_play_cap"";
adev->acp.acp_res[3].flags = IORESOURCE_MEM;
adev->acp.acp_res[3].start = acp_base + ACP_BT_PLAY_REGS_START;
adev->acp.acp_res[3].end = acp_base + ACP_BT_PLAY_REGS_END;
adev->acp.acp_res[4].name = ""acp2x_dma_irq"";
adev->acp.acp_res[4].flags = IORESOURCE_IRQ;
adev->acp.acp_res[4].start = amdgpu_irq_create_mapping(adev, 162);
adev->acp.acp_res[4].end = adev->acp.acp_res[4].start;
adev->acp.acp_cell[0].name = ""acp_audio_dma"";
adev->acp.acp_cell[0].num_resources = 5;
adev->acp.acp_cell[0].resources = &adev->acp.acp_res[0];
adev->acp.acp_cell[0].platform_data = &adev->asic_type;
adev->acp.acp_cell[0].pdata_size = sizeof(adev->asic_type);
adev->acp.acp_cell[1].name = ""designware-i2s"";
adev->acp.acp_cell[1].num_resources = 1;
adev->acp.acp_cell[1].resources = &adev->acp.acp_res[1];
adev->acp.acp_cell[1].platform_data = &i2s_pdata[0];
adev->acp.acp_cell[1].pdata_size = sizeof(struct i2s_platform_data);
adev->acp.acp_cell[2].name = ""designware-i2s"";
adev->acp.acp_cell[2].num_resources = 1;
adev->acp.acp_cell[2].resources = &adev->acp.acp_res[2];
adev->acp.acp_cell[2].platform_data = &i2s_pdata[1];
adev->acp.acp_cell[2].pdata_size = sizeof(struct i2s_platform_data);
adev->acp.acp_cell[3].name = ""designware-i2s"";
adev->acp.acp_cell[3].num_resources = 1;
adev->acp.acp_cell[3].resources = &adev->acp.acp_res[3];
adev->acp.acp_cell[3].platform_data = &i2s_pdata[2];
adev->acp.acp_cell[3].pdata_size = sizeof(struct i2s_platform_data);
r = mfd_add_hotplug_devices(adev->acp.parent, adev->acp.acp_cell,
ACP_DEVS);
if (r)
return r;
for (i = 0; i < ACP_DEVS ; i++) {
dev = get_mfd_cell_dev(adev->acp.acp_cell[i].name, i);
r = pm_genpd_add_device(&adev->acp.acp_genpd->gpd, dev);
if (r) {
dev_err(dev, ""Failed to add dev to genpd\n"");
return r;
}
}
val = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);
val |= ACP_SOFT_RESET__SoftResetAud_MASK;
cgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);
count = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;
while (true) {
val = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);
if (ACP_SOFT_RESET__SoftResetAudDone_MASK ==
(val & ACP_SOFT_RESET__SoftResetAudDone_MASK))
break;
if (--count == 0) {
dev_err(&adev->pdev->dev, ""Failed to reset ACP\n"");
return -ETIMEDOUT;
}
udelay(100);
}
val = cgs_read_register(adev->acp.cgs_device, mmACP_CONTROL);
val = val | ACP_CONTROL__ClkEn_MASK;
cgs_write_register(adev->acp.cgs_device, mmACP_CONTROL, val);
count = ACP_CLOCK_EN_TIME_OUT_VALUE;
while (true) {
val = cgs_read_register(adev->acp.cgs_device, mmACP_STATUS);
if (val & (u32) 0x1)
break;
if (--count == 0) {
dev_err(&adev->pdev->dev, ""Failed to reset ACP\n"");
return -ETIMEDOUT;
}
udelay(100);
}
val = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);
val &= ~ACP_SOFT_RESET__SoftResetAud_MASK;
cgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);
return 0;
}","static int acp_hw_init(void *VAR_0)
{
int VAR_1, VAR_2;
uint64_t VAR_3;
u32 VAR_4 = 0;
u32 VAR_5 = 0;
struct device *VAR_6;
struct i2s_platform_data *VAR_7;
struct amdgpu_device *VAR_8 = (struct amdgpu_device *)VAR_0;
const struct amdgpu_ip_block *VAR_9 =
amdgpu_device_ip_get_ip_block(VAR_8, VAR_10);
if (!VAR_9)
return -VAR_11;
VAR_1 = amd_acp_hw_init(VAR_8->acp.cgs_device,
VAR_9->version->major, VAR_9->version->minor);
if (VAR_1 == -VAR_12) {
amdgpu_dpm_set_powergating_by_smu(VAR_8, VAR_10, true);
return 0;
} else if (VAR_1) {
return VAR_1;
}
if (VAR_8->rmmio_size == 0 || VAR_8->rmmio_size < 0x5289)
return -VAR_11;
VAR_3 = VAR_8->rmmio_base;
VAR_8->acp.acp_genpd = kzalloc(sizeof(struct acp_pm_domain), VAR_13);
if (VAR_8->acp.acp_genpd == NULL)
return -VAR_14;
VAR_8->acp.acp_genpd->gpd.name = ""ACP_AUDIO"";
VAR_8->acp.acp_genpd->gpd.power_off = VAR_15;
VAR_8->acp.acp_genpd->gpd.power_on = VAR_16;
VAR_8->acp.acp_genpd->adev = VAR_8;
pm_genpd_init(&VAR_8->acp.acp_genpd->gpd, NULL, false);
VAR_8->acp.acp_cell = kcalloc(VAR_17, sizeof(struct mfd_cell),
VAR_13);
if (VAR_8->acp.acp_cell == NULL)
return -VAR_14;
VAR_8->acp.acp_res = kcalloc(5, sizeof(struct resource), VAR_13);
if (VAR_8->acp.acp_res == NULL) {
kfree(VAR_8->acp.acp_cell);
return -VAR_14;
}
VAR_7 = kcalloc(3, sizeof(struct i2s_platform_data), VAR_13);
if (VAR_7 == NULL) {
kfree(VAR_8->acp.acp_res);
kfree(VAR_8->acp.acp_cell);
return -VAR_14;
}
switch (VAR_8->asic_type) {
case VAR_18:
VAR_7[0].quirks = VAR_19 |
VAR_20;
break;
default:
VAR_7[0].quirks = VAR_19;
}
VAR_7[0].cap = VAR_21;
VAR_7[0].snd_rates = VAR_22;
VAR_7[0].i2s_reg_comp1 = VAR_23;
VAR_7[0].i2s_reg_comp2 = VAR_24;
switch (VAR_8->asic_type) {
case VAR_18:
VAR_7[1].quirks = VAR_19 |
VAR_25 |
VAR_20;
break;
default:
VAR_7[1].quirks = VAR_19 |
VAR_25;
}
VAR_7[1].cap = VAR_26;
VAR_7[1].snd_rates = VAR_22;
VAR_7[1].i2s_reg_comp1 = VAR_27;
VAR_7[1].i2s_reg_comp2 = VAR_28;
VAR_7[2].quirks = VAR_19;
switch (VAR_8->asic_type) {
case VAR_18:
VAR_7[2].quirks |= VAR_20;
break;
default:
break;
}
VAR_7[2].cap = VAR_21 | VAR_26;
VAR_7[2].snd_rates = VAR_22;
VAR_7[2].i2s_reg_comp1 = VAR_29;
VAR_7[2].i2s_reg_comp2 = VAR_30;
VAR_8->acp.acp_res[0].name = ""acp2x_dma"";
VAR_8->acp.acp_res[0].flags = VAR_31;
VAR_8->acp.acp_res[0].start = VAR_3;
VAR_8->acp.acp_res[0].end = VAR_3 + VAR_32;
VAR_8->acp.acp_res[1].name = ""acp2x_dw_i2s_play"";
VAR_8->acp.acp_res[1].flags = VAR_31;
VAR_8->acp.acp_res[1].start = VAR_3 + VAR_33;
VAR_8->acp.acp_res[1].end = VAR_3 + VAR_34;
VAR_8->acp.acp_res[2].name = ""acp2x_dw_i2s_cap"";
VAR_8->acp.acp_res[2].flags = VAR_31;
VAR_8->acp.acp_res[2].start = VAR_3 + VAR_35;
VAR_8->acp.acp_res[2].end = VAR_3 + VAR_36;
VAR_8->acp.acp_res[3].name = ""acp2x_dw_bt_i2s_play_cap"";
VAR_8->acp.acp_res[3].flags = VAR_31;
VAR_8->acp.acp_res[3].start = VAR_3 + VAR_37;
VAR_8->acp.acp_res[3].end = VAR_3 + VAR_38;
VAR_8->acp.acp_res[4].name = ""acp2x_dma_irq"";
VAR_8->acp.acp_res[4].flags = VAR_39;
VAR_8->acp.acp_res[4].start = amdgpu_irq_create_mapping(VAR_8, 162);
VAR_8->acp.acp_res[4].end = VAR_8->acp.acp_res[4].start;
VAR_8->acp.acp_cell[0].name = ""acp_audio_dma"";
VAR_8->acp.acp_cell[0].num_resources = 5;
VAR_8->acp.acp_cell[0].resources = &VAR_8->acp.acp_res[0];
VAR_8->acp.acp_cell[0].platform_data = &VAR_8->asic_type;
VAR_8->acp.acp_cell[0].pdata_size = sizeof(VAR_8->asic_type);
VAR_8->acp.acp_cell[1].name = ""designware-i2s"";
VAR_8->acp.acp_cell[1].num_resources = 1;
VAR_8->acp.acp_cell[1].resources = &VAR_8->acp.acp_res[1];
VAR_8->acp.acp_cell[1].platform_data = &VAR_7[0];
VAR_8->acp.acp_cell[1].pdata_size = sizeof(struct i2s_platform_data);
VAR_8->acp.acp_cell[2].name = ""designware-i2s"";
VAR_8->acp.acp_cell[2].num_resources = 1;
VAR_8->acp.acp_cell[2].resources = &VAR_8->acp.acp_res[2];
VAR_8->acp.acp_cell[2].platform_data = &VAR_7[1];
VAR_8->acp.acp_cell[2].pdata_size = sizeof(struct i2s_platform_data);
VAR_8->acp.acp_cell[3].name = ""designware-i2s"";
VAR_8->acp.acp_cell[3].num_resources = 1;
VAR_8->acp.acp_cell[3].resources = &VAR_8->acp.acp_res[3];
VAR_8->acp.acp_cell[3].platform_data = &VAR_7[2];
VAR_8->acp.acp_cell[3].pdata_size = sizeof(struct i2s_platform_data);
VAR_1 = mfd_add_hotplug_devices(VAR_8->acp.parent, VAR_8->acp.acp_cell,
VAR_17);
if (VAR_1)
return VAR_1;
for (VAR_2 = 0; VAR_2 < VAR_17 ; VAR_2++) {
VAR_6 = get_mfd_cell_dev(VAR_8->acp.acp_cell[VAR_2].name, VAR_2);
VAR_1 = pm_genpd_add_device(&VAR_8->acp.acp_genpd->gpd, VAR_6);
if (VAR_1) {
dev_err(VAR_6, ""Failed to add dev to genpd\n"");
return VAR_1;
}
}
VAR_4 = cgs_read_register(VAR_8->acp.cgs_device, VAR_40);
VAR_4 |= VAR_41;
cgs_write_register(VAR_8->acp.cgs_device, VAR_40, VAR_4);
VAR_5 = VAR_42;
while (true) {
VAR_4 = cgs_read_register(VAR_8->acp.cgs_device, VAR_40);
if (VAR_43 ==
(VAR_4 & VAR_43))
break;
if (--VAR_5 == 0) {
dev_err(&VAR_8->pdev->dev, ""Failed to reset ACP\n"");
return -VAR_44;
}
udelay(100);
}
VAR_4 = cgs_read_register(VAR_8->acp.cgs_device, VAR_45);
VAR_4 = VAR_4 | VAR_46;
cgs_write_register(VAR_8->acp.cgs_device, VAR_45, VAR_4);
VAR_5 = VAR_47;
while (true) {
VAR_4 = cgs_read_register(VAR_8->acp.cgs_device, VAR_48);
if (VAR_4 & (u32) 0x1)
break;
if (--VAR_5 == 0) {
dev_err(&VAR_8->pdev->dev, ""Failed to reset ACP\n"");
return -VAR_44;
}
udelay(100);
}
VAR_4 = cgs_read_register(VAR_8->acp.cgs_device, VAR_40);
VAR_4 &= ~VAR_41;
cgs_write_register(VAR_8->acp.cgs_device, VAR_40, VAR_4);
return 0;
}",torvalds/linux/57be09c6e8747bf48704136d9e3f92bfb93f5725/amdgpu_acp.c/vul/before/0.json,"static int acp_hw_init(void *handle)
{
	int r, i;
	uint64_t acp_base;
	u32 val = 0;
	u32 count = 0;
	struct device *dev;
	struct i2s_platform_data *i2s_pdata = NULL;

	struct amdgpu_device *adev = (struct amdgpu_device *)handle;

	const struct amdgpu_ip_block *ip_block =
		amdgpu_device_ip_get_ip_block(adev, AMD_IP_BLOCK_TYPE_ACP);

	if (!ip_block)
		return -EINVAL;

	r = amd_acp_hw_init(adev->acp.cgs_device,
			    ip_block->version->major, ip_block->version->minor);
	/* -ENODEV means board uses AZ rather than ACP */
	if (r == -ENODEV) {
		amdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, true);
		return 0;
	} else if (r) {
		return r;
	}

	if (adev->rmmio_size == 0 || adev->rmmio_size < 0x5289)
		return -EINVAL;

	acp_base = adev->rmmio_base;


	adev->acp.acp_genpd = kzalloc(sizeof(struct acp_pm_domain), GFP_KERNEL);
	if (adev->acp.acp_genpd == NULL)
		return -ENOMEM;

	adev->acp.acp_genpd->gpd.name = ""ACP_AUDIO"";
	adev->acp.acp_genpd->gpd.power_off = acp_poweroff;
	adev->acp.acp_genpd->gpd.power_on = acp_poweron;


	adev->acp.acp_genpd->adev = adev;

	pm_genpd_init(&adev->acp.acp_genpd->gpd, NULL, false);

	adev->acp.acp_cell = kcalloc(ACP_DEVS, sizeof(struct mfd_cell),
							GFP_KERNEL);

	if (adev->acp.acp_cell == NULL) {
		r = -ENOMEM;
		goto failure;
	}

	adev->acp.acp_res = kcalloc(5, sizeof(struct resource), GFP_KERNEL);
	if (adev->acp.acp_res == NULL) {
		r = -ENOMEM;
		goto failure;
	}

	i2s_pdata = kcalloc(3, sizeof(struct i2s_platform_data), GFP_KERNEL);
	if (i2s_pdata == NULL) {
		r = -ENOMEM;
		goto failure;
	}

	switch (adev->asic_type) {
	case CHIP_STONEY:
		i2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |
			DW_I2S_QUIRK_16BIT_IDX_OVERRIDE;
		break;
	default:
		i2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET;
	}
	i2s_pdata[0].cap = DWC_I2S_PLAY;
	i2s_pdata[0].snd_rates = SNDRV_PCM_RATE_8000_96000;
	i2s_pdata[0].i2s_reg_comp1 = ACP_I2S_COMP1_PLAY_REG_OFFSET;
	i2s_pdata[0].i2s_reg_comp2 = ACP_I2S_COMP2_PLAY_REG_OFFSET;
	switch (adev->asic_type) {
	case CHIP_STONEY:
		i2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |
			DW_I2S_QUIRK_COMP_PARAM1 |
			DW_I2S_QUIRK_16BIT_IDX_OVERRIDE;
		break;
	default:
		i2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |
			DW_I2S_QUIRK_COMP_PARAM1;
	}

	i2s_pdata[1].cap = DWC_I2S_RECORD;
	i2s_pdata[1].snd_rates = SNDRV_PCM_RATE_8000_96000;
	i2s_pdata[1].i2s_reg_comp1 = ACP_I2S_COMP1_CAP_REG_OFFSET;
	i2s_pdata[1].i2s_reg_comp2 = ACP_I2S_COMP2_CAP_REG_OFFSET;

	i2s_pdata[2].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET;
	switch (adev->asic_type) {
	case CHIP_STONEY:
		i2s_pdata[2].quirks |= DW_I2S_QUIRK_16BIT_IDX_OVERRIDE;
		break;
	default:
		break;
	}

	i2s_pdata[2].cap = DWC_I2S_PLAY | DWC_I2S_RECORD;
	i2s_pdata[2].snd_rates = SNDRV_PCM_RATE_8000_96000;
	i2s_pdata[2].i2s_reg_comp1 = ACP_BT_COMP1_REG_OFFSET;
	i2s_pdata[2].i2s_reg_comp2 = ACP_BT_COMP2_REG_OFFSET;

	adev->acp.acp_res[0].name = ""acp2x_dma"";
	adev->acp.acp_res[0].flags = IORESOURCE_MEM;
	adev->acp.acp_res[0].start = acp_base;
	adev->acp.acp_res[0].end = acp_base + ACP_DMA_REGS_END;

	adev->acp.acp_res[1].name = ""acp2x_dw_i2s_play"";
	adev->acp.acp_res[1].flags = IORESOURCE_MEM;
	adev->acp.acp_res[1].start = acp_base + ACP_I2S_PLAY_REGS_START;
	adev->acp.acp_res[1].end = acp_base + ACP_I2S_PLAY_REGS_END;

	adev->acp.acp_res[2].name = ""acp2x_dw_i2s_cap"";
	adev->acp.acp_res[2].flags = IORESOURCE_MEM;
	adev->acp.acp_res[2].start = acp_base + ACP_I2S_CAP_REGS_START;
	adev->acp.acp_res[2].end = acp_base + ACP_I2S_CAP_REGS_END;

	adev->acp.acp_res[3].name = ""acp2x_dw_bt_i2s_play_cap"";
	adev->acp.acp_res[3].flags = IORESOURCE_MEM;
	adev->acp.acp_res[3].start = acp_base + ACP_BT_PLAY_REGS_START;
	adev->acp.acp_res[3].end = acp_base + ACP_BT_PLAY_REGS_END;

	adev->acp.acp_res[4].name = ""acp2x_dma_irq"";
	adev->acp.acp_res[4].flags = IORESOURCE_IRQ;
	adev->acp.acp_res[4].start = amdgpu_irq_create_mapping(adev, 162);
	adev->acp.acp_res[4].end = adev->acp.acp_res[4].start;

	adev->acp.acp_cell[0].name = ""acp_audio_dma"";
	adev->acp.acp_cell[0].num_resources = 5;
	adev->acp.acp_cell[0].resources = &adev->acp.acp_res[0];
	adev->acp.acp_cell[0].platform_data = &adev->asic_type;
	adev->acp.acp_cell[0].pdata_size = sizeof(adev->asic_type);

	adev->acp.acp_cell[1].name = ""designware-i2s"";
	adev->acp.acp_cell[1].num_resources = 1;
	adev->acp.acp_cell[1].resources = &adev->acp.acp_res[1];
	adev->acp.acp_cell[1].platform_data = &i2s_pdata[0];
	adev->acp.acp_cell[1].pdata_size = sizeof(struct i2s_platform_data);

	adev->acp.acp_cell[2].name = ""designware-i2s"";
	adev->acp.acp_cell[2].num_resources = 1;
	adev->acp.acp_cell[2].resources = &adev->acp.acp_res[2];
	adev->acp.acp_cell[2].platform_data = &i2s_pdata[1];
	adev->acp.acp_cell[2].pdata_size = sizeof(struct i2s_platform_data);

	adev->acp.acp_cell[3].name = ""designware-i2s"";
	adev->acp.acp_cell[3].num_resources = 1;
	adev->acp.acp_cell[3].resources = &adev->acp.acp_res[3];
	adev->acp.acp_cell[3].platform_data = &i2s_pdata[2];
	adev->acp.acp_cell[3].pdata_size = sizeof(struct i2s_platform_data);

	r = mfd_add_hotplug_devices(adev->acp.parent, adev->acp.acp_cell,
								ACP_DEVS);
	if (r)
		goto failure;

	for (i = 0; i < ACP_DEVS ; i++) {
		dev = get_mfd_cell_dev(adev->acp.acp_cell[i].name, i);
		r = pm_genpd_add_device(&adev->acp.acp_genpd->gpd, dev);
		if (r) {
			dev_err(dev, ""Failed to add dev to genpd\n"");
			goto failure;
		}
	}


	/* Assert Soft reset of ACP */
	val = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);

	val |= ACP_SOFT_RESET__SoftResetAud_MASK;
	cgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);

	count = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;
	while (true) {
		val = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);
		if (ACP_SOFT_RESET__SoftResetAudDone_MASK ==
		    (val & ACP_SOFT_RESET__SoftResetAudDone_MASK))
			break;
		if (--count == 0) {
			dev_err(&adev->pdev->dev, ""Failed to reset ACP\n"");
			r = -ETIMEDOUT;
			goto failure;
		}
		udelay(100);
	}
	/* Enable clock to ACP and wait until the clock is enabled */
	val = cgs_read_register(adev->acp.cgs_device, mmACP_CONTROL);
	val = val | ACP_CONTROL__ClkEn_MASK;
	cgs_write_register(adev->acp.cgs_device, mmACP_CONTROL, val);

	count = ACP_CLOCK_EN_TIME_OUT_VALUE;

	while (true) {
		val = cgs_read_register(adev->acp.cgs_device, mmACP_STATUS);
		if (val & (u32) 0x1)
			break;
		if (--count == 0) {
			dev_err(&adev->pdev->dev, ""Failed to reset ACP\n"");
			r = -ETIMEDOUT;
			goto failure;
		}
		udelay(100);
	}
	/* Deassert the SOFT RESET flags */
	val = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);
	val &= ~ACP_SOFT_RESET__SoftResetAud_MASK;
	cgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);
	return 0;

failure:
	kfree(i2s_pdata);
	kfree(adev->acp.acp_res);
	kfree(adev->acp.acp_cell);
	kfree(adev->acp.acp_genpd);
	return r;
}","static int acp_hw_init(void *VAR_0)
{
	int VAR_1, VAR_2;
	uint64_t VAR_3;
	u32 VAR_4 = 0;
	u32 VAR_5 = 0;
	struct device *VAR_6;
	struct i2s_platform_data *VAR_7 = NULL;

	struct amdgpu_device *VAR_8 = (struct amdgpu_device *)VAR_0;

	const struct amdgpu_ip_block *VAR_9 =
		amdgpu_device_ip_get_ip_block(VAR_8, VAR_10);

	if (!VAR_9)
		return -VAR_11;

	VAR_1 = amd_acp_hw_init(VAR_8->acp.cgs_device,
			    VAR_9->version->major, VAR_9->version->minor);
	/* COMMENT_0 */
	if (VAR_1 == -VAR_12) {
		amdgpu_dpm_set_powergating_by_smu(VAR_8, VAR_10, true);
		return 0;
	} else if (VAR_1) {
		return VAR_1;
	}

	if (VAR_8->rmmio_size == 0 || VAR_8->rmmio_size < 0x5289)
		return -VAR_11;

	VAR_3 = VAR_8->rmmio_base;


	VAR_8->acp.acp_genpd = kzalloc(sizeof(struct acp_pm_domain), VAR_13);
	if (VAR_8->acp.acp_genpd == NULL)
		return -VAR_14;

	VAR_8->acp.acp_genpd->gpd.name = ""ACP_AUDIO"";
	VAR_8->acp.acp_genpd->gpd.power_off = VAR_15;
	VAR_8->acp.acp_genpd->gpd.power_on = VAR_16;


	VAR_8->acp.acp_genpd->adev = VAR_8;

	pm_genpd_init(&VAR_8->acp.acp_genpd->gpd, NULL, false);

	VAR_8->acp.acp_cell = kcalloc(VAR_17, sizeof(struct mfd_cell),
							VAR_13);

	if (VAR_8->acp.acp_cell == NULL) {
		VAR_1 = -VAR_14;
		goto failure;
	}

	VAR_8->acp.acp_res = kcalloc(5, sizeof(struct resource), VAR_13);
	if (VAR_8->acp.acp_res == NULL) {
		VAR_1 = -VAR_14;
		goto failure;
	}

	VAR_7 = kcalloc(3, sizeof(struct i2s_platform_data), VAR_13);
	if (VAR_7 == NULL) {
		VAR_1 = -VAR_14;
		goto failure;
	}

	switch (VAR_8->asic_type) {
	case VAR_18:
		VAR_7[0].quirks = VAR_19 |
			VAR_20;
		break;
	default:
		VAR_7[0].quirks = VAR_19;
	}
	VAR_7[0].cap = VAR_21;
	VAR_7[0].snd_rates = VAR_22;
	VAR_7[0].i2s_reg_comp1 = VAR_23;
	VAR_7[0].i2s_reg_comp2 = VAR_24;
	switch (VAR_8->asic_type) {
	case VAR_18:
		VAR_7[1].quirks = VAR_19 |
			VAR_25 |
			VAR_20;
		break;
	default:
		VAR_7[1].quirks = VAR_19 |
			VAR_25;
	}

	VAR_7[1].cap = VAR_26;
	VAR_7[1].snd_rates = VAR_22;
	VAR_7[1].i2s_reg_comp1 = VAR_27;
	VAR_7[1].i2s_reg_comp2 = VAR_28;

	VAR_7[2].quirks = VAR_19;
	switch (VAR_8->asic_type) {
	case VAR_18:
		VAR_7[2].quirks |= VAR_20;
		break;
	default:
		break;
	}

	VAR_7[2].cap = VAR_21 | VAR_26;
	VAR_7[2].snd_rates = VAR_22;
	VAR_7[2].i2s_reg_comp1 = VAR_29;
	VAR_7[2].i2s_reg_comp2 = VAR_30;

	VAR_8->acp.acp_res[0].name = ""acp2x_dma"";
	VAR_8->acp.acp_res[0].flags = VAR_31;
	VAR_8->acp.acp_res[0].start = VAR_3;
	VAR_8->acp.acp_res[0].end = VAR_3 + VAR_32;

	VAR_8->acp.acp_res[1].name = ""acp2x_dw_i2s_play"";
	VAR_8->acp.acp_res[1].flags = VAR_31;
	VAR_8->acp.acp_res[1].start = VAR_3 + VAR_33;
	VAR_8->acp.acp_res[1].end = VAR_3 + VAR_34;

	VAR_8->acp.acp_res[2].name = ""acp2x_dw_i2s_cap"";
	VAR_8->acp.acp_res[2].flags = VAR_31;
	VAR_8->acp.acp_res[2].start = VAR_3 + VAR_35;
	VAR_8->acp.acp_res[2].end = VAR_3 + VAR_36;

	VAR_8->acp.acp_res[3].name = ""acp2x_dw_bt_i2s_play_cap"";
	VAR_8->acp.acp_res[3].flags = VAR_31;
	VAR_8->acp.acp_res[3].start = VAR_3 + VAR_37;
	VAR_8->acp.acp_res[3].end = VAR_3 + VAR_38;

	VAR_8->acp.acp_res[4].name = ""acp2x_dma_irq"";
	VAR_8->acp.acp_res[4].flags = VAR_39;
	VAR_8->acp.acp_res[4].start = amdgpu_irq_create_mapping(VAR_8, 162);
	VAR_8->acp.acp_res[4].end = VAR_8->acp.acp_res[4].start;

	VAR_8->acp.acp_cell[0].name = ""acp_audio_dma"";
	VAR_8->acp.acp_cell[0].num_resources = 5;
	VAR_8->acp.acp_cell[0].resources = &VAR_8->acp.acp_res[0];
	VAR_8->acp.acp_cell[0].platform_data = &VAR_8->asic_type;
	VAR_8->acp.acp_cell[0].pdata_size = sizeof(VAR_8->asic_type);

	VAR_8->acp.acp_cell[1].name = ""designware-i2s"";
	VAR_8->acp.acp_cell[1].num_resources = 1;
	VAR_8->acp.acp_cell[1].resources = &VAR_8->acp.acp_res[1];
	VAR_8->acp.acp_cell[1].platform_data = &VAR_7[0];
	VAR_8->acp.acp_cell[1].pdata_size = sizeof(struct i2s_platform_data);

	VAR_8->acp.acp_cell[2].name = ""designware-i2s"";
	VAR_8->acp.acp_cell[2].num_resources = 1;
	VAR_8->acp.acp_cell[2].resources = &VAR_8->acp.acp_res[2];
	VAR_8->acp.acp_cell[2].platform_data = &VAR_7[1];
	VAR_8->acp.acp_cell[2].pdata_size = sizeof(struct i2s_platform_data);

	VAR_8->acp.acp_cell[3].name = ""designware-i2s"";
	VAR_8->acp.acp_cell[3].num_resources = 1;
	VAR_8->acp.acp_cell[3].resources = &VAR_8->acp.acp_res[3];
	VAR_8->acp.acp_cell[3].platform_data = &VAR_7[2];
	VAR_8->acp.acp_cell[3].pdata_size = sizeof(struct i2s_platform_data);

	VAR_1 = mfd_add_hotplug_devices(VAR_8->acp.parent, VAR_8->acp.acp_cell,
								VAR_17);
	if (VAR_1)
		goto failure;

	for (VAR_2 = 0; VAR_2 < VAR_17 ; VAR_2++) {
		VAR_6 = get_mfd_cell_dev(VAR_8->acp.acp_cell[VAR_2].name, VAR_2);
		VAR_1 = pm_genpd_add_device(&VAR_8->acp.acp_genpd->gpd, VAR_6);
		if (VAR_1) {
			dev_err(VAR_6, ""Failed to add dev to genpd\n"");
			goto failure;
		}
	}


	/* COMMENT_1 */
	VAR_4 = cgs_read_register(VAR_8->acp.cgs_device, VAR_40);

	VAR_4 |= VAR_41;
	cgs_write_register(VAR_8->acp.cgs_device, VAR_40, VAR_4);

	VAR_5 = VAR_42;
	while (true) {
		VAR_4 = cgs_read_register(VAR_8->acp.cgs_device, VAR_40);
		if (VAR_43 ==
		    (VAR_4 & VAR_43))
			break;
		if (--VAR_5 == 0) {
			dev_err(&VAR_8->pdev->dev, ""Failed to reset ACP\n"");
			VAR_1 = -VAR_44;
			goto failure;
		}
		udelay(100);
	}
	/* COMMENT_2 */
	VAR_4 = cgs_read_register(VAR_8->acp.cgs_device, VAR_45);
	VAR_4 = VAR_4 | VAR_46;
	cgs_write_register(VAR_8->acp.cgs_device, VAR_45, VAR_4);

	VAR_5 = VAR_47;

	while (true) {
		VAR_4 = cgs_read_register(VAR_8->acp.cgs_device, VAR_48);
		if (VAR_4 & (u32) 0x1)
			break;
		if (--VAR_5 == 0) {
			dev_err(&VAR_8->pdev->dev, ""Failed to reset ACP\n"");
			VAR_1 = -VAR_44;
			goto failure;
		}
		udelay(100);
	}
	/* COMMENT_3 */
	VAR_4 = cgs_read_register(VAR_8->acp.cgs_device, VAR_40);
	VAR_4 &= ~VAR_41;
	cgs_write_register(VAR_8->acp.cgs_device, VAR_40, VAR_4);
	return 0;

failure:
	kfree(VAR_7);
	kfree(VAR_8->acp.acp_res);
	kfree(VAR_8->acp.acp_cell);
	kfree(VAR_8->acp.acp_genpd);
	return VAR_1;
}",torvalds/linux/57be09c6e8747bf48704136d9e3f92bfb93f5725/amdgpu_acp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
 	u32 val = 0;
 	u32 count = 0;
 	struct device *dev;
-	struct i2s_platform_data *i2s_pdata;
+	struct i2s_platform_data *i2s_pdata = NULL;
 
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
@@ -47,20 +47,21 @@
 	adev->acp.acp_cell = kcalloc(ACP_DEVS, sizeof(struct mfd_cell),
 							GFP_KERNEL);
 
-	if (adev->acp.acp_cell == NULL)
-		return -ENOMEM;
+	if (adev->acp.acp_cell == NULL) {
+		r = -ENOMEM;
+		goto failure;
+	}
 
 	adev->acp.acp_res = kcalloc(5, sizeof(struct resource), GFP_KERNEL);
 	if (adev->acp.acp_res == NULL) {
-		kfree(adev->acp.acp_cell);
-		return -ENOMEM;
+		r = -ENOMEM;
+		goto failure;
 	}
 
 	i2s_pdata = kcalloc(3, sizeof(struct i2s_platform_data), GFP_KERNEL);
 	if (i2s_pdata == NULL) {
-		kfree(adev->acp.acp_res);
-		kfree(adev->acp.acp_cell);
-		return -ENOMEM;
+		r = -ENOMEM;
+		goto failure;
 	}
 
 	switch (adev->asic_type) {
@@ -157,14 +158,14 @@
 	r = mfd_add_hotplug_devices(adev->acp.parent, adev->acp.acp_cell,
 								ACP_DEVS);
 	if (r)
-		return r;
+		goto failure;
 
 	for (i = 0; i < ACP_DEVS ; i++) {
 		dev = get_mfd_cell_dev(adev->acp.acp_cell[i].name, i);
 		r = pm_genpd_add_device(&adev->acp.acp_genpd->gpd, dev);
 		if (r) {
 			dev_err(dev, ""Failed to add dev to genpd\n"");
-			return r;
+			goto failure;
 		}
 	}
 
@@ -183,7 +184,8 @@
 			break;
 		if (--count == 0) {
 			dev_err(&adev->pdev->dev, ""Failed to reset ACP\n"");
-			return -ETIMEDOUT;
+			r = -ETIMEDOUT;
+			goto failure;
 		}
 		udelay(100);
 	}
@@ -200,7 +202,8 @@
 			break;
 		if (--count == 0) {
 			dev_err(&adev->pdev->dev, ""Failed to reset ACP\n"");
-			return -ETIMEDOUT;
+			r = -ETIMEDOUT;
+			goto failure;
 		}
 		udelay(100);
 	}
@@ -209,4 +212,11 @@
 	val &= ~ACP_SOFT_RESET__SoftResetAud_MASK;
 	cgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);
 	return 0;
+
+failure:
+	kfree(i2s_pdata);
+	kfree(adev->acp.acp_res);
+	kfree(adev->acp.acp_cell);
+	kfree(adev->acp.acp_genpd);
+	return r;
 }","{'deleted_lines': ['\tstruct i2s_platform_data *i2s_pdata;', '\tif (adev->acp.acp_cell == NULL)', '\t\treturn -ENOMEM;', '\t\tkfree(adev->acp.acp_cell);', '\t\treturn -ENOMEM;', '\t\tkfree(adev->acp.acp_res);', '\t\tkfree(adev->acp.acp_cell);', '\t\treturn -ENOMEM;', '\t\treturn r;', '\t\t\treturn r;', '\t\t\treturn -ETIMEDOUT;', '\t\t\treturn -ETIMEDOUT;'], 'added_lines': ['\tstruct i2s_platform_data *i2s_pdata = NULL;', '\tif (adev->acp.acp_cell == NULL) {', '\t\tr = -ENOMEM;', '\t\tgoto failure;', '\t}', '\t\tr = -ENOMEM;', '\t\tgoto failure;', '\t\tr = -ENOMEM;', '\t\tgoto failure;', '\t\tgoto failure;', '\t\t\tgoto failure;', '\t\t\tr = -ETIMEDOUT;', '\t\t\tgoto failure;', '\t\t\tr = -ETIMEDOUT;', '\t\t\tgoto failure;', '', 'failure:', '\tkfree(i2s_pdata);', '\tkfree(adev->acp.acp_res);', '\tkfree(adev->acp.acp_cell);', '\tkfree(adev->acp.acp_genpd);', '\treturn r;']}",True,"Four memory leaks in the acp_hw_init() function in drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption) by triggering mfd_add_hotplug_devices() or pm_genpd_add_device() failures, aka CID-57be09c6e874. NOTE: third parties dispute the relevance of this because the attacker must already have privileges for module loading",4.4,MEDIUM,1,test,2019-10-02T03:46:07Z,3
CVE-2019-15695,"['CWE-787', 'CWE-754']",AV:N/AC:L/Au:S/C:P/I:P/A:P,0,CendioOssman/tigervnc,"Handle pixel formats with odd shift values

Our fast paths assume that each channel fits in to a separate byte.
That means the shift needs to be a multiple of 8. Start actually
checking this so that a client cannot trip us up and possibly cause
incorrect code exection.

Issue found by Pavel Cheremushkin from Kaspersky Lab.",05e28490873a861379c943bf616614b78b558b89,https://github.com/CendioOssman/tigervnc/commit/05e28490873a861379c943bf616614b78b558b89,common/rfb/PixelFormat.cxx,PixelFormat::is888,"bool PixelFormat::is888(void) const
{
if (!trueColour)
return false;
if (bpp != 32)
return false;
if (depth != 24)
return false;
if (redMax != 255)
return false;
if (greenMax != 255)
return false;
if (blueMax != 255)
return false;
return true;
}","bool PixelFormat::is888(void) const
{
if (!VAR_0)
return false;
if (VAR_1 != 32)
return false;
if (VAR_2 != 24)
return false;
if (VAR_3 != 255)
return false;
if (VAR_4 != 255)
return false;
if (VAR_5 != 255)
return false;
return true;
}",CendioOssman/tigervnc/05e28490873a861379c943bf616614b78b558b89/PixelFormat.cxx/vul/before/0.json,"bool PixelFormat::is888(void) const
{
  if (!trueColour)
    return false;
  if (bpp != 32)
    return false;
  if (depth != 24)
    return false;
  if (redMax != 255)
    return false;
  if (greenMax != 255)
    return false;
  if (blueMax != 255)
    return false;
  if ((redShift & 0x7) != 0)
    return false;
  if ((greenShift & 0x7) != 0)
    return false;
  if ((blueShift & 0x7) != 0)
    return false;

  return true;
}","bool PixelFormat::is888(void) const
{
  if (!VAR_0)
    return false;
  if (VAR_1 != 32)
    return false;
  if (VAR_2 != 24)
    return false;
  if (VAR_3 != 255)
    return false;
  if (VAR_4 != 255)
    return false;
  if (VAR_5 != 255)
    return false;
  if ((VAR_6 & 0x7) != 0)
    return false;
  if ((VAR_7 & 0x7) != 0)
    return false;
  if ((VAR_8 & 0x7) != 0)
    return false;

  return true;
}",CendioOssman/tigervnc/05e28490873a861379c943bf616614b78b558b89/PixelFormat.cxx/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,12 @@
     return false;
   if (blueMax != 255)
     return false;
+  if ((redShift & 0x7) != 0)
+    return false;
+  if ((greenShift & 0x7) != 0)
+    return false;
+  if ((blueShift & 0x7) != 0)
+    return false;
 
   return true;
 }","{'deleted_lines': [], 'added_lines': ['  if ((redShift & 0x7) != 0)', '    return false;', '  if ((greenShift & 0x7) != 0)', '    return false;', '  if ((blueShift & 0x7) != 0)', '    return false;']}",True,"TigerVNC version prior to 1.10.1 is vulnerable to stack buffer overflow, which could be triggered from CMsgReader::readSetCursor. This vulnerability occurs due to insufficient sanitization of PixelFormat. Since remote attacker can choose offset from start of the buffer to start writing his values, exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.",7.2,HIGH,2,test,2019-10-02T14:06:08Z,3
CVE-2019-17266,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,GNOME/libsoup,"NTLM: Avoid a potential heap buffer overflow in v2 authentication

Check the length of the decoded v2 challenge before attempting to
parse it, to avoid reading past it.

Fixes #173",f8a54ac85eec2008c85393f331cdd251af8266ad,https://github.com/GNOME/libsoup/commit/f8a54ac85eec2008c85393f331cdd251af8266ad,libsoup/soup-auth-ntlm.c,soup_ntlm_parse_challenge,"static gboolean
soup_ntlm_parse_challenge (const char *challenge,
char      **nonce,
char      **default_domain,
gboolean   *ntlmv2_session,
gboolean   *negotiate_target,
char**target_info,
size_t*target_info_sz)
{
gsize clen;
NTLMString domain;
NTLMString target;
guchar *chall;
guint32 flags;
chall = g_base64_decode (challenge, &clen);
if (clen < NTLM_CHALLENGE_DOMAIN_STRING_OFFSET ||
clen < NTLM_CHALLENGE_NONCE_OFFSET + NTLM_CHALLENGE_NONCE_LENGTH) {
g_free (chall);
return FALSE;
}
memcpy (&flags, chall + NTLM_CHALLENGE_FLAGS_OFFSET, sizeof(flags));
flags = GUINT_FROM_LE (flags);
*ntlmv2_session = (flags & NTLM_FLAGS_NEGOTIATE_NTLMV2) ? TRUE : FALSE;
*negotiate_target = (flags & NTLM_FLAGS_NEGOTIATE_TARGET_INFORMATION ) ? TRUE : FALSE;
if (default_domain) {
memcpy (&domain, chall + NTLM_CHALLENGE_DOMAIN_STRING_OFFSET, sizeof (domain));
domain.length = GUINT16_FROM_LE (domain.length);
domain.offset = GUINT16_FROM_LE (domain.offset);
if (clen < domain.length + domain.offset) {
g_free (chall);
return FALSE;
}
*default_domain = g_convert ((char *)chall + domain.offset,
domain.length, ""UTF-8"", ""UCS-2LE"",
NULL, NULL, NULL);
}
if (nonce) {
*nonce = g_memdup (chall + NTLM_CHALLENGE_NONCE_OFFSET,
NTLM_CHALLENGE_NONCE_LENGTH);
}
if (*negotiate_target && target_info) {
memcpy (&target, chall + NTLM_CHALLENGE_TARGET_INFORMATION_OFFSET, sizeof (target));
target.length = GUINT16_FROM_LE (target.length);
target.offset = GUINT16_FROM_LE (target.offset);
if (clen < target.length + target.offset) {
g_free (chall);
return FALSE;
}
*target_info = g_memdup (chall + target.offset, target.length);
*target_info_sz = target.length;
}
g_free (chall);
return TRUE;
}","static gboolean
soup_ntlm_parse_challenge (const char *VAR_0,
char      **VAR_1,
char      **VAR_2,
gboolean   *VAR_3,
gboolean   *VAR_4,
char**VAR_5,
size_t*VAR_6)
{
gsize VAR_7;
NTLMString VAR_8;
NTLMString VAR_9;
guchar *VAR_10;
guint32 VAR_11;
VAR_10 = g_base64_decode (VAR_0, &VAR_7);
if (VAR_7 < VAR_12 ||
VAR_7 < VAR_13 + VAR_14) {
g_free (VAR_10);
return FALSE;
}
memcpy (&VAR_11, VAR_10 + VAR_15, sizeof(VAR_11));
VAR_11 = GUINT_FROM_LE (VAR_11);
*VAR_3 = (VAR_11 & VAR_16) ? TRUE : FALSE;
*VAR_4 = (VAR_11 & VAR_17 ) ? TRUE : FALSE;
if (VAR_2) {
memcpy (&VAR_8, VAR_10 + VAR_12, sizeof (VAR_8));
VAR_8.length = GUINT16_FROM_LE (VAR_8.length);
VAR_8.offset = GUINT16_FROM_LE (VAR_8.offset);
if (VAR_7 < VAR_8.length + VAR_8.offset) {
g_free (VAR_10);
return FALSE;
}
*VAR_2 = g_convert ((char *)VAR_10 + VAR_8.offset,
VAR_8.length, ""UTF-8"", ""UCS-2LE"",
NULL, NULL, NULL);
}
if (VAR_1) {
*VAR_1 = g_memdup (VAR_10 + VAR_13,
VAR_14);
}
if (*VAR_4 && VAR_5) {
memcpy (&VAR_9, VAR_10 + VAR_18, sizeof (VAR_9));
VAR_9.length = GUINT16_FROM_LE (VAR_9.length);
VAR_9.offset = GUINT16_FROM_LE (VAR_9.offset);
if (VAR_7 < VAR_9.length + VAR_9.offset) {
g_free (VAR_10);
return FALSE;
}
*VAR_5 = g_memdup (VAR_10 + VAR_9.offset, VAR_9.length);
*VAR_6 = VAR_9.length;
}
g_free (VAR_10);
return TRUE;
}",GNOME/libsoup/f8a54ac85eec2008c85393f331cdd251af8266ad/soup-auth-ntlm.c/vul/before/0.json,"static gboolean
soup_ntlm_parse_challenge (const char *challenge,
			   char      **nonce,
			   char      **default_domain,
			   gboolean   *ntlmv2_session,
			   gboolean   *negotiate_target,
			   char		**target_info,
			   size_t	*target_info_sz)
{
	gsize clen;
	NTLMString domain;
	NTLMString target;
	guchar *chall;
	guint32 flags;

	chall = g_base64_decode (challenge, &clen);
	if (clen < NTLM_CHALLENGE_DOMAIN_STRING_OFFSET ||
	    clen < NTLM_CHALLENGE_NONCE_OFFSET + NTLM_CHALLENGE_NONCE_LENGTH) {
		g_free (chall);
		return FALSE;
	}

	memcpy (&flags, chall + NTLM_CHALLENGE_FLAGS_OFFSET, sizeof(flags));
	flags = GUINT_FROM_LE (flags);
	*ntlmv2_session = (flags & NTLM_FLAGS_NEGOTIATE_NTLMV2) ? TRUE : FALSE;
	/* To know if NTLMv2 responses should be calculated */
	*negotiate_target = (flags & NTLM_FLAGS_NEGOTIATE_TARGET_INFORMATION ) ? TRUE : FALSE;
        if (*negotiate_target) {
            if (clen < NTLM_CHALLENGE_TARGET_INFORMATION_OFFSET + sizeof (target)) {
                g_free (chall);
                return FALSE;
            }
        }

	if (default_domain) {
		memcpy (&domain, chall + NTLM_CHALLENGE_DOMAIN_STRING_OFFSET, sizeof (domain));
		domain.length = GUINT16_FROM_LE (domain.length);
		domain.offset = GUINT16_FROM_LE (domain.offset);

		if (clen < domain.length + domain.offset) {
			g_free (chall);
			return FALSE;
		}

		*default_domain = g_convert ((char *)chall + domain.offset,
					     domain.length, ""UTF-8"", ""UCS-2LE"",
					     NULL, NULL, NULL);
	}

	if (nonce) {
		*nonce = g_memdup (chall + NTLM_CHALLENGE_NONCE_OFFSET,
				   NTLM_CHALLENGE_NONCE_LENGTH);
	}
	/* For NTLMv2 response */
	if (*negotiate_target && target_info) {
		memcpy (&target, chall + NTLM_CHALLENGE_TARGET_INFORMATION_OFFSET, sizeof (target));
		target.length = GUINT16_FROM_LE (target.length);
		target.offset = GUINT16_FROM_LE (target.offset);

		if (clen < target.length + target.offset) {
			g_free (chall);
			return FALSE;
		}
		*target_info = g_memdup (chall + target.offset, target.length);
		*target_info_sz = target.length;
	}

	g_free (chall);
	return TRUE;
}","static gboolean
soup_ntlm_parse_challenge (const char *VAR_0,
			   char      **VAR_1,
			   char      **VAR_2,
			   gboolean   *VAR_3,
			   gboolean   *VAR_4,
			   char		**VAR_5,
			   size_t	*VAR_6)
{
	gsize VAR_7;
	NTLMString VAR_8;
	NTLMString VAR_9;
	guchar *VAR_10;
	guint32 VAR_11;

	VAR_10 = g_base64_decode (VAR_0, &VAR_7);
	if (VAR_7 < VAR_12 ||
	    VAR_7 < VAR_13 + VAR_14) {
		g_free (VAR_10);
		return FALSE;
	}

	memcpy (&VAR_11, VAR_10 + VAR_15, sizeof(VAR_11));
	VAR_11 = GUINT_FROM_LE (VAR_11);
	*VAR_3 = (VAR_11 & VAR_16) ? TRUE : FALSE;
	/* COMMENT_0 */
	*VAR_4 = (VAR_11 & VAR_17 ) ? TRUE : FALSE;
        if (*VAR_4) {
            if (VAR_7 < VAR_18 + sizeof (VAR_9)) {
                g_free (VAR_10);
                return FALSE;
            }
        }

	if (VAR_2) {
		memcpy (&VAR_8, VAR_10 + VAR_12, sizeof (VAR_8));
		VAR_8.length = GUINT16_FROM_LE (VAR_8.length);
		VAR_8.offset = GUINT16_FROM_LE (VAR_8.offset);

		if (VAR_7 < VAR_8.length + VAR_8.offset) {
			g_free (VAR_10);
			return FALSE;
		}

		*VAR_2 = g_convert ((char *)VAR_10 + VAR_8.offset,
					     VAR_8.length, ""UTF-8"", ""UCS-2LE"",
					     NULL, NULL, NULL);
	}

	if (VAR_1) {
		*VAR_1 = g_memdup (VAR_10 + VAR_13,
				   VAR_14);
	}
	/* COMMENT_1 */
	if (*VAR_4 && VAR_5) {
		memcpy (&VAR_9, VAR_10 + VAR_18, sizeof (VAR_9));
		VAR_9.length = GUINT16_FROM_LE (VAR_9.length);
		VAR_9.offset = GUINT16_FROM_LE (VAR_9.offset);

		if (VAR_7 < VAR_9.length + VAR_9.offset) {
			g_free (VAR_10);
			return FALSE;
		}
		*VAR_5 = g_memdup (VAR_10 + VAR_9.offset, VAR_9.length);
		*VAR_6 = VAR_9.length;
	}

	g_free (VAR_10);
	return TRUE;
}",GNOME/libsoup/f8a54ac85eec2008c85393f331cdd251af8266ad/soup-auth-ntlm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -25,6 +25,12 @@
 	*ntlmv2_session = (flags & NTLM_FLAGS_NEGOTIATE_NTLMV2) ? TRUE : FALSE;
 	/* To know if NTLMv2 responses should be calculated */
 	*negotiate_target = (flags & NTLM_FLAGS_NEGOTIATE_TARGET_INFORMATION ) ? TRUE : FALSE;
+        if (*negotiate_target) {
+            if (clen < NTLM_CHALLENGE_TARGET_INFORMATION_OFFSET + sizeof (target)) {
+                g_free (chall);
+                return FALSE;
+            }
+        }
 
 	if (default_domain) {
 		memcpy (&domain, chall + NTLM_CHALLENGE_DOMAIN_STRING_OFFSET, sizeof (domain));","{'deleted_lines': [], 'added_lines': ['        if (*negotiate_target) {', '            if (clen < NTLM_CHALLENGE_TARGET_INFORMATION_OFFSET + sizeof (target)) {', '                g_free (chall);', '                return FALSE;', '            }', '        }']}",True,libsoup from versions 2.65.1 until 2.68.1 have a heap-based buffer over-read because soup_ntlm_parse_challenge() in soup-auth-ntlm.c does not properly check an NTLM message's length before proceeding with a memcpy.,9.8,CRITICAL,3,test,2019-10-07T13:32:15Z,3
CVE-2019-20079,"['CWE-416', 'CWE-120']",AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vim,"patch 8.1.2136: using freed memory with autocmd from fuzzer

Problem:    using freed memory with autocmd from fuzzer. (Dhiraj Mishra,
            Dominique Pelle)
Solution:   Avoid using ""wp"" after autocommands. (closes #5041)",ec66c41d84e574baf8009dbc0bd088d2bc5b2421,https://github.com/vim/vim/commit/ec66c41d84e574baf8009dbc0bd088d2bc5b2421,src/window.c,win_enter_ext,"static void
win_enter_ext(
win_T*wp,
intundo_sync,
intcurwin_invalid,
inttrigger_new_autocmds,
inttrigger_enter_autocmds,
inttrigger_leave_autocmds)
{
intother_buffer = FALSE;
if (wp == curwin && !curwin_invalid)
return;
#ifdef FEAT_JOB_CHANNEL
if (!curwin_invalid)
leaving_window(curwin);
#endif
if (!curwin_invalid && trigger_leave_autocmds)
{
if (wp->w_buffer != curbuf)
{
apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);
other_buffer = TRUE;
if (!win_valid(wp))
return;
}
apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);
if (!win_valid(wp))
return;
#ifdef FEAT_EVAL
if (aborting())
return;
#endif
}
if (undo_sync && curbuf != wp->w_buffer)
u_sync(FALSE);
update_topline();
if (wp->w_buffer != curbuf)
buf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);
if (!curwin_invalid)
{
prevwin = curwin;
curwin->w_redr_status = TRUE;
}
curwin = wp;
curbuf = wp->w_buffer;
check_cursor();
if (!virtual_active())
curwin->w_cursor.coladd = 0;
changed_line_abv_curs();
if (curwin->w_localdir != NULL || curtab->tp_localdir != NULL)
{
char_u*dirname;
if (globaldir == NULL)
{
char_ucwd[MAXPATHL];
if (mch_dirname(cwd, MAXPATHL) == OK)
globaldir = vim_strsave(cwd);
}
if (curwin->w_localdir != NULL)
dirname = curwin->w_localdir;
else
dirname = curtab->tp_localdir;
if (mch_chdir((char *)dirname) == 0)
shorten_fnames(TRUE);
}
else if (globaldir != NULL)
{
vim_ignored = mch_chdir((char *)globaldir);
VIM_CLEAR(globaldir);
shorten_fnames(TRUE);
}
#ifdef FEAT_JOB_CHANNEL
entering_window(curwin);
#endif
if (trigger_new_autocmds)
apply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);
if (trigger_enter_autocmds)
{
apply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);
if (other_buffer)
apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);
}
#ifdef FEAT_TITLE
maketitle();
#endif
curwin->w_redr_status = TRUE;
#ifdef FEAT_TERMINAL
if (bt_terminal(wp->w_buffer))
redraw_mode = TRUE;
#endif
redraw_tabline = TRUE;
if (restart_edit)
redraw_later(VALID);
if (curwin->w_height < p_wh && !curwin->w_p_wfh
#ifdef FEAT_TEXT_PROP
&& !popup_is_popup(curwin)
#endif
)
win_setheight((int)p_wh);
else if (curwin->w_height == 0)
win_setheight(1);
if (curwin->w_width < p_wiw && !curwin->w_p_wfw)
win_setwidth((int)p_wiw);
setmouse();
DO_AUTOCHDIR;
}","static void
win_enter_ext(
win_T*VAR_0,
intVAR_1,
intVAR_2,
intVAR_3,
intVAR_4,
intVAR_5)
{
intVAR_6 = FALSE;
if (VAR_0 == VAR_7 && !VAR_2)
return;
#ifdef VAR_8
if (!VAR_2)
leaving_window(VAR_7);
#endif
if (!VAR_2 && VAR_5)
{
if (VAR_0->w_buffer != VAR_9)
{
apply_autocmds(VAR_10, NULL, NULL, FALSE, VAR_9);
VAR_6 = TRUE;
if (!win_valid(VAR_0))
return;
}
apply_autocmds(VAR_11, NULL, NULL, FALSE, VAR_9);
if (!win_valid(VAR_0))
return;
#ifdef VAR_12
if (aborting())
return;
#endif
}
if (VAR_1 && VAR_9 != VAR_0->w_buffer)
u_sync(FALSE);
update_topline();
if (VAR_0->w_buffer != VAR_9)
buf_copy_options(VAR_0->w_buffer, VAR_13 | VAR_14);
if (!VAR_2)
{
VAR_15 = VAR_7;
VAR_7->w_redr_status = TRUE;
}
VAR_7 = VAR_0;
VAR_9 = VAR_0->w_buffer;
check_cursor();
if (!virtual_active())
VAR_7->w_cursor.coladd = 0;
changed_line_abv_curs();
if (VAR_7->w_localdir != NULL || VAR_16->tp_localdir != NULL)
{
char_u*VAR_17;
if (VAR_18 == NULL)
{
char_uVAR_19[VAR_20];
if (mch_dirname(VAR_19, VAR_20) == VAR_21)
VAR_18 = vim_strsave(VAR_19);
}
if (VAR_7->w_localdir != NULL)
VAR_17 = VAR_7->w_localdir;
else
VAR_17 = VAR_16->tp_localdir;
if (mch_chdir((char *)VAR_17) == 0)
shorten_fnames(TRUE);
}
else if (VAR_18 != NULL)
{
VAR_22 = mch_chdir((char *)VAR_18);
VIM_CLEAR(VAR_18);
shorten_fnames(TRUE);
}
#ifdef VAR_8
entering_window(VAR_7);
#endif
if (VAR_3)
apply_autocmds(VAR_23, NULL, NULL, FALSE, VAR_9);
if (VAR_4)
{
apply_autocmds(VAR_24, NULL, NULL, FALSE, VAR_9);
if (VAR_6)
apply_autocmds(VAR_25, NULL, NULL, FALSE, VAR_9);
}
#ifdef VAR_26
maketitle();
#endif
VAR_7->w_redr_status = TRUE;
#ifdef VAR_27
if (bt_terminal(VAR_0->w_buffer))
VAR_28 = TRUE;
#endif
VAR_29 = TRUE;
if (VAR_30)
redraw_later(VAR_31);
if (VAR_7->w_height < VAR_32 && !VAR_7->w_p_wfh
#ifdef VAR_33
&& !popup_is_popup(VAR_7)
#endif
)
win_setheight((int)VAR_32);
else if (VAR_7->w_height == 0)
win_setheight(1);
if (VAR_7->w_width < VAR_34 && !VAR_7->w_p_wfw)
win_setwidth((int)VAR_34);
setmouse();
VAR_35;
}",vim/ec66c41d84e574baf8009dbc0bd088d2bc5b2421/window.c/vul/before/0.json,"static void
win_enter_ext(
    win_T	*wp,
    int		undo_sync,
    int		curwin_invalid,
    int		trigger_new_autocmds,
    int		trigger_enter_autocmds,
    int		trigger_leave_autocmds)
{
    int		other_buffer = FALSE;

    if (wp == curwin && !curwin_invalid)	/* nothing to do */
	return;

#ifdef FEAT_JOB_CHANNEL
    if (!curwin_invalid)
	leaving_window(curwin);
#endif

    if (!curwin_invalid && trigger_leave_autocmds)
    {
	/*
	 * Be careful: If autocommands delete the window, return now.
	 */
	if (wp->w_buffer != curbuf)
	{
	    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);
	    other_buffer = TRUE;
	    if (!win_valid(wp))
		return;
	}
	apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);
	if (!win_valid(wp))
	    return;
#ifdef FEAT_EVAL
	/* autocmds may abort script processing */
	if (aborting())
	    return;
#endif
    }

    /* sync undo before leaving the current buffer */
    if (undo_sync && curbuf != wp->w_buffer)
	u_sync(FALSE);

    /* Might need to scroll the old window before switching, e.g., when the
     * cursor was moved. */
    update_topline();

    /* may have to copy the buffer options when 'cpo' contains 'S' */
    if (wp->w_buffer != curbuf)
	buf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);
    if (!curwin_invalid)
    {
	prevwin = curwin;	/* remember for CTRL-W p */
	curwin->w_redr_status = TRUE;
    }
    curwin = wp;
    curbuf = wp->w_buffer;
    check_cursor();
    if (!virtual_active())
	curwin->w_cursor.coladd = 0;
    changed_line_abv_curs();	/* assume cursor position needs updating */

    if (curwin->w_localdir != NULL || curtab->tp_localdir != NULL)
    {
	char_u	*dirname;

	// Window or tab has a local directory: Save current directory as
	// global directory (unless that was done already) and change to the
	// local directory.
	if (globaldir == NULL)
	{
	    char_u	cwd[MAXPATHL];

	    if (mch_dirname(cwd, MAXPATHL) == OK)
		globaldir = vim_strsave(cwd);
	}
	if (curwin->w_localdir != NULL)
	    dirname = curwin->w_localdir;
	else
	    dirname = curtab->tp_localdir;

	if (mch_chdir((char *)dirname) == 0)
	    shorten_fnames(TRUE);
    }
    else if (globaldir != NULL)
    {
	/* Window doesn't have a local directory and we are not in the global
	 * directory: Change to the global directory. */
	vim_ignored = mch_chdir((char *)globaldir);
	VIM_CLEAR(globaldir);
	shorten_fnames(TRUE);
    }

#ifdef FEAT_JOB_CHANNEL
    entering_window(curwin);
#endif
    // Careful: autocommands may close the window and make ""wp"" invalid
    if (trigger_new_autocmds)
	apply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);
    if (trigger_enter_autocmds)
    {
	apply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);
	if (other_buffer)
	    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);
    }

#ifdef FEAT_TITLE
    maketitle();
#endif
    curwin->w_redr_status = TRUE;
#ifdef FEAT_TERMINAL
    if (bt_terminal(curwin->w_buffer))
	// terminal is likely in another mode
	redraw_mode = TRUE;
#endif
    redraw_tabline = TRUE;
    if (restart_edit)
	redraw_later(VALID);	/* causes status line redraw */

    /* set window height to desired minimal value */
    if (curwin->w_height < p_wh && !curwin->w_p_wfh
#ifdef FEAT_TEXT_PROP
	    && !popup_is_popup(curwin)
#endif
	    )
	win_setheight((int)p_wh);
    else if (curwin->w_height == 0)
	win_setheight(1);

    /* set window width to desired minimal value */
    if (curwin->w_width < p_wiw && !curwin->w_p_wfw)
	win_setwidth((int)p_wiw);

    setmouse();			// in case jumped to/from help buffer

    /* Change directories when the 'acd' option is set. */
    DO_AUTOCHDIR;
}","static void
win_enter_ext(
    win_T	*VAR_0,
    int		VAR_1,
    int		VAR_2,
    int		VAR_3,
    int		VAR_4,
    int		VAR_5)
{
    int		VAR_6 = FALSE;

    if (VAR_0 == VAR_7 && !VAR_2)	/* COMMENT_0 */
	return;

#ifdef VAR_8
    if (!VAR_2)
	leaving_window(VAR_7);
#endif

    if (!VAR_2 && VAR_5)
    {
	/* COMMENT_1 */
                                                              
    
	if (VAR_0->w_buffer != VAR_9)
	{
	    apply_autocmds(VAR_10, NULL, NULL, FALSE, VAR_9);
	    VAR_6 = TRUE;
	    if (!win_valid(VAR_0))
		return;
	}
	apply_autocmds(VAR_11, NULL, NULL, FALSE, VAR_9);
	if (!win_valid(VAR_0))
	    return;
#ifdef VAR_12
	/* COMMENT_4 */
	if (aborting())
	    return;
#endif
    }

    /* COMMENT_5 */
    if (VAR_1 && VAR_9 != VAR_0->w_buffer)
	u_sync(FALSE);

    /* COMMENT_6 */
                           
    update_topline();

    /* COMMENT_8 */
    if (VAR_0->w_buffer != VAR_9)
	buf_copy_options(VAR_0->w_buffer, VAR_13 | VAR_14);
    if (!VAR_2)
    {
	VAR_15 = VAR_7;	/* COMMENT_9 */
	VAR_7->w_redr_status = TRUE;
    }
    VAR_7 = VAR_0;
    VAR_9 = VAR_0->w_buffer;
    check_cursor();
    if (!virtual_active())
	VAR_7->w_cursor.coladd = 0;
    changed_line_abv_curs();	/* COMMENT_10 */

    if (VAR_7->w_localdir != NULL || VAR_16->tp_localdir != NULL)
    {
	char_u	*VAR_17;

	/* COMMENT_11 */
	/* COMMENT_12 */
	/* COMMENT_13 */
	if (VAR_18 == NULL)
	{
	    char_u	VAR_19[VAR_20];

	    if (mch_dirname(VAR_19, VAR_20) == VAR_21)
		VAR_18 = vim_strsave(VAR_19);
	}
	if (VAR_7->w_localdir != NULL)
	    VAR_17 = VAR_7->w_localdir;
	else
	    VAR_17 = VAR_16->tp_localdir;

	if (mch_chdir((char *)VAR_17) == 0)
	    shorten_fnames(TRUE);
    }
    else if (VAR_18 != NULL)
    {
	/* COMMENT_14 */
                                                 
	VAR_22 = mch_chdir((char *)VAR_18);
	VIM_CLEAR(VAR_18);
	shorten_fnames(TRUE);
    }

#ifdef VAR_8
    entering_window(VAR_7);
#endif
    /* COMMENT_16 */
    if (VAR_3)
	apply_autocmds(VAR_23, NULL, NULL, FALSE, VAR_9);
    if (VAR_4)
    {
	apply_autocmds(VAR_24, NULL, NULL, FALSE, VAR_9);
	if (VAR_6)
	    apply_autocmds(VAR_25, NULL, NULL, FALSE, VAR_9);
    }

#ifdef VAR_26
    maketitle();
#endif
    VAR_7->w_redr_status = TRUE;
#ifdef VAR_27
    if (bt_terminal(VAR_7->w_buffer))
	/* COMMENT_17 */
	VAR_28 = TRUE;
#endif
    VAR_29 = TRUE;
    if (VAR_30)
	redraw_later(VAR_31);	/* COMMENT_18 */

    /* COMMENT_19 */
    if (VAR_7->w_height < VAR_32 && !VAR_7->w_p_wfh
#ifdef VAR_33
	    && !popup_is_popup(VAR_7)
#endif
	    )
	win_setheight((int)VAR_32);
    else if (VAR_7->w_height == 0)
	win_setheight(1);

    /* COMMENT_20 */
    if (VAR_7->w_width < VAR_34 && !VAR_7->w_p_wfw)
	win_setwidth((int)VAR_34);

    setmouse();			/* COMMENT_21 */

    /* COMMENT_22 */
    VAR_35;
}",vim/ec66c41d84e574baf8009dbc0bd088d2bc5b2421/window.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -96,6 +96,7 @@
 #ifdef FEAT_JOB_CHANNEL
     entering_window(curwin);
 #endif
+    // Careful: autocommands may close the window and make ""wp"" invalid
     if (trigger_new_autocmds)
 	apply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);
     if (trigger_enter_autocmds)
@@ -110,7 +111,7 @@
 #endif
     curwin->w_redr_status = TRUE;
 #ifdef FEAT_TERMINAL
-    if (bt_terminal(wp->w_buffer))
+    if (bt_terminal(curwin->w_buffer))
 	// terminal is likely in another mode
 	redraw_mode = TRUE;
 #endif","{'deleted_lines': ['    if (bt_terminal(wp->w_buffer))'], 'added_lines': ['    // Careful: autocommands may close the window and make ""wp"" invalid', '    if (bt_terminal(curwin->w_buffer))']}",True,The autocmd feature in window.c in Vim before 8.1.2136 accesses freed memory.,7.8,HIGH,2,test,2019-10-11T19:19:13Z,3
CVE-2019-18424,['CWE-78'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"passthrough: quarantine PCI devices

When a PCI device is assigned to an untrusted domain, it is possible for
that domain to program the device to DMA to an arbitrary address. The
IOMMU is used to protect the host from malicious DMA by making sure that
the device addresses can only target memory assigned to the guest. However,
when the guest domain is torn down the device is assigned back to dom0,
thus allowing any in-flight DMA to potentially target critical host data.

This patch introduces a 'quarantine' for PCI devices using dom_io. When
the toolstack makes a device assignable (by binding it to pciback), it
will now also assign it to DOMID_IO and the device will only be assigned
back to dom0 when the device is made unassignable again. Whilst device is
assignable it will only ever transfer between dom_io and guest domains.
dom_io is actually only used as a sentinel domain for quarantining purposes;
it is not configured with any IOMMU mappings. Assignment to dom_io simply
means that the device's initiator (requestor) identifier is not present in
the IOMMU's device table and thus any DMA transactions issued will be
terminated with a fault condition.

In addition, a fix to assignment handling is made for VT-d.  Failure
during the assignment step should not lead to a device still being
associated with its prior owner. Hand the device to DomIO temporarily,
until the assignment step has completed successfully.  Remove the PI
hooks from the source domain then earlier as well.

Failure of the recovery reassign_device_ownership() may not go silent:
There e.g. may still be left over RMRR mappings in the domain assignment
to which has failed, and hence we can't allow that domain to continue
executing.

NOTE: This patch also includes one printk() cleanup; the
      ""XEN_DOMCTL_assign_device: "" tag is dropped in iommu_do_pci_domctl(),
      since similar printk()-s elsewhere also don't log such a tag.

This is XSA-302.

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,xen/drivers/passthrough/vtd/iommu.c,iommu_domain_init,"int iommu_domain_init(struct domain *d, unsigned int opts)
{
struct domain_iommu *hd = dom_iommu(d);
int ret = 0;
if ( !is_iommu_enabled(d) )
return 0;
#ifdef CONFIG_NUMA
hd->node = NUMA_NO_NODE;
#endif
ret = arch_iommu_domain_init(d);
if ( ret )
return ret;
hd->platform_ops = iommu_get_ops();
ret = hd->platform_ops->init(d);
if ( ret )
return ret;
if ( is_hardware_domain(d) )
check_hwdom_reqs(d); 
hd->hap_pt_share = hap_enabled(d) && iommu_hap_pt_share &&
!(opts & XEN_DOMCTL_IOMMU_no_sharept);
if ( !is_hardware_domain(d) || iommu_hwdom_strict )
hd->need_sync = !iommu_use_hap_pt(d);
ASSERT(!(hd->need_sync && hd->hap_pt_share));
return 0;
}","int iommu_domain_init(struct domain *VAR_0, unsigned int VAR_1)
{
struct domain_iommu *VAR_2 = dom_iommu(VAR_0);
int VAR_3 = 0;
if ( !is_iommu_enabled(VAR_0) )
return 0;
#ifdef VAR_4
VAR_2->node = VAR_5;
#endif
VAR_3 = arch_iommu_domain_init(VAR_0);
if ( VAR_3 )
return VAR_3;
VAR_2->platform_ops = iommu_get_ops();
VAR_3 = VAR_2->platform_ops->init(VAR_0);
if ( VAR_3 )
return VAR_3;
if ( is_hardware_domain(VAR_0) )
check_hwdom_reqs(VAR_0); 
VAR_2->hap_pt_share = hap_enabled(VAR_0) && VAR_6 &&
!(VAR_1 & VAR_7);
if ( !is_hardware_domain(VAR_0) || VAR_8 )
VAR_2->need_sync = !iommu_use_hap_pt(VAR_0);
ASSERT(!(VAR_2->need_sync && VAR_2->hap_pt_share));
return 0;
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/iommu.c/vul/before/1.json,"int iommu_domain_init(struct domain *d, unsigned int opts)
{
    struct domain_iommu *hd = dom_iommu(d);
    int ret = 0;

    if ( !is_iommu_enabled(d) )
        return 0;

#ifdef CONFIG_NUMA
    hd->node = NUMA_NO_NODE;
#endif

    ret = arch_iommu_domain_init(d);
    if ( ret )
        return ret;

    hd->platform_ops = iommu_get_ops();
    ret = hd->platform_ops->init(d);
    if ( ret || is_system_domain(d) )
        return ret;

    if ( is_hardware_domain(d) )
        check_hwdom_reqs(d); /* may modify iommu_hwdom_strict */

    /*
     * Use shared page tables for HAP and IOMMU if the global option
     * is enabled (from which we can infer the h/w is capable) and
     * the domain options do not disallow it. HAP must, of course, also
     * be enabled.
     */
    hd->hap_pt_share = hap_enabled(d) && iommu_hap_pt_share &&
        !(opts & XEN_DOMCTL_IOMMU_no_sharept);

    /*
     * NB: 'relaxed' h/w domains don't need the IOMMU mappings to be kept
     *     in-sync with their assigned pages because all host RAM will be
     *     mapped during hwdom_init().
     */
    if ( !is_hardware_domain(d) || iommu_hwdom_strict )
        hd->need_sync = !iommu_use_hap_pt(d);

    ASSERT(!(hd->need_sync && hd->hap_pt_share));

    return 0;
}","int iommu_domain_init(struct domain *VAR_0, unsigned int VAR_1)
{
    struct domain_iommu *VAR_2 = dom_iommu(VAR_0);
    int VAR_3 = 0;

    if ( !is_iommu_enabled(VAR_0) )
        return 0;

#ifdef VAR_4
    VAR_2->node = VAR_5;
#endif

    VAR_3 = arch_iommu_domain_init(VAR_0);
    if ( VAR_3 )
        return VAR_3;

    VAR_2->platform_ops = iommu_get_ops();
    VAR_3 = VAR_2->platform_ops->init(VAR_0);
    if ( VAR_3 || is_system_domain(VAR_0) )
        return VAR_3;

    if ( is_hardware_domain(VAR_0) )
        check_hwdom_reqs(VAR_0); /* COMMENT_0 */

    /* COMMENT_1 */
                                                                    
                                                                  
                                                                       
                  
       
    VAR_2->hap_pt_share = hap_enabled(VAR_0) && VAR_6 &&
        !(VAR_1 & VAR_7);

    /* COMMENT_7 */
                                                                         
                                                                         
                                      
       
    if ( !is_hardware_domain(VAR_0) || VAR_8 )
        VAR_2->need_sync = !iommu_use_hap_pt(VAR_0);

    ASSERT(!(VAR_2->need_sync && VAR_2->hap_pt_share));

    return 0;
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/iommu.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -16,7 +16,7 @@
 
     hd->platform_ops = iommu_get_ops();
     ret = hd->platform_ops->init(d);
-    if ( ret )
+    if ( ret || is_system_domain(d) )
         return ret;
 
     if ( is_hardware_domain(d) )","{'deleted_lines': ['    if ( ret )'], 'added_lines': ['    if ( ret || is_system_domain(d) )']}",True,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",6.8,MEDIUM,1,test,2019-10-18T16:41:44Z,3
CVE-2019-18424,['CWE-78'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"passthrough: quarantine PCI devices

When a PCI device is assigned to an untrusted domain, it is possible for
that domain to program the device to DMA to an arbitrary address. The
IOMMU is used to protect the host from malicious DMA by making sure that
the device addresses can only target memory assigned to the guest. However,
when the guest domain is torn down the device is assigned back to dom0,
thus allowing any in-flight DMA to potentially target critical host data.

This patch introduces a 'quarantine' for PCI devices using dom_io. When
the toolstack makes a device assignable (by binding it to pciback), it
will now also assign it to DOMID_IO and the device will only be assigned
back to dom0 when the device is made unassignable again. Whilst device is
assignable it will only ever transfer between dom_io and guest domains.
dom_io is actually only used as a sentinel domain for quarantining purposes;
it is not configured with any IOMMU mappings. Assignment to dom_io simply
means that the device's initiator (requestor) identifier is not present in
the IOMMU's device table and thus any DMA transactions issued will be
terminated with a fault condition.

In addition, a fix to assignment handling is made for VT-d.  Failure
during the assignment step should not lead to a device still being
associated with its prior owner. Hand the device to DomIO temporarily,
until the assignment step has completed successfully.  Remove the PI
hooks from the source domain then earlier as well.

Failure of the recovery reassign_device_ownership() may not go silent:
There e.g. may still be left over RMRR mappings in the domain assignment
to which has failed, and hence we can't allow that domain to continue
executing.

NOTE: This patch also includes one printk() cleanup; the
      ""XEN_DOMCTL_assign_device: "" tag is dropped in iommu_do_pci_domctl(),
      since similar printk()-s elsewhere also don't log such a tag.

This is XSA-302.

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,xen/drivers/passthrough/vtd/iommu.c,iommu_setup,"int __init iommu_setup(void)
{
int rc = -ENODEV;
bool_t force_intremap = force_iommu && iommu_intremap;
if ( iommu_hwdom_strict )
iommu_hwdom_passthrough = false;
if ( iommu_enable )
{
rc = iommu_hardware_setup();
iommu_enabled = (rc == 0);
}
if ( !iommu_enabled )
iommu_intremap = 0;
if ( (force_iommu && !iommu_enabled) ||
(force_intremap && !iommu_intremap) )
panic(""Couldn't enable %s and iommu=required/force\n"",
!iommu_enabled ? ""IOMMU"" : ""Interrupt Remapping"");
if ( !iommu_intremap )
iommu_intpost = 0;
printk(""I/O virtualisation %sabled\n"", iommu_enabled ? ""en"" : ""dis"");
if ( !iommu_enabled )
{
iommu_snoop = 0;
iommu_hwdom_passthrough = false;
iommu_hwdom_strict = false;
}
else
{
printk("" - Dom0 mode: %s\n"",
iommu_hwdom_passthrough ? ""Passthrough"" :
iommu_hwdom_strict ? ""Strict"" : ""Relaxed"");
printk(""Interrupt remapping %sabled\n"", iommu_intremap ? ""en"" : ""dis"");
tasklet_init(&iommu_pt_cleanup_tasklet, iommu_free_pagetables, 0);
}
return rc;
}","int __init iommu_setup(void)
{
int VAR_0 = -VAR_1;
bool_t VAR_2 = VAR_3 && VAR_4;
if ( VAR_5 )
VAR_6 = false;
if ( VAR_7 )
{
VAR_0 = iommu_hardware_setup();
VAR_8 = (VAR_0 == 0);
}
if ( !VAR_8 )
VAR_4 = 0;
if ( (VAR_3 && !VAR_8) ||
(VAR_2 && !VAR_4) )
panic(""Couldn't enable %s and iommu=required/force\n"",
!VAR_8 ? ""IOMMU"" : ""Interrupt Remapping"");
if ( !VAR_4 )
VAR_9 = 0;
printk(""I/O virtualisation %sabled\n"", VAR_8 ? ""en"" : ""dis"");
if ( !VAR_8 )
{
VAR_10 = 0;
VAR_6 = false;
VAR_5 = false;
}
else
{
printk("" - Dom0 mode: %s\n"",
VAR_6 ? ""Passthrough"" :
VAR_5 ? ""Strict"" : ""Relaxed"");
printk(""Interrupt remapping %sabled\n"", VAR_4 ? ""en"" : ""dis"");
tasklet_init(&VAR_11, VAR_12, 0);
}
return VAR_0;
}",,"int __init iommu_setup(void)
{
    int rc = -ENODEV;
    bool_t force_intremap = force_iommu && iommu_intremap;

    if ( iommu_hwdom_strict )
        iommu_hwdom_passthrough = false;

    if ( iommu_enable )
    {
        rc = iommu_hardware_setup();
        iommu_enabled = (rc == 0);
    }
    if ( !iommu_enabled )
        iommu_intremap = 0;

    if ( (force_iommu && !iommu_enabled) ||
         (force_intremap && !iommu_intremap) )
        panic(""Couldn't enable %s and iommu=required/force\n"",
              !iommu_enabled ? ""IOMMU"" : ""Interrupt Remapping"");

    if ( !iommu_intremap )
        iommu_intpost = 0;

    printk(""I/O virtualisation %sabled\n"", iommu_enabled ? ""en"" : ""dis"");
    if ( !iommu_enabled )
    {
        iommu_snoop = 0;
        iommu_hwdom_passthrough = false;
        iommu_hwdom_strict = false;
    }
    else
    {
        dom_io->options |= XEN_DOMCTL_CDF_iommu;
        if ( iommu_domain_init(dom_io, 0) )
            panic(""Could not set up quarantine\n"");

        printk("" - Dom0 mode: %s\n"",
               iommu_hwdom_passthrough ? ""Passthrough"" :
               iommu_hwdom_strict ? ""Strict"" : ""Relaxed"");
        printk(""Interrupt remapping %sabled\n"", iommu_intremap ? ""en"" : ""dis"");
        tasklet_init(&iommu_pt_cleanup_tasklet, iommu_free_pagetables, 0);
    }

    return rc;
}","int __init iommu_setup(void)
{
    int VAR_0 = -VAR_1;
    bool_t VAR_2 = VAR_3 && VAR_4;

    if ( VAR_5 )
        VAR_6 = false;

    if ( VAR_7 )
    {
        VAR_0 = iommu_hardware_setup();
        VAR_8 = (VAR_0 == 0);
    }
    if ( !VAR_8 )
        VAR_4 = 0;

    if ( (VAR_3 && !VAR_8) ||
         (VAR_2 && !VAR_4) )
        panic(""Couldn't enable %s and iommu=required/force\n"",
              !VAR_8 ? ""IOMMU"" : ""Interrupt Remapping"");

    if ( !VAR_4 )
        VAR_9 = 0;

    printk(""I/O virtualisation %sabled\n"", VAR_8 ? ""en"" : ""dis"");
    if ( !VAR_8 )
    {
        VAR_10 = 0;
        VAR_6 = false;
        VAR_5 = false;
    }
    else
    {
        VAR_11->options |= VAR_12;
        if ( iommu_domain_init(VAR_11, 0) )
            panic(""Could not set up quarantine\n"");

        printk("" - Dom0 mode: %s\n"",
               VAR_6 ? ""Passthrough"" :
               VAR_5 ? ""Strict"" : ""Relaxed"");
        printk(""Interrupt remapping %sabled\n"", VAR_4 ? ""en"" : ""dis"");
        tasklet_init(&VAR_13, VAR_14, 0);
    }

    return VAR_0;
}",,"--- func_before
+++ func_after
@@ -31,6 +31,10 @@
     }
     else
     {
+        dom_io->options |= XEN_DOMCTL_CDF_iommu;
+        if ( iommu_domain_init(dom_io, 0) )
+            panic(""Could not set up quarantine\n"");
+
         printk("" - Dom0 mode: %s\n"",
                iommu_hwdom_passthrough ? ""Passthrough"" :
                iommu_hwdom_strict ? ""Strict"" : ""Relaxed"");","{'deleted_lines': [], 'added_lines': ['        dom_io->options |= XEN_DOMCTL_CDF_iommu;', '        if ( iommu_domain_init(dom_io, 0) )', '            panic(""Could not set up quarantine\\n"");', '']}",True,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",6.8,MEDIUM,1,test,2019-10-18T16:41:44Z,3
CVE-2019-18424,['CWE-78'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"passthrough: quarantine PCI devices

When a PCI device is assigned to an untrusted domain, it is possible for
that domain to program the device to DMA to an arbitrary address. The
IOMMU is used to protect the host from malicious DMA by making sure that
the device addresses can only target memory assigned to the guest. However,
when the guest domain is torn down the device is assigned back to dom0,
thus allowing any in-flight DMA to potentially target critical host data.

This patch introduces a 'quarantine' for PCI devices using dom_io. When
the toolstack makes a device assignable (by binding it to pciback), it
will now also assign it to DOMID_IO and the device will only be assigned
back to dom0 when the device is made unassignable again. Whilst device is
assignable it will only ever transfer between dom_io and guest domains.
dom_io is actually only used as a sentinel domain for quarantining purposes;
it is not configured with any IOMMU mappings. Assignment to dom_io simply
means that the device's initiator (requestor) identifier is not present in
the IOMMU's device table and thus any DMA transactions issued will be
terminated with a fault condition.

In addition, a fix to assignment handling is made for VT-d.  Failure
during the assignment step should not lead to a device still being
associated with its prior owner. Hand the device to DomIO temporarily,
until the assignment step has completed successfully.  Remove the PI
hooks from the source domain then earlier as well.

Failure of the recovery reassign_device_ownership() may not go silent:
There e.g. may still be left over RMRR mappings in the domain assignment
to which has failed, and hence we can't allow that domain to continue
executing.

NOTE: This patch also includes one printk() cleanup; the
      ""XEN_DOMCTL_assign_device: "" tag is dropped in iommu_do_pci_domctl(),
      since similar printk()-s elsewhere also don't log such a tag.

This is XSA-302.

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,xen/drivers/passthrough/pci.c,device_assigned,"static int device_assigned(u16 seg, u8 bus, u8 devfn)
{
struct pci_dev *pdev;
pcidevs_lock();
pdev = pci_get_pdev_by_domain(hardware_domain, seg, bus, devfn);
pcidevs_unlock();
return pdev ? 0 : -EBUSY;
}","static int device_assigned(u16 VAR_0, u8 VAR_1, u8 VAR_2)
{
struct pci_dev *VAR_3;
pcidevs_lock();
VAR_3 = pci_get_pdev_by_domain(VAR_4, VAR_0, VAR_1, VAR_2);
pcidevs_unlock();
return VAR_3 ? 0 : -VAR_5;
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/pci.c/vul/before/2.json,"static int device_assigned(u16 seg, u8 bus, u8 devfn)
{
    struct pci_dev *pdev;
    int rc = 0;

    pcidevs_lock();

    pdev = pci_get_pdev(seg, bus, devfn);

    if ( !pdev )
        rc = -ENODEV;
    /*
     * If the device exists and it is not owned by either the hardware
     * domain or dom_io then it must be assigned to a guest, or be
     * hidden (owned by dom_xen).
     */
    else if ( pdev->domain != hardware_domain &&
              pdev->domain != dom_io )
        rc = -EBUSY;

    pcidevs_unlock();

    return rc;
}","static int device_assigned(u16 VAR_0, u8 VAR_1, u8 VAR_2)
{
    struct pci_dev *VAR_3;
    int VAR_4 = 0;

    pcidevs_lock();

    VAR_3 = pci_get_pdev(VAR_0, VAR_1, VAR_2);

    if ( !VAR_3 )
        VAR_4 = -VAR_5;
    /* COMMENT_0 */
                                                                      
                                                                  
                                 
       
    else if ( VAR_3->domain != VAR_6 &&
              VAR_3->domain != VAR_7 )
        VAR_4 = -VAR_8;

    pcidevs_unlock();

    return VAR_4;
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/pci.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,10 +1,24 @@
 static int device_assigned(u16 seg, u8 bus, u8 devfn)
 {
     struct pci_dev *pdev;
+    int rc = 0;
 
     pcidevs_lock();
-    pdev = pci_get_pdev_by_domain(hardware_domain, seg, bus, devfn);
+
+    pdev = pci_get_pdev(seg, bus, devfn);
+
+    if ( !pdev )
+        rc = -ENODEV;
+    /*
+     * If the device exists and it is not owned by either the hardware
+     * domain or dom_io then it must be assigned to a guest, or be
+     * hidden (owned by dom_xen).
+     */
+    else if ( pdev->domain != hardware_domain &&
+              pdev->domain != dom_io )
+        rc = -EBUSY;
+
     pcidevs_unlock();
 
-    return pdev ? 0 : -EBUSY;
+    return rc;
 }","{'deleted_lines': ['    pdev = pci_get_pdev_by_domain(hardware_domain, seg, bus, devfn);', '    return pdev ? 0 : -EBUSY;'], 'added_lines': ['    int rc = 0;', '', '    pdev = pci_get_pdev(seg, bus, devfn);', '', '    if ( !pdev )', '        rc = -ENODEV;', '    /*', '     * If the device exists and it is not owned by either the hardware', '     * domain or dom_io then it must be assigned to a guest, or be', '     * hidden (owned by dom_xen).', '     */', '    else if ( pdev->domain != hardware_domain &&', '              pdev->domain != dom_io )', '        rc = -EBUSY;', '', '    return rc;']}",True,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",6.8,MEDIUM,1,test,2019-10-18T16:41:44Z,3
CVE-2019-18424,['CWE-78'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"passthrough: quarantine PCI devices

When a PCI device is assigned to an untrusted domain, it is possible for
that domain to program the device to DMA to an arbitrary address. The
IOMMU is used to protect the host from malicious DMA by making sure that
the device addresses can only target memory assigned to the guest. However,
when the guest domain is torn down the device is assigned back to dom0,
thus allowing any in-flight DMA to potentially target critical host data.

This patch introduces a 'quarantine' for PCI devices using dom_io. When
the toolstack makes a device assignable (by binding it to pciback), it
will now also assign it to DOMID_IO and the device will only be assigned
back to dom0 when the device is made unassignable again. Whilst device is
assignable it will only ever transfer between dom_io and guest domains.
dom_io is actually only used as a sentinel domain for quarantining purposes;
it is not configured with any IOMMU mappings. Assignment to dom_io simply
means that the device's initiator (requestor) identifier is not present in
the IOMMU's device table and thus any DMA transactions issued will be
terminated with a fault condition.

In addition, a fix to assignment handling is made for VT-d.  Failure
during the assignment step should not lead to a device still being
associated with its prior owner. Hand the device to DomIO temporarily,
until the assignment step has completed successfully.  Remove the PI
hooks from the source domain then earlier as well.

Failure of the recovery reassign_device_ownership() may not go silent:
There e.g. may still be left over RMRR mappings in the domain assignment
to which has failed, and hence we can't allow that domain to continue
executing.

NOTE: This patch also includes one printk() cleanup; the
      ""XEN_DOMCTL_assign_device: "" tag is dropped in iommu_do_pci_domctl(),
      since similar printk()-s elsewhere also don't log such a tag.

This is XSA-302.

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,xen/drivers/passthrough/pci.c,assign_device,"static int assign_device(struct domain *d, u16 seg, u8 bus, u8 devfn, u32 flag)
{
const struct domain_iommu *hd = dom_iommu(d);
struct pci_dev *pdev;
int rc = 0;
if ( !is_iommu_enabled(d) )
return 0;
if ( unlikely((is_hvm_domain(d) &&
d->arch.hvm.mem_sharing_enabled) ||
vm_event_check_ring(d->vm_event_paging) ||
p2m_get_hostp2m(d)->global_logdirty) )
return -EXDEV;
if ( !pcidevs_trylock() )
return -ERESTART;
pdev = pci_get_pdev_by_domain(hardware_domain, seg, bus, devfn);
if ( !pdev )
{
rc = pci_get_pdev(seg, bus, devfn) ? -EBUSY : -ENODEV;
goto done;
}
if ( pdev->msix )
{
rc = pci_reset_msix_state(pdev);
if ( rc )
goto done;
msixtbl_init(d);
}
pdev->fault.count = 0;
if ( (rc = hd->platform_ops->assign_device(d, devfn, pci_to_dev(pdev), flag)) )
goto done;
for ( ; pdev->phantom_stride; rc = 0 )
{
devfn += pdev->phantom_stride;
if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )
break;
rc = hd->platform_ops->assign_device(d, devfn, pci_to_dev(pdev), flag);
if ( rc )
printk(XENLOG_G_WARNING ""d%d: assign %04x:%02x:%02x.%u failed (%d)\n"",
d->domain_id, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),
rc);
}
done:
pcidevs_unlock();
return rc;
}","static int assign_device(struct domain *VAR_0, u16 VAR_1, u8 VAR_2, u8 VAR_3, u32 VAR_4)
{
const struct domain_iommu *VAR_5 = dom_iommu(VAR_0);
struct pci_dev *VAR_6;
int VAR_7 = 0;
if ( !is_iommu_enabled(VAR_0) )
return 0;
if ( unlikely((is_hvm_domain(VAR_0) &&
VAR_0->arch.hvm.mem_sharing_enabled) ||
vm_event_check_ring(VAR_0->vm_event_paging) ||
p2m_get_hostp2m(VAR_0)->global_logdirty) )
return -VAR_8;
if ( !pcidevs_trylock() )
return -VAR_9;
VAR_6 = pci_get_pdev_by_domain(VAR_10, VAR_1, VAR_2, VAR_3);
if ( !VAR_6 )
{
VAR_7 = pci_get_pdev(VAR_1, VAR_2, VAR_3) ? -VAR_11 : -VAR_12;
goto done;
}
if ( VAR_6->msix )
{
VAR_7 = pci_reset_msix_state(VAR_6);
if ( VAR_7 )
goto done;
msixtbl_init(VAR_0);
}
VAR_6->fault.count = 0;
if ( (VAR_7 = VAR_5->platform_ops->assign_device(VAR_0, VAR_3, pci_to_dev(VAR_6), VAR_4)) )
goto done;
for ( ; VAR_6->phantom_stride; VAR_7 = 0 )
{
VAR_3 += VAR_6->phantom_stride;
if ( PCI_SLOT(VAR_3) != PCI_SLOT(VAR_6->devfn) )
break;
VAR_7 = VAR_5->platform_ops->assign_device(VAR_0, VAR_3, pci_to_dev(VAR_6), VAR_4);
if ( VAR_7 )
printk(XENLOG_G_WARNING ""d%d: assign %04x:%02x:%02x.%u failed (%d)\n"",
VAR_0->domain_id, VAR_1, VAR_2, PCI_SLOT(VAR_3), PCI_FUNC(VAR_3),
VAR_7);
}
done:
pcidevs_unlock();
return VAR_7;
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/pci.c/vul/before/1.json,"static int assign_device(struct domain *d, u16 seg, u8 bus, u8 devfn, u32 flag)
{
    const struct domain_iommu *hd = dom_iommu(d);
    struct pci_dev *pdev;
    int rc = 0;

    if ( !is_iommu_enabled(d) )
        return 0;

    /* Prevent device assign if mem paging or mem sharing have been 
     * enabled for this domain */
    if ( d != dom_io &&
         unlikely((is_hvm_domain(d) &&
                   d->arch.hvm.mem_sharing_enabled) ||
                  vm_event_check_ring(d->vm_event_paging) ||
                  p2m_get_hostp2m(d)->global_logdirty) )
        return -EXDEV;

    if ( !pcidevs_trylock() )
        return -ERESTART;

    pdev = pci_get_pdev(seg, bus, devfn);

    rc = -ENODEV;
    if ( !pdev )
        goto done;

    rc = 0;
    if ( d == pdev->domain )
        goto done;

    rc = -EBUSY;
    if ( pdev->domain != hardware_domain &&
         pdev->domain != dom_io )
        goto done;

    if ( pdev->msix )
    {
        rc = pci_reset_msix_state(pdev);
        if ( rc )
            goto done;
        msixtbl_init(d);
    }

    pdev->fault.count = 0;

    if ( (rc = hd->platform_ops->assign_device(d, devfn, pci_to_dev(pdev), flag)) )
        goto done;

    for ( ; pdev->phantom_stride; rc = 0 )
    {
        devfn += pdev->phantom_stride;
        if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )
            break;
        rc = hd->platform_ops->assign_device(d, devfn, pci_to_dev(pdev), flag);
        if ( rc )
            printk(XENLOG_G_WARNING ""d%d: assign %04x:%02x:%02x.%u failed (%d)\n"",
                   d->domain_id, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),
                   rc);
    }

 done:
    /* The device is assigned to dom_io so mark it as quarantined */
    if ( !rc && d == dom_io )
        pdev->quarantine = true;

    pcidevs_unlock();

    return rc;
}","static int assign_device(struct domain *VAR_0, u16 VAR_1, u8 VAR_2, u8 VAR_3, u32 VAR_4)
{
    const struct domain_iommu *VAR_5 = dom_iommu(VAR_0);
    struct pci_dev *VAR_6;
    int VAR_7 = 0;

    if ( !is_iommu_enabled(VAR_0) )
        return 0;

    /* COMMENT_0 */
                                 
    if ( VAR_0 != VAR_8 &&
         unlikely((is_hvm_domain(VAR_0) &&
                   VAR_0->arch.hvm.mem_sharing_enabled) ||
                  vm_event_check_ring(VAR_0->vm_event_paging) ||
                  p2m_get_hostp2m(VAR_0)->global_logdirty) )
        return -VAR_9;

    if ( !pcidevs_trylock() )
        return -VAR_10;

    VAR_6 = pci_get_pdev(VAR_1, VAR_2, VAR_3);

    VAR_7 = -VAR_11;
    if ( !VAR_6 )
        goto done;

    VAR_7 = 0;
    if ( VAR_0 == VAR_6->domain )
        goto done;

    VAR_7 = -VAR_12;
    if ( VAR_6->domain != VAR_13 &&
         VAR_6->domain != VAR_8 )
        goto done;

    if ( VAR_6->msix )
    {
        VAR_7 = pci_reset_msix_state(VAR_6);
        if ( VAR_7 )
            goto done;
        msixtbl_init(VAR_0);
    }

    VAR_6->fault.count = 0;

    if ( (VAR_7 = VAR_5->platform_ops->assign_device(VAR_0, VAR_3, pci_to_dev(VAR_6), VAR_4)) )
        goto done;

    for ( ; VAR_6->phantom_stride; VAR_7 = 0 )
    {
        VAR_3 += VAR_6->phantom_stride;
        if ( PCI_SLOT(VAR_3) != PCI_SLOT(VAR_6->devfn) )
            break;
        VAR_7 = VAR_5->platform_ops->assign_device(VAR_0, VAR_3, pci_to_dev(VAR_6), VAR_4);
        if ( VAR_7 )
            printk(XENLOG_G_WARNING ""d%d: assign %04x:%02x:%02x.%u failed (%d)\n"",
                   VAR_0->domain_id, VAR_1, VAR_2, PCI_SLOT(VAR_3), PCI_FUNC(VAR_3),
                   VAR_7);
    }

 done:
    /* COMMENT_2 */
    if ( !VAR_7 && VAR_0 == VAR_8 )
        VAR_6->quarantine = true;

    pcidevs_unlock();

    return VAR_7;
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/pci.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -9,7 +9,8 @@
 
     /* Prevent device assign if mem paging or mem sharing have been 
      * enabled for this domain */
-    if ( unlikely((is_hvm_domain(d) &&
+    if ( d != dom_io &&
+         unlikely((is_hvm_domain(d) &&
                    d->arch.hvm.mem_sharing_enabled) ||
                   vm_event_check_ring(d->vm_event_paging) ||
                   p2m_get_hostp2m(d)->global_logdirty) )
@@ -18,12 +19,20 @@
     if ( !pcidevs_trylock() )
         return -ERESTART;
 
-    pdev = pci_get_pdev_by_domain(hardware_domain, seg, bus, devfn);
+    pdev = pci_get_pdev(seg, bus, devfn);
+
+    rc = -ENODEV;
     if ( !pdev )
-    {
-        rc = pci_get_pdev(seg, bus, devfn) ? -EBUSY : -ENODEV;
         goto done;
-    }
+
+    rc = 0;
+    if ( d == pdev->domain )
+        goto done;
+
+    rc = -EBUSY;
+    if ( pdev->domain != hardware_domain &&
+         pdev->domain != dom_io )
+        goto done;
 
     if ( pdev->msix )
     {
@@ -51,6 +60,10 @@
     }
 
  done:
+    /* The device is assigned to dom_io so mark it as quarantined */
+    if ( !rc && d == dom_io )
+        pdev->quarantine = true;
+
     pcidevs_unlock();
 
     return rc;","{'deleted_lines': ['    if ( unlikely((is_hvm_domain(d) &&', '    pdev = pci_get_pdev_by_domain(hardware_domain, seg, bus, devfn);', '    {', '        rc = pci_get_pdev(seg, bus, devfn) ? -EBUSY : -ENODEV;', '    }'], 'added_lines': ['    if ( d != dom_io &&', '         unlikely((is_hvm_domain(d) &&', '    pdev = pci_get_pdev(seg, bus, devfn);', '', '    rc = -ENODEV;', '', '    rc = 0;', '    if ( d == pdev->domain )', '        goto done;', '', '    rc = -EBUSY;', '    if ( pdev->domain != hardware_domain &&', '         pdev->domain != dom_io )', '        goto done;', '    /* The device is assigned to dom_io so mark it as quarantined */', '    if ( !rc && d == dom_io )', '        pdev->quarantine = true;', '']}",True,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",6.8,MEDIUM,1,test,2019-10-18T16:41:44Z,3
CVE-2019-18424,['CWE-78'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"passthrough: quarantine PCI devices

When a PCI device is assigned to an untrusted domain, it is possible for
that domain to program the device to DMA to an arbitrary address. The
IOMMU is used to protect the host from malicious DMA by making sure that
the device addresses can only target memory assigned to the guest. However,
when the guest domain is torn down the device is assigned back to dom0,
thus allowing any in-flight DMA to potentially target critical host data.

This patch introduces a 'quarantine' for PCI devices using dom_io. When
the toolstack makes a device assignable (by binding it to pciback), it
will now also assign it to DOMID_IO and the device will only be assigned
back to dom0 when the device is made unassignable again. Whilst device is
assignable it will only ever transfer between dom_io and guest domains.
dom_io is actually only used as a sentinel domain for quarantining purposes;
it is not configured with any IOMMU mappings. Assignment to dom_io simply
means that the device's initiator (requestor) identifier is not present in
the IOMMU's device table and thus any DMA transactions issued will be
terminated with a fault condition.

In addition, a fix to assignment handling is made for VT-d.  Failure
during the assignment step should not lead to a device still being
associated with its prior owner. Hand the device to DomIO temporarily,
until the assignment step has completed successfully.  Remove the PI
hooks from the source domain then earlier as well.

Failure of the recovery reassign_device_ownership() may not go silent:
There e.g. may still be left over RMRR mappings in the domain assignment
to which has failed, and hence we can't allow that domain to continue
executing.

NOTE: This patch also includes one printk() cleanup; the
      ""XEN_DOMCTL_assign_device: "" tag is dropped in iommu_do_pci_domctl(),
      since similar printk()-s elsewhere also don't log such a tag.

This is XSA-302.

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,xen/drivers/passthrough/pci.c,deassign_device,"static int deassign_device(struct domain *d, uint16_t seg, uint8_t bus,
uint8_t devfn)
{
const struct domain_iommu *hd = dom_iommu(d);
struct pci_dev *pdev;
int ret = 0;
if ( !is_iommu_enabled(d) )
return -EINVAL;
ASSERT(pcidevs_locked());
pdev = pci_get_pdev_by_domain(d, seg, bus, devfn);
if ( !pdev )
return -ENODEV;
while ( pdev->phantom_stride )
{
devfn += pdev->phantom_stride;
if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )
break;
ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,
pci_to_dev(pdev));
if ( !ret )
continue;
printk(XENLOG_G_ERR ""%pd: deassign %04x:%02x:%02x.%u failed (%d)\n"",
d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), ret);
return ret;
}
devfn = pdev->devfn;
ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,
pci_to_dev(pdev));
if ( ret )
{
dprintk(XENLOG_G_ERR,
""%pd: deassign device (%04x:%02x:%02x.%u) failed\n"",
d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));
return ret;
}
pdev->fault.count = 0;
return ret;
}","static int deassign_device(struct domain *VAR_0, uint16_t VAR_1, uint8_t VAR_2,
uint8_t VAR_3)
{
const struct domain_iommu *VAR_4 = dom_iommu(VAR_0);
struct pci_dev *VAR_5;
int VAR_6 = 0;
if ( !is_iommu_enabled(VAR_0) )
return -VAR_7;
ASSERT(pcidevs_locked());
VAR_5 = pci_get_pdev_by_domain(VAR_0, VAR_1, VAR_2, VAR_3);
if ( !VAR_5 )
return -VAR_8;
while ( VAR_5->phantom_stride )
{
VAR_3 += VAR_5->phantom_stride;
if ( PCI_SLOT(VAR_3) != PCI_SLOT(VAR_5->devfn) )
break;
VAR_6 = VAR_4->platform_ops->reassign_device(VAR_0, VAR_9, VAR_3,
pci_to_dev(VAR_5));
if ( !VAR_6 )
continue;
printk(XENLOG_G_ERR ""%pd: deassign %04x:%02x:%02x.%u failed (%d)\n"",
VAR_0, VAR_1, VAR_2, PCI_SLOT(VAR_3), PCI_FUNC(VAR_3), VAR_6);
return VAR_6;
}
VAR_3 = VAR_5->devfn;
VAR_6 = VAR_4->platform_ops->reassign_device(VAR_0, VAR_9, VAR_3,
pci_to_dev(VAR_5));
if ( VAR_6 )
{
dprintk(VAR_10,
""%pd: deassign device (%04x:%02x:%02x.%u) failed\n"",
VAR_0, VAR_1, VAR_2, PCI_SLOT(VAR_3), PCI_FUNC(VAR_3));
return VAR_6;
}
VAR_5->fault.count = 0;
return VAR_6;
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/pci.c/vul/before/0.json,"static int deassign_device(struct domain *d, uint16_t seg, uint8_t bus,
                           uint8_t devfn)
{
    const struct domain_iommu *hd = dom_iommu(d);
    struct pci_dev *pdev;
    struct domain *target;
    int ret = 0;

    if ( !is_iommu_enabled(d) )
        return -EINVAL;

    ASSERT(pcidevs_locked());
    pdev = pci_get_pdev_by_domain(d, seg, bus, devfn);
    if ( !pdev )
        return -ENODEV;

    /* De-assignment from dom_io should de-quarantine the device */
    target = (pdev->quarantine && pdev->domain != dom_io) ?
        dom_io : hardware_domain;

    while ( pdev->phantom_stride )
    {
        devfn += pdev->phantom_stride;
        if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )
            break;
        ret = hd->platform_ops->reassign_device(d, target, devfn,
                                                pci_to_dev(pdev));
        if ( !ret )
            continue;

        printk(XENLOG_G_ERR ""%pd: deassign %04x:%02x:%02x.%u failed (%d)\n"",
               d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), ret);
        return ret;
    }

    devfn = pdev->devfn;
    ret = hd->platform_ops->reassign_device(d, target, devfn,
                                            pci_to_dev(pdev));
    if ( ret )
    {
        dprintk(XENLOG_G_ERR,
                ""%pd: deassign device (%04x:%02x:%02x.%u) failed\n"",
                d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));
        return ret;
    }

    if ( pdev->domain == hardware_domain  )
        pdev->quarantine = false;

    pdev->fault.count = 0;

    return ret;
}","static int deassign_device(struct domain *VAR_0, uint16_t VAR_1, uint8_t VAR_2,
                           uint8_t VAR_3)
{
    const struct domain_iommu *VAR_4 = dom_iommu(VAR_0);
    struct pci_dev *VAR_5;
    struct domain *VAR_6;
    int VAR_7 = 0;

    if ( !is_iommu_enabled(VAR_0) )
        return -VAR_8;

    ASSERT(pcidevs_locked());
    VAR_5 = pci_get_pdev_by_domain(VAR_0, VAR_1, VAR_2, VAR_3);
    if ( !VAR_5 )
        return -VAR_9;

    /* COMMENT_0 */
    VAR_6 = (VAR_5->quarantine && VAR_5->domain != VAR_10) ?
        VAR_10 : VAR_11;

    while ( VAR_5->phantom_stride )
    {
        VAR_3 += VAR_5->phantom_stride;
        if ( PCI_SLOT(VAR_3) != PCI_SLOT(VAR_5->devfn) )
            break;
        VAR_7 = VAR_4->platform_ops->reassign_device(VAR_0, VAR_6, VAR_3,
                                                pci_to_dev(VAR_5));
        if ( !VAR_7 )
            continue;

        printk(XENLOG_G_ERR ""%pd: deassign %04x:%02x:%02x.%u failed (%d)\n"",
               VAR_0, VAR_1, VAR_2, PCI_SLOT(VAR_3), PCI_FUNC(VAR_3), VAR_7);
        return VAR_7;
    }

    VAR_3 = VAR_5->devfn;
    VAR_7 = VAR_4->platform_ops->reassign_device(VAR_0, VAR_6, VAR_3,
                                            pci_to_dev(VAR_5));
    if ( VAR_7 )
    {
        dprintk(VAR_12,
                ""%pd: deassign device (%04x:%02x:%02x.%u) failed\n"",
                VAR_0, VAR_1, VAR_2, PCI_SLOT(VAR_3), PCI_FUNC(VAR_3));
        return VAR_7;
    }

    if ( VAR_5->domain == VAR_11  )
        VAR_5->quarantine = false;

    VAR_5->fault.count = 0;

    return VAR_7;
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/pci.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,6 +3,7 @@
 {
     const struct domain_iommu *hd = dom_iommu(d);
     struct pci_dev *pdev;
+    struct domain *target;
     int ret = 0;
 
     if ( !is_iommu_enabled(d) )
@@ -13,12 +14,16 @@
     if ( !pdev )
         return -ENODEV;
 
+    /* De-assignment from dom_io should de-quarantine the device */
+    target = (pdev->quarantine && pdev->domain != dom_io) ?
+        dom_io : hardware_domain;
+
     while ( pdev->phantom_stride )
     {
         devfn += pdev->phantom_stride;
         if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )
             break;
-        ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,
+        ret = hd->platform_ops->reassign_device(d, target, devfn,
                                                 pci_to_dev(pdev));
         if ( !ret )
             continue;
@@ -29,7 +34,7 @@
     }
 
     devfn = pdev->devfn;
-    ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,
+    ret = hd->platform_ops->reassign_device(d, target, devfn,
                                             pci_to_dev(pdev));
     if ( ret )
     {
@@ -39,6 +44,9 @@
         return ret;
     }
 
+    if ( pdev->domain == hardware_domain  )
+        pdev->quarantine = false;
+
     pdev->fault.count = 0;
 
     return ret;","{'deleted_lines': ['        ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,', '    ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,'], 'added_lines': ['    struct domain *target;', '    /* De-assignment from dom_io should de-quarantine the device */', '    target = (pdev->quarantine && pdev->domain != dom_io) ?', '        dom_io : hardware_domain;', '', '        ret = hd->platform_ops->reassign_device(d, target, devfn,', '    ret = hd->platform_ops->reassign_device(d, target, devfn,', '    if ( pdev->domain == hardware_domain  )', '        pdev->quarantine = false;', '']}",True,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",6.8,MEDIUM,1,test,2019-10-18T16:41:44Z,3
CVE-2019-18424,['CWE-78'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"passthrough: quarantine PCI devices

When a PCI device is assigned to an untrusted domain, it is possible for
that domain to program the device to DMA to an arbitrary address. The
IOMMU is used to protect the host from malicious DMA by making sure that
the device addresses can only target memory assigned to the guest. However,
when the guest domain is torn down the device is assigned back to dom0,
thus allowing any in-flight DMA to potentially target critical host data.

This patch introduces a 'quarantine' for PCI devices using dom_io. When
the toolstack makes a device assignable (by binding it to pciback), it
will now also assign it to DOMID_IO and the device will only be assigned
back to dom0 when the device is made unassignable again. Whilst device is
assignable it will only ever transfer between dom_io and guest domains.
dom_io is actually only used as a sentinel domain for quarantining purposes;
it is not configured with any IOMMU mappings. Assignment to dom_io simply
means that the device's initiator (requestor) identifier is not present in
the IOMMU's device table and thus any DMA transactions issued will be
terminated with a fault condition.

In addition, a fix to assignment handling is made for VT-d.  Failure
during the assignment step should not lead to a device still being
associated with its prior owner. Hand the device to DomIO temporarily,
until the assignment step has completed successfully.  Remove the PI
hooks from the source domain then earlier as well.

Failure of the recovery reassign_device_ownership() may not go silent:
There e.g. may still be left over RMRR mappings in the domain assignment
to which has failed, and hence we can't allow that domain to continue
executing.

NOTE: This patch also includes one printk() cleanup; the
      ""XEN_DOMCTL_assign_device: "" tag is dropped in iommu_do_pci_domctl(),
      since similar printk()-s elsewhere also don't log such a tag.

This is XSA-302.

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,xen/common/domctl.c,do_domctl,"long do_domctl(XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)
{
long ret = 0;
bool_t copyback = 0;
struct xen_domctl curop, *op = &curop;
struct domain *d;
if ( copy_from_guest(op, u_domctl, 1) )
return -EFAULT;
if ( op->interface_version != XEN_DOMCTL_INTERFACE_VERSION )
return -EACCES;
switch ( op->cmd )
{
case XEN_DOMCTL_test_assign_device:
case XEN_DOMCTL_vm_event_op:
if ( op->domain == DOMID_INVALID )
{
case XEN_DOMCTL_createdomain:
case XEN_DOMCTL_gdbsx_guestmemio:
d = NULL;
break;
}
default:
d = rcu_lock_domain_by_id(op->domain);
if ( !d && op->cmd != XEN_DOMCTL_getdomaininfo )
return -ESRCH;
}
ret = xsm_domctl(XSM_OTHER, d, op->cmd);
if ( ret )
goto domctl_out_unlock_domonly;
if ( !domctl_lock_acquire() )
{
if ( d )
rcu_unlock_domain(d);
return hypercall_create_continuation(
__HYPERVISOR_domctl, ""h"", u_domctl);
}
switch ( op->cmd )
{
case XEN_DOMCTL_setvcpucontext:
{
vcpu_guest_context_u c = { .nat = NULL };
unsigned int vcpu = op->u.vcpucontext.vcpu;
struct vcpu *v;
ret = -EINVAL;
if ( (d == current->domain) || 
(vcpu >= d->max_vcpus) || ((v = d->vcpu[vcpu]) == NULL) )
break;
if ( guest_handle_is_null(op->u.vcpucontext.ctxt) )
{
ret = vcpu_reset(v);
if ( ret == -ERESTART )
ret = hypercall_create_continuation(
__HYPERVISOR_domctl, ""h"", u_domctl);
break;
}
#ifdef CONFIG_COMPAT
BUILD_BUG_ON(sizeof(struct vcpu_guest_context)
< sizeof(struct compat_vcpu_guest_context));
#endif
ret = -ENOMEM;
if ( (c.nat = alloc_vcpu_guest_context()) == NULL )
break;
#ifdef CONFIG_COMPAT
if ( !is_pv_32bit_domain(d) )
ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);
else
ret = copy_from_guest(c.cmp,
guest_handle_cast(op->u.vcpucontext.ctxt,
void), 1);
#else
ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);
#endif
ret = ret ? -EFAULT : 0;
if ( ret == 0 )
{
domain_pause(d);
ret = arch_set_info_guest(v, c);
domain_unpause(d);
if ( ret == -ERESTART )
ret = hypercall_create_continuation(
__HYPERVISOR_domctl, ""h"", u_domctl);
}
free_vcpu_guest_context(c.nat);
break;
}
case XEN_DOMCTL_pausedomain:
ret = -EINVAL;
if ( d != current->domain )
ret = domain_pause_by_systemcontroller(d);
break;
case XEN_DOMCTL_unpausedomain:
ret = domain_unpause_by_systemcontroller(d);
break;
case XEN_DOMCTL_resumedomain:
if ( d == current->domain ) 
ret = -EINVAL;
else
domain_resume(d);
break;
case XEN_DOMCTL_createdomain:
{
domid_t        dom;
static domid_t rover = 0;
dom = op->domain;
if ( (dom > 0) && (dom < DOMID_FIRST_RESERVED) )
{
ret = -EINVAL;
if ( !is_free_domid(dom) )
break;
}
else
{
for ( dom = rover + 1; dom != rover; dom++ )
{
if ( dom == DOMID_FIRST_RESERVED )
dom = 1;
if ( is_free_domid(dom) )
break;
}
ret = -ENOMEM;
if ( dom == rover )
break;
rover = dom;
}
d = domain_create(dom, &op->u.createdomain, false);
if ( IS_ERR(d) )
{
ret = PTR_ERR(d);
d = NULL;
break;
}
ret = 0;
op->domain = d->domain_id;
copyback = 1;
d = NULL;
break;
}
case XEN_DOMCTL_max_vcpus:
{
unsigned int i, max = op->u.max_vcpus.max;
ret = -EINVAL;
if ( (d == current->domain) || 
(max != d->max_vcpus) )   
break;
domain_pause(d);
ret = -ENOMEM;
for ( i = 0; i < max; i++ )
{
if ( d->vcpu[i] != NULL )
continue;
if ( vcpu_create(d, i) == NULL )
goto maxvcpu_out;
}
domain_update_node_affinity(d);
ret = 0;
maxvcpu_out:
domain_unpause(d);
break;
}
case XEN_DOMCTL_soft_reset:
if ( d == current->domain ) 
{
ret = -EINVAL;
break;
}
ret = domain_soft_reset(d);
break;
case XEN_DOMCTL_destroydomain:
domctl_lock_release();
domain_lock(d);
ret = domain_kill(d);
domain_unlock(d);
if ( ret == -ERESTART )
ret = hypercall_create_continuation(
__HYPERVISOR_domctl, ""h"", u_domctl);
goto domctl_out_unlock_domonly;
case XEN_DOMCTL_setnodeaffinity:
{
nodemask_t new_affinity;
ret = xenctl_bitmap_to_nodemask(&new_affinity,
&op->u.nodeaffinity.nodemap);
if ( !ret )
ret = domain_set_node_affinity(d, &new_affinity);
break;
}
case XEN_DOMCTL_getnodeaffinity:
ret = nodemask_to_xenctl_bitmap(&op->u.nodeaffinity.nodemap,
&d->node_affinity);
break;
case XEN_DOMCTL_setvcpuaffinity:
case XEN_DOMCTL_getvcpuaffinity:
{
struct vcpu *v;
const struct sched_unit *unit;
struct xen_domctl_vcpuaffinity *vcpuaff = &op->u.vcpuaffinity;
ret = -EINVAL;
if ( vcpuaff->vcpu >= d->max_vcpus )
break;
ret = -ESRCH;
if ( (v = d->vcpu[vcpuaff->vcpu]) == NULL )
break;
unit = v->sched_unit;
ret = -EINVAL;
if ( vcpuaffinity_params_invalid(vcpuaff) )
break;
if ( op->cmd == XEN_DOMCTL_setvcpuaffinity )
{
cpumask_var_t new_affinity, old_affinity;
cpumask_t *online = cpupool_domain_master_cpumask(v->domain);
if ( !alloc_cpumask_var(&old_affinity) )
{
ret = -ENOMEM;
break;
}
cpumask_copy(old_affinity, unit->cpu_hard_affinity);
if ( !alloc_cpumask_var(&new_affinity) )
{
free_cpumask_var(old_affinity);
ret = -ENOMEM;
break;
}
if ( vcpuaff->flags & XEN_VCPUAFFINITY_FORCE )
vcpu_temporary_affinity(v, NR_CPUS, VCPU_AFFINITY_OVERRIDE);
ret = 0;
if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )
{
ret = xenctl_bitmap_to_bitmap(cpumask_bits(new_affinity),
&vcpuaff->cpumap_hard,
nr_cpu_ids);
if ( !ret )
ret = vcpu_set_hard_affinity(v, new_affinity);
if ( ret )
goto setvcpuaffinity_out;
cpumask_and(new_affinity, online, unit->cpu_hard_affinity);
ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_hard,
new_affinity);
}
if ( vcpuaff->flags & XEN_VCPUAFFINITY_SOFT )
{
ret = xenctl_bitmap_to_bitmap(cpumask_bits(new_affinity),
&vcpuaff->cpumap_soft,
nr_cpu_ids);
if ( !ret)
ret = vcpu_set_soft_affinity(v, new_affinity);
if ( ret )
{
if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )
vcpu_set_hard_affinity(v, old_affinity);
goto setvcpuaffinity_out;
}
cpumask_and(new_affinity, new_affinity, online);
cpumask_and(new_affinity, new_affinity,
unit->cpu_hard_affinity);
ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_soft,
new_affinity);
}
setvcpuaffinity_out:
free_cpumask_var(new_affinity);
free_cpumask_var(old_affinity);
}
else
{
if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )
ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_hard,
unit->cpu_hard_affinity);
if ( vcpuaff->flags & XEN_VCPUAFFINITY_SOFT )
ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_soft,
unit->cpu_soft_affinity);
}
break;
}
case XEN_DOMCTL_scheduler_op:
ret = sched_adjust(d, &op->u.scheduler_op);
copyback = 1;
break;
case XEN_DOMCTL_getdomaininfo:
{
domid_t dom = DOMID_INVALID;
if ( !d )
{
ret = -EINVAL;
if ( op->domain >= DOMID_FIRST_RESERVED )
break;
rcu_read_lock(&domlist_read_lock);
dom = op->domain;
for_each_domain ( d )
if ( d->domain_id >= dom )
break;
}
ret = -ESRCH;
if ( d == NULL )
goto getdomaininfo_out;
ret = xsm_getdomaininfo(XSM_HOOK, d);
if ( ret )
goto getdomaininfo_out;
getdomaininfo(d, &op->u.getdomaininfo);
op->domain = op->u.getdomaininfo.domain;
copyback = 1;
getdomaininfo_out:
if ( dom == DOMID_INVALID )
break;
rcu_read_unlock(&domlist_read_lock);
d = NULL;
break;
}
case XEN_DOMCTL_getvcpucontext:
{
vcpu_guest_context_u c = { .nat = NULL };
struct vcpu         *v;
ret = -EINVAL;
if ( op->u.vcpucontext.vcpu >= d->max_vcpus ||
(v = d->vcpu[op->u.vcpucontext.vcpu]) == NULL ||
v == current ) 
goto getvcpucontext_out;
ret = -ENODATA;
if ( !v->is_initialised )
goto getvcpucontext_out;
#ifdef CONFIG_COMPAT
BUILD_BUG_ON(sizeof(struct vcpu_guest_context)
< sizeof(struct compat_vcpu_guest_context));
#endif
ret = -ENOMEM;
if ( (c.nat = xzalloc(struct vcpu_guest_context)) == NULL )
goto getvcpucontext_out;
vcpu_pause(v);
arch_get_info_guest(v, c);
ret = 0;
vcpu_unpause(v);
#ifdef CONFIG_COMPAT
if ( !is_pv_32bit_domain(d) )
ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);
else
ret = copy_to_guest(guest_handle_cast(op->u.vcpucontext.ctxt,
void), c.cmp, 1);
#else
ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);
#endif
if ( ret )
ret = -EFAULT;
copyback = 1;
getvcpucontext_out:
xfree(c.nat);
break;
}
case XEN_DOMCTL_getvcpuinfo:
{
struct vcpu   *v;
struct vcpu_runstate_info runstate;
ret = -EINVAL;
if ( op->u.getvcpuinfo.vcpu >= d->max_vcpus )
break;
ret = -ESRCH;
if ( (v = d->vcpu[op->u.getvcpuinfo.vcpu]) == NULL )
break;
vcpu_runstate_get(v, &runstate);
op->u.getvcpuinfo.online   = !(v->pause_flags & VPF_down);
op->u.getvcpuinfo.blocked  = !!(v->pause_flags & VPF_blocked);
op->u.getvcpuinfo.running  = v->is_running;
op->u.getvcpuinfo.cpu_time = runstate.time[RUNSTATE_running];
op->u.getvcpuinfo.cpu      = v->processor;
ret = 0;
copyback = 1;
break;
}
case XEN_DOMCTL_max_mem:
{
uint64_t new_max = op->u.max_mem.max_memkb >> (PAGE_SHIFT - 10);
spin_lock(&d->page_alloc_lock);
d->max_pages = min(new_max, (uint64_t)(typeof(d->max_pages))-1);
spin_unlock(&d->page_alloc_lock);
break;
}
case XEN_DOMCTL_setdomainhandle:
memcpy(d->handle, op->u.setdomainhandle.handle,
sizeof(xen_domain_handle_t));
break;
case XEN_DOMCTL_setdebugging:
if ( unlikely(d == current->domain) ) 
ret = -EINVAL;
else
{
domain_pause(d);
d->debugger_attached = !!op->u.setdebugging.enable;
domain_unpause(d); 
}
break;
case XEN_DOMCTL_irq_permission:
{
unsigned int pirq = op->u.irq_permission.pirq, irq;
int allow = op->u.irq_permission.allow_access;
if ( pirq >= current->domain->nr_pirqs )
{
ret = -EINVAL;
break;
}
irq = pirq_access_permitted(current->domain, pirq);
if ( !irq || xsm_irq_permission(XSM_HOOK, d, irq, allow) )
ret = -EPERM;
else if ( allow )
ret = irq_permit_access(d, irq);
else
ret = irq_deny_access(d, irq);
break;
}
case XEN_DOMCTL_iomem_permission:
{
unsigned long mfn = op->u.iomem_permission.first_mfn;
unsigned long nr_mfns = op->u.iomem_permission.nr_mfns;
int allow = op->u.iomem_permission.allow_access;
ret = -EINVAL;
if ( (mfn + nr_mfns - 1) < mfn ) 
break;
if ( !iomem_access_permitted(current->domain,
mfn, mfn + nr_mfns - 1) ||
xsm_iomem_permission(XSM_HOOK, d, mfn, mfn + nr_mfns - 1, allow) )
ret = -EPERM;
else if ( allow )
ret = iomem_permit_access(d, mfn, mfn + nr_mfns - 1);
else
ret = iomem_deny_access(d, mfn, mfn + nr_mfns - 1);
if ( !ret )
memory_type_changed(d);
break;
}
case XEN_DOMCTL_memory_mapping:
{
unsigned long gfn = op->u.memory_mapping.first_gfn;
unsigned long mfn = op->u.memory_mapping.first_mfn;
unsigned long nr_mfns = op->u.memory_mapping.nr_mfns;
unsigned long mfn_end = mfn + nr_mfns - 1;
int add = op->u.memory_mapping.add_mapping;
ret = -EINVAL;
if ( mfn_end < mfn || 
((mfn | mfn_end) >> (paddr_bits - PAGE_SHIFT)) ||
(gfn + nr_mfns - 1) < gfn ) 
break;
#ifndef CONFIG_X86 
ret = -E2BIG;
if ( nr_mfns > 64 )
break;
#endif
ret = -EPERM;
if ( !iomem_access_permitted(current->domain, mfn, mfn_end) ||
!iomem_access_permitted(d, mfn, mfn_end) )
break;
ret = xsm_iomem_mapping(XSM_HOOK, d, mfn, mfn_end, add);
if ( ret )
break;
if ( add )
{
printk(XENLOG_G_DEBUG
""memory_map:add: dom%d gfn=%lx mfn=%lx nr=%lx\n"",
d->domain_id, gfn, mfn, nr_mfns);
ret = map_mmio_regions(d, _gfn(gfn), nr_mfns, _mfn(mfn));
if ( ret < 0 )
printk(XENLOG_G_WARNING
""memory_map:fail: dom%d gfn=%lx mfn=%lx nr=%lx ret:%ld\n"",
d->domain_id, gfn, mfn, nr_mfns, ret);
}
else
{
printk(XENLOG_G_DEBUG
""memory_map:remove: dom%d gfn=%lx mfn=%lx nr=%lx\n"",
d->domain_id, gfn, mfn, nr_mfns);
ret = unmap_mmio_regions(d, _gfn(gfn), nr_mfns, _mfn(mfn));
if ( ret < 0 && is_hardware_domain(current->domain) )
printk(XENLOG_ERR
""memory_map: error %ld removing dom%d access to [%lx,%lx]\n"",
ret, d->domain_id, mfn, mfn_end);
}
memory_type_changed(d);
break;
}
case XEN_DOMCTL_settimeoffset:
domain_set_time_offset(d, op->u.settimeoffset.time_offset_seconds);
break;
case XEN_DOMCTL_set_target:
{
struct domain *e;
ret = -ESRCH;
e = get_domain_by_id(op->u.set_target.target);
if ( e == NULL )
break;
ret = -EINVAL;
if ( (d == e) || (d->target != NULL) )
{
put_domain(e);
break;
}
ret = -EOPNOTSUPP;
if ( is_hvm_domain(e) )
ret = xsm_set_target(XSM_HOOK, d, e);
if ( ret )
{
put_domain(e);
break;
}
d->target = e;
break;
}
case XEN_DOMCTL_subscribe:
d->suspend_evtchn = op->u.subscribe.port;
break;
case XEN_DOMCTL_vm_event_op:
ret = vm_event_domctl(d, &op->u.vm_event_op);
if ( ret == 0 )
copyback = true;
break;
#ifdef CONFIG_MEM_ACCESS
case XEN_DOMCTL_set_access_required:
if ( unlikely(current->domain == d) ) 
ret = -EPERM;
else
{
domain_pause(d);
arch_p2m_set_access_required(d,
op->u.access_required.access_required);
domain_unpause(d);
}
break;
#endif
case XEN_DOMCTL_set_virq_handler:
ret = set_global_virq_handler(d, op->u.set_virq_handler.virq);
break;
case XEN_DOMCTL_setvnumainfo:
{
struct vnuma_info *vnuma;
vnuma = vnuma_init(&op->u.vnuma, d);
if ( IS_ERR(vnuma) )
{
ret = PTR_ERR(vnuma);
break;
}
write_lock(&d->vnuma_rwlock);
vnuma_destroy(d->vnuma);
d->vnuma = vnuma;
write_unlock(&d->vnuma_rwlock);
break;
}
case XEN_DOMCTL_monitor_op:
ret = monitor_domctl(d, &op->u.monitor_op);
if ( !ret )
copyback = 1;
break;
default:
ret = arch_do_domctl(op, d, u_domctl);
break;
}
domctl_lock_release();
domctl_out_unlock_domonly:
if ( d )
rcu_unlock_domain(d);
if ( copyback && __copy_to_guest(u_domctl, op, 1) )
ret = -EFAULT;
return ret;
}","long do_domctl(VAR_0(xen_domctl_t) VAR_1)
{
long VAR_2 = 0;
bool_t VAR_3 = 0;
struct xen_domctl VAR_4, *VAR_5 = &VAR_4;
struct domain *VAR_6;
if ( copy_from_guest(VAR_5, VAR_1, 1) )
return -VAR_7;
if ( VAR_5->interface_version != VAR_8 )
return -VAR_9;
switch ( VAR_5->cmd )
{
case VAR_10:
case VAR_11:
if ( VAR_5->domain == VAR_12 )
{
case VAR_13:
case VAR_14:
VAR_6 = NULL;
break;
}
default:
VAR_6 = rcu_lock_domain_by_id(VAR_5->domain);
if ( !VAR_6 && VAR_5->cmd != VAR_15 )
return -VAR_16;
}
VAR_2 = xsm_domctl(VAR_17, VAR_6, VAR_5->cmd);
if ( VAR_2 )
goto domctl_out_unlock_domonly;
if ( !domctl_lock_acquire() )
{
if ( VAR_6 )
rcu_unlock_domain(VAR_6);
return hypercall_create_continuation(
VAR_18, ""h"", VAR_1);
}
switch ( VAR_5->cmd )
{
case VAR_19:
{
vcpu_guest_context_u VAR_20 = { .nat = NULL };
unsigned int VAR_21 = VAR_5->u.vcpucontext.vcpu;
struct vcpu *VAR_22;
VAR_2 = -VAR_23;
if ( (VAR_6 == VAR_24->domain) || 
(vcpu >= VAR_6->max_vcpus) || ((VAR_22 = VAR_6->vcpu[vcpu]) == NULL) )
break;
if ( guest_handle_is_null(VAR_5->u.vcpucontext.ctxt) )
{
VAR_2 = vcpu_reset(VAR_22);
if ( VAR_2 == -VAR_25 )
VAR_2 = hypercall_create_continuation(
VAR_18, ""h"", VAR_1);
break;
}
#ifdef VAR_26
BUILD_BUG_ON(sizeof(struct vcpu_guest_context)
< sizeof(struct compat_vcpu_guest_context));
#endif
VAR_2 = -VAR_27;
if ( (VAR_20.nat = alloc_vcpu_guest_context()) == NULL )
break;
#ifdef VAR_26
if ( !is_pv_32bit_domain(VAR_6) )
VAR_2 = copy_from_guest(VAR_20.nat, VAR_5->u.vcpucontext.ctxt, 1);
else
VAR_2 = copy_from_guest(VAR_20.cmp,
guest_handle_cast(VAR_5->u.vcpucontext.ctxt,
VAR_28), 1);
#else
VAR_2 = copy_from_guest(VAR_20.nat, VAR_5->u.vcpucontext.ctxt, 1);
#endif
VAR_2 = VAR_2 ? -VAR_7 : 0;
if ( VAR_2 == 0 )
{
domain_pause(VAR_6);
VAR_2 = arch_set_info_guest(VAR_22, VAR_20);
domain_unpause(VAR_6);
if ( VAR_2 == -VAR_25 )
VAR_2 = hypercall_create_continuation(
VAR_18, ""h"", VAR_1);
}
free_vcpu_guest_context(VAR_20.nat);
break;
}
case VAR_29:
VAR_2 = -VAR_23;
if ( VAR_6 != VAR_24->domain )
VAR_2 = domain_pause_by_systemcontroller(VAR_6);
break;
case VAR_30:
VAR_2 = domain_unpause_by_systemcontroller(VAR_6);
break;
case VAR_31:
if ( VAR_6 == VAR_24->domain ) 
VAR_2 = -VAR_23;
else
domain_resume(VAR_6);
break;
case VAR_13:
{
domid_t        VAR_32;
static domid_t VAR_33 = 0;
VAR_32 = VAR_5->domain;
if ( (VAR_32 > 0) && (VAR_32 < VAR_34) )
{
VAR_2 = -VAR_23;
if ( !is_free_domid(VAR_32) )
break;
}
else
{
for ( VAR_32 = VAR_33 + 1; VAR_32 != VAR_33; VAR_32++ )
{
if ( VAR_32 == VAR_34 )
VAR_32 = 1;
if ( is_free_domid(VAR_32) )
break;
}
VAR_2 = -VAR_27;
if ( VAR_32 == VAR_33 )
break;
VAR_33 = VAR_32;
}
VAR_6 = domain_create(VAR_32, &VAR_5->u.createdomain, false);
if ( IS_ERR(VAR_6) )
{
VAR_2 = PTR_ERR(VAR_6);
VAR_6 = NULL;
break;
}
VAR_2 = 0;
VAR_5->domain = VAR_6->domain_id;
VAR_3 = 1;
VAR_6 = NULL;
break;
}
case VAR_35:
{
unsigned int VAR_36, VAR_37 = VAR_5->u.max_vcpus.max;
VAR_2 = -VAR_23;
if ( (VAR_6 == VAR_24->domain) || 
(VAR_37 != VAR_6->max_vcpus) )   
break;
domain_pause(VAR_6);
VAR_2 = -VAR_27;
for ( VAR_36 = 0; VAR_36 < VAR_37; VAR_36++ )
{
if ( VAR_6->vcpu[VAR_36] != NULL )
continue;
if ( vcpu_create(VAR_6, VAR_36) == NULL )
goto maxvcpu_out;
}
domain_update_node_affinity(VAR_6);
VAR_2 = 0;
maxvcpu_out:
domain_unpause(VAR_6);
break;
}
case VAR_38:
if ( VAR_6 == VAR_24->domain ) 
{
VAR_2 = -VAR_23;
break;
}
VAR_2 = domain_soft_reset(VAR_6);
break;
case VAR_39:
domctl_lock_release();
domain_lock(VAR_6);
VAR_2 = domain_kill(VAR_6);
domain_unlock(VAR_6);
if ( VAR_2 == -VAR_25 )
VAR_2 = hypercall_create_continuation(
VAR_18, ""h"", VAR_1);
goto domctl_out_unlock_domonly;
case VAR_40:
{
nodemask_t VAR_41;
VAR_2 = xenctl_bitmap_to_nodemask(&VAR_41,
&VAR_5->u.nodeaffinity.nodemap);
if ( !VAR_2 )
VAR_2 = domain_set_node_affinity(VAR_6, &VAR_41);
break;
}
case VAR_42:
VAR_2 = nodemask_to_xenctl_bitmap(&VAR_5->u.nodeaffinity.nodemap,
&VAR_6->node_affinity);
break;
case VAR_43:
case VAR_44:
{
struct vcpu *VAR_22;
const struct sched_unit *VAR_45;
struct xen_domctl_vcpuaffinity *VAR_46 = &VAR_5->u.vcpuaffinity;
VAR_2 = -VAR_23;
if ( VAR_46->vcpu >= VAR_6->max_vcpus )
break;
VAR_2 = -VAR_16;
if ( (VAR_22 = VAR_6->vcpu[VAR_46->vcpu]) == NULL )
break;
VAR_45 = VAR_22->sched_unit;
VAR_2 = -VAR_23;
if ( vcpuaffinity_params_invalid(VAR_46) )
break;
if ( VAR_5->cmd == VAR_43 )
{
cpumask_var_t VAR_41, VAR_47;
cpumask_t *VAR_48 = cpupool_domain_master_cpumask(VAR_22->domain);
if ( !alloc_cpumask_var(&VAR_47) )
{
VAR_2 = -VAR_27;
break;
}
cpumask_copy(VAR_47, VAR_45->cpu_hard_affinity);
if ( !alloc_cpumask_var(&VAR_41) )
{
free_cpumask_var(VAR_47);
VAR_2 = -VAR_27;
break;
}
if ( VAR_46->flags & VAR_49 )
vcpu_temporary_affinity(VAR_22, VAR_50, VAR_51);
VAR_2 = 0;
if ( VAR_46->flags & VAR_52 )
{
VAR_2 = xenctl_bitmap_to_bitmap(cpumask_bits(VAR_41),
&VAR_46->cpumap_hard,
VAR_53);
if ( !VAR_2 )
VAR_2 = vcpu_set_hard_affinity(VAR_22, VAR_41);
if ( VAR_2 )
goto setvcpuaffinity_out;
cpumask_and(VAR_41, VAR_48, VAR_45->cpu_hard_affinity);
VAR_2 = cpumask_to_xenctl_bitmap(&VAR_46->cpumap_hard,
VAR_41);
}
if ( VAR_46->flags & VAR_54 )
{
VAR_2 = xenctl_bitmap_to_bitmap(cpumask_bits(VAR_41),
&VAR_46->cpumap_soft,
VAR_53);
if ( !VAR_2)
VAR_2 = vcpu_set_soft_affinity(VAR_22, VAR_41);
if ( VAR_2 )
{
if ( VAR_46->flags & VAR_52 )
vcpu_set_hard_affinity(VAR_22, VAR_47);
goto setvcpuaffinity_out;
}
cpumask_and(VAR_41, VAR_41, VAR_48);
cpumask_and(VAR_41, VAR_41,
VAR_45->cpu_hard_affinity);
VAR_2 = cpumask_to_xenctl_bitmap(&VAR_46->cpumap_soft,
VAR_41);
}
setvcpuaffinity_out:
free_cpumask_var(VAR_41);
free_cpumask_var(VAR_47);
}
else
{
if ( VAR_46->flags & VAR_52 )
VAR_2 = cpumask_to_xenctl_bitmap(&VAR_46->cpumap_hard,
VAR_45->cpu_hard_affinity);
if ( VAR_46->flags & VAR_54 )
VAR_2 = cpumask_to_xenctl_bitmap(&VAR_46->cpumap_soft,
VAR_45->cpu_soft_affinity);
}
break;
}
case VAR_55:
VAR_2 = sched_adjust(VAR_6, &VAR_5->u.scheduler_op);
VAR_3 = 1;
break;
case VAR_15:
{
domid_t VAR_32 = VAR_12;
if ( !VAR_6 )
{
VAR_2 = -VAR_23;
if ( VAR_5->domain >= VAR_34 )
break;
rcu_read_lock(&VAR_56);
VAR_32 = VAR_5->domain;
VAR_57 ( d )
if ( d->VAR_58 >= VAR_32 )
break;
}
VAR_2 = -VAR_16;
if ( d == NULL )
goto getdomaininfo_out;
VAR_2 = xsm_getdomaininfo(VAR_59, d);
if ( VAR_2 )
goto getdomaininfo_out;
getdomaininfo(d, &VAR_5->u.getdomaininfo);
VAR_5->domain = VAR_5->u.getdomaininfo.domain;
VAR_3 = 1;
getdomaininfo_out:
if ( VAR_32 == VAR_12 )
break;
rcu_read_unlock(&VAR_56);
d = NULL;
break;
}
case VAR_60:
{
vcpu_guest_context_u VAR_20 = { .nat = NULL };
struct vcpu         *VAR_22;
VAR_2 = -VAR_23;
if ( VAR_5->u.vcpucontext.vcpu >= d->max_vcpus ||
(VAR_22 = d->vcpu[VAR_5->u.vcpucontext.vcpu]) == NULL ||
VAR_22 == VAR_24 ) 
goto getvcpucontext_out;
VAR_2 = -VAR_61;
if ( !VAR_22->is_initialised )
goto getvcpucontext_out;
#ifdef VAR_26
BUILD_BUG_ON(sizeof(struct vcpu_guest_context)
< sizeof(struct compat_vcpu_guest_context));
#endif
VAR_2 = -VAR_27;
if ( (VAR_20.nat = xzalloc(struct vcpu_guest_context)) == NULL )
goto getvcpucontext_out;
vcpu_pause(VAR_22);
arch_get_info_guest(VAR_22, VAR_20);
VAR_2 = 0;
vcpu_unpause(VAR_22);
#ifdef VAR_26
if ( !is_pv_32bit_domain(d) )
VAR_2 = copy_to_guest(VAR_5->u.vcpucontext.ctxt, VAR_20.nat, 1);
else
VAR_2 = copy_to_guest(guest_handle_cast(VAR_5->u.vcpucontext.ctxt,
VAR_28), VAR_20.cmp, 1);
#else
VAR_2 = copy_to_guest(VAR_5->u.vcpucontext.ctxt, VAR_20.nat, 1);
#endif
if ( VAR_2 )
VAR_2 = -VAR_7;
VAR_3 = 1;
getvcpucontext_out:
xfree(VAR_20.nat);
break;
}
case VAR_62:
{
struct vcpu   *VAR_22;
struct vcpu_runstate_info VAR_63;
VAR_2 = -VAR_23;
if ( VAR_5->u.getvcpuinfo.vcpu >= d->max_vcpus )
break;
VAR_2 = -VAR_16;
if ( (VAR_22 = d->vcpu[VAR_5->u.getvcpuinfo.vcpu]) == NULL )
break;
vcpu_runstate_get(VAR_22, &VAR_63);
VAR_5->u.getvcpuinfo.online   = !(VAR_22->pause_flags & VAR_64);
VAR_5->u.getvcpuinfo.blocked  = !!(VAR_22->pause_flags & VAR_65);
VAR_5->u.getvcpuinfo.running  = VAR_22->is_running;
VAR_5->u.getvcpuinfo.cpu_time = VAR_63.time[VAR_66];
VAR_5->u.getvcpuinfo.cpu      = VAR_22->processor;
VAR_2 = 0;
VAR_3 = 1;
break;
}
case VAR_67:
{
uint64_t VAR_68 = VAR_5->u.max_mem.max_memkb >> (VAR_69 - 10);
spin_lock(&d->page_alloc_lock);
d->max_pages = min(VAR_68, (uint64_t)(typeof(d->max_pages))-1);
spin_unlock(&d->page_alloc_lock);
break;
}
case VAR_70:
memcpy(d->handle, VAR_5->u.setdomainhandle.handle,
sizeof(VAR_71));
break;
case VAR_72:
if ( unlikely(d == VAR_24->domain) ) 
VAR_2 = -VAR_23;
else
{
domain_pause(d);
d->debugger_attached = !!VAR_5->u.setdebugging.enable;
domain_unpause(d); 
}
break;
case VAR_73:
{
unsigned int VAR_74 = VAR_5->u.irq_permission.pirq, VAR_75;
int VAR_76 = VAR_5->u.irq_permission.allow_access;
if ( VAR_74 >= VAR_24->domain->nr_pirqs )
{
VAR_2 = -VAR_23;
break;
}
VAR_75 = pirq_access_permitted(VAR_24->domain, VAR_74);
if ( !VAR_75 || xsm_irq_permission(VAR_59, d, VAR_75, VAR_76) )
VAR_2 = -VAR_77;
else if ( VAR_76 )
VAR_2 = irq_permit_access(d, VAR_75);
else
VAR_2 = irq_deny_access(d, VAR_75);
break;
}
case VAR_78:
{
unsigned long VAR_79 = VAR_5->u.iomem_permission.first_mfn;
unsigned long VAR_80 = VAR_5->u.iomem_permission.nr_mfns;
int VAR_76 = VAR_5->u.iomem_permission.allow_access;
VAR_2 = -VAR_23;
if ( (VAR_79 + VAR_80 - 1) < VAR_79 ) 
break;
if ( !iomem_access_permitted(VAR_24->domain,
VAR_79, VAR_79 + VAR_80 - 1) ||
xsm_iomem_permission(VAR_59, d, VAR_79, VAR_79 + VAR_80 - 1, VAR_76) )
VAR_2 = -VAR_77;
else if ( VAR_76 )
VAR_2 = iomem_permit_access(d, VAR_79, VAR_79 + VAR_80 - 1);
else
VAR_2 = iomem_deny_access(d, VAR_79, VAR_79 + VAR_80 - 1);
if ( !VAR_2 )
memory_type_changed(d);
break;
}
case VAR_81:
{
unsigned long VAR_82 = VAR_5->u.memory_mapping.first_gfn;
unsigned long VAR_79 = VAR_5->u.memory_mapping.first_mfn;
unsigned long VAR_80 = VAR_5->u.memory_mapping.nr_mfns;
unsigned long VAR_83 = VAR_79 + VAR_80 - 1;
int VAR_84 = VAR_5->u.memory_mapping.add_mapping;
VAR_2 = -VAR_23;
if ( VAR_83 < VAR_79 || 
((VAR_79 | VAR_83) >> (VAR_85 - VAR_69)) ||
(VAR_82 + VAR_80 - 1) < VAR_82 ) 
break;
#ifndef VAR_86 
VAR_2 = -VAR_87;
if ( VAR_80 > 64 )
break;
#endif
VAR_2 = -VAR_77;
if ( !iomem_access_permitted(VAR_24->domain, VAR_79, VAR_83) ||
!iomem_access_permitted(d, VAR_79, VAR_83) )
break;
VAR_2 = xsm_iomem_mapping(VAR_59, d, VAR_79, VAR_83, VAR_84);
if ( VAR_2 )
break;
if ( VAR_84 )
{
VAR_88(VAR_89
""memory_map:add: dom%d gfn=%lx mfn=%lx nr=%lx\n"",
d->domain_id, VAR_82, VAR_79, VAR_80);
VAR_2 = map_mmio_regions(d, _gfn(VAR_82), VAR_80, _mfn(VAR_79));
if ( VAR_2 < 0 )
VAR_88(XENLOG_G_WARNING
""memory_map:fail: dom%d gfn=%lx mfn=%lx nr=%lx ret:%ld\n"",
d->domain_id, VAR_82, VAR_79, VAR_80, VAR_2);
}
else
{
VAR_88(VAR_89
""memory_map:remove: dom%d gfn=%lx mfn=%lx nr=%lx\n"",
d->domain_id, VAR_82, VAR_79, VAR_80);
VAR_2 = unmap_mmio_regions(d, _gfn(VAR_82), VAR_80, _mfn(VAR_79));
if ( VAR_2 < 0 && is_hardware_domain(VAR_24->domain) )
VAR_88(XENLOG_ERR
""memory_map: error %ld removing dom%d access to [%lx,%lx]\n"",
VAR_2, d->domain_id, VAR_79, VAR_83);
}
memory_type_changed(d);
break;
}
case VAR_90:
domain_set_time_offset(d, VAR_5->u.settimeoffset.time_offset_seconds);
break;
case VAR_91:
{
struct domain *VAR_92;
VAR_2 = -VAR_16;
VAR_92 = get_domain_by_id(VAR_5->u.set_target.target);
if ( VAR_92 == NULL )
break;
VAR_2 = -VAR_23;
if ( (d == VAR_92) || (d->target != NULL) )
{
put_domain(VAR_92);
break;
}
VAR_2 = -VAR_93;
if ( is_hvm_domain(VAR_92) )
VAR_2 = xsm_set_target(VAR_59, d, VAR_92);
if ( VAR_2 )
{
put_domain(VAR_92);
break;
}
d->target = VAR_92;
break;
}
case VAR_94:
d->suspend_evtchn = VAR_5->u.subscribe.port;
break;
case VAR_11:
VAR_2 = vm_event_domctl(d, &VAR_5->u.vm_event_op);
if ( VAR_2 == 0 )
VAR_3 = true;
break;
#ifdef VAR_95
case VAR_96:
if ( unlikely(VAR_24->domain == d) ) 
VAR_2 = -VAR_77;
else
{
domain_pause(d);
arch_p2m_set_access_required(d,
VAR_5->u.access_required.access_required);
domain_unpause(d);
}
break;
#endif
case VAR_97:
VAR_2 = set_global_virq_handler(d, VAR_5->u.set_virq_handler.virq);
break;
case VAR_98:
{
struct vnuma_info *VAR_99;
VAR_99 = vnuma_init(&VAR_5->u.vnuma, d);
if ( IS_ERR(VAR_99) )
{
VAR_2 = PTR_ERR(VAR_99);
break;
}
write_lock(&d->vnuma_rwlock);
vnuma_destroy(d->vnuma);
d->vnuma = VAR_99;
write_unlock(&d->vnuma_rwlock);
break;
}
case VAR_100:
VAR_2 = monitor_domctl(d, &VAR_5->u.monitor_op);
if ( !VAR_2 )
VAR_3 = 1;
break;
default:
VAR_2 = arch_do_domctl(VAR_5, d, VAR_1);
break;
}
domctl_lock_release();
domctl_out_unlock_domonly:
if ( d )
rcu_unlock_domain(d);
if ( VAR_3 && __copy_to_guest(VAR_1, VAR_5, 1) )
VAR_2 = -VAR_7;
return VAR_2;
}",,"long do_domctl(XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)
{
    long ret = 0;
    bool_t copyback = 0;
    struct xen_domctl curop, *op = &curop;
    struct domain *d;

    if ( copy_from_guest(op, u_domctl, 1) )
        return -EFAULT;

    if ( op->interface_version != XEN_DOMCTL_INTERFACE_VERSION )
        return -EACCES;

    switch ( op->cmd )
    {
    case XEN_DOMCTL_assign_device:
    case XEN_DOMCTL_deassign_device:
        if ( op->domain == DOMID_IO )
        {
            d = dom_io;
            break;
        }
        else if ( op->domain == DOMID_INVALID )
            return -ESRCH;
        /* fall through */
    case XEN_DOMCTL_test_assign_device:
    case XEN_DOMCTL_vm_event_op:
        if ( op->domain == DOMID_INVALID )
        {
    case XEN_DOMCTL_createdomain:
    case XEN_DOMCTL_gdbsx_guestmemio:
            d = NULL;
            break;
        }
        /* fall through */
    default:
        d = rcu_lock_domain_by_id(op->domain);
        if ( !d && op->cmd != XEN_DOMCTL_getdomaininfo )
            return -ESRCH;
    }

    ret = xsm_domctl(XSM_OTHER, d, op->cmd);
    if ( ret )
        goto domctl_out_unlock_domonly;

    if ( !domctl_lock_acquire() )
    {
        if ( d && d != dom_io )
            rcu_unlock_domain(d);
        return hypercall_create_continuation(
            __HYPERVISOR_domctl, ""h"", u_domctl);
    }

    switch ( op->cmd )
    {

    case XEN_DOMCTL_setvcpucontext:
    {
        vcpu_guest_context_u c = { .nat = NULL };
        unsigned int vcpu = op->u.vcpucontext.vcpu;
        struct vcpu *v;

        ret = -EINVAL;
        if ( (d == current->domain) || /* no domain_pause() */
             (vcpu >= d->max_vcpus) || ((v = d->vcpu[vcpu]) == NULL) )
            break;

        if ( guest_handle_is_null(op->u.vcpucontext.ctxt) )
        {
            ret = vcpu_reset(v);
            if ( ret == -ERESTART )
                ret = hypercall_create_continuation(
                          __HYPERVISOR_domctl, ""h"", u_domctl);
            break;
        }

#ifdef CONFIG_COMPAT
        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)
                     < sizeof(struct compat_vcpu_guest_context));
#endif
        ret = -ENOMEM;
        if ( (c.nat = alloc_vcpu_guest_context()) == NULL )
            break;

#ifdef CONFIG_COMPAT
        if ( !is_pv_32bit_domain(d) )
            ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);
        else
            ret = copy_from_guest(c.cmp,
                                  guest_handle_cast(op->u.vcpucontext.ctxt,
                                                    void), 1);
#else
        ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);
#endif
        ret = ret ? -EFAULT : 0;

        if ( ret == 0 )
        {
            domain_pause(d);
            ret = arch_set_info_guest(v, c);
            domain_unpause(d);

            if ( ret == -ERESTART )
                ret = hypercall_create_continuation(
                          __HYPERVISOR_domctl, ""h"", u_domctl);
        }

        free_vcpu_guest_context(c.nat);
        break;
    }

    case XEN_DOMCTL_pausedomain:
        ret = -EINVAL;
        if ( d != current->domain )
            ret = domain_pause_by_systemcontroller(d);
        break;

    case XEN_DOMCTL_unpausedomain:
        ret = domain_unpause_by_systemcontroller(d);
        break;

    case XEN_DOMCTL_resumedomain:
        if ( d == current->domain ) /* no domain_pause() */
            ret = -EINVAL;
        else
            domain_resume(d);
        break;

    case XEN_DOMCTL_createdomain:
    {
        domid_t        dom;
        static domid_t rover = 0;

        dom = op->domain;
        if ( (dom > 0) && (dom < DOMID_FIRST_RESERVED) )
        {
            ret = -EINVAL;
            if ( !is_free_domid(dom) )
                break;
        }
        else
        {
            for ( dom = rover + 1; dom != rover; dom++ )
            {
                if ( dom == DOMID_FIRST_RESERVED )
                    dom = 1;
                if ( is_free_domid(dom) )
                    break;
            }

            ret = -ENOMEM;
            if ( dom == rover )
                break;

            rover = dom;
        }

        d = domain_create(dom, &op->u.createdomain, false);
        if ( IS_ERR(d) )
        {
            ret = PTR_ERR(d);
            d = NULL;
            break;
        }

        ret = 0;
        op->domain = d->domain_id;
        copyback = 1;
        d = NULL;
        break;
    }

    case XEN_DOMCTL_max_vcpus:
    {
        unsigned int i, max = op->u.max_vcpus.max;

        ret = -EINVAL;
        if ( (d == current->domain) || /* no domain_pause() */
             (max != d->max_vcpus) )   /* max_vcpus set up in createdomain */
            break;

        /* Needed, for example, to ensure writable p.t. state is synced. */
        domain_pause(d);

        ret = -ENOMEM;

        for ( i = 0; i < max; i++ )
        {
            if ( d->vcpu[i] != NULL )
                continue;

            if ( vcpu_create(d, i) == NULL )
                goto maxvcpu_out;
        }

        domain_update_node_affinity(d);
        ret = 0;

    maxvcpu_out:
        domain_unpause(d);
        break;
    }

    case XEN_DOMCTL_soft_reset:
        if ( d == current->domain ) /* no domain_pause() */
        {
            ret = -EINVAL;
            break;
        }
        ret = domain_soft_reset(d);
        break;

    case XEN_DOMCTL_destroydomain:
        domctl_lock_release();
        domain_lock(d);
        ret = domain_kill(d);
        domain_unlock(d);
        if ( ret == -ERESTART )
            ret = hypercall_create_continuation(
                __HYPERVISOR_domctl, ""h"", u_domctl);
        goto domctl_out_unlock_domonly;

    case XEN_DOMCTL_setnodeaffinity:
    {
        nodemask_t new_affinity;

        ret = xenctl_bitmap_to_nodemask(&new_affinity,
                                        &op->u.nodeaffinity.nodemap);
        if ( !ret )
            ret = domain_set_node_affinity(d, &new_affinity);
        break;
    }

    case XEN_DOMCTL_getnodeaffinity:
        ret = nodemask_to_xenctl_bitmap(&op->u.nodeaffinity.nodemap,
                                        &d->node_affinity);
        break;

    case XEN_DOMCTL_setvcpuaffinity:
    case XEN_DOMCTL_getvcpuaffinity:
    {
        struct vcpu *v;
        const struct sched_unit *unit;
        struct xen_domctl_vcpuaffinity *vcpuaff = &op->u.vcpuaffinity;

        ret = -EINVAL;
        if ( vcpuaff->vcpu >= d->max_vcpus )
            break;

        ret = -ESRCH;
        if ( (v = d->vcpu[vcpuaff->vcpu]) == NULL )
            break;

        unit = v->sched_unit;
        ret = -EINVAL;
        if ( vcpuaffinity_params_invalid(vcpuaff) )
            break;

        if ( op->cmd == XEN_DOMCTL_setvcpuaffinity )
        {
            cpumask_var_t new_affinity, old_affinity;
            cpumask_t *online = cpupool_domain_master_cpumask(v->domain);

            /*
             * We want to be able to restore hard affinity if we are trying
             * setting both and changing soft affinity (which happens later,
             * when hard affinity has been succesfully chaged already) fails.
             */
            if ( !alloc_cpumask_var(&old_affinity) )
            {
                ret = -ENOMEM;
                break;
            }
            cpumask_copy(old_affinity, unit->cpu_hard_affinity);

            if ( !alloc_cpumask_var(&new_affinity) )
            {
                free_cpumask_var(old_affinity);
                ret = -ENOMEM;
                break;
            }

            /* Undo a stuck SCHED_pin_override? */
            if ( vcpuaff->flags & XEN_VCPUAFFINITY_FORCE )
                vcpu_temporary_affinity(v, NR_CPUS, VCPU_AFFINITY_OVERRIDE);

            ret = 0;

            /*
             * We both set a new affinity and report back to the caller what
             * the scheduler will be effectively using.
             */
            if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )
            {
                ret = xenctl_bitmap_to_bitmap(cpumask_bits(new_affinity),
                                              &vcpuaff->cpumap_hard,
                                              nr_cpu_ids);
                if ( !ret )
                    ret = vcpu_set_hard_affinity(v, new_affinity);
                if ( ret )
                    goto setvcpuaffinity_out;

                /*
                 * For hard affinity, what we return is the intersection of
                 * cpupool's online mask and the new hard affinity.
                 */
                cpumask_and(new_affinity, online, unit->cpu_hard_affinity);
                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_hard,
                                               new_affinity);
            }
            if ( vcpuaff->flags & XEN_VCPUAFFINITY_SOFT )
            {
                ret = xenctl_bitmap_to_bitmap(cpumask_bits(new_affinity),
                                              &vcpuaff->cpumap_soft,
                                              nr_cpu_ids);
                if ( !ret)
                    ret = vcpu_set_soft_affinity(v, new_affinity);
                if ( ret )
                {
                    /*
                     * Since we're returning error, the caller expects nothing
                     * happened, so we rollback the changes to hard affinity
                     * (if any).
                     */
                    if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )
                        vcpu_set_hard_affinity(v, old_affinity);
                    goto setvcpuaffinity_out;
                }

                /*
                 * For soft affinity, we return the intersection between the
                 * new soft affinity, the cpupool's online map and the (new)
                 * hard affinity.
                 */
                cpumask_and(new_affinity, new_affinity, online);
                cpumask_and(new_affinity, new_affinity,
                            unit->cpu_hard_affinity);
                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_soft,
                                               new_affinity);
            }

 setvcpuaffinity_out:
            free_cpumask_var(new_affinity);
            free_cpumask_var(old_affinity);
        }
        else
        {
            if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )
                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_hard,
                                               unit->cpu_hard_affinity);
            if ( vcpuaff->flags & XEN_VCPUAFFINITY_SOFT )
                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_soft,
                                               unit->cpu_soft_affinity);
        }
        break;
    }

    case XEN_DOMCTL_scheduler_op:
        ret = sched_adjust(d, &op->u.scheduler_op);
        copyback = 1;
        break;

    case XEN_DOMCTL_getdomaininfo:
    {
        domid_t dom = DOMID_INVALID;

        if ( !d )
        {
            ret = -EINVAL;
            if ( op->domain >= DOMID_FIRST_RESERVED )
                break;

            rcu_read_lock(&domlist_read_lock);

            dom = op->domain;
            for_each_domain ( d )
                if ( d->domain_id >= dom )
                    break;
        }

        ret = -ESRCH;
        if ( d == NULL )
            goto getdomaininfo_out;

        ret = xsm_getdomaininfo(XSM_HOOK, d);
        if ( ret )
            goto getdomaininfo_out;

        getdomaininfo(d, &op->u.getdomaininfo);

        op->domain = op->u.getdomaininfo.domain;
        copyback = 1;

    getdomaininfo_out:
        /* When d was non-NULL upon entry, no cleanup is needed. */
        if ( dom == DOMID_INVALID )
            break;

        rcu_read_unlock(&domlist_read_lock);
        d = NULL;
        break;
    }

    case XEN_DOMCTL_getvcpucontext:
    {
        vcpu_guest_context_u c = { .nat = NULL };
        struct vcpu         *v;

        ret = -EINVAL;
        if ( op->u.vcpucontext.vcpu >= d->max_vcpus ||
             (v = d->vcpu[op->u.vcpucontext.vcpu]) == NULL ||
             v == current ) /* no vcpu_pause() */
            goto getvcpucontext_out;

        ret = -ENODATA;
        if ( !v->is_initialised )
            goto getvcpucontext_out;

#ifdef CONFIG_COMPAT
        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)
                     < sizeof(struct compat_vcpu_guest_context));
#endif
        ret = -ENOMEM;
        if ( (c.nat = xzalloc(struct vcpu_guest_context)) == NULL )
            goto getvcpucontext_out;

        vcpu_pause(v);

        arch_get_info_guest(v, c);
        ret = 0;

        vcpu_unpause(v);

#ifdef CONFIG_COMPAT
        if ( !is_pv_32bit_domain(d) )
            ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);
        else
            ret = copy_to_guest(guest_handle_cast(op->u.vcpucontext.ctxt,
                                                  void), c.cmp, 1);
#else
        ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);
#endif

        if ( ret )
            ret = -EFAULT;
        copyback = 1;

    getvcpucontext_out:
        xfree(c.nat);
        break;
    }

    case XEN_DOMCTL_getvcpuinfo:
    {
        struct vcpu   *v;
        struct vcpu_runstate_info runstate;

        ret = -EINVAL;
        if ( op->u.getvcpuinfo.vcpu >= d->max_vcpus )
            break;

        ret = -ESRCH;
        if ( (v = d->vcpu[op->u.getvcpuinfo.vcpu]) == NULL )
            break;

        vcpu_runstate_get(v, &runstate);

        op->u.getvcpuinfo.online   = !(v->pause_flags & VPF_down);
        op->u.getvcpuinfo.blocked  = !!(v->pause_flags & VPF_blocked);
        op->u.getvcpuinfo.running  = v->is_running;
        op->u.getvcpuinfo.cpu_time = runstate.time[RUNSTATE_running];
        op->u.getvcpuinfo.cpu      = v->processor;
        ret = 0;
        copyback = 1;
        break;
    }

    case XEN_DOMCTL_max_mem:
    {
        uint64_t new_max = op->u.max_mem.max_memkb >> (PAGE_SHIFT - 10);

        spin_lock(&d->page_alloc_lock);
        /*
         * NB. We removed a check that new_max >= current tot_pages; this means
         * that the domain will now be allowed to ""ratchet"" down to new_max. In
         * the meantime, while tot > max, all new allocations are disallowed.
         */
        d->max_pages = min(new_max, (uint64_t)(typeof(d->max_pages))-1);
        spin_unlock(&d->page_alloc_lock);
        break;
    }

    case XEN_DOMCTL_setdomainhandle:
        memcpy(d->handle, op->u.setdomainhandle.handle,
               sizeof(xen_domain_handle_t));
        break;

    case XEN_DOMCTL_setdebugging:
        if ( unlikely(d == current->domain) ) /* no domain_pause() */
            ret = -EINVAL;
        else
        {
            domain_pause(d);
            d->debugger_attached = !!op->u.setdebugging.enable;
            domain_unpause(d); /* causes guest to latch new status */
        }
        break;

    case XEN_DOMCTL_irq_permission:
    {
        unsigned int pirq = op->u.irq_permission.pirq, irq;
        int allow = op->u.irq_permission.allow_access;

        if ( pirq >= current->domain->nr_pirqs )
        {
            ret = -EINVAL;
            break;
        }
        irq = pirq_access_permitted(current->domain, pirq);
        if ( !irq || xsm_irq_permission(XSM_HOOK, d, irq, allow) )
            ret = -EPERM;
        else if ( allow )
            ret = irq_permit_access(d, irq);
        else
            ret = irq_deny_access(d, irq);
        break;
    }

    case XEN_DOMCTL_iomem_permission:
    {
        unsigned long mfn = op->u.iomem_permission.first_mfn;
        unsigned long nr_mfns = op->u.iomem_permission.nr_mfns;
        int allow = op->u.iomem_permission.allow_access;

        ret = -EINVAL;
        if ( (mfn + nr_mfns - 1) < mfn ) /* wrap? */
            break;

        if ( !iomem_access_permitted(current->domain,
                                     mfn, mfn + nr_mfns - 1) ||
             xsm_iomem_permission(XSM_HOOK, d, mfn, mfn + nr_mfns - 1, allow) )
            ret = -EPERM;
        else if ( allow )
            ret = iomem_permit_access(d, mfn, mfn + nr_mfns - 1);
        else
            ret = iomem_deny_access(d, mfn, mfn + nr_mfns - 1);
        if ( !ret )
            memory_type_changed(d);
        break;
    }

    case XEN_DOMCTL_memory_mapping:
    {
        unsigned long gfn = op->u.memory_mapping.first_gfn;
        unsigned long mfn = op->u.memory_mapping.first_mfn;
        unsigned long nr_mfns = op->u.memory_mapping.nr_mfns;
        unsigned long mfn_end = mfn + nr_mfns - 1;
        int add = op->u.memory_mapping.add_mapping;

        ret = -EINVAL;
        if ( mfn_end < mfn || /* wrap? */
             ((mfn | mfn_end) >> (paddr_bits - PAGE_SHIFT)) ||
             (gfn + nr_mfns - 1) < gfn ) /* wrap? */
            break;

#ifndef CONFIG_X86 /* XXX ARM!? */
        ret = -E2BIG;
        /* Must break hypercall up as this could take a while. */
        if ( nr_mfns > 64 )
            break;
#endif

        ret = -EPERM;
        if ( !iomem_access_permitted(current->domain, mfn, mfn_end) ||
             !iomem_access_permitted(d, mfn, mfn_end) )
            break;

        ret = xsm_iomem_mapping(XSM_HOOK, d, mfn, mfn_end, add);
        if ( ret )
            break;

        if ( add )
        {
            printk(XENLOG_G_DEBUG
                   ""memory_map:add: dom%d gfn=%lx mfn=%lx nr=%lx\n"",
                   d->domain_id, gfn, mfn, nr_mfns);

            ret = map_mmio_regions(d, _gfn(gfn), nr_mfns, _mfn(mfn));
            if ( ret < 0 )
                printk(XENLOG_G_WARNING
                       ""memory_map:fail: dom%d gfn=%lx mfn=%lx nr=%lx ret:%ld\n"",
                       d->domain_id, gfn, mfn, nr_mfns, ret);
        }
        else
        {
            printk(XENLOG_G_DEBUG
                   ""memory_map:remove: dom%d gfn=%lx mfn=%lx nr=%lx\n"",
                   d->domain_id, gfn, mfn, nr_mfns);

            ret = unmap_mmio_regions(d, _gfn(gfn), nr_mfns, _mfn(mfn));
            if ( ret < 0 && is_hardware_domain(current->domain) )
                printk(XENLOG_ERR
                       ""memory_map: error %ld removing dom%d access to [%lx,%lx]\n"",
                       ret, d->domain_id, mfn, mfn_end);
        }
        /* Do this unconditionally to cover errors on above failure paths. */
        memory_type_changed(d);
        break;
    }

    case XEN_DOMCTL_settimeoffset:
        domain_set_time_offset(d, op->u.settimeoffset.time_offset_seconds);
        break;

    case XEN_DOMCTL_set_target:
    {
        struct domain *e;

        ret = -ESRCH;
        e = get_domain_by_id(op->u.set_target.target);
        if ( e == NULL )
            break;

        ret = -EINVAL;
        if ( (d == e) || (d->target != NULL) )
        {
            put_domain(e);
            break;
        }

        ret = -EOPNOTSUPP;
        if ( is_hvm_domain(e) )
            ret = xsm_set_target(XSM_HOOK, d, e);
        if ( ret )
        {
            put_domain(e);
            break;
        }

        /* Hold reference on @e until we destroy @d. */
        d->target = e;
        break;
    }

    case XEN_DOMCTL_subscribe:
        d->suspend_evtchn = op->u.subscribe.port;
        break;

    case XEN_DOMCTL_vm_event_op:
        ret = vm_event_domctl(d, &op->u.vm_event_op);
        if ( ret == 0 )
            copyback = true;
        break;

#ifdef CONFIG_MEM_ACCESS
    case XEN_DOMCTL_set_access_required:
        if ( unlikely(current->domain == d) ) /* no domain_pause() */
            ret = -EPERM;
        else
        {
            domain_pause(d);
            arch_p2m_set_access_required(d,
                op->u.access_required.access_required);
            domain_unpause(d);
        }
        break;
#endif

    case XEN_DOMCTL_set_virq_handler:
        ret = set_global_virq_handler(d, op->u.set_virq_handler.virq);
        break;

    case XEN_DOMCTL_setvnumainfo:
    {
        struct vnuma_info *vnuma;

        vnuma = vnuma_init(&op->u.vnuma, d);
        if ( IS_ERR(vnuma) )
        {
            ret = PTR_ERR(vnuma);
            break;
        }

        /* overwrite vnuma topology for domain. */
        write_lock(&d->vnuma_rwlock);
        vnuma_destroy(d->vnuma);
        d->vnuma = vnuma;
        write_unlock(&d->vnuma_rwlock);

        break;
    }

    case XEN_DOMCTL_monitor_op:
        ret = monitor_domctl(d, &op->u.monitor_op);
        if ( !ret )
            copyback = 1;
        break;

    default:
        ret = arch_do_domctl(op, d, u_domctl);
        break;
    }

    domctl_lock_release();

 domctl_out_unlock_domonly:
    if ( d && d != dom_io )
        rcu_unlock_domain(d);

    if ( copyback && __copy_to_guest(u_domctl, op, 1) )
        ret = -EFAULT;

    return ret;
}","long do_domctl(VAR_0(xen_domctl_t) VAR_1)
{
    long VAR_2 = 0;
    bool_t VAR_3 = 0;
    struct xen_domctl VAR_4, *VAR_5 = &VAR_4;
    struct domain *VAR_6;

    if ( copy_from_guest(VAR_5, VAR_1, 1) )
        return -VAR_7;

    if ( VAR_5->interface_version != VAR_8 )
        return -VAR_9;

    switch ( VAR_5->cmd )
    {
    case VAR_10:
    case VAR_11:
        if ( VAR_5->domain == VAR_12 )
        {
            VAR_6 = VAR_13;
            break;
        }
        else if ( VAR_5->domain == VAR_14 )
            return -VAR_15;
        /* COMMENT_0 */
    case VAR_16:
    case VAR_17:
        if ( VAR_5->domain == VAR_14 )
        {
    case VAR_18:
    case VAR_19:
            VAR_6 = NULL;
            break;
        }
        /* COMMENT_0 */
    default:
        VAR_6 = rcu_lock_domain_by_id(VAR_5->domain);
        if ( !VAR_6 && VAR_5->cmd != VAR_20 )
            return -VAR_15;
    }

    VAR_2 = xsm_domctl(VAR_21, VAR_6, VAR_5->cmd);
    if ( VAR_2 )
        goto domctl_out_unlock_domonly;

    if ( !domctl_lock_acquire() )
    {
        if ( VAR_6 && VAR_6 != VAR_13 )
            rcu_unlock_domain(VAR_6);
        return hypercall_create_continuation(
            VAR_22, ""h"", VAR_1);
    }

    switch ( VAR_5->cmd )
    {

    case VAR_23:
    {
        vcpu_guest_context_u VAR_24 = { .nat = NULL };
        unsigned int VAR_25 = VAR_5->u.vcpucontext.vcpu;
        struct vcpu *VAR_26;

        VAR_2 = -VAR_27;
        if ( (VAR_6 == VAR_28->domain) || /* COMMENT_1 */
             (vcpu >= VAR_6->max_vcpus) || ((VAR_26 = VAR_6->vcpu[vcpu]) == NULL) )
            break;

        if ( guest_handle_is_null(VAR_5->u.vcpucontext.ctxt) )
        {
            VAR_2 = vcpu_reset(VAR_26);
            if ( VAR_2 == -VAR_29 )
                VAR_2 = hypercall_create_continuation(
                          VAR_22, ""h"", VAR_1);
            break;
        }

#ifdef VAR_30
        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)
                     < sizeof(struct compat_vcpu_guest_context));
#endif
        VAR_2 = -VAR_31;
        if ( (VAR_24.nat = alloc_vcpu_guest_context()) == NULL )
            break;

#ifdef VAR_30
        if ( !is_pv_32bit_domain(VAR_6) )
            VAR_2 = copy_from_guest(VAR_24.nat, VAR_5->u.vcpucontext.ctxt, 1);
        else
            VAR_2 = copy_from_guest(VAR_24.cmp,
                                  guest_handle_cast(VAR_5->u.vcpucontext.ctxt,
                                                    VAR_32), 1);
#else
        VAR_2 = copy_from_guest(VAR_24.nat, VAR_5->u.vcpucontext.ctxt, 1);
#endif
        VAR_2 = VAR_2 ? -VAR_7 : 0;

        if ( VAR_2 == 0 )
        {
            domain_pause(VAR_6);
            VAR_2 = arch_set_info_guest(VAR_26, VAR_24);
            domain_unpause(VAR_6);

            if ( VAR_2 == -VAR_29 )
                VAR_2 = hypercall_create_continuation(
                          VAR_22, ""h"", VAR_1);
        }

        free_vcpu_guest_context(VAR_24.nat);
        break;
    }

    case VAR_33:
        VAR_2 = -VAR_27;
        if ( VAR_6 != VAR_28->domain )
            VAR_2 = domain_pause_by_systemcontroller(VAR_6);
        break;

    case VAR_34:
        VAR_2 = domain_unpause_by_systemcontroller(VAR_6);
        break;

    case VAR_35:
        if ( VAR_6 == VAR_28->domain ) /* COMMENT_1 */
            VAR_2 = -VAR_27;
        else
            domain_resume(VAR_6);
        break;

    case VAR_18:
    {
        domid_t        VAR_36;
        static domid_t VAR_37 = 0;

        VAR_36 = VAR_5->domain;
        if ( (VAR_36 > 0) && (VAR_36 < VAR_38) )
        {
            VAR_2 = -VAR_27;
            if ( !is_free_domid(VAR_36) )
                break;
        }
        else
        {
            for ( VAR_36 = VAR_37 + 1; VAR_36 != VAR_37; VAR_36++ )
            {
                if ( VAR_36 == VAR_38 )
                    VAR_36 = 1;
                if ( is_free_domid(VAR_36) )
                    break;
            }

            VAR_2 = -VAR_31;
            if ( VAR_36 == VAR_37 )
                break;

            VAR_37 = VAR_36;
        }

        VAR_6 = domain_create(VAR_36, &VAR_5->u.createdomain, false);
        if ( IS_ERR(VAR_6) )
        {
            VAR_2 = PTR_ERR(VAR_6);
            VAR_6 = NULL;
            break;
        }

        VAR_2 = 0;
        VAR_5->domain = VAR_6->domain_id;
        VAR_3 = 1;
        VAR_6 = NULL;
        break;
    }

    case VAR_39:
    {
        unsigned int VAR_40, VAR_41 = VAR_5->u.max_vcpus.max;

        VAR_2 = -VAR_27;
        if ( (VAR_6 == VAR_28->domain) || /* COMMENT_1 */
             (VAR_41 != VAR_6->max_vcpus) )   /* COMMENT_2 */
            break;

        /* COMMENT_3 */
        domain_pause(VAR_6);

        VAR_2 = -VAR_31;

        for ( VAR_40 = 0; VAR_40 < VAR_41; VAR_40++ )
        {
            if ( VAR_6->vcpu[VAR_40] != NULL )
                continue;

            if ( vcpu_create(VAR_6, VAR_40) == NULL )
                goto maxvcpu_out;
        }

        domain_update_node_affinity(VAR_6);
        VAR_2 = 0;

    maxvcpu_out:
        domain_unpause(VAR_6);
        break;
    }

    case VAR_42:
        if ( VAR_6 == VAR_28->domain ) /* COMMENT_1 */
        {
            VAR_2 = -VAR_27;
            break;
        }
        VAR_2 = domain_soft_reset(VAR_6);
        break;

    case VAR_43:
        domctl_lock_release();
        domain_lock(VAR_6);
        VAR_2 = domain_kill(VAR_6);
        domain_unlock(VAR_6);
        if ( VAR_2 == -VAR_29 )
            VAR_2 = hypercall_create_continuation(
                VAR_22, ""h"", VAR_1);
        goto domctl_out_unlock_domonly;

    case VAR_44:
    {
        nodemask_t VAR_45;

        VAR_2 = xenctl_bitmap_to_nodemask(&VAR_45,
                                        &VAR_5->u.nodeaffinity.nodemap);
        if ( !VAR_2 )
            VAR_2 = domain_set_node_affinity(VAR_6, &VAR_45);
        break;
    }

    case VAR_46:
        VAR_2 = nodemask_to_xenctl_bitmap(&VAR_5->u.nodeaffinity.nodemap,
                                        &VAR_6->node_affinity);
        break;

    case VAR_47:
    case VAR_48:
    {
        struct vcpu *VAR_26;
        const struct sched_unit *VAR_49;
        struct xen_domctl_vcpuaffinity *VAR_50 = &VAR_5->u.vcpuaffinity;

        VAR_2 = -VAR_27;
        if ( VAR_50->vcpu >= VAR_6->max_vcpus )
            break;

        VAR_2 = -VAR_15;
        if ( (VAR_26 = VAR_6->vcpu[VAR_50->vcpu]) == NULL )
            break;

        VAR_49 = VAR_26->sched_unit;
        VAR_2 = -VAR_27;
        if ( vcpuaffinity_params_invalid(VAR_50) )
            break;

        if ( VAR_5->cmd == VAR_47 )
        {
            cpumask_var_t VAR_45, VAR_51;
            cpumask_t *VAR_52 = cpupool_domain_master_cpumask(VAR_26->domain);

            /* COMMENT_4 */
                                                                           
                                                                            
                                                                             
               
            if ( !alloc_cpumask_var(&VAR_51) )
            {
                VAR_2 = -VAR_31;
                break;
            }
            cpumask_copy(VAR_51, VAR_49->cpu_hard_affinity);

            if ( !alloc_cpumask_var(&VAR_45) )
            {
                free_cpumask_var(VAR_51);
                VAR_2 = -VAR_31;
                break;
            }

            /* COMMENT_9 */
            if ( VAR_50->flags & VAR_53 )
                vcpu_temporary_affinity(VAR_26, VAR_54, VAR_55);

            VAR_2 = 0;

            /* COMMENT_10 */
                                                                            
                                                       
               
            if ( VAR_50->flags & VAR_56 )
            {
                VAR_2 = xenctl_bitmap_to_bitmap(cpumask_bits(VAR_45),
                                              &VAR_50->cpumap_hard,
                                              VAR_57);
                if ( !VAR_2 )
                    VAR_2 = vcpu_set_hard_affinity(VAR_26, VAR_45);
                if ( VAR_2 )
                    goto setvcpuaffinity_out;

                /* COMMENT_14 */
                                                                           
                                                                   
                   
                cpumask_and(VAR_45, VAR_52, VAR_49->cpu_hard_affinity);
                VAR_2 = cpumask_to_xenctl_bitmap(&VAR_50->cpumap_hard,
                                               VAR_45);
            }
            if ( VAR_50->flags & VAR_58 )
            {
                VAR_2 = xenctl_bitmap_to_bitmap(cpumask_bits(VAR_45),
                                              &VAR_50->cpumap_soft,
                                              VAR_57);
                if ( !VAR_2)
                    VAR_2 = vcpu_set_soft_affinity(VAR_26, VAR_45);
                if ( VAR_2 )
                {
                    /* COMMENT_18 */
                                                                              
                                                                            
                                
                       
                    if ( VAR_50->flags & VAR_56 )
                        vcpu_set_hard_affinity(VAR_26, VAR_51);
                    goto setvcpuaffinity_out;
                }

                /* COMMENT_23 */
                                                                            
                                                                            
                                 
                   
                cpumask_and(VAR_45, VAR_45, VAR_52);
                cpumask_and(VAR_45, VAR_45,
                            VAR_49->cpu_hard_affinity);
                VAR_2 = cpumask_to_xenctl_bitmap(&VAR_50->cpumap_soft,
                                               VAR_45);
            }

 setvcpuaffinity_out:
            free_cpumask_var(VAR_45);
            free_cpumask_var(VAR_51);
        }
        else
        {
            if ( VAR_50->flags & VAR_56 )
                VAR_2 = cpumask_to_xenctl_bitmap(&VAR_50->cpumap_hard,
                                               VAR_49->cpu_hard_affinity);
            if ( VAR_50->flags & VAR_58 )
                VAR_2 = cpumask_to_xenctl_bitmap(&VAR_50->cpumap_soft,
                                               VAR_49->cpu_soft_affinity);
        }
        break;
    }

    case VAR_59:
        VAR_2 = sched_adjust(VAR_6, &VAR_5->u.scheduler_op);
        VAR_3 = 1;
        break;

    case VAR_20:
    {
        domid_t VAR_36 = VAR_14;

        if ( !VAR_6 )
        {
            VAR_2 = -VAR_27;
            if ( VAR_5->domain >= VAR_38 )
                break;

            rcu_read_lock(&VAR_60);

            VAR_36 = VAR_5->domain;
            VAR_61 ( d )
                if ( d->VAR_62 >= VAR_36 )
                    break;
        }

        VAR_2 = -VAR_15;
        if ( d == NULL )
            goto getdomaininfo_out;

        VAR_2 = xsm_getdomaininfo(VAR_63, d);
        if ( VAR_2 )
            goto getdomaininfo_out;

        getdomaininfo(d, &VAR_5->u.getdomaininfo);

        VAR_5->domain = VAR_5->u.getdomaininfo.domain;
        VAR_3 = 1;

    getdomaininfo_out:
        /* COMMENT_28 */
        if ( VAR_36 == VAR_14 )
            break;

        rcu_read_unlock(&VAR_60);
        d = NULL;
        break;
    }

    case VAR_64:
    {
        vcpu_guest_context_u VAR_24 = { .nat = NULL };
        struct vcpu         *VAR_26;

        VAR_2 = -VAR_27;
        if ( VAR_5->u.vcpucontext.vcpu >= d->max_vcpus ||
             (VAR_26 = d->vcpu[VAR_5->u.vcpucontext.vcpu]) == NULL ||
             VAR_26 == VAR_28 ) /* COMMENT_29 */
            goto getvcpucontext_out;

        VAR_2 = -VAR_65;
        if ( !VAR_26->is_initialised )
            goto getvcpucontext_out;

#ifdef VAR_30
        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)
                     < sizeof(struct compat_vcpu_guest_context));
#endif
        VAR_2 = -VAR_31;
        if ( (VAR_24.nat = xzalloc(struct vcpu_guest_context)) == NULL )
            goto getvcpucontext_out;

        vcpu_pause(VAR_26);

        arch_get_info_guest(VAR_26, VAR_24);
        VAR_2 = 0;

        vcpu_unpause(VAR_26);

#ifdef VAR_30
        if ( !is_pv_32bit_domain(d) )
            VAR_2 = copy_to_guest(VAR_5->u.vcpucontext.ctxt, VAR_24.nat, 1);
        else
            VAR_2 = copy_to_guest(guest_handle_cast(VAR_5->u.vcpucontext.ctxt,
                                                  VAR_32), VAR_24.cmp, 1);
#else
        VAR_2 = copy_to_guest(VAR_5->u.vcpucontext.ctxt, VAR_24.nat, 1);
#endif

        if ( VAR_2 )
            VAR_2 = -VAR_7;
        VAR_3 = 1;

    getvcpucontext_out:
        xfree(VAR_24.nat);
        break;
    }

    case VAR_66:
    {
        struct vcpu   *VAR_26;
        struct vcpu_runstate_info VAR_67;

        VAR_2 = -VAR_27;
        if ( VAR_5->u.getvcpuinfo.vcpu >= d->max_vcpus )
            break;

        VAR_2 = -VAR_15;
        if ( (VAR_26 = d->vcpu[VAR_5->u.getvcpuinfo.vcpu]) == NULL )
            break;

        vcpu_runstate_get(VAR_26, &VAR_67);

        VAR_5->u.getvcpuinfo.online   = !(VAR_26->pause_flags & VAR_68);
        VAR_5->u.getvcpuinfo.blocked  = !!(VAR_26->pause_flags & VAR_69);
        VAR_5->u.getvcpuinfo.running  = VAR_26->is_running;
        VAR_5->u.getvcpuinfo.cpu_time = VAR_67.time[VAR_70];
        VAR_5->u.getvcpuinfo.cpu      = VAR_26->processor;
        VAR_2 = 0;
        VAR_3 = 1;
        break;
    }

    case VAR_71:
    {
        uint64_t VAR_72 = VAR_5->u.max_mem.max_memkb >> (VAR_73 - 10);

        spin_lock(&d->page_alloc_lock);
        /* COMMENT_30 */
                                                                               
                                                                               
                                                                             
           
        d->max_pages = min(VAR_72, (uint64_t)(typeof(d->max_pages))-1);
        spin_unlock(&d->page_alloc_lock);
        break;
    }

    case VAR_74:
        memcpy(d->handle, VAR_5->u.setdomainhandle.handle,
               sizeof(VAR_75));
        break;

    case VAR_76:
        if ( unlikely(d == VAR_28->domain) ) /* COMMENT_1 */
            VAR_2 = -VAR_27;
        else
        {
            domain_pause(d);
            d->debugger_attached = !!VAR_5->u.setdebugging.enable;
            domain_unpause(d); /* COMMENT_35 */
        }
        break;

    case VAR_77:
    {
        unsigned int VAR_78 = VAR_5->u.irq_permission.pirq, VAR_79;
        int VAR_80 = VAR_5->u.irq_permission.allow_access;

        if ( VAR_78 >= VAR_28->domain->nr_pirqs )
        {
            VAR_2 = -VAR_27;
            break;
        }
        VAR_79 = pirq_access_permitted(VAR_28->domain, VAR_78);
        if ( !VAR_79 || xsm_irq_permission(VAR_63, d, VAR_79, VAR_80) )
            VAR_2 = -VAR_81;
        else if ( VAR_80 )
            VAR_2 = irq_permit_access(d, VAR_79);
        else
            VAR_2 = irq_deny_access(d, VAR_79);
        break;
    }

    case VAR_82:
    {
        unsigned long VAR_83 = VAR_5->u.iomem_permission.first_mfn;
        unsigned long VAR_84 = VAR_5->u.iomem_permission.nr_mfns;
        int VAR_80 = VAR_5->u.iomem_permission.allow_access;

        VAR_2 = -VAR_27;
        if ( (VAR_83 + VAR_84 - 1) < VAR_83 ) /* COMMENT_36 */
            break;

        if ( !iomem_access_permitted(VAR_28->domain,
                                     VAR_83, VAR_83 + VAR_84 - 1) ||
             xsm_iomem_permission(VAR_63, d, VAR_83, VAR_83 + VAR_84 - 1, VAR_80) )
            VAR_2 = -VAR_81;
        else if ( VAR_80 )
            VAR_2 = iomem_permit_access(d, VAR_83, VAR_83 + VAR_84 - 1);
        else
            VAR_2 = iomem_deny_access(d, VAR_83, VAR_83 + VAR_84 - 1);
        if ( !VAR_2 )
            memory_type_changed(d);
        break;
    }

    case VAR_85:
    {
        unsigned long VAR_86 = VAR_5->u.memory_mapping.first_gfn;
        unsigned long VAR_83 = VAR_5->u.memory_mapping.first_mfn;
        unsigned long VAR_84 = VAR_5->u.memory_mapping.nr_mfns;
        unsigned long VAR_87 = VAR_83 + VAR_84 - 1;
        int VAR_88 = VAR_5->u.memory_mapping.add_mapping;

        VAR_2 = -VAR_27;
        if ( VAR_87 < VAR_83 || /* COMMENT_36 */
             ((VAR_83 | VAR_87) >> (VAR_89 - VAR_73)) ||
             (VAR_86 + VAR_84 - 1) < VAR_86 ) /* COMMENT_36 */
            break;

#ifndef VAR_90 /* COMMENT_37 */
        VAR_2 = -VAR_91;
        /* COMMENT_38 */
        if ( VAR_84 > 64 )
            break;
#endif

        VAR_2 = -VAR_81;
        if ( !iomem_access_permitted(VAR_28->domain, VAR_83, VAR_87) ||
             !iomem_access_permitted(d, VAR_83, VAR_87) )
            break;

        VAR_2 = xsm_iomem_mapping(VAR_63, d, VAR_83, VAR_87, VAR_88);
        if ( VAR_2 )
            break;

        if ( VAR_88 )
        {
            VAR_92(VAR_93
                   ""memory_map:add: dom%d gfn=%lx mfn=%lx nr=%lx\n"",
                   d->domain_id, VAR_86, VAR_83, VAR_84);

            VAR_2 = map_mmio_regions(d, _gfn(VAR_86), VAR_84, _mfn(VAR_83));
            if ( VAR_2 < 0 )
                VAR_92(XENLOG_G_WARNING
                       ""memory_map:fail: dom%d gfn=%lx mfn=%lx nr=%lx ret:%ld\n"",
                       d->domain_id, VAR_86, VAR_83, VAR_84, VAR_2);
        }
        else
        {
            VAR_92(VAR_93
                   ""memory_map:remove: dom%d gfn=%lx mfn=%lx nr=%lx\n"",
                   d->domain_id, VAR_86, VAR_83, VAR_84);

            VAR_2 = unmap_mmio_regions(d, _gfn(VAR_86), VAR_84, _mfn(VAR_83));
            if ( VAR_2 < 0 && is_hardware_domain(VAR_28->domain) )
                VAR_92(XENLOG_ERR
                       ""memory_map: error %ld removing dom%d access to [%lx,%lx]\n"",
                       VAR_2, d->domain_id, VAR_83, VAR_87);
        }
        /* COMMENT_39 */
        memory_type_changed(d);
        break;
    }

    case VAR_94:
        domain_set_time_offset(d, VAR_5->u.settimeoffset.time_offset_seconds);
        break;

    case VAR_95:
    {
        struct domain *VAR_96;

        VAR_2 = -VAR_15;
        VAR_96 = get_domain_by_id(VAR_5->u.set_target.target);
        if ( VAR_96 == NULL )
            break;

        VAR_2 = -VAR_27;
        if ( (d == VAR_96) || (d->target != NULL) )
        {
            put_domain(VAR_96);
            break;
        }

        VAR_2 = -VAR_97;
        if ( is_hvm_domain(VAR_96) )
            VAR_2 = xsm_set_target(VAR_63, d, VAR_96);
        if ( VAR_2 )
        {
            put_domain(VAR_96);
            break;
        }

        /* COMMENT_40 */
        d->target = VAR_96;
        break;
    }

    case VAR_98:
        d->suspend_evtchn = VAR_5->u.subscribe.port;
        break;

    case VAR_17:
        VAR_2 = vm_event_domctl(d, &VAR_5->u.vm_event_op);
        if ( VAR_2 == 0 )
            VAR_3 = true;
        break;

#ifdef VAR_99
    case VAR_100:
        if ( unlikely(VAR_28->domain == d) ) /* COMMENT_1 */
            VAR_2 = -VAR_81;
        else
        {
            domain_pause(d);
            arch_p2m_set_access_required(d,
                VAR_5->u.access_required.access_required);
            domain_unpause(d);
        }
        break;
#endif

    case VAR_101:
        VAR_2 = set_global_virq_handler(d, VAR_5->u.set_virq_handler.virq);
        break;

    case VAR_102:
    {
        struct vnuma_info *VAR_103;

        VAR_103 = vnuma_init(&VAR_5->u.vnuma, d);
        if ( IS_ERR(VAR_103) )
        {
            VAR_2 = PTR_ERR(VAR_103);
            break;
        }

        /* COMMENT_41 */
        write_lock(&d->vnuma_rwlock);
        vnuma_destroy(d->vnuma);
        d->vnuma = VAR_103;
        write_unlock(&d->vnuma_rwlock);

        break;
    }

    case VAR_104:
        VAR_2 = monitor_domctl(d, &VAR_5->u.monitor_op);
        if ( !VAR_2 )
            VAR_3 = 1;
        break;

    default:
        VAR_2 = arch_do_domctl(VAR_5, d, VAR_1);
        break;
    }

    domctl_lock_release();

 domctl_out_unlock_domonly:
    if ( d && d != VAR_13 )
        rcu_unlock_domain(d);

    if ( VAR_3 && __copy_to_guest(VAR_1, VAR_5, 1) )
        VAR_2 = -VAR_7;

    return VAR_2;
}",,"--- func_before
+++ func_after
@@ -13,6 +13,16 @@
 
     switch ( op->cmd )
     {
+    case XEN_DOMCTL_assign_device:
+    case XEN_DOMCTL_deassign_device:
+        if ( op->domain == DOMID_IO )
+        {
+            d = dom_io;
+            break;
+        }
+        else if ( op->domain == DOMID_INVALID )
+            return -ESRCH;
+        /* fall through */
     case XEN_DOMCTL_test_assign_device:
     case XEN_DOMCTL_vm_event_op:
         if ( op->domain == DOMID_INVALID )
@@ -35,7 +45,7 @@
 
     if ( !domctl_lock_acquire() )
     {
-        if ( d )
+        if ( d && d != dom_io )
             rcu_unlock_domain(d);
         return hypercall_create_continuation(
             __HYPERVISOR_domctl, ""h"", u_domctl);
@@ -694,7 +704,7 @@
     domctl_lock_release();
 
  domctl_out_unlock_domonly:
-    if ( d )
+    if ( d && d != dom_io )
         rcu_unlock_domain(d);
 
     if ( copyback && __copy_to_guest(u_domctl, op, 1) )","{'deleted_lines': ['        if ( d )', '    if ( d )'], 'added_lines': ['    case XEN_DOMCTL_assign_device:', '    case XEN_DOMCTL_deassign_device:', '        if ( op->domain == DOMID_IO )', '        {', '            d = dom_io;', '            break;', '        }', '        else if ( op->domain == DOMID_INVALID )', '            return -ESRCH;', '        /* fall through */', '        if ( d && d != dom_io )', '    if ( d && d != dom_io )']}",True,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",6.8,MEDIUM,1,test,2019-10-18T16:41:44Z,3
CVE-2019-18424,['CWE-78'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"passthrough: quarantine PCI devices

When a PCI device is assigned to an untrusted domain, it is possible for
that domain to program the device to DMA to an arbitrary address. The
IOMMU is used to protect the host from malicious DMA by making sure that
the device addresses can only target memory assigned to the guest. However,
when the guest domain is torn down the device is assigned back to dom0,
thus allowing any in-flight DMA to potentially target critical host data.

This patch introduces a 'quarantine' for PCI devices using dom_io. When
the toolstack makes a device assignable (by binding it to pciback), it
will now also assign it to DOMID_IO and the device will only be assigned
back to dom0 when the device is made unassignable again. Whilst device is
assignable it will only ever transfer between dom_io and guest domains.
dom_io is actually only used as a sentinel domain for quarantining purposes;
it is not configured with any IOMMU mappings. Assignment to dom_io simply
means that the device's initiator (requestor) identifier is not present in
the IOMMU's device table and thus any DMA transactions issued will be
terminated with a fault condition.

In addition, a fix to assignment handling is made for VT-d.  Failure
during the assignment step should not lead to a device still being
associated with its prior owner. Hand the device to DomIO temporarily,
until the assignment step has completed successfully.  Remove the PI
hooks from the source domain then earlier as well.

Failure of the recovery reassign_device_ownership() may not go silent:
There e.g. may still be left over RMRR mappings in the domain assignment
to which has failed, and hence we can't allow that domain to continue
executing.

NOTE: This patch also includes one printk() cleanup; the
      ""XEN_DOMCTL_assign_device: "" tag is dropped in iommu_do_pci_domctl(),
      since similar printk()-s elsewhere also don't log such a tag.

This is XSA-302.

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,xen/drivers/passthrough/device_tree.c,iommu_do_dt_domctl,"int iommu_do_dt_domctl(struct xen_domctl *domctl, struct domain *d,
XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)
{
int ret;
struct dt_device_node *dev;
switch ( domctl->cmd )
{
case XEN_DOMCTL_assign_device:
ASSERT(d);
case XEN_DOMCTL_test_assign_device:
ret = -ENODEV;
if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_DT )
break;
ret = -EINVAL;
if ( (d && d->is_dying) || domctl->u.assign_device.flags )
break;
ret = dt_find_node_by_gpath(domctl->u.assign_device.u.dt.path,
domctl->u.assign_device.u.dt.size,
&dev);
if ( ret )
break;
ret = xsm_assign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev));
if ( ret )
break;
if ( domctl->cmd == XEN_DOMCTL_test_assign_device )
{
if ( iommu_dt_device_is_assigned(dev) )
{
printk(XENLOG_G_ERR ""%s already assigned.\n"",
dt_node_full_name(dev));
ret = -EINVAL;
}
break;
}
ret = iommu_add_dt_device(dev);
if ( ret < 0 && ret != -EEXIST )
{
printk(XENLOG_G_ERR ""Failed to add %s to the IOMMU\n"",
dt_node_full_name(dev));
break;
}
ret = iommu_assign_dt_device(d, dev);
if ( ret )
printk(XENLOG_G_ERR ""XEN_DOMCTL_assign_dt_device: assign \""%s\""""
"" to dom%u failed (%d)\n"",
dt_node_full_name(dev), d->domain_id, ret);
break;
case XEN_DOMCTL_deassign_device:
ret = -ENODEV;
if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_DT )
break;
ret = -EINVAL;
if ( domctl->u.assign_device.flags )
break;
ret = dt_find_node_by_gpath(domctl->u.assign_device.u.dt.path,
domctl->u.assign_device.u.dt.size,
&dev);
if ( ret )
break;
ret = xsm_deassign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev));
ret = iommu_deassign_dt_device(d, dev);
if ( ret )
printk(XENLOG_G_ERR ""XEN_DOMCTL_assign_dt_device: assign \""%s\""""
"" to dom%u failed (%d)\n"",
dt_node_full_name(dev), d->domain_id, ret);
break;
default:
ret = -ENOSYS;
break;
}
return ret;
}","int iommu_do_dt_domctl(struct xen_domctl *VAR_0, struct domain *VAR_1,
VAR_2(xen_domctl_t) VAR_3)
{
int VAR_4;
struct dt_device_node *VAR_5;
switch ( VAR_0->cmd )
{
case VAR_6:
ASSERT(VAR_1);
case VAR_7:
VAR_4 = -VAR_8;
if ( VAR_0->u.assign_device.dev != VAR_9 )
break;
VAR_4 = -VAR_10;
if ( (VAR_1 && VAR_1->is_dying) || VAR_0->u.assign_device.flags )
break;
VAR_4 = dt_find_node_by_gpath(VAR_0->u.assign_device.u.dt.path,
VAR_0->u.assign_device.u.dt.size,
&VAR_5);
if ( VAR_4 )
break;
VAR_4 = xsm_assign_dtdevice(VAR_11, VAR_1, dt_node_full_name(VAR_5));
if ( VAR_4 )
break;
if ( VAR_0->cmd == VAR_7 )
{
if ( iommu_dt_device_is_assigned(VAR_5) )
{
printk(XENLOG_G_ERR ""%s already assigned.\n"",
dt_node_full_name(VAR_5));
VAR_4 = -VAR_10;
}
break;
}
VAR_4 = iommu_add_dt_device(VAR_5);
if ( VAR_4 < 0 && VAR_4 != -VAR_12 )
{
printk(XENLOG_G_ERR ""Failed to add %s to the IOMMU\n"",
dt_node_full_name(VAR_5));
break;
}
VAR_4 = iommu_assign_dt_device(VAR_1, VAR_5);
if ( VAR_4 )
printk(XENLOG_G_ERR ""XEN_DOMCTL_assign_dt_device: assign \""%s\""""
"" to dom%u failed (%d)\n"",
dt_node_full_name(VAR_5), VAR_1->domain_id, VAR_4);
break;
case VAR_13:
VAR_4 = -VAR_8;
if ( VAR_0->u.assign_device.dev != VAR_9 )
break;
VAR_4 = -VAR_10;
if ( VAR_0->u.assign_device.flags )
break;
VAR_4 = dt_find_node_by_gpath(VAR_0->u.assign_device.u.dt.path,
VAR_0->u.assign_device.u.dt.size,
&VAR_5);
if ( VAR_4 )
break;
VAR_4 = xsm_deassign_dtdevice(VAR_11, VAR_1, dt_node_full_name(VAR_5));
VAR_4 = iommu_deassign_dt_device(VAR_1, VAR_5);
if ( VAR_4 )
printk(XENLOG_G_ERR ""XEN_DOMCTL_assign_dt_device: assign \""%s\""""
"" to dom%u failed (%d)\n"",
dt_node_full_name(VAR_5), VAR_1->domain_id, VAR_4);
break;
default:
VAR_4 = -VAR_14;
break;
}
return VAR_4;
}",,"int iommu_do_dt_domctl(struct xen_domctl *domctl, struct domain *d,
                       XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)
{
    int ret;
    struct dt_device_node *dev;

    switch ( domctl->cmd )
    {
    case XEN_DOMCTL_assign_device:
        ASSERT(d);
        /* fall through */
    case XEN_DOMCTL_test_assign_device:
        ret = -ENODEV;
        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_DT )
            break;

        ret = -EINVAL;
        if ( (d && d->is_dying) || domctl->u.assign_device.flags )
            break;

        ret = dt_find_node_by_gpath(domctl->u.assign_device.u.dt.path,
                                    domctl->u.assign_device.u.dt.size,
                                    &dev);
        if ( ret )
            break;

        ret = xsm_assign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev));
        if ( ret )
            break;

        if ( domctl->cmd == XEN_DOMCTL_test_assign_device )
        {
            if ( iommu_dt_device_is_assigned(dev) )
            {
                printk(XENLOG_G_ERR ""%s already assigned.\n"",
                       dt_node_full_name(dev));
                ret = -EINVAL;
            }
            break;
        }

        if ( d == dom_io )
            return -EINVAL;

        ret = iommu_add_dt_device(dev);
        /*
         * Ignore ""-EEXIST"" error code as it would mean that the device is
         * already added to the IOMMU (positive result). Such happens after
         * re-creating guest domain.
         */
        if ( ret < 0 && ret != -EEXIST )
        {
            printk(XENLOG_G_ERR ""Failed to add %s to the IOMMU\n"",
                   dt_node_full_name(dev));
            break;
        }

        ret = iommu_assign_dt_device(d, dev);

        if ( ret )
            printk(XENLOG_G_ERR ""XEN_DOMCTL_assign_dt_device: assign \""%s\""""
                   "" to dom%u failed (%d)\n"",
                   dt_node_full_name(dev), d->domain_id, ret);
        break;

    case XEN_DOMCTL_deassign_device:
        ret = -ENODEV;
        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_DT )
            break;

        ret = -EINVAL;
        if ( domctl->u.assign_device.flags )
            break;

        ret = dt_find_node_by_gpath(domctl->u.assign_device.u.dt.path,
                                    domctl->u.assign_device.u.dt.size,
                                    &dev);
        if ( ret )
            break;

        ret = xsm_deassign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev));

        if ( d == dom_io )
            return -EINVAL;

        ret = iommu_deassign_dt_device(d, dev);

        if ( ret )
            printk(XENLOG_G_ERR ""XEN_DOMCTL_assign_dt_device: assign \""%s\""""
                   "" to dom%u failed (%d)\n"",
                   dt_node_full_name(dev), d->domain_id, ret);
        break;

    default:
        ret = -ENOSYS;
        break;
    }

    return ret;
}","int iommu_do_dt_domctl(struct xen_domctl *VAR_0, struct domain *VAR_1,
                       VAR_2(xen_domctl_t) VAR_3)
{
    int VAR_4;
    struct dt_device_node *VAR_5;

    switch ( VAR_0->cmd )
    {
    case VAR_6:
        ASSERT(VAR_1);
        /* COMMENT_0 */
    case VAR_7:
        VAR_4 = -VAR_8;
        if ( VAR_0->u.assign_device.dev != VAR_9 )
            break;

        VAR_4 = -VAR_10;
        if ( (VAR_1 && VAR_1->is_dying) || VAR_0->u.assign_device.flags )
            break;

        VAR_4 = dt_find_node_by_gpath(VAR_0->u.assign_device.u.dt.path,
                                    VAR_0->u.assign_device.u.dt.size,
                                    &VAR_5);
        if ( VAR_4 )
            break;

        VAR_4 = xsm_assign_dtdevice(VAR_11, VAR_1, dt_node_full_name(VAR_5));
        if ( VAR_4 )
            break;

        if ( VAR_0->cmd == VAR_7 )
        {
            if ( iommu_dt_device_is_assigned(VAR_5) )
            {
                printk(XENLOG_G_ERR ""%s already assigned.\n"",
                       dt_node_full_name(VAR_5));
                VAR_4 = -VAR_10;
            }
            break;
        }

        if ( VAR_1 == VAR_12 )
            return -VAR_10;

        VAR_4 = iommu_add_dt_device(VAR_5);
        /* COMMENT_1 */
                                                                          
                                                                           
                                    
           
        if ( VAR_4 < 0 && VAR_4 != -VAR_13 )
        {
            printk(XENLOG_G_ERR ""Failed to add %s to the IOMMU\n"",
                   dt_node_full_name(VAR_5));
            break;
        }

        VAR_4 = iommu_assign_dt_device(VAR_1, VAR_5);

        if ( VAR_4 )
            printk(XENLOG_G_ERR ""XEN_DOMCTL_assign_dt_device: assign \""%s\""""
                   "" to dom%u failed (%d)\n"",
                   dt_node_full_name(VAR_5), VAR_1->domain_id, VAR_4);
        break;

    case VAR_14:
        VAR_4 = -VAR_8;
        if ( VAR_0->u.assign_device.dev != VAR_9 )
            break;

        VAR_4 = -VAR_10;
        if ( VAR_0->u.assign_device.flags )
            break;

        VAR_4 = dt_find_node_by_gpath(VAR_0->u.assign_device.u.dt.path,
                                    VAR_0->u.assign_device.u.dt.size,
                                    &VAR_5);
        if ( VAR_4 )
            break;

        VAR_4 = xsm_deassign_dtdevice(VAR_11, VAR_1, dt_node_full_name(VAR_5));

        if ( VAR_1 == VAR_12 )
            return -VAR_10;

        VAR_4 = iommu_deassign_dt_device(VAR_1, VAR_5);

        if ( VAR_4 )
            printk(XENLOG_G_ERR ""XEN_DOMCTL_assign_dt_device: assign \""%s\""""
                   "" to dom%u failed (%d)\n"",
                   dt_node_full_name(VAR_5), VAR_1->domain_id, VAR_4);
        break;

    default:
        VAR_4 = -VAR_15;
        break;
    }

    return VAR_4;
}",,"--- func_before
+++ func_after
@@ -39,6 +39,9 @@
             break;
         }
 
+        if ( d == dom_io )
+            return -EINVAL;
+
         ret = iommu_add_dt_device(dev);
         /*
          * Ignore ""-EEXIST"" error code as it would mean that the device is
@@ -77,6 +80,9 @@
 
         ret = xsm_deassign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev));
 
+        if ( d == dom_io )
+            return -EINVAL;
+
         ret = iommu_deassign_dt_device(d, dev);
 
         if ( ret )","{'deleted_lines': [], 'added_lines': ['        if ( d == dom_io )', '            return -EINVAL;', '', '        if ( d == dom_io )', '            return -EINVAL;', '']}",True,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",6.8,MEDIUM,1,test,2019-10-18T16:41:44Z,3
CVE-2019-18424,['CWE-78'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"passthrough: quarantine PCI devices

When a PCI device is assigned to an untrusted domain, it is possible for
that domain to program the device to DMA to an arbitrary address. The
IOMMU is used to protect the host from malicious DMA by making sure that
the device addresses can only target memory assigned to the guest. However,
when the guest domain is torn down the device is assigned back to dom0,
thus allowing any in-flight DMA to potentially target critical host data.

This patch introduces a 'quarantine' for PCI devices using dom_io. When
the toolstack makes a device assignable (by binding it to pciback), it
will now also assign it to DOMID_IO and the device will only be assigned
back to dom0 when the device is made unassignable again. Whilst device is
assignable it will only ever transfer between dom_io and guest domains.
dom_io is actually only used as a sentinel domain for quarantining purposes;
it is not configured with any IOMMU mappings. Assignment to dom_io simply
means that the device's initiator (requestor) identifier is not present in
the IOMMU's device table and thus any DMA transactions issued will be
terminated with a fault condition.

In addition, a fix to assignment handling is made for VT-d.  Failure
during the assignment step should not lead to a device still being
associated with its prior owner. Hand the device to DomIO temporarily,
until the assignment step has completed successfully.  Remove the PI
hooks from the source domain then earlier as well.

Failure of the recovery reassign_device_ownership() may not go silent:
There e.g. may still be left over RMRR mappings in the domain assignment
to which has failed, and hence we can't allow that domain to continue
executing.

NOTE: This patch also includes one printk() cleanup; the
      ""XEN_DOMCTL_assign_device: "" tag is dropped in iommu_do_pci_domctl(),
      since similar printk()-s elsewhere also don't log such a tag.

This is XSA-302.

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,xen/drivers/passthrough/pci.c,iommu_do_pci_domctl,"int iommu_do_pci_domctl(
struct xen_domctl *domctl, struct domain *d,
XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)
{
u16 seg;
u8 bus, devfn;
int ret = 0;
uint32_t machine_sbdf;
switch ( domctl->cmd )
{
unsigned int flags;
case XEN_DOMCTL_get_device_group:
{
u32 max_sdevs;
XEN_GUEST_HANDLE_64(uint32) sdevs;
ret = xsm_get_device_group(XSM_HOOK, domctl->u.get_device_group.machine_sbdf);
if ( ret )
break;
seg = domctl->u.get_device_group.machine_sbdf >> 16;
bus = PCI_BUS(domctl->u.get_device_group.machine_sbdf);
devfn = PCI_DEVFN2(domctl->u.get_device_group.machine_sbdf);
max_sdevs = domctl->u.get_device_group.max_sdevs;
sdevs = domctl->u.get_device_group.sdev_array;
ret = iommu_get_device_group(d, seg, bus, devfn, sdevs, max_sdevs);
if ( ret < 0 )
{
dprintk(XENLOG_ERR, ""iommu_get_device_group() failed!\n"");
ret = -EFAULT;
domctl->u.get_device_group.num_sdevs = 0;
}
else
{
domctl->u.get_device_group.num_sdevs = ret;
ret = 0;
}
if ( __copy_field_to_guest(u_domctl, domctl, u.get_device_group) )
ret = -EFAULT;
}
break;
case XEN_DOMCTL_assign_device:
ASSERT(d);
case XEN_DOMCTL_test_assign_device:
if ( d == current->domain )
{
ret = -EINVAL;
break;
}
ret = -ENODEV;
if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_PCI )
break;
ret = -EINVAL;
flags = domctl->u.assign_device.flags;
if ( domctl->cmd == XEN_DOMCTL_assign_device
? d->is_dying || (flags & ~XEN_DOMCTL_DEV_RDM_RELAXED)
: flags )
break;
machine_sbdf = domctl->u.assign_device.u.pci.machine_sbdf;
ret = xsm_assign_device(XSM_HOOK, d, machine_sbdf);
if ( ret )
break;
seg = machine_sbdf >> 16;
bus = PCI_BUS(machine_sbdf);
devfn = PCI_DEVFN2(machine_sbdf);
ret = device_assigned(seg, bus, devfn);
if ( domctl->cmd == XEN_DOMCTL_test_assign_device )
{
if ( ret )
{
printk(XENLOG_G_INFO
""%04x:%02x:%02x.%u already assigned, or non-existent\n"",
seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));
ret = -EINVAL;
}
break;
}
if ( !ret )
ret = assign_device(d, seg, bus, devfn, flags);
if ( ret == -ERESTART )
ret = hypercall_create_continuation(__HYPERVISOR_domctl,
""h"", u_domctl);
else if ( ret )
printk(XENLOG_G_ERR ""XEN_DOMCTL_assign_device: ""
""assign %04x:%02x:%02x.%u to dom%d failed (%d)\n"",
seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),
d->domain_id, ret);
break;
case XEN_DOMCTL_deassign_device:
if ( d == current->domain )
{
ret = -EINVAL;
break;
}
ret = -ENODEV;
if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_PCI )
break;
ret = -EINVAL;
if ( domctl->u.assign_device.flags )
break;
machine_sbdf = domctl->u.assign_device.u.pci.machine_sbdf;
ret = xsm_deassign_device(XSM_HOOK, d, machine_sbdf);
if ( ret )
break;
seg = machine_sbdf >> 16;
bus = PCI_BUS(machine_sbdf);
devfn = PCI_DEVFN2(machine_sbdf);
pcidevs_lock();
ret = deassign_device(d, seg, bus, devfn);
pcidevs_unlock();
if ( ret )
printk(XENLOG_G_ERR
""deassign %04x:%02x:%02x.%u from dom%d failed (%d)\n"",
seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),
d->domain_id, ret);
break;
default:
ret = -ENOSYS;
break;
}
return ret;
}","int iommu_do_pci_domctl(
struct xen_domctl *VAR_0, struct domain *VAR_1,
VAR_2(xen_domctl_t) VAR_3)
{
u16 VAR_4;
u8 VAR_5, VAR_6;
int VAR_7 = 0;
uint32_t VAR_8;
switch ( VAR_0->cmd )
{
unsigned int VAR_9;
case VAR_10:
{
u32 VAR_11;
VAR_12(uint32) VAR_13;
VAR_7 = xsm_get_device_group(VAR_14, VAR_0->u.get_device_group.machine_sbdf);
if ( VAR_7 )
break;
VAR_4 = VAR_0->u.get_device_group.machine_sbdf >> 16;
VAR_5 = PCI_BUS(VAR_0->u.get_device_group.machine_sbdf);
VAR_6 = PCI_DEVFN2(VAR_0->u.get_device_group.machine_sbdf);
VAR_11 = VAR_0->u.get_device_group.max_sdevs;
VAR_13 = VAR_0->u.get_device_group.sdev_array;
VAR_7 = iommu_get_device_group(VAR_1, VAR_4, VAR_5, VAR_6, VAR_13, VAR_11);
if ( VAR_7 < 0 )
{
dprintk(VAR_15, ""iommu_get_device_group() failed!\n"");
VAR_7 = -VAR_16;
VAR_0->u.get_device_group.num_sdevs = 0;
}
else
{
VAR_0->u.get_device_group.num_sdevs = VAR_7;
VAR_7 = 0;
}
if ( __copy_field_to_guest(VAR_3, VAR_0, VAR_17.get_device_group) )
VAR_7 = -VAR_16;
}
break;
case VAR_18:
ASSERT(VAR_1);
case VAR_19:
if ( VAR_1 == VAR_20->domain )
{
VAR_7 = -VAR_21;
break;
}
VAR_7 = -VAR_22;
if ( VAR_0->u.assign_device.dev != VAR_23 )
break;
VAR_7 = -VAR_21;
VAR_9 = VAR_0->u.assign_device.flags;
if ( VAR_0->cmd == VAR_18
? VAR_1->is_dying || (VAR_9 & ~VAR_24)
: VAR_9 )
break;
VAR_8 = VAR_0->u.assign_device.u.pci.machine_sbdf;
VAR_7 = xsm_assign_device(VAR_14, VAR_1, VAR_8);
if ( VAR_7 )
break;
VAR_4 = VAR_8 >> 16;
VAR_5 = PCI_BUS(VAR_8);
VAR_6 = PCI_DEVFN2(VAR_8);
VAR_7 = device_assigned(VAR_4, VAR_5, VAR_6);
if ( VAR_0->cmd == VAR_19 )
{
if ( VAR_7 )
{
printk(XENLOG_G_INFO
""%04x:%02x:%02x.%u already assigned, or non-existent\n"",
VAR_4, VAR_5, PCI_SLOT(VAR_6), PCI_FUNC(VAR_6));
VAR_7 = -VAR_21;
}
break;
}
if ( !VAR_7 )
VAR_7 = assign_device(VAR_1, VAR_4, VAR_5, VAR_6, VAR_9);
if ( VAR_7 == -VAR_25 )
VAR_7 = hypercall_create_continuation(VAR_26,
""h"", VAR_3);
else if ( VAR_7 )
printk(XENLOG_G_ERR ""XEN_DOMCTL_assign_device: ""
""assign %04x:%02x:%02x.%u to dom%d failed (%d)\n"",
VAR_4, VAR_5, PCI_SLOT(VAR_6), PCI_FUNC(VAR_6),
VAR_1->domain_id, VAR_7);
break;
case VAR_27:
if ( VAR_1 == VAR_20->domain )
{
VAR_7 = -VAR_21;
break;
}
VAR_7 = -VAR_22;
if ( VAR_0->u.assign_device.dev != VAR_23 )
break;
VAR_7 = -VAR_21;
if ( VAR_0->u.assign_device.flags )
break;
VAR_8 = VAR_0->u.assign_device.u.pci.machine_sbdf;
VAR_7 = xsm_deassign_device(VAR_14, VAR_1, VAR_8);
if ( VAR_7 )
break;
VAR_4 = VAR_8 >> 16;
VAR_5 = PCI_BUS(VAR_8);
VAR_6 = PCI_DEVFN2(VAR_8);
pcidevs_lock();
VAR_7 = deassign_device(VAR_1, VAR_4, VAR_5, VAR_6);
pcidevs_unlock();
if ( VAR_7 )
printk(XENLOG_G_ERR
""deassign %04x:%02x:%02x.%u from dom%d failed (%d)\n"",
VAR_4, VAR_5, PCI_SLOT(VAR_6), PCI_FUNC(VAR_6),
VAR_1->domain_id, VAR_7);
break;
default:
VAR_7 = -VAR_28;
break;
}
return VAR_7;
}",,"int iommu_do_pci_domctl(
    struct xen_domctl *domctl, struct domain *d,
    XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)
{
    u16 seg;
    u8 bus, devfn;
    int ret = 0;
    uint32_t machine_sbdf;

    switch ( domctl->cmd )
    {
        unsigned int flags;

    case XEN_DOMCTL_get_device_group:
    {
        u32 max_sdevs;
        XEN_GUEST_HANDLE_64(uint32) sdevs;

        ret = xsm_get_device_group(XSM_HOOK, domctl->u.get_device_group.machine_sbdf);
        if ( ret )
            break;

        seg = domctl->u.get_device_group.machine_sbdf >> 16;
        bus = PCI_BUS(domctl->u.get_device_group.machine_sbdf);
        devfn = PCI_DEVFN2(domctl->u.get_device_group.machine_sbdf);
        max_sdevs = domctl->u.get_device_group.max_sdevs;
        sdevs = domctl->u.get_device_group.sdev_array;

        ret = iommu_get_device_group(d, seg, bus, devfn, sdevs, max_sdevs);
        if ( ret < 0 )
        {
            dprintk(XENLOG_ERR, ""iommu_get_device_group() failed!\n"");
            ret = -EFAULT;
            domctl->u.get_device_group.num_sdevs = 0;
        }
        else
        {
            domctl->u.get_device_group.num_sdevs = ret;
            ret = 0;
        }
        if ( __copy_field_to_guest(u_domctl, domctl, u.get_device_group) )
            ret = -EFAULT;
    }
    break;

    case XEN_DOMCTL_assign_device:
        ASSERT(d);
        /* fall through */
    case XEN_DOMCTL_test_assign_device:
        /* Don't support self-assignment of devices. */
        if ( d == current->domain )
        {
            ret = -EINVAL;
            break;
        }

        ret = -ENODEV;
        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_PCI )
            break;

        ret = -EINVAL;
        flags = domctl->u.assign_device.flags;
        if ( domctl->cmd == XEN_DOMCTL_assign_device
             ? d->is_dying || (flags & ~XEN_DOMCTL_DEV_RDM_RELAXED)
             : flags )
            break;

        machine_sbdf = domctl->u.assign_device.u.pci.machine_sbdf;

        ret = xsm_assign_device(XSM_HOOK, d, machine_sbdf);
        if ( ret )
            break;

        seg = machine_sbdf >> 16;
        bus = PCI_BUS(machine_sbdf);
        devfn = PCI_DEVFN2(machine_sbdf);

        ret = device_assigned(seg, bus, devfn);
        if ( domctl->cmd == XEN_DOMCTL_test_assign_device )
        {
            if ( ret )
            {
                printk(XENLOG_G_INFO
                       ""%04x:%02x:%02x.%u already assigned, or non-existent\n"",
                       seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));
                ret = -EINVAL;
            }
            break;
        }
        if ( !ret )
            ret = assign_device(d, seg, bus, devfn, flags);
        if ( ret == -ERESTART )
            ret = hypercall_create_continuation(__HYPERVISOR_domctl,
                                                ""h"", u_domctl);
        else if ( ret )
            printk(XENLOG_G_ERR
                   ""assign %04x:%02x:%02x.%u to dom%d failed (%d)\n"",
                   seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),
                   d->domain_id, ret);

        break;

    case XEN_DOMCTL_deassign_device:
        /* Don't support self-deassignment of devices. */
        if ( d == current->domain )
        {
            ret = -EINVAL;
            break;
        }

        ret = -ENODEV;
        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_PCI )
            break;

        ret = -EINVAL;
        if ( domctl->u.assign_device.flags )
            break;

        machine_sbdf = domctl->u.assign_device.u.pci.machine_sbdf;

        ret = xsm_deassign_device(XSM_HOOK, d, machine_sbdf);
        if ( ret )
            break;

        seg = machine_sbdf >> 16;
        bus = PCI_BUS(machine_sbdf);
        devfn = PCI_DEVFN2(machine_sbdf);

        pcidevs_lock();
        ret = deassign_device(d, seg, bus, devfn);
        pcidevs_unlock();
        if ( ret )
            printk(XENLOG_G_ERR
                   ""deassign %04x:%02x:%02x.%u from dom%d failed (%d)\n"",
                   seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),
                   d->domain_id, ret);

        break;

    default:
        ret = -ENOSYS;
        break;
    }

    return ret;
}","int iommu_do_pci_domctl(
    struct xen_domctl *VAR_0, struct domain *VAR_1,
    VAR_2(xen_domctl_t) VAR_3)
{
    u16 VAR_4;
    u8 VAR_5, VAR_6;
    int VAR_7 = 0;
    uint32_t VAR_8;

    switch ( VAR_0->cmd )
    {
        unsigned int VAR_9;

    case VAR_10:
    {
        u32 VAR_11;
        VAR_12(uint32) VAR_13;

        VAR_7 = xsm_get_device_group(VAR_14, VAR_0->u.get_device_group.machine_sbdf);
        if ( VAR_7 )
            break;

        VAR_4 = VAR_0->u.get_device_group.machine_sbdf >> 16;
        VAR_5 = PCI_BUS(VAR_0->u.get_device_group.machine_sbdf);
        VAR_6 = PCI_DEVFN2(VAR_0->u.get_device_group.machine_sbdf);
        VAR_11 = VAR_0->u.get_device_group.max_sdevs;
        VAR_13 = VAR_0->u.get_device_group.sdev_array;

        VAR_7 = iommu_get_device_group(VAR_1, VAR_4, VAR_5, VAR_6, VAR_13, VAR_11);
        if ( VAR_7 < 0 )
        {
            dprintk(VAR_15, ""iommu_get_device_group() failed!\n"");
            VAR_7 = -VAR_16;
            VAR_0->u.get_device_group.num_sdevs = 0;
        }
        else
        {
            VAR_0->u.get_device_group.num_sdevs = VAR_7;
            VAR_7 = 0;
        }
        if ( __copy_field_to_guest(VAR_3, VAR_0, VAR_17.get_device_group) )
            VAR_7 = -VAR_16;
    }
    break;

    case VAR_18:
        ASSERT(VAR_1);
        /* COMMENT_0 */
    case VAR_19:
        /* COMMENT_1 */
        if ( VAR_1 == VAR_20->domain )
        {
            VAR_7 = -VAR_21;
            break;
        }

        VAR_7 = -VAR_22;
        if ( VAR_0->u.assign_device.dev != VAR_23 )
            break;

        VAR_7 = -VAR_21;
        VAR_9 = VAR_0->u.assign_device.flags;
        if ( VAR_0->cmd == VAR_18
             ? VAR_1->is_dying || (VAR_9 & ~VAR_24)
             : VAR_9 )
            break;

        VAR_8 = VAR_0->u.assign_device.u.pci.machine_sbdf;

        VAR_7 = xsm_assign_device(VAR_14, VAR_1, VAR_8);
        if ( VAR_7 )
            break;

        VAR_4 = VAR_8 >> 16;
        VAR_5 = PCI_BUS(VAR_8);
        VAR_6 = PCI_DEVFN2(VAR_8);

        VAR_7 = device_assigned(VAR_4, VAR_5, VAR_6);
        if ( VAR_0->cmd == VAR_19 )
        {
            if ( VAR_7 )
            {
                printk(XENLOG_G_INFO
                       ""%04x:%02x:%02x.%u already assigned, or non-existent\n"",
                       VAR_4, VAR_5, PCI_SLOT(VAR_6), PCI_FUNC(VAR_6));
                VAR_7 = -VAR_21;
            }
            break;
        }
        if ( !VAR_7 )
            VAR_7 = assign_device(VAR_1, VAR_4, VAR_5, VAR_6, VAR_9);
        if ( VAR_7 == -VAR_25 )
            VAR_7 = hypercall_create_continuation(VAR_26,
                                                ""h"", VAR_3);
        else if ( VAR_7 )
            printk(XENLOG_G_ERR
                   ""assign %04x:%02x:%02x.%u to dom%d failed (%d)\n"",
                   VAR_4, VAR_5, PCI_SLOT(VAR_6), PCI_FUNC(VAR_6),
                   VAR_1->domain_id, VAR_7);

        break;

    case VAR_27:
        /* COMMENT_2 */
        if ( VAR_1 == VAR_20->domain )
        {
            VAR_7 = -VAR_21;
            break;
        }

        VAR_7 = -VAR_22;
        if ( VAR_0->u.assign_device.dev != VAR_23 )
            break;

        VAR_7 = -VAR_21;
        if ( VAR_0->u.assign_device.flags )
            break;

        VAR_8 = VAR_0->u.assign_device.u.pci.machine_sbdf;

        VAR_7 = xsm_deassign_device(VAR_14, VAR_1, VAR_8);
        if ( VAR_7 )
            break;

        VAR_4 = VAR_8 >> 16;
        VAR_5 = PCI_BUS(VAR_8);
        VAR_6 = PCI_DEVFN2(VAR_8);

        pcidevs_lock();
        VAR_7 = deassign_device(VAR_1, VAR_4, VAR_5, VAR_6);
        pcidevs_unlock();
        if ( VAR_7 )
            printk(XENLOG_G_ERR
                   ""deassign %04x:%02x:%02x.%u from dom%d failed (%d)\n"",
                   VAR_4, VAR_5, PCI_SLOT(VAR_6), PCI_FUNC(VAR_6),
                   VAR_1->domain_id, VAR_7);

        break;

    default:
        VAR_7 = -VAR_28;
        break;
    }

    return VAR_7;
}",,"--- func_before
+++ func_after
@@ -93,7 +93,7 @@
             ret = hypercall_create_continuation(__HYPERVISOR_domctl,
                                                 ""h"", u_domctl);
         else if ( ret )
-            printk(XENLOG_G_ERR ""XEN_DOMCTL_assign_device: ""
+            printk(XENLOG_G_ERR
                    ""assign %04x:%02x:%02x.%u to dom%d failed (%d)\n"",
                    seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),
                    d->domain_id, ret);","{'deleted_lines': ['            printk(XENLOG_G_ERR ""XEN_DOMCTL_assign_device: ""'], 'added_lines': ['            printk(XENLOG_G_ERR']}",True,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",6.8,MEDIUM,1,test,2019-10-18T16:41:44Z,3
CVE-2019-18424,['CWE-78'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"passthrough: quarantine PCI devices

When a PCI device is assigned to an untrusted domain, it is possible for
that domain to program the device to DMA to an arbitrary address. The
IOMMU is used to protect the host from malicious DMA by making sure that
the device addresses can only target memory assigned to the guest. However,
when the guest domain is torn down the device is assigned back to dom0,
thus allowing any in-flight DMA to potentially target critical host data.

This patch introduces a 'quarantine' for PCI devices using dom_io. When
the toolstack makes a device assignable (by binding it to pciback), it
will now also assign it to DOMID_IO and the device will only be assigned
back to dom0 when the device is made unassignable again. Whilst device is
assignable it will only ever transfer between dom_io and guest domains.
dom_io is actually only used as a sentinel domain for quarantining purposes;
it is not configured with any IOMMU mappings. Assignment to dom_io simply
means that the device's initiator (requestor) identifier is not present in
the IOMMU's device table and thus any DMA transactions issued will be
terminated with a fault condition.

In addition, a fix to assignment handling is made for VT-d.  Failure
during the assignment step should not lead to a device still being
associated with its prior owner. Hand the device to DomIO temporarily,
until the assignment step has completed successfully.  Remove the PI
hooks from the source domain then earlier as well.

Failure of the recovery reassign_device_ownership() may not go silent:
There e.g. may still be left over RMRR mappings in the domain assignment
to which has failed, and hence we can't allow that domain to continue
executing.

NOTE: This patch also includes one printk() cleanup; the
      ""XEN_DOMCTL_assign_device: "" tag is dropped in iommu_do_pci_domctl(),
      since similar printk()-s elsewhere also don't log such a tag.

This is XSA-302.

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,tools/libxl/libxl_pci.c,libxl__device_pci_assignable_remove,"static int libxl__device_pci_assignable_remove(libxl__gc *gc,
libxl_device_pci *pcidev,
int rebind)
{
int rc;
char *driver_path;
if ( (rc=pciback_dev_is_assigned(gc, pcidev)) < 0 ) {
return ERROR_FAIL;
} else if ( rc ) {
pciback_dev_unassign(gc, pcidev);
} else {
LOG(WARN, ""Not bound to pciback"");
}
driver_path = pci_assignable_driver_path_read(gc, pcidev);
if ( driver_path ) {
if ( rebind ) {
LOG(INFO, ""Rebinding to driver at %s"", driver_path);
if ( sysfs_write_bdf(gc,
GCSPRINTF(""%s/bind"", driver_path),
pcidev) < 0 ) {
LOGE(ERROR, ""Couldn't bind device to %s"", driver_path);
return -1;
}
pci_assignable_driver_path_remove(gc, pcidev);
}
} else {
if ( rebind ) {
LOG(WARN,
""Couldn't find path for original driver; not rebinding"");
}
}
return 0;
}","static int libxl__device_pci_assignable_remove(libxl__gc *VAR_0,
libxl_device_pci *VAR_1,
int VAR_2)
{
int VAR_3;
char *VAR_4;
if ( (VAR_3=pciback_dev_is_assigned(VAR_0, VAR_1)) < 0 ) {
return VAR_5;
} else if ( VAR_3 ) {
pciback_dev_unassign(VAR_0, VAR_1);
} else {
LOG(VAR_6, ""Not bound to pciback"");
}
VAR_4 = pci_assignable_driver_path_read(VAR_0, VAR_1);
if ( VAR_4 ) {
if ( VAR_2 ) {
LOG(VAR_7, ""Rebinding to driver at %s"", VAR_4);
if ( sysfs_write_bdf(VAR_0,
GCSPRINTF(""%s/bind"", VAR_4),
VAR_1) < 0 ) {
LOGE(VAR_8, ""Couldn't bind device to %s"", VAR_4);
return -1;
}
pci_assignable_driver_path_remove(VAR_0, VAR_1);
}
} else {
if ( VAR_2 ) {
LOG(VAR_6,
""Couldn't find path for original driver; not rebinding"");
}
}
return 0;
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/libxl_pci.c/vul/before/0.json,"static int libxl__device_pci_assignable_remove(libxl__gc *gc,
                                               libxl_device_pci *pcidev,
                                               int rebind)
{
    libxl_ctx *ctx = libxl__gc_owner(gc);
    int rc;
    char *driver_path;

    /* De-quarantine */
    rc = xc_deassign_device(ctx->xch, DOMID_IO, pcidev_encode_bdf(pcidev));
    if ( rc < 0 ) {
        LOG(ERROR, ""failed to de-quarantine ""PCI_BDF, pcidev->domain, pcidev->bus,
            pcidev->dev, pcidev->func);
        return ERROR_FAIL;
    }

    /* Unbind from pciback */
    if ( (rc=pciback_dev_is_assigned(gc, pcidev)) < 0 ) {
        return ERROR_FAIL;
    } else if ( rc ) {
        pciback_dev_unassign(gc, pcidev);
    } else {
        LOG(WARN, ""Not bound to pciback"");
    }

    /* Rebind if necessary */
    driver_path = pci_assignable_driver_path_read(gc, pcidev);

    if ( driver_path ) {
        if ( rebind ) {
            LOG(INFO, ""Rebinding to driver at %s"", driver_path);

            if ( sysfs_write_bdf(gc,
                                 GCSPRINTF(""%s/bind"", driver_path),
                                 pcidev) < 0 ) {
                LOGE(ERROR, ""Couldn't bind device to %s"", driver_path);
                return -1;
            }

            pci_assignable_driver_path_remove(gc, pcidev);
        }
    } else {
        if ( rebind ) {
            LOG(WARN,
                ""Couldn't find path for original driver; not rebinding"");
        }
    }

    return 0;
}","static int libxl__device_pci_assignable_remove(libxl__gc *VAR_0,
                                               libxl_device_pci *VAR_1,
                                               int VAR_2)
{
    libxl_ctx *VAR_3 = libxl__gc_owner(VAR_0);
    int VAR_4;
    char *VAR_5;

    /* COMMENT_0 */
    VAR_4 = xc_deassign_device(VAR_3->xch, VAR_6, pcidev_encode_bdf(VAR_1));
    if ( VAR_4 < 0 ) {
        LOG(VAR_7, ""failed to de-quarantine ""VAR_8, VAR_1->domain, VAR_1->bus,
            VAR_1->dev, VAR_1->func);
        return VAR_9;
    }

    /* COMMENT_1 */
    if ( (VAR_4=pciback_dev_is_assigned(VAR_0, VAR_1)) < 0 ) {
        return VAR_9;
    } else if ( VAR_4 ) {
        pciback_dev_unassign(VAR_0, VAR_1);
    } else {
        LOG(VAR_10, ""Not bound to pciback"");
    }

    /* COMMENT_2 */
    VAR_5 = pci_assignable_driver_path_read(VAR_0, VAR_1);

    if ( VAR_5 ) {
        if ( VAR_2 ) {
            LOG(VAR_11, ""Rebinding to driver at %s"", VAR_5);

            if ( sysfs_write_bdf(VAR_0,
                                 GCSPRINTF(""%s/bind"", VAR_5),
                                 VAR_1) < 0 ) {
                LOGE(VAR_7, ""Couldn't bind device to %s"", VAR_5);
                return -1;
            }

            pci_assignable_driver_path_remove(VAR_0, VAR_1);
        }
    } else {
        if ( VAR_2 ) {
            LOG(VAR_10,
                ""Couldn't find path for original driver; not rebinding"");
        }
    }

    return 0;
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/libxl_pci.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,8 +2,17 @@
                                                libxl_device_pci *pcidev,
                                                int rebind)
 {
+    libxl_ctx *ctx = libxl__gc_owner(gc);
     int rc;
     char *driver_path;
+
+    /* De-quarantine */
+    rc = xc_deassign_device(ctx->xch, DOMID_IO, pcidev_encode_bdf(pcidev));
+    if ( rc < 0 ) {
+        LOG(ERROR, ""failed to de-quarantine ""PCI_BDF, pcidev->domain, pcidev->bus,
+            pcidev->dev, pcidev->func);
+        return ERROR_FAIL;
+    }
 
     /* Unbind from pciback */
     if ( (rc=pciback_dev_is_assigned(gc, pcidev)) < 0 ) {","{'deleted_lines': [], 'added_lines': ['    libxl_ctx *ctx = libxl__gc_owner(gc);', '', '    /* De-quarantine */', '    rc = xc_deassign_device(ctx->xch, DOMID_IO, pcidev_encode_bdf(pcidev));', '    if ( rc < 0 ) {', '        LOG(ERROR, ""failed to de-quarantine ""PCI_BDF, pcidev->domain, pcidev->bus,', '            pcidev->dev, pcidev->func);', '        return ERROR_FAIL;', '    }']}",True,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",6.8,MEDIUM,1,test,2019-10-18T16:41:44Z,3
CVE-2019-18424,['CWE-78'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"passthrough: quarantine PCI devices

When a PCI device is assigned to an untrusted domain, it is possible for
that domain to program the device to DMA to an arbitrary address. The
IOMMU is used to protect the host from malicious DMA by making sure that
the device addresses can only target memory assigned to the guest. However,
when the guest domain is torn down the device is assigned back to dom0,
thus allowing any in-flight DMA to potentially target critical host data.

This patch introduces a 'quarantine' for PCI devices using dom_io. When
the toolstack makes a device assignable (by binding it to pciback), it
will now also assign it to DOMID_IO and the device will only be assigned
back to dom0 when the device is made unassignable again. Whilst device is
assignable it will only ever transfer between dom_io and guest domains.
dom_io is actually only used as a sentinel domain for quarantining purposes;
it is not configured with any IOMMU mappings. Assignment to dom_io simply
means that the device's initiator (requestor) identifier is not present in
the IOMMU's device table and thus any DMA transactions issued will be
terminated with a fault condition.

In addition, a fix to assignment handling is made for VT-d.  Failure
during the assignment step should not lead to a device still being
associated with its prior owner. Hand the device to DomIO temporarily,
until the assignment step has completed successfully.  Remove the PI
hooks from the source domain then earlier as well.

Failure of the recovery reassign_device_ownership() may not go silent:
There e.g. may still be left over RMRR mappings in the domain assignment
to which has failed, and hence we can't allow that domain to continue
executing.

NOTE: This patch also includes one printk() cleanup; the
      ""XEN_DOMCTL_assign_device: "" tag is dropped in iommu_do_pci_domctl(),
      since similar printk()-s elsewhere also don't log such a tag.

This is XSA-302.

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,xen/drivers/passthrough/amd/pci_amd_iommu.c,amd_iommu_assign_device,"static int amd_iommu_assign_device(struct domain *d, u8 devfn,
struct pci_dev *pdev,
u32 flag)
{
struct ivrs_mappings *ivrs_mappings = get_ivrs_mappings(pdev->seg);
int bdf = PCI_BDF2(pdev->bus, devfn);
int req_id = get_dma_requestor_id(pdev->seg, bdf);
if ( ivrs_mappings[req_id].unity_map_enable )
{
amd_iommu_reserve_domain_unity_map(
d,
ivrs_mappings[req_id].addr_range_start,
ivrs_mappings[req_id].addr_range_length,
ivrs_mappings[req_id].write_permission,
ivrs_mappings[req_id].read_permission);
}
return reassign_device(hardware_domain, d, devfn, pdev);
}","static int amd_iommu_assign_device(struct domain *VAR_0, u8 VAR_1,
struct pci_dev *VAR_2,
u32 VAR_3)
{
struct ivrs_mappings *ivrs_mappings = get_ivrs_mappings(VAR_2->seg);
int VAR_4 = PCI_BDF2(VAR_2->bus, VAR_1);
int VAR_5 = get_dma_requestor_id(VAR_2->seg, VAR_4);
if ( ivrs_mappings[VAR_5].unity_map_enable )
{
amd_iommu_reserve_domain_unity_map(
VAR_0,
ivrs_mappings[VAR_5].addr_range_start,
ivrs_mappings[VAR_5].addr_range_length,
ivrs_mappings[VAR_5].write_permission,
ivrs_mappings[VAR_5].read_permission);
}
return reassign_device(VAR_6, VAR_0, VAR_1, VAR_2);
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/pci_amd_iommu.c/vul/before/2.json,"static int amd_iommu_assign_device(struct domain *d, u8 devfn,
                                   struct pci_dev *pdev,
                                   u32 flag)
{
    struct ivrs_mappings *ivrs_mappings = get_ivrs_mappings(pdev->seg);
    int bdf = PCI_BDF2(pdev->bus, devfn);
    int req_id = get_dma_requestor_id(pdev->seg, bdf);

    if ( ivrs_mappings[req_id].unity_map_enable )
    {
        amd_iommu_reserve_domain_unity_map(
            d,
            ivrs_mappings[req_id].addr_range_start,
            ivrs_mappings[req_id].addr_range_length,
            ivrs_mappings[req_id].write_permission,
            ivrs_mappings[req_id].read_permission);
    }

    return reassign_device(pdev->domain, d, devfn, pdev);
}","static int amd_iommu_assign_device(struct domain *VAR_0, u8 VAR_1,
                                   struct pci_dev *VAR_2,
                                   u32 VAR_3)
{
    struct ivrs_mappings *ivrs_mappings = get_ivrs_mappings(VAR_2->seg);
    int VAR_4 = PCI_BDF2(VAR_2->bus, VAR_1);
    int VAR_5 = get_dma_requestor_id(VAR_2->seg, VAR_4);

    if ( ivrs_mappings[VAR_5].unity_map_enable )
    {
        amd_iommu_reserve_domain_unity_map(
            VAR_0,
            ivrs_mappings[VAR_5].addr_range_start,
            ivrs_mappings[VAR_5].addr_range_length,
            ivrs_mappings[VAR_5].write_permission,
            ivrs_mappings[VAR_5].read_permission);
    }

    return reassign_device(VAR_2->domain, VAR_0, VAR_1, VAR_2);
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/pci_amd_iommu.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -16,5 +16,5 @@
             ivrs_mappings[req_id].read_permission);
     }
 
-    return reassign_device(hardware_domain, d, devfn, pdev);
+    return reassign_device(pdev->domain, d, devfn, pdev);
 }","{'deleted_lines': ['    return reassign_device(hardware_domain, d, devfn, pdev);'], 'added_lines': ['    return reassign_device(pdev->domain, d, devfn, pdev);']}",True,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",6.8,MEDIUM,1,test,2019-10-18T16:41:44Z,3
CVE-2019-18424,['CWE-78'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"passthrough: quarantine PCI devices

When a PCI device is assigned to an untrusted domain, it is possible for
that domain to program the device to DMA to an arbitrary address. The
IOMMU is used to protect the host from malicious DMA by making sure that
the device addresses can only target memory assigned to the guest. However,
when the guest domain is torn down the device is assigned back to dom0,
thus allowing any in-flight DMA to potentially target critical host data.

This patch introduces a 'quarantine' for PCI devices using dom_io. When
the toolstack makes a device assignable (by binding it to pciback), it
will now also assign it to DOMID_IO and the device will only be assigned
back to dom0 when the device is made unassignable again. Whilst device is
assignable it will only ever transfer between dom_io and guest domains.
dom_io is actually only used as a sentinel domain for quarantining purposes;
it is not configured with any IOMMU mappings. Assignment to dom_io simply
means that the device's initiator (requestor) identifier is not present in
the IOMMU's device table and thus any DMA transactions issued will be
terminated with a fault condition.

In addition, a fix to assignment handling is made for VT-d.  Failure
during the assignment step should not lead to a device still being
associated with its prior owner. Hand the device to DomIO temporarily,
until the assignment step has completed successfully.  Remove the PI
hooks from the source domain then earlier as well.

Failure of the recovery reassign_device_ownership() may not go silent:
There e.g. may still be left over RMRR mappings in the domain assignment
to which has failed, and hence we can't allow that domain to continue
executing.

NOTE: This patch also includes one printk() cleanup; the
      ""XEN_DOMCTL_assign_device: "" tag is dropped in iommu_do_pci_domctl(),
      since similar printk()-s elsewhere also don't log such a tag.

This is XSA-302.

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,xen/drivers/passthrough/amd/pci_amd_iommu.c,amd_iommu_disable_domain_device,"static void amd_iommu_disable_domain_device(const struct domain *domain,
struct amd_iommu *iommu,
uint8_t devfn, struct pci_dev *pdev)
{
struct amd_iommu_dte *table, *dte;
unsigned long flags;
int req_id;
u8 bus = pdev->bus;
BUG_ON ( iommu->dev_table.buffer == NULL );
req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));
table = iommu->dev_table.buffer;
dte = &table[req_id];
spin_lock_irqsave(&iommu->lock, flags);
if ( dte->tv || dte->v )
{
dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_ABORTED;
smp_wmb();
dte->iv = true;
dte->tv = false;
dte->gv = false;
dte->i = false;
dte->ex = false;
dte->sa = false;
dte->se = false;
dte->sd = false;
dte->sys_mgt = IOMMU_DEV_TABLE_SYS_MGT_DMA_ABORTED;
dte->ioctl = IOMMU_DEV_TABLE_IO_CONTROL_ABORTED;
smp_wmb();
dte->v = true;
amd_iommu_flush_device(iommu, req_id);
AMD_IOMMU_DEBUG(""Disable: device id = %#x, ""
""domain = %d, paging mode = %d\n"",
req_id,  domain->domain_id,
dom_iommu(domain)->arch.paging_mode);
}
spin_unlock_irqrestore(&iommu->lock, flags);
ASSERT(pcidevs_locked());
if ( devfn == pdev->devfn &&
pci_ats_device(iommu->seg, bus, devfn) &&
pci_ats_enabled(iommu->seg, bus, devfn) )
disable_ats_device(pdev);
}","static void amd_iommu_disable_domain_device(const struct domain *domain,
struct amd_iommu *VAR_0,
uint8_t VAR_1, struct pci_dev *VAR_2)
{
struct amd_iommu_dte *VAR_3, *VAR_4;
unsigned long VAR_5;
int VAR_6;
u8 VAR_7 = VAR_2->bus;
BUG_ON ( VAR_0->dev_table.buffer == NULL );
VAR_6 = get_dma_requestor_id(VAR_0->seg, PCI_BDF2(VAR_7, VAR_1));
VAR_3 = VAR_0->dev_table.buffer;
VAR_4 = &VAR_3[VAR_6];
spin_lock_irqsave(&VAR_0->lock, VAR_5);
if ( VAR_4->tv || VAR_4->v )
{
VAR_4->int_ctl = VAR_8;
smp_wmb();
VAR_4->iv = true;
VAR_4->tv = false;
VAR_4->gv = false;
VAR_4->i = false;
VAR_4->ex = false;
VAR_4->sa = false;
VAR_4->se = false;
VAR_4->sd = false;
VAR_4->sys_mgt = VAR_9;
VAR_4->ioctl = VAR_10;
smp_wmb();
VAR_4->v = true;
amd_iommu_flush_device(VAR_0, VAR_6);
AMD_IOMMU_DEBUG(""Disable: device id = %#x, ""
""domain = %d, paging mode = %d\n"",
VAR_6,  domain->domain_id,
dom_iommu(domain)->arch.paging_mode);
}
spin_unlock_irqrestore(&VAR_0->lock, VAR_5);
ASSERT(pcidevs_locked());
if ( VAR_1 == VAR_2->devfn &&
pci_ats_device(VAR_0->seg, VAR_7, VAR_1) &&
pci_ats_enabled(VAR_0->seg, VAR_7, VAR_1) )
disable_ats_device(VAR_2);
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/pci_amd_iommu.c/vul/before/1.json,"static void amd_iommu_disable_domain_device(const struct domain *domain,
                                            struct amd_iommu *iommu,
                                            uint8_t devfn, struct pci_dev *pdev)
{
    struct amd_iommu_dte *table, *dte;
    unsigned long flags;
    int req_id;
    u8 bus = pdev->bus;

    /* dom_io is used as a sentinel for quarantined devices */
    if ( domain == dom_io )
        return;

    BUG_ON ( iommu->dev_table.buffer == NULL );
    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));
    table = iommu->dev_table.buffer;
    dte = &table[req_id];

    spin_lock_irqsave(&iommu->lock, flags);
    if ( dte->tv || dte->v )
    {
        /* See the comment in amd_iommu_setup_device_table(). */
        dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_ABORTED;
        smp_wmb();
        dte->iv = true;
        dte->tv = false;
        dte->gv = false;
        dte->i = false;
        dte->ex = false;
        dte->sa = false;
        dte->se = false;
        dte->sd = false;
        dte->sys_mgt = IOMMU_DEV_TABLE_SYS_MGT_DMA_ABORTED;
        dte->ioctl = IOMMU_DEV_TABLE_IO_CONTROL_ABORTED;
        smp_wmb();
        dte->v = true;

        amd_iommu_flush_device(iommu, req_id);

        AMD_IOMMU_DEBUG(""Disable: device id = %#x, ""
                        ""domain = %d, paging mode = %d\n"",
                        req_id,  domain->domain_id,
                        dom_iommu(domain)->arch.paging_mode);
    }
    spin_unlock_irqrestore(&iommu->lock, flags);

    ASSERT(pcidevs_locked());

    if ( devfn == pdev->devfn &&
         pci_ats_device(iommu->seg, bus, devfn) &&
         pci_ats_enabled(iommu->seg, bus, devfn) )
        disable_ats_device(pdev);
}","static void amd_iommu_disable_domain_device(const struct domain *domain,
                                            struct amd_iommu *VAR_0,
                                            uint8_t VAR_1, struct pci_dev *VAR_2)
{
    struct amd_iommu_dte *VAR_3, *VAR_4;
    unsigned long VAR_5;
    int VAR_6;
    u8 VAR_7 = VAR_2->bus;

    /* COMMENT_0 */
    if ( domain == VAR_8 )
        return;

    BUG_ON ( VAR_0->dev_table.buffer == NULL );
    VAR_6 = get_dma_requestor_id(VAR_0->seg, PCI_BDF2(VAR_7, VAR_1));
    VAR_3 = VAR_0->dev_table.buffer;
    VAR_4 = &VAR_3[VAR_6];

    spin_lock_irqsave(&VAR_0->lock, VAR_5);
    if ( VAR_4->tv || VAR_4->v )
    {
        /* COMMENT_1 */
        VAR_4->int_ctl = VAR_9;
        smp_wmb();
        VAR_4->iv = true;
        VAR_4->tv = false;
        VAR_4->gv = false;
        VAR_4->i = false;
        VAR_4->ex = false;
        VAR_4->sa = false;
        VAR_4->se = false;
        VAR_4->sd = false;
        VAR_4->sys_mgt = VAR_10;
        VAR_4->ioctl = VAR_11;
        smp_wmb();
        VAR_4->v = true;

        amd_iommu_flush_device(VAR_0, VAR_6);

        AMD_IOMMU_DEBUG(""Disable: device id = %#x, ""
                        ""domain = %d, paging mode = %d\n"",
                        VAR_6,  domain->domain_id,
                        dom_iommu(domain)->arch.paging_mode);
    }
    spin_unlock_irqrestore(&VAR_0->lock, VAR_5);

    ASSERT(pcidevs_locked());

    if ( VAR_1 == VAR_2->devfn &&
         pci_ats_device(VAR_0->seg, VAR_7, VAR_1) &&
         pci_ats_enabled(VAR_0->seg, VAR_7, VAR_1) )
        disable_ats_device(VAR_2);
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/pci_amd_iommu.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -6,6 +6,10 @@
     unsigned long flags;
     int req_id;
     u8 bus = pdev->bus;
+
+    /* dom_io is used as a sentinel for quarantined devices */
+    if ( domain == dom_io )
+        return;
 
     BUG_ON ( iommu->dev_table.buffer == NULL );
     req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));","{'deleted_lines': [], 'added_lines': ['', '    /* dom_io is used as a sentinel for quarantined devices */', '    if ( domain == dom_io )', '        return;']}",True,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",6.8,MEDIUM,1,test,2019-10-18T16:41:44Z,3
CVE-2019-18424,['CWE-78'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"passthrough: quarantine PCI devices

When a PCI device is assigned to an untrusted domain, it is possible for
that domain to program the device to DMA to an arbitrary address. The
IOMMU is used to protect the host from malicious DMA by making sure that
the device addresses can only target memory assigned to the guest. However,
when the guest domain is torn down the device is assigned back to dom0,
thus allowing any in-flight DMA to potentially target critical host data.

This patch introduces a 'quarantine' for PCI devices using dom_io. When
the toolstack makes a device assignable (by binding it to pciback), it
will now also assign it to DOMID_IO and the device will only be assigned
back to dom0 when the device is made unassignable again. Whilst device is
assignable it will only ever transfer between dom_io and guest domains.
dom_io is actually only used as a sentinel domain for quarantining purposes;
it is not configured with any IOMMU mappings. Assignment to dom_io simply
means that the device's initiator (requestor) identifier is not present in
the IOMMU's device table and thus any DMA transactions issued will be
terminated with a fault condition.

In addition, a fix to assignment handling is made for VT-d.  Failure
during the assignment step should not lead to a device still being
associated with its prior owner. Hand the device to DomIO temporarily,
until the assignment step has completed successfully.  Remove the PI
hooks from the source domain then earlier as well.

Failure of the recovery reassign_device_ownership() may not go silent:
There e.g. may still be left over RMRR mappings in the domain assignment
to which has failed, and hence we can't allow that domain to continue
executing.

NOTE: This patch also includes one printk() cleanup; the
      ""XEN_DOMCTL_assign_device: "" tag is dropped in iommu_do_pci_domctl(),
      since similar printk()-s elsewhere also don't log such a tag.

This is XSA-302.

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,xen/drivers/passthrough/amd/pci_amd_iommu.c,amd_iommu_setup_domain_device,"static void amd_iommu_setup_domain_device(
struct domain *domain, struct amd_iommu *iommu,
uint8_t devfn, struct pci_dev *pdev)
{
struct amd_iommu_dte *table, *dte;
unsigned long flags;
int req_id, valid = 1;
u8 bus = pdev->bus;
const struct domain_iommu *hd = dom_iommu(domain);
BUG_ON( !hd->arch.root_table || !hd->arch.paging_mode ||
!iommu->dev_table.buffer );
if ( iommu_hwdom_passthrough && is_hardware_domain(domain) )
valid = 0;
req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));
table = iommu->dev_table.buffer;
dte = &table[req_id];
spin_lock_irqsave(&iommu->lock, flags);
if ( !dte->v || !dte->tv )
{
amd_iommu_set_root_page_table(
dte, page_to_maddr(hd->arch.root_table), domain->domain_id,
hd->arch.paging_mode, valid);
if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&
iommu_has_cap(iommu, PCI_CAP_IOTLB_SHIFT) )
dte->i = ats_enabled;
amd_iommu_flush_device(iommu, req_id);
AMD_IOMMU_DEBUG(""Setup I/O page table: device id = %#x, type = %#x, ""
""root table = %#""PRIx64"", ""
""domain = %d, paging mode = %d\n"",
req_id, pdev->type,
page_to_maddr(hd->arch.root_table),
domain->domain_id, hd->arch.paging_mode);
}
spin_unlock_irqrestore(&iommu->lock, flags);
ASSERT(pcidevs_locked());
if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&
!pci_ats_enabled(iommu->seg, bus, pdev->devfn) )
{
if ( devfn == pdev->devfn )
enable_ats_device(pdev, &iommu->ats_devices);
amd_iommu_flush_iotlb(devfn, pdev, INV_IOMMU_ALL_PAGES_ADDRESS, 0);
}
}","static void amd_iommu_setup_domain_device(
struct domain *domain, struct amd_iommu *VAR_0,
uint8_t VAR_1, struct pci_dev *VAR_2)
{
struct amd_iommu_dte *VAR_3, *VAR_4;
unsigned long VAR_5;
int VAR_6, VAR_7 = 1;
u8 VAR_8 = VAR_2->bus;
const struct domain_iommu *VAR_9 = dom_iommu(domain);
BUG_ON( !VAR_9->arch.root_table || !VAR_9->arch.paging_mode ||
!VAR_0->dev_table.buffer );
if ( VAR_10 && is_hardware_domain(domain) )
VAR_7 = 0;
VAR_6 = get_dma_requestor_id(VAR_0->seg, PCI_BDF2(VAR_8, VAR_1));
VAR_3 = VAR_0->dev_table.buffer;
VAR_4 = &VAR_3[VAR_6];
spin_lock_irqsave(&VAR_0->lock, VAR_5);
if ( !VAR_4->v || !VAR_4->tv )
{
amd_iommu_set_root_page_table(
VAR_4, page_to_maddr(VAR_9->arch.root_table), domain->domain_id,
VAR_9->arch.paging_mode, VAR_7);
if ( pci_ats_device(VAR_0->seg, VAR_8, VAR_2->devfn) &&
iommu_has_cap(VAR_0, VAR_11) )
VAR_4->i = VAR_12;
amd_iommu_flush_device(VAR_0, VAR_6);
AMD_IOMMU_DEBUG(""Setup I/O page table: device id = %#x, type = %#x, ""
""root table = %#""VAR_13"", ""
""domain = %d, paging mode = %d\n"",
VAR_6, VAR_2->type,
page_to_maddr(VAR_9->arch.root_table),
domain->domain_id, VAR_9->arch.paging_mode);
}
spin_unlock_irqrestore(&VAR_0->lock, VAR_5);
ASSERT(pcidevs_locked());
if ( pci_ats_device(VAR_0->seg, VAR_8, VAR_2->devfn) &&
!pci_ats_enabled(VAR_0->seg, VAR_8, VAR_2->devfn) )
{
if ( VAR_1 == VAR_2->devfn )
enable_ats_device(VAR_2, &VAR_0->ats_devices);
amd_iommu_flush_iotlb(VAR_1, VAR_2, VAR_14, 0);
}
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/pci_amd_iommu.c/vul/before/0.json,"static void amd_iommu_setup_domain_device(
    struct domain *domain, struct amd_iommu *iommu,
    uint8_t devfn, struct pci_dev *pdev)
{
    struct amd_iommu_dte *table, *dte;
    unsigned long flags;
    int req_id, valid = 1;
    u8 bus = pdev->bus;
    const struct domain_iommu *hd = dom_iommu(domain);

    /* dom_io is used as a sentinel for quarantined devices */
    if ( domain == dom_io )
        return;

    BUG_ON( !hd->arch.root_table || !hd->arch.paging_mode ||
            !iommu->dev_table.buffer );

    if ( iommu_hwdom_passthrough && is_hardware_domain(domain) )
        valid = 0;

    /* get device-table entry */
    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));
    table = iommu->dev_table.buffer;
    dte = &table[req_id];

    spin_lock_irqsave(&iommu->lock, flags);

    if ( !dte->v || !dte->tv )
    {
        /* bind DTE to domain page-tables */
        amd_iommu_set_root_page_table(
            dte, page_to_maddr(hd->arch.root_table), domain->domain_id,
            hd->arch.paging_mode, valid);

        if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&
             iommu_has_cap(iommu, PCI_CAP_IOTLB_SHIFT) )
            dte->i = ats_enabled;

        amd_iommu_flush_device(iommu, req_id);

        AMD_IOMMU_DEBUG(""Setup I/O page table: device id = %#x, type = %#x, ""
                        ""root table = %#""PRIx64"", ""
                        ""domain = %d, paging mode = %d\n"",
                        req_id, pdev->type,
                        page_to_maddr(hd->arch.root_table),
                        domain->domain_id, hd->arch.paging_mode);
    }

    spin_unlock_irqrestore(&iommu->lock, flags);

    ASSERT(pcidevs_locked());

    if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&
         !pci_ats_enabled(iommu->seg, bus, pdev->devfn) )
    {
        if ( devfn == pdev->devfn )
            enable_ats_device(pdev, &iommu->ats_devices);

        amd_iommu_flush_iotlb(devfn, pdev, INV_IOMMU_ALL_PAGES_ADDRESS, 0);
    }
}","static void amd_iommu_setup_domain_device(
    struct domain *domain, struct amd_iommu *VAR_0,
    uint8_t VAR_1, struct pci_dev *VAR_2)
{
    struct amd_iommu_dte *VAR_3, *VAR_4;
    unsigned long VAR_5;
    int VAR_6, VAR_7 = 1;
    u8 VAR_8 = VAR_2->bus;
    const struct domain_iommu *VAR_9 = dom_iommu(domain);

    /* COMMENT_0 */
    if ( domain == VAR_10 )
        return;

    BUG_ON( !VAR_9->arch.root_table || !VAR_9->arch.paging_mode ||
            !VAR_0->dev_table.buffer );

    if ( VAR_11 && is_hardware_domain(domain) )
        VAR_7 = 0;

    /* COMMENT_1 */
    VAR_6 = get_dma_requestor_id(VAR_0->seg, PCI_BDF2(VAR_8, VAR_1));
    VAR_3 = VAR_0->dev_table.buffer;
    VAR_4 = &VAR_3[VAR_6];

    spin_lock_irqsave(&VAR_0->lock, VAR_5);

    if ( !VAR_4->v || !VAR_4->tv )
    {
        /* COMMENT_2 */
        amd_iommu_set_root_page_table(
            VAR_4, page_to_maddr(VAR_9->arch.root_table), domain->domain_id,
            VAR_9->arch.paging_mode, VAR_7);

        if ( pci_ats_device(VAR_0->seg, VAR_8, VAR_2->devfn) &&
             iommu_has_cap(VAR_0, VAR_12) )
            VAR_4->i = VAR_13;

        amd_iommu_flush_device(VAR_0, VAR_6);

        AMD_IOMMU_DEBUG(""Setup I/O page table: device id = %#x, type = %#x, ""
                        ""root table = %#""VAR_14"", ""
                        ""domain = %d, paging mode = %d\n"",
                        VAR_6, VAR_2->type,
                        page_to_maddr(VAR_9->arch.root_table),
                        domain->domain_id, VAR_9->arch.paging_mode);
    }

    spin_unlock_irqrestore(&VAR_0->lock, VAR_5);

    ASSERT(pcidevs_locked());

    if ( pci_ats_device(VAR_0->seg, VAR_8, VAR_2->devfn) &&
         !pci_ats_enabled(VAR_0->seg, VAR_8, VAR_2->devfn) )
    {
        if ( VAR_1 == VAR_2->devfn )
            enable_ats_device(VAR_2, &VAR_0->ats_devices);

        amd_iommu_flush_iotlb(VAR_1, VAR_2, VAR_15, 0);
    }
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/pci_amd_iommu.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,6 +7,10 @@
     int req_id, valid = 1;
     u8 bus = pdev->bus;
     const struct domain_iommu *hd = dom_iommu(domain);
+
+    /* dom_io is used as a sentinel for quarantined devices */
+    if ( domain == dom_io )
+        return;
 
     BUG_ON( !hd->arch.root_table || !hd->arch.paging_mode ||
             !iommu->dev_table.buffer );","{'deleted_lines': [], 'added_lines': ['', '    /* dom_io is used as a sentinel for quarantined devices */', '    if ( domain == dom_io )', '        return;']}",True,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",6.8,MEDIUM,1,test,2019-10-18T16:41:44Z,3
CVE-2019-18424,['CWE-78'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"passthrough: quarantine PCI devices

When a PCI device is assigned to an untrusted domain, it is possible for
that domain to program the device to DMA to an arbitrary address. The
IOMMU is used to protect the host from malicious DMA by making sure that
the device addresses can only target memory assigned to the guest. However,
when the guest domain is torn down the device is assigned back to dom0,
thus allowing any in-flight DMA to potentially target critical host data.

This patch introduces a 'quarantine' for PCI devices using dom_io. When
the toolstack makes a device assignable (by binding it to pciback), it
will now also assign it to DOMID_IO and the device will only be assigned
back to dom0 when the device is made unassignable again. Whilst device is
assignable it will only ever transfer between dom_io and guest domains.
dom_io is actually only used as a sentinel domain for quarantining purposes;
it is not configured with any IOMMU mappings. Assignment to dom_io simply
means that the device's initiator (requestor) identifier is not present in
the IOMMU's device table and thus any DMA transactions issued will be
terminated with a fault condition.

In addition, a fix to assignment handling is made for VT-d.  Failure
during the assignment step should not lead to a device still being
associated with its prior owner. Hand the device to DomIO temporarily,
until the assignment step has completed successfully.  Remove the PI
hooks from the source domain then earlier as well.

Failure of the recovery reassign_device_ownership() may not go silent:
There e.g. may still be left over RMRR mappings in the domain assignment
to which has failed, and hence we can't allow that domain to continue
executing.

NOTE: This patch also includes one printk() cleanup; the
      ""XEN_DOMCTL_assign_device: "" tag is dropped in iommu_do_pci_domctl(),
      since similar printk()-s elsewhere also don't log such a tag.

This is XSA-302.

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,xen/common/domain.c,setup_system_domains,"void __init setup_system_domains(void)
{
dom_xen = domain_create(DOMID_XEN, NULL, false);
if ( IS_ERR(dom_xen) )
panic(""Failed to create d[XEN]: %ld\n"", PTR_ERR(dom_xen));
dom_io = domain_create(DOMID_IO, NULL, false);
if ( IS_ERR(dom_io) )
panic(""Failed to create d[IO]: %ld\n"", PTR_ERR(dom_io));
#ifdef CONFIG_MEM_SHARING
dom_cow = domain_create(DOMID_COW, NULL, false);
if ( IS_ERR(dom_cow) )
panic(""Failed to create d[COW]: %ld\n"", PTR_ERR(dom_cow));
#endif
}","void __init setup_system_domains(void)
{
VAR_0 = domain_create(VAR_1, NULL, false);
if ( IS_ERR(VAR_0) )
panic(""Failed to create d[XEN]: %ld\n"", PTR_ERR(VAR_0));
VAR_2 = domain_create(VAR_3, NULL, false);
if ( IS_ERR(VAR_2) )
panic(""Failed to create d[IO]: %ld\n"", PTR_ERR(VAR_2));
#ifdef VAR_4
VAR_5 = domain_create(VAR_6, NULL, false);
if ( IS_ERR(VAR_5) )
panic(""Failed to create d[COW]: %ld\n"", PTR_ERR(VAR_5));
#endif
}",,"void __init setup_system_domains(void)
{
    /*
     * Initialise our DOMID_XEN domain.
     * Any Xen-heap pages that we will allow to be mapped will have
     * their domain field set to dom_xen.
     * Hidden PCI devices will also be associated with this domain
     * (but be [partly] controlled by Dom0 nevertheless).
     */
    dom_xen = domain_create(DOMID_XEN, NULL, false);
    if ( IS_ERR(dom_xen) )
        panic(""Failed to create d[XEN]: %ld\n"", PTR_ERR(dom_xen));

    /*
     * Initialise our DOMID_IO domain.
     * This domain owns I/O pages that are within the range of the page_info
     * array. Mappings occur at the priv of the caller.
     * Quarantined PCI devices will be associated with this domain.
     */
    dom_io = domain_create(DOMID_IO, NULL, false);
    if ( IS_ERR(dom_io) )
        panic(""Failed to create d[IO]: %ld\n"", PTR_ERR(dom_io));

#ifdef CONFIG_MEM_SHARING
    /*
     * Initialise our COW domain.
     * This domain owns sharable pages.
     */
    dom_cow = domain_create(DOMID_COW, NULL, false);
    if ( IS_ERR(dom_cow) )
        panic(""Failed to create d[COW]: %ld\n"", PTR_ERR(dom_cow));
#endif
}","void __init setup_system_domains(void)
{
    /* COMMENT_0 */
                                       
                                                                   
                                         
                                                                  
                                                         
       
    VAR_0 = domain_create(VAR_1, NULL, false);
    if ( IS_ERR(VAR_0) )
        panic(""Failed to create d[XEN]: %ld\n"", PTR_ERR(VAR_0));

    /* COMMENT_7 */
                                      
                                                                            
                                                       
                                                                   
       
    VAR_2 = domain_create(VAR_3, NULL, false);
    if ( IS_ERR(VAR_2) )
        panic(""Failed to create d[IO]: %ld\n"", PTR_ERR(VAR_2));

#ifdef VAR_4
    /* COMMENT_13 */
                                 
                                       
       
    VAR_5 = domain_create(VAR_6, NULL, false);
    if ( IS_ERR(VAR_5) )
        panic(""Failed to create d[COW]: %ld\n"", PTR_ERR(VAR_5));
#endif
}",,"--- func_before
+++ func_after
@@ -15,6 +15,7 @@
      * Initialise our DOMID_IO domain.
      * This domain owns I/O pages that are within the range of the page_info
      * array. Mappings occur at the priv of the caller.
+     * Quarantined PCI devices will be associated with this domain.
      */
     dom_io = domain_create(DOMID_IO, NULL, false);
     if ( IS_ERR(dom_io) )","{'deleted_lines': [], 'added_lines': ['     * Quarantined PCI devices will be associated with this domain.']}",True,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",6.8,MEDIUM,1,test,2019-10-18T16:41:44Z,3
CVE-2019-18424,['CWE-78'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"passthrough: quarantine PCI devices

When a PCI device is assigned to an untrusted domain, it is possible for
that domain to program the device to DMA to an arbitrary address. The
IOMMU is used to protect the host from malicious DMA by making sure that
the device addresses can only target memory assigned to the guest. However,
when the guest domain is torn down the device is assigned back to dom0,
thus allowing any in-flight DMA to potentially target critical host data.

This patch introduces a 'quarantine' for PCI devices using dom_io. When
the toolstack makes a device assignable (by binding it to pciback), it
will now also assign it to DOMID_IO and the device will only be assigned
back to dom0 when the device is made unassignable again. Whilst device is
assignable it will only ever transfer between dom_io and guest domains.
dom_io is actually only used as a sentinel domain for quarantining purposes;
it is not configured with any IOMMU mappings. Assignment to dom_io simply
means that the device's initiator (requestor) identifier is not present in
the IOMMU's device table and thus any DMA transactions issued will be
terminated with a fault condition.

In addition, a fix to assignment handling is made for VT-d.  Failure
during the assignment step should not lead to a device still being
associated with its prior owner. Hand the device to DomIO temporarily,
until the assignment step has completed successfully.  Remove the PI
hooks from the source domain then earlier as well.

Failure of the recovery reassign_device_ownership() may not go silent:
There e.g. may still be left over RMRR mappings in the domain assignment
to which has failed, and hence we can't allow that domain to continue
executing.

NOTE: This patch also includes one printk() cleanup; the
      ""XEN_DOMCTL_assign_device: "" tag is dropped in iommu_do_pci_domctl(),
      since similar printk()-s elsewhere also don't log such a tag.

This is XSA-302.

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,xen/drivers/passthrough/iommu.c,iommu_domain_init,"int iommu_domain_init(struct domain *d, unsigned int opts)
{
struct domain_iommu *hd = dom_iommu(d);
int ret = 0;
if ( !is_iommu_enabled(d) )
return 0;
#ifdef CONFIG_NUMA
hd->node = NUMA_NO_NODE;
#endif
ret = arch_iommu_domain_init(d);
if ( ret )
return ret;
hd->platform_ops = iommu_get_ops();
ret = hd->platform_ops->init(d);
if ( ret )
return ret;
if ( is_hardware_domain(d) )
check_hwdom_reqs(d); 
hd->hap_pt_share = hap_enabled(d) && iommu_hap_pt_share &&
!(opts & XEN_DOMCTL_IOMMU_no_sharept);
if ( !is_hardware_domain(d) || iommu_hwdom_strict )
hd->need_sync = !iommu_use_hap_pt(d);
ASSERT(!(hd->need_sync && hd->hap_pt_share));
return 0;
}","int iommu_domain_init(struct domain *VAR_0, unsigned int VAR_1)
{
struct domain_iommu *VAR_2 = dom_iommu(VAR_0);
int VAR_3 = 0;
if ( !is_iommu_enabled(VAR_0) )
return 0;
#ifdef VAR_4
VAR_2->node = VAR_5;
#endif
VAR_3 = arch_iommu_domain_init(VAR_0);
if ( VAR_3 )
return VAR_3;
VAR_2->platform_ops = iommu_get_ops();
VAR_3 = VAR_2->platform_ops->init(VAR_0);
if ( VAR_3 )
return VAR_3;
if ( is_hardware_domain(VAR_0) )
check_hwdom_reqs(VAR_0); 
VAR_2->hap_pt_share = hap_enabled(VAR_0) && VAR_6 &&
!(VAR_1 & VAR_7);
if ( !is_hardware_domain(VAR_0) || VAR_8 )
VAR_2->need_sync = !iommu_use_hap_pt(VAR_0);
ASSERT(!(VAR_2->need_sync && VAR_2->hap_pt_share));
return 0;
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/iommu.c/vul/before/1.json,"int iommu_domain_init(struct domain *d, unsigned int opts)
{
    struct domain_iommu *hd = dom_iommu(d);
    int ret = 0;

    if ( !is_iommu_enabled(d) )
        return 0;

#ifdef CONFIG_NUMA
    hd->node = NUMA_NO_NODE;
#endif

    ret = arch_iommu_domain_init(d);
    if ( ret )
        return ret;

    hd->platform_ops = iommu_get_ops();
    ret = hd->platform_ops->init(d);
    if ( ret || is_system_domain(d) )
        return ret;

    if ( is_hardware_domain(d) )
        check_hwdom_reqs(d); /* may modify iommu_hwdom_strict */

    /*
     * Use shared page tables for HAP and IOMMU if the global option
     * is enabled (from which we can infer the h/w is capable) and
     * the domain options do not disallow it. HAP must, of course, also
     * be enabled.
     */
    hd->hap_pt_share = hap_enabled(d) && iommu_hap_pt_share &&
        !(opts & XEN_DOMCTL_IOMMU_no_sharept);

    /*
     * NB: 'relaxed' h/w domains don't need the IOMMU mappings to be kept
     *     in-sync with their assigned pages because all host RAM will be
     *     mapped during hwdom_init().
     */
    if ( !is_hardware_domain(d) || iommu_hwdom_strict )
        hd->need_sync = !iommu_use_hap_pt(d);

    ASSERT(!(hd->need_sync && hd->hap_pt_share));

    return 0;
}","int iommu_domain_init(struct domain *VAR_0, unsigned int VAR_1)
{
    struct domain_iommu *VAR_2 = dom_iommu(VAR_0);
    int VAR_3 = 0;

    if ( !is_iommu_enabled(VAR_0) )
        return 0;

#ifdef VAR_4
    VAR_2->node = VAR_5;
#endif

    VAR_3 = arch_iommu_domain_init(VAR_0);
    if ( VAR_3 )
        return VAR_3;

    VAR_2->platform_ops = iommu_get_ops();
    VAR_3 = VAR_2->platform_ops->init(VAR_0);
    if ( VAR_3 || is_system_domain(VAR_0) )
        return VAR_3;

    if ( is_hardware_domain(VAR_0) )
        check_hwdom_reqs(VAR_0); /* COMMENT_0 */

    /* COMMENT_1 */
                                                                    
                                                                  
                                                                       
                  
       
    VAR_2->hap_pt_share = hap_enabled(VAR_0) && VAR_6 &&
        !(VAR_1 & VAR_7);

    /* COMMENT_7 */
                                                                         
                                                                         
                                      
       
    if ( !is_hardware_domain(VAR_0) || VAR_8 )
        VAR_2->need_sync = !iommu_use_hap_pt(VAR_0);

    ASSERT(!(VAR_2->need_sync && VAR_2->hap_pt_share));

    return 0;
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/iommu.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -16,7 +16,7 @@
 
     hd->platform_ops = iommu_get_ops();
     ret = hd->platform_ops->init(d);
-    if ( ret )
+    if ( ret || is_system_domain(d) )
         return ret;
 
     if ( is_hardware_domain(d) )","{'deleted_lines': ['    if ( ret )'], 'added_lines': ['    if ( ret || is_system_domain(d) )']}",True,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",6.8,MEDIUM,1,test,2019-10-18T16:41:44Z,3
CVE-2019-18424,['CWE-78'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"passthrough: quarantine PCI devices

When a PCI device is assigned to an untrusted domain, it is possible for
that domain to program the device to DMA to an arbitrary address. The
IOMMU is used to protect the host from malicious DMA by making sure that
the device addresses can only target memory assigned to the guest. However,
when the guest domain is torn down the device is assigned back to dom0,
thus allowing any in-flight DMA to potentially target critical host data.

This patch introduces a 'quarantine' for PCI devices using dom_io. When
the toolstack makes a device assignable (by binding it to pciback), it
will now also assign it to DOMID_IO and the device will only be assigned
back to dom0 when the device is made unassignable again. Whilst device is
assignable it will only ever transfer between dom_io and guest domains.
dom_io is actually only used as a sentinel domain for quarantining purposes;
it is not configured with any IOMMU mappings. Assignment to dom_io simply
means that the device's initiator (requestor) identifier is not present in
the IOMMU's device table and thus any DMA transactions issued will be
terminated with a fault condition.

In addition, a fix to assignment handling is made for VT-d.  Failure
during the assignment step should not lead to a device still being
associated with its prior owner. Hand the device to DomIO temporarily,
until the assignment step has completed successfully.  Remove the PI
hooks from the source domain then earlier as well.

Failure of the recovery reassign_device_ownership() may not go silent:
There e.g. may still be left over RMRR mappings in the domain assignment
to which has failed, and hence we can't allow that domain to continue
executing.

NOTE: This patch also includes one printk() cleanup; the
      ""XEN_DOMCTL_assign_device: "" tag is dropped in iommu_do_pci_domctl(),
      since similar printk()-s elsewhere also don't log such a tag.

This is XSA-302.

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,xen/drivers/passthrough/iommu.c,iommu_setup,"int __init iommu_setup(void)
{
int rc = -ENODEV;
bool_t force_intremap = force_iommu && iommu_intremap;
if ( iommu_hwdom_strict )
iommu_hwdom_passthrough = false;
if ( iommu_enable )
{
rc = iommu_hardware_setup();
iommu_enabled = (rc == 0);
}
if ( !iommu_enabled )
iommu_intremap = 0;
if ( (force_iommu && !iommu_enabled) ||
(force_intremap && !iommu_intremap) )
panic(""Couldn't enable %s and iommu=required/force\n"",
!iommu_enabled ? ""IOMMU"" : ""Interrupt Remapping"");
if ( !iommu_intremap )
iommu_intpost = 0;
printk(""I/O virtualisation %sabled\n"", iommu_enabled ? ""en"" : ""dis"");
if ( !iommu_enabled )
{
iommu_snoop = 0;
iommu_hwdom_passthrough = false;
iommu_hwdom_strict = false;
}
else
{
printk("" - Dom0 mode: %s\n"",
iommu_hwdom_passthrough ? ""Passthrough"" :
iommu_hwdom_strict ? ""Strict"" : ""Relaxed"");
printk(""Interrupt remapping %sabled\n"", iommu_intremap ? ""en"" : ""dis"");
tasklet_init(&iommu_pt_cleanup_tasklet, iommu_free_pagetables, 0);
}
return rc;
}","int __init iommu_setup(void)
{
int VAR_0 = -VAR_1;
bool_t VAR_2 = VAR_3 && VAR_4;
if ( VAR_5 )
VAR_6 = false;
if ( VAR_7 )
{
VAR_0 = iommu_hardware_setup();
VAR_8 = (VAR_0 == 0);
}
if ( !VAR_8 )
VAR_4 = 0;
if ( (VAR_3 && !VAR_8) ||
(VAR_2 && !VAR_4) )
panic(""Couldn't enable %s and iommu=required/force\n"",
!VAR_8 ? ""IOMMU"" : ""Interrupt Remapping"");
if ( !VAR_4 )
VAR_9 = 0;
printk(""I/O virtualisation %sabled\n"", VAR_8 ? ""en"" : ""dis"");
if ( !VAR_8 )
{
VAR_10 = 0;
VAR_6 = false;
VAR_5 = false;
}
else
{
printk("" - Dom0 mode: %s\n"",
VAR_6 ? ""Passthrough"" :
VAR_5 ? ""Strict"" : ""Relaxed"");
printk(""Interrupt remapping %sabled\n"", VAR_4 ? ""en"" : ""dis"");
tasklet_init(&VAR_11, VAR_12, 0);
}
return VAR_0;
}",,"int __init iommu_setup(void)
{
    int rc = -ENODEV;
    bool_t force_intremap = force_iommu && iommu_intremap;

    if ( iommu_hwdom_strict )
        iommu_hwdom_passthrough = false;

    if ( iommu_enable )
    {
        rc = iommu_hardware_setup();
        iommu_enabled = (rc == 0);
    }
    if ( !iommu_enabled )
        iommu_intremap = 0;

    if ( (force_iommu && !iommu_enabled) ||
         (force_intremap && !iommu_intremap) )
        panic(""Couldn't enable %s and iommu=required/force\n"",
              !iommu_enabled ? ""IOMMU"" : ""Interrupt Remapping"");

    if ( !iommu_intremap )
        iommu_intpost = 0;

    printk(""I/O virtualisation %sabled\n"", iommu_enabled ? ""en"" : ""dis"");
    if ( !iommu_enabled )
    {
        iommu_snoop = 0;
        iommu_hwdom_passthrough = false;
        iommu_hwdom_strict = false;
    }
    else
    {
        dom_io->options |= XEN_DOMCTL_CDF_iommu;
        if ( iommu_domain_init(dom_io, 0) )
            panic(""Could not set up quarantine\n"");

        printk("" - Dom0 mode: %s\n"",
               iommu_hwdom_passthrough ? ""Passthrough"" :
               iommu_hwdom_strict ? ""Strict"" : ""Relaxed"");
        printk(""Interrupt remapping %sabled\n"", iommu_intremap ? ""en"" : ""dis"");
        tasklet_init(&iommu_pt_cleanup_tasklet, iommu_free_pagetables, 0);
    }

    return rc;
}","int __init iommu_setup(void)
{
    int VAR_0 = -VAR_1;
    bool_t VAR_2 = VAR_3 && VAR_4;

    if ( VAR_5 )
        VAR_6 = false;

    if ( VAR_7 )
    {
        VAR_0 = iommu_hardware_setup();
        VAR_8 = (VAR_0 == 0);
    }
    if ( !VAR_8 )
        VAR_4 = 0;

    if ( (VAR_3 && !VAR_8) ||
         (VAR_2 && !VAR_4) )
        panic(""Couldn't enable %s and iommu=required/force\n"",
              !VAR_8 ? ""IOMMU"" : ""Interrupt Remapping"");

    if ( !VAR_4 )
        VAR_9 = 0;

    printk(""I/O virtualisation %sabled\n"", VAR_8 ? ""en"" : ""dis"");
    if ( !VAR_8 )
    {
        VAR_10 = 0;
        VAR_6 = false;
        VAR_5 = false;
    }
    else
    {
        VAR_11->options |= VAR_12;
        if ( iommu_domain_init(VAR_11, 0) )
            panic(""Could not set up quarantine\n"");

        printk("" - Dom0 mode: %s\n"",
               VAR_6 ? ""Passthrough"" :
               VAR_5 ? ""Strict"" : ""Relaxed"");
        printk(""Interrupt remapping %sabled\n"", VAR_4 ? ""en"" : ""dis"");
        tasklet_init(&VAR_13, VAR_14, 0);
    }

    return VAR_0;
}",,"--- func_before
+++ func_after
@@ -31,6 +31,10 @@
     }
     else
     {
+        dom_io->options |= XEN_DOMCTL_CDF_iommu;
+        if ( iommu_domain_init(dom_io, 0) )
+            panic(""Could not set up quarantine\n"");
+
         printk("" - Dom0 mode: %s\n"",
                iommu_hwdom_passthrough ? ""Passthrough"" :
                iommu_hwdom_strict ? ""Strict"" : ""Relaxed"");","{'deleted_lines': [], 'added_lines': ['        dom_io->options |= XEN_DOMCTL_CDF_iommu;', '        if ( iommu_domain_init(dom_io, 0) )', '            panic(""Could not set up quarantine\\n"");', '']}",True,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",6.8,MEDIUM,1,test,2019-10-18T16:41:44Z,3
CVE-2019-18424,['CWE-78'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"passthrough: quarantine PCI devices

When a PCI device is assigned to an untrusted domain, it is possible for
that domain to program the device to DMA to an arbitrary address. The
IOMMU is used to protect the host from malicious DMA by making sure that
the device addresses can only target memory assigned to the guest. However,
when the guest domain is torn down the device is assigned back to dom0,
thus allowing any in-flight DMA to potentially target critical host data.

This patch introduces a 'quarantine' for PCI devices using dom_io. When
the toolstack makes a device assignable (by binding it to pciback), it
will now also assign it to DOMID_IO and the device will only be assigned
back to dom0 when the device is made unassignable again. Whilst device is
assignable it will only ever transfer between dom_io and guest domains.
dom_io is actually only used as a sentinel domain for quarantining purposes;
it is not configured with any IOMMU mappings. Assignment to dom_io simply
means that the device's initiator (requestor) identifier is not present in
the IOMMU's device table and thus any DMA transactions issued will be
terminated with a fault condition.

In addition, a fix to assignment handling is made for VT-d.  Failure
during the assignment step should not lead to a device still being
associated with its prior owner. Hand the device to DomIO temporarily,
until the assignment step has completed successfully.  Remove the PI
hooks from the source domain then earlier as well.

Failure of the recovery reassign_device_ownership() may not go silent:
There e.g. may still be left over RMRR mappings in the domain assignment
to which has failed, and hence we can't allow that domain to continue
executing.

NOTE: This patch also includes one printk() cleanup; the
      ""XEN_DOMCTL_assign_device: "" tag is dropped in iommu_do_pci_domctl(),
      since similar printk()-s elsewhere also don't log such a tag.

This is XSA-302.

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,tools/libxl/libxl_pci.c,libxl__device_pci_assignable_add,"static int libxl__device_pci_assignable_add(libxl__gc *gc,
libxl_device_pci *pcidev,
int rebind)
{
unsigned dom, bus, dev, func;
char *spath, *driver_path = NULL;
int rc;
struct stat st;
dom = pcidev->domain;
bus = pcidev->bus;
dev = pcidev->dev;
func = pcidev->func;
spath = GCSPRINTF(SYSFS_PCI_DEV""/""PCI_BDF, dom, bus, dev, func);
if ( lstat(spath, &st) ) {
LOGE(ERROR, ""Couldn't lstat %s"", spath);
return ERROR_FAIL;
}","static int libxl__device_pci_assignable_add(libxl__gc *VAR_0,
libxl_device_pci *VAR_1,
int VAR_2)
{
unsigned VAR_3, VAR_4, VAR_5, VAR_6;
char *VAR_7, *VAR_8 = NULL;
int VAR_9;
struct stat VAR_10;
VAR_3 = VAR_1->domain;
VAR_4 = VAR_1->bus;
VAR_5 = VAR_1->dev;
VAR_6 = VAR_1->func;
VAR_7 = GCSPRINTF(VAR_11""/""PCI_BDF, dom, bus, dev, func);
if ( lstat(VAR_7, &VAR_10) ) {
LOGE(VAR_12, ""Couldn't lstat %s"", VAR_7);
return VAR_13;
}",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/libxl_pci.c/vul/before/1.json,"static int libxl__device_pci_assignable_add(libxl__gc *gc,
                                            libxl_device_pci *pcidev,
                                            int rebind)
{
    libxl_ctx *ctx = libxl__gc_owner(gc);
    unsigned dom, bus, dev, func;
    char *spath, *driver_path = NULL;
    int rc;
    struct stat st;

    /* Local copy for convenience */
    dom = pcidev->domain;
    bus = pcidev->bus;
    dev = pcidev->dev;
    func = pcidev->func;

    /* See if the device exists */
    spath = GCSPRINTF(SYSFS_PCI_DEV""/""PCI_BDF, dom, bus, dev, func);
    if ( lstat(spath, &st) ) {
        LOGE(ERROR, ""Couldn't lstat %s"", spath);
        return ERROR_FAIL;
    }","static int libxl__device_pci_assignable_add(libxl__gc *VAR_0,
                                            libxl_device_pci *VAR_1,
                                            int VAR_2)
{
    libxl_ctx *VAR_3 = libxl__gc_owner(VAR_0);
    unsigned VAR_4, VAR_5, VAR_6, VAR_7;
    char *VAR_8, *VAR_9 = NULL;
    int VAR_10;
    struct stat VAR_11;

    /* COMMENT_0 */
    VAR_4 = VAR_1->domain;
    VAR_5 = VAR_1->bus;
    VAR_6 = VAR_1->dev;
    VAR_7 = VAR_1->func;

    /* COMMENT_1 */
    VAR_8 = GCSPRINTF(VAR_12""/""PCI_BDF, dom, bus, dev, func);
    if ( lstat(VAR_8, &VAR_11) ) {
        LOGE(VAR_13, ""Couldn't lstat %s"", VAR_8);
        return VAR_14;
    }",xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/libxl_pci.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,6 +2,7 @@
                                             libxl_device_pci *pcidev,
                                             int rebind)
 {
+    libxl_ctx *ctx = libxl__gc_owner(gc);
     unsigned dom, bus, dev, func;
     char *spath, *driver_path = NULL;
     int rc;","{'deleted_lines': [], 'added_lines': ['    libxl_ctx *ctx = libxl__gc_owner(gc);']}",True,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",6.8,MEDIUM,1,test,2019-10-18T16:41:44Z,3
CVE-2019-18635,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,mooltipass/moolticute,Fix possible nullptr dereference in MPDevice_win,a6df0989f737bfae5e87a9ffbce6f4949be77ed7,https://github.com/mooltipass/moolticute/commit/a6df0989f737bfae5e87a9ffbce6f4949be77ed7,src/MPDevice_win.cpp,MPDevice_win::enumerateDevices,"QList<MPPlatformDef> MPDevice_win::enumerateDevices()
{
HID.load();
QList<MPPlatformDef> devlist;
SP_DEVINFO_DATA devinfo_data;
SP_DEVICE_INTERFACE_DATA dev_data;
SP_DEVICE_INTERFACE_DETAIL_DATA_A *dev_detail_data = NULL;
HDEVINFO dev_info_set = INVALID_HANDLE_VALUE;
int idx = 0;
::ZeroMemory(&devinfo_data, sizeof(devinfo_data));
devinfo_data.cbSize = sizeof(SP_DEVINFO_DATA);
dev_data.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
dev_info_set = SetupDiGetClassDevsA(&IClassGuid, nullptr, nullptr, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
while (SetupDiEnumDeviceInterfaces(dev_info_set,
nullptr,
&IClassGuid,
idx,
&dev_data))
{
DWORD required_size = 0;
bool ret = SetupDiGetDeviceInterfaceDetailA(dev_info_set,
&dev_data,
nullptr,
0,
&required_size,
nullptr);
dev_detail_data = (SP_DEVICE_INTERFACE_DETAIL_DATA_A*) malloc(required_size);
dev_detail_data->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A);
ret = SetupDiGetDeviceInterfaceDetailA(dev_info_set,
&dev_data,
dev_detail_data,
required_size,
nullptr,
nullptr);
++idx;
if (!ret)
{
free(dev_detail_data);
continue;
}
QString path = QString(dev_detail_data->DevicePath);
free(dev_detail_data);
bool isBLE = false;
bool isBluetooth = false;
if (!checkDevice(path, isBLE, isBluetooth))
{
continue;
}
qDebug() << ""Found mooltipass: "" << path;
devlist << getPlatDef(path, isBLE, isBluetooth);
}
SetupDiDestroyDeviceInfoList(dev_info_set);
return devlist;
}","QList<MPPlatformDef> MPDevice_win::enumerateDevices()
{
VAR_0.load();
QList<MPPlatformDef> VAR_1;
SP_DEVINFO_DATA VAR_2;
SP_DEVICE_INTERFACE_DATA VAR_3;
SP_DEVICE_INTERFACE_DETAIL_DATA_A *VAR_4 = NULL;
HDEVINFO VAR_5 = VAR_6;
int VAR_7 = 0;
::ZeroMemory(&VAR_2, sizeof(VAR_2));
VAR_2.cbSize = sizeof(SP_DEVINFO_DATA);
VAR_3.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
VAR_5 = SetupDiGetClassDevsA(&VAR_8, nullptr, nullptr, VAR_9 | VAR_10);
while (SetupDiEnumDeviceInterfaces(VAR_5,
nullptr,
&VAR_8,
VAR_7,
&VAR_3))
{
DWORD VAR_11 = 0;
bool VAR_12 = SetupDiGetDeviceInterfaceDetailA(VAR_5,
&VAR_3,
nullptr,
0,
&VAR_11,
nullptr);
VAR_4 = (SP_DEVICE_INTERFACE_DETAIL_DATA_A*) malloc(VAR_11);
VAR_4->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A);
VAR_12 = SetupDiGetDeviceInterfaceDetailA(VAR_5,
&VAR_3,
VAR_4,
VAR_11,
nullptr,
nullptr);
++VAR_7;
if (!VAR_12)
{
free(VAR_4);
continue;
}
QString VAR_13 = QString(VAR_4->DevicePath);
free(VAR_4);
bool VAR_14 = false;
bool VAR_15 = false;
if (!checkDevice(VAR_13, VAR_14, VAR_15))
{
continue;
}
qDebug() << ""Found mooltipass: "" << VAR_13;
VAR_1 << getPlatDef(VAR_13, VAR_14, VAR_15);
}
SetupDiDestroyDeviceInfoList(VAR_5);
return VAR_1;
}",mooltipass/moolticute/a6df0989f737bfae5e87a9ffbce6f4949be77ed7/MPDevice_win.cpp/vul/before/0.json,"QList<MPPlatformDef> MPDevice_win::enumerateDevices()
{
    HID.load();

    QList<MPPlatformDef> devlist;

    SP_DEVINFO_DATA devinfo_data;
    SP_DEVICE_INTERFACE_DATA dev_data;
    SP_DEVICE_INTERFACE_DETAIL_DATA_A *dev_detail_data = NULL;
    HDEVINFO dev_info_set = INVALID_HANDLE_VALUE;
    int idx = 0;

    ::ZeroMemory(&devinfo_data, sizeof(devinfo_data));
    devinfo_data.cbSize = sizeof(SP_DEVINFO_DATA);
    dev_data.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    //Get all devices from HID class
    dev_info_set = SetupDiGetClassDevsA(&IClassGuid, nullptr, nullptr, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);

    while (SetupDiEnumDeviceInterfaces(dev_info_set,
                                       nullptr,
                                       &IClassGuid,
                                       idx,
                                       &dev_data))
    {
        DWORD required_size = 0;

        //first call is to get the required_size
        bool ret = SetupDiGetDeviceInterfaceDetailA(dev_info_set,
                                                    &dev_data,
                                                    nullptr,
                                                    0,
                                                    &required_size,
                                                    nullptr);

        if (0 == required_size)
        {
            qCritical() << ""Invalid DeviceInterfaceDetailData buffer size"";
            continue;
        }

        //alloc data
        dev_detail_data = (SP_DEVICE_INTERFACE_DETAIL_DATA_A*) malloc(required_size);
        if (!dev_detail_data)
        {
            qCritical() << ""Allocating SP_DEVICE_INTERFACE_DETAIL_DATA_A data failed."";
            break;
        }
        dev_detail_data->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A);

        //Get device info now
        ret = SetupDiGetDeviceInterfaceDetailA(dev_info_set,
                                               &dev_data,
                                               dev_detail_data,
                                               required_size,
                                               nullptr,
                                               nullptr);

        ++idx;
        if (!ret)
        {
            free(dev_detail_data);
            continue;
        }

        QString path = QString(dev_detail_data->DevicePath);
        free(dev_detail_data);

        bool isBLE = false;
        bool isBluetooth = false;
        if (!checkDevice(path, isBLE, isBluetooth))
        {
            continue;
        }
        qDebug() << ""Found mooltipass: "" << path;

        //TODO: extract interface number from path string and check it

        devlist << getPlatDef(path, isBLE, isBluetooth);
    }

    SetupDiDestroyDeviceInfoList(dev_info_set);

    return devlist;
}","QList<MPPlatformDef> MPDevice_win::enumerateDevices()
{
    VAR_0.load();

    QList<MPPlatformDef> VAR_1;

    SP_DEVINFO_DATA VAR_2;
    SP_DEVICE_INTERFACE_DATA VAR_3;
    SP_DEVICE_INTERFACE_DETAIL_DATA_A *VAR_4 = NULL;
    HDEVINFO VAR_5 = VAR_6;
    int VAR_7 = 0;

    ::ZeroMemory(&VAR_2, sizeof(VAR_2));
    VAR_2.cbSize = sizeof(SP_DEVINFO_DATA);
    VAR_3.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    /* COMMENT_0 */
    VAR_5 = SetupDiGetClassDevsA(&VAR_8, nullptr, nullptr, VAR_9 | VAR_10);

    while (SetupDiEnumDeviceInterfaces(VAR_5,
                                       nullptr,
                                       &VAR_8,
                                       VAR_7,
                                       &VAR_3))
    {
        DWORD VAR_11 = 0;

        /* COMMENT_1 */
        bool VAR_12 = SetupDiGetDeviceInterfaceDetailA(VAR_5,
                                                    &VAR_3,
                                                    nullptr,
                                                    0,
                                                    &VAR_11,
                                                    nullptr);

        if (0 == VAR_11)
        {
            qCritical() << ""Invalid DeviceInterfaceDetailData buffer size"";
            continue;
        }

        /* COMMENT_2 */
        VAR_4 = (SP_DEVICE_INTERFACE_DETAIL_DATA_A*) malloc(VAR_11);
        if (!VAR_4)
        {
            qCritical() << ""Allocating SP_DEVICE_INTERFACE_DETAIL_DATA_A data failed."";
            break;
        }
        VAR_4->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A);

        /* COMMENT_3 */
        VAR_12 = SetupDiGetDeviceInterfaceDetailA(VAR_5,
                                               &VAR_3,
                                               VAR_4,
                                               VAR_11,
                                               nullptr,
                                               nullptr);

        ++VAR_7;
        if (!VAR_12)
        {
            free(VAR_4);
            continue;
        }

        QString VAR_13 = QString(VAR_4->DevicePath);
        free(VAR_4);

        bool VAR_14 = false;
        bool VAR_15 = false;
        if (!checkDevice(VAR_13, VAR_14, VAR_15))
        {
            continue;
        }
        qDebug() << ""Found mooltipass: "" << VAR_13;

        /* COMMENT_4 */

        VAR_1 << getPlatDef(VAR_13, VAR_14, VAR_15);
    }

    SetupDiDestroyDeviceInfoList(VAR_5);

    return VAR_1;
}",mooltipass/moolticute/a6df0989f737bfae5e87a9ffbce6f4949be77ed7/MPDevice_win.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -33,8 +33,19 @@
                                                     &required_size,
                                                     nullptr);
 
+        if (0 == required_size)
+        {
+            qCritical() << ""Invalid DeviceInterfaceDetailData buffer size"";
+            continue;
+        }
+
         //alloc data
         dev_detail_data = (SP_DEVICE_INTERFACE_DETAIL_DATA_A*) malloc(required_size);
+        if (!dev_detail_data)
+        {
+            qCritical() << ""Allocating SP_DEVICE_INTERFACE_DETAIL_DATA_A data failed."";
+            break;
+        }
         dev_detail_data->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A);
 
         //Get device info now","{'deleted_lines': [], 'added_lines': ['        if (0 == required_size)', '        {', '            qCritical() << ""Invalid DeviceInterfaceDetailData buffer size"";', '            continue;', '        }', '', '        if (!dev_detail_data)', '        {', '            qCritical() << ""Allocating SP_DEVICE_INTERFACE_DETAIL_DATA_A data failed."";', '            break;', '        }']}",True,An issue was discovered in Mooltipass Moolticute through v0.42.1 and v0.42.x-testing through v0.42.5-testing. There is a NULL pointer dereference in MPDevice_win.cpp.,7.5,HIGH,2,test,2019-10-27T17:51:32Z,3
CVE-2020-16300,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ArtifexSoftware/ghostpdl,"Bug 701807: avoid buffer overflow in tiff12_print_page().

Fixes:
    ./sanbin/gs -r650 -sOutputFile=tmp -sDEVICE=tiff12nc ../bug-701807.pdf",714e8995cd582d418276915cbbec3c70711fb19e,https://github.com/ArtifexSoftware/ghostpdl/commit/714e8995cd582d418276915cbbec3c70711fb19e,devices/gdevtfnx.c,tiff12_print_page,"static int
tiff12_print_page(gx_device_printer * pdev, gp_file * file)
{
gx_device_tiff *const tfdev = (gx_device_tiff *)pdev;
int code;
if (gdev_prn_file_is_new(pdev)) {
tfdev->tif = tiff_from_filep(pdev, pdev->dname, file, tfdev->BigEndian, tfdev->UseBigTIFF);
if (!tfdev->tif)
return_error(gs_error_invalidfileaccess);
}
code = gdev_tiff_begin_page(tfdev, file);
if (code < 0)
return code;
TIFFSetField(tfdev->tif, TIFFTAG_BITSPERSAMPLE, 4);
tiff_set_rgb_fields(tfdev);
TIFFCheckpointDirectory(tfdev->tif);
{
int y;
int size = gdev_prn_raster(pdev);
byte *data = gs_alloc_bytes(pdev->memory, size, ""tiff12_print_page"");
if (data == 0)
return_error(gs_error_VMerror);
memset(data, 0, size);
for (y = 0; y < pdev->height; ++y) {
const byte *src;
byte *dest;
int x;
code = gdev_prn_copy_scan_lines(pdev, y, data, size);
if (code < 0)
break;
for (src = data, dest = data, x = 0; x < size;
src += 6, dest += 3, x += 6
) {
dest[0] = (src[0] & 0xf0) | (src[1] >> 4);
dest[1] = (src[2] & 0xf0) | (src[3] >> 4);
dest[2] = (src[4] & 0xf0) | (src[5] >> 4);
}
TIFFWriteScanline(tfdev->tif, data, y, 0);
}
gs_free_object(pdev->memory, data, ""tiff12_print_page"");
TIFFWriteDirectory(tfdev->tif);
}
return code;
}","static int
tiff12_print_page(gx_device_printer * VAR_0, gp_file * VAR_1)
{
gx_device_tiff *const VAR_2 = (gx_device_tiff *)VAR_0;
int VAR_3;
if (gdev_prn_file_is_new(VAR_0)) {
VAR_2->tif = tiff_from_filep(VAR_0, VAR_0->dname, VAR_1, VAR_2->BigEndian, VAR_2->UseBigTIFF);
if (!VAR_2->tif)
return_error(VAR_4);
}
VAR_3 = gdev_tiff_begin_page(VAR_2, VAR_1);
if (VAR_3 < 0)
return VAR_3;
TIFFSetField(VAR_2->tif, VAR_5, 4);
tiff_set_rgb_fields(VAR_2);
TIFFCheckpointDirectory(VAR_2->tif);
{
int VAR_6;
int VAR_7 = gdev_prn_raster(VAR_0);
byte *VAR_8 = gs_alloc_bytes(VAR_0->memory, VAR_7, ""tiff12_print_page"");
if (VAR_8 == 0)
return_error(VAR_9);
memset(VAR_8, 0, VAR_7);
for (VAR_6 = 0; VAR_6 < VAR_0->height; ++VAR_6) {
const byte *VAR_10;
byte *VAR_11;
int VAR_12;
VAR_3 = gdev_prn_copy_scan_lines(VAR_0, VAR_6, VAR_8, VAR_7);
if (VAR_3 < 0)
break;
for (VAR_10 = VAR_8, VAR_11 = VAR_8, VAR_12 = 0; VAR_12 < VAR_7;
VAR_10 += 6, VAR_11 += 3, VAR_12 += 6
) {
VAR_11[0] = (VAR_10[0] & 0xf0) | (VAR_10[1] >> 4);
VAR_11[1] = (VAR_10[2] & 0xf0) | (VAR_10[3] >> 4);
VAR_11[2] = (VAR_10[4] & 0xf0) | (VAR_10[5] >> 4);
}
TIFFWriteScanline(VAR_2->tif, VAR_8, VAR_6, 0);
}
gs_free_object(VAR_0->memory, VAR_8, ""tiff12_print_page"");
TIFFWriteDirectory(VAR_2->tif);
}
return VAR_3;
}",ArtifexSoftware/ghostpdl/714e8995cd582d418276915cbbec3c70711fb19e/gdevtfnx.c/vul/before/0.json,"static int
tiff12_print_page(gx_device_printer * pdev, gp_file * file)
{
    gx_device_tiff *const tfdev = (gx_device_tiff *)pdev;
    int code;

    /* open the TIFF device */
    if (gdev_prn_file_is_new(pdev)) {
        tfdev->tif = tiff_from_filep(pdev, pdev->dname, file, tfdev->BigEndian, tfdev->UseBigTIFF);
        if (!tfdev->tif)
            return_error(gs_error_invalidfileaccess);
    }

    code = gdev_tiff_begin_page(tfdev, file);
    if (code < 0)
        return code;

    TIFFSetField(tfdev->tif, TIFFTAG_BITSPERSAMPLE, 4);
    tiff_set_rgb_fields(tfdev);

    TIFFCheckpointDirectory(tfdev->tif);

    /* Write the page data. */
    {
        int y;
        int size = gdev_prn_raster(pdev);

        /* We allocate an extra 5 bytes to avoid buffer overflow when accessing
        src[5] below, if size if not multiple of 6. This fixes bug-701807. */
        int size_alloc = size + 5;
        byte *data = gs_alloc_bytes(pdev->memory, size_alloc, ""tiff12_print_page"");

        if (data == 0)
            return_error(gs_error_VMerror);

        memset(data, 0, size_alloc);

        for (y = 0; y < pdev->height; ++y) {
            const byte *src;
            byte *dest;
            int x;

            code = gdev_prn_copy_scan_lines(pdev, y, data, size);
            if (code < 0)
                break;

            for (src = data, dest = data, x = 0; x < size;
                 src += 6, dest += 3, x += 6
                ) {
                dest[0] = (src[0] & 0xf0) | (src[1] >> 4);
                dest[1] = (src[2] & 0xf0) | (src[3] >> 4);
                dest[2] = (src[4] & 0xf0) | (src[5] >> 4);
            }
            TIFFWriteScanline(tfdev->tif, data, y, 0);
        }
        gs_free_object(pdev->memory, data, ""tiff12_print_page"");

        TIFFWriteDirectory(tfdev->tif);
    }

    return code;
}","static int
tiff12_print_page(gx_device_printer * VAR_0, gp_file * VAR_1)
{
    gx_device_tiff *const VAR_2 = (gx_device_tiff *)VAR_0;
    int VAR_3;

    /* COMMENT_0 */
    if (gdev_prn_file_is_new(VAR_0)) {
        VAR_2->tif = tiff_from_filep(VAR_0, VAR_0->dname, VAR_1, VAR_2->BigEndian, VAR_2->UseBigTIFF);
        if (!VAR_2->tif)
            return_error(VAR_4);
    }

    VAR_3 = gdev_tiff_begin_page(VAR_2, VAR_1);
    if (VAR_3 < 0)
        return VAR_3;

    TIFFSetField(VAR_2->tif, VAR_5, 4);
    tiff_set_rgb_fields(VAR_2);

    TIFFCheckpointDirectory(VAR_2->tif);

    /* COMMENT_1 */
    {
        int VAR_6;
        int VAR_7 = gdev_prn_raster(VAR_0);

        /* COMMENT_2 */
                                                                             
        int VAR_8 = VAR_7 + 5;
        byte *VAR_9 = gs_alloc_bytes(VAR_0->memory, VAR_8, ""tiff12_print_page"");

        if (VAR_9 == 0)
            return_error(VAR_10);

        memset(VAR_9, 0, VAR_8);

        for (VAR_6 = 0; VAR_6 < VAR_0->height; ++VAR_6) {
            const byte *VAR_11;
            byte *VAR_12;
            int VAR_13;

            VAR_3 = gdev_prn_copy_scan_lines(VAR_0, VAR_6, VAR_9, VAR_7);
            if (VAR_3 < 0)
                break;

            for (VAR_11 = VAR_9, VAR_12 = VAR_9, VAR_13 = 0; VAR_13 < VAR_7;
                 VAR_11 += 6, VAR_12 += 3, VAR_13 += 6
                ) {
                VAR_12[0] = (VAR_11[0] & 0xf0) | (VAR_11[1] >> 4);
                VAR_12[1] = (VAR_11[2] & 0xf0) | (VAR_11[3] >> 4);
                VAR_12[2] = (VAR_11[4] & 0xf0) | (VAR_11[5] >> 4);
            }
            TIFFWriteScanline(VAR_2->tif, VAR_9, VAR_6, 0);
        }
        gs_free_object(VAR_0->memory, VAR_9, ""tiff12_print_page"");

        TIFFWriteDirectory(VAR_2->tif);
    }

    return VAR_3;
}",ArtifexSoftware/ghostpdl/714e8995cd582d418276915cbbec3c70711fb19e/gdevtfnx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -24,12 +24,16 @@
     {
         int y;
         int size = gdev_prn_raster(pdev);
-        byte *data = gs_alloc_bytes(pdev->memory, size, ""tiff12_print_page"");
+
+        /* We allocate an extra 5 bytes to avoid buffer overflow when accessing
+        src[5] below, if size if not multiple of 6. This fixes bug-701807. */
+        int size_alloc = size + 5;
+        byte *data = gs_alloc_bytes(pdev->memory, size_alloc, ""tiff12_print_page"");
 
         if (data == 0)
             return_error(gs_error_VMerror);
 
-        memset(data, 0, size);
+        memset(data, 0, size_alloc);
 
         for (y = 0; y < pdev->height; ++y) {
             const byte *src;","{'deleted_lines': ['        byte *data = gs_alloc_bytes(pdev->memory, size, ""tiff12_print_page"");', '        memset(data, 0, size);'], 'added_lines': ['', '        /* We allocate an extra 5 bytes to avoid buffer overflow when accessing', '        src[5] below, if size if not multiple of 6. This fixes bug-701807. */', '        int size_alloc = size + 5;', '        byte *data = gs_alloc_bytes(pdev->memory, size_alloc, ""tiff12_print_page"");', '        memset(data, 0, size_alloc);']}",True,A buffer overflow vulnerability in tiff12_print_page() in devices/gdevtfnx.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.,5.5,MEDIUM,1,test,2019-10-31T11:55:38Z,3
CVE-2019-18425,['CWE-269'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/PV: check GDT/LDT limits during emulation

Accesses beyond the LDT limit originating from emulation would trigger
the ASSERT() in pv_map_ldt_shadow_page(). On production builds such
accesses would cause an attempt to promote the touched page (offset from
the present LDT base address) to a segment descriptor one. If this
happens to succeed, guest user mode would be able to elevate its
privileges to that of the guest kernel. This is particularly easy when
there's no LDT at all, in which case the LDT base stored internally to
Xen is simply zero.

Also adjust the ASSERT() that was triggering: It was off by one to
begin with, and for production builds we also better use
ASSERT_UNREACHABLE() instead with suitable recovery code afterwards.

This is XSA-298.

Reported-by: Andrew Cooper <andrew.cooper3@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>",93021cbe880a8013691a48d0febef8ed7d3e3ebd,https://github.com/xen-project/xen/commit/93021cbe880a8013691a48d0febef8ed7d3e3ebd,xen/arch/x86/pv/emul-gate-op.c,read_gate_descriptor,"static int read_gate_descriptor(unsigned int gate_sel,
const struct vcpu *v,
unsigned int *sel,
unsigned long *off,
unsigned int *ar)
{
seg_desc_t desc;
const seg_desc_t *pdesc = gdt_ldt_desc_ptr(gate_sel);
if ( (gate_sel < 4) ||
((gate_sel >= FIRST_RESERVED_GDT_BYTE) && !(gate_sel & 4)) ||
__get_user(desc, pdesc) )
return 0;
*sel = (desc.a >> 16) & 0x0000fffc;
*off = (desc.a & 0x0000ffff) | (desc.b & 0xffff0000);
*ar = desc.b & 0x0000ffff;
if ( *ar & _SEGMENT_DPL )
return 0;
*ar |= (desc.a >> (16 - 13)) & _SEGMENT_DPL;
if ( !is_pv_32bit_vcpu(v) )
{
if ( (*ar & 0x1f00) != 0x0c00 ||
(gate_sel >= FIRST_RESERVED_GDT_BYTE - 8 && !(gate_sel & 4)) ||
__get_user(desc, pdesc + 1) ||
(desc.b & 0x1f00) )
return 0;
*off |= (unsigned long)desc.a << 32;
return 1;
}
switch ( *ar & 0x1f00 )
{
case 0x0400:
*off &= 0xffff;
break;
case 0x0c00:
break;
default:
return 0;
}
return 1;
}","static int read_gate_descriptor(unsigned int VAR_0,
const struct vcpu *VAR_1,
unsigned int *VAR_2,
unsigned long *VAR_3,
unsigned int *VAR_4)
{
seg_desc_t VAR_5;
const seg_desc_t *VAR_6 = gdt_ldt_desc_ptr(VAR_0);
if ( (VAR_0 < 4) ||
((VAR_0 >= VAR_7) && !(VAR_0 & 4)) ||
__get_user(VAR_5, VAR_6) )
return 0;
*VAR_2 = (VAR_5.a >> 16) & 0x0000fffc;
*VAR_3 = (VAR_5.a & 0x0000ffff) | (VAR_5.b & 0xffff0000);
*VAR_4 = VAR_5.b & 0x0000ffff;
if ( *VAR_4 & VAR_8 )
return 0;
*VAR_4 |= (VAR_5.a >> (16 - 13)) & VAR_8;
if ( !is_pv_32bit_vcpu(VAR_1) )
{
if ( (*VAR_4 & 0x1f00) != 0x0c00 ||
(VAR_0 >= VAR_7 - 8 && !(VAR_0 & 4)) ||
__get_user(VAR_5, VAR_6 + 1) ||
(VAR_5.b & 0x1f00) )
return 0;
*VAR_3 |= (unsigned long)VAR_5.a << 32;
return 1;
}
switch ( *VAR_4 & 0x1f00 )
{
case 0x0400:
*VAR_3 &= 0xffff;
break;
case 0x0c00:
break;
default:
return 0;
}
return 1;
}",xen-project/xen/93021cbe880a8013691a48d0febef8ed7d3e3ebd/emul-gate-op.c/vul/before/0.json,"static int read_gate_descriptor(unsigned int gate_sel,
                                const struct vcpu *v,
                                unsigned int *sel,
                                unsigned long *off,
                                unsigned int *ar)
{
    seg_desc_t desc;
    const seg_desc_t *pdesc = gdt_ldt_desc_ptr(gate_sel);

    if ( (gate_sel < 4) ||
         /*
          * We're interested in call gates only, which occupy a single
          * seg_desc_t for 32-bit and a consecutive pair of them for 64-bit.
          */
         ((gate_sel >> 3) + !is_pv_32bit_vcpu(v) >=
          (gate_sel & 4 ? v->arch.pv.ldt_ents
                        : v->arch.pv.gdt_ents)) ||
         __get_user(desc, pdesc) )
        return 0;

    *sel = (desc.a >> 16) & 0x0000fffc;
    *off = (desc.a & 0x0000ffff) | (desc.b & 0xffff0000);
    *ar = desc.b & 0x0000ffff;

    /*
     * check_descriptor() clears the DPL field and stores the
     * guest requested DPL in the selector's RPL field.
     */
    if ( *ar & _SEGMENT_DPL )
        return 0;
    *ar |= (desc.a >> (16 - 13)) & _SEGMENT_DPL;

    if ( !is_pv_32bit_vcpu(v) )
    {
        if ( (*ar & 0x1f00) != 0x0c00 ||
             /* Limit check done above already. */
             __get_user(desc, pdesc + 1) ||
             (desc.b & 0x1f00) )
            return 0;

        *off |= (unsigned long)desc.a << 32;
        return 1;
    }

    switch ( *ar & 0x1f00 )
    {
    case 0x0400:
        *off &= 0xffff;
        break;
    case 0x0c00:
        break;
    default:
        return 0;
    }

    return 1;
}","static int read_gate_descriptor(unsigned int VAR_0,
                                const struct vcpu *VAR_1,
                                unsigned int *VAR_2,
                                unsigned long *VAR_3,
                                unsigned int *VAR_4)
{
    seg_desc_t VAR_5;
    const seg_desc_t *VAR_6 = gdt_ldt_desc_ptr(VAR_0);

    if ( (VAR_0 < 4) ||
         /* COMMENT_0 */
                                                                      
                                                                            
            
         ((VAR_0 >> 3) + !is_pv_32bit_vcpu(VAR_1) >=
          (VAR_0 & 4 ? VAR_1->arch.pv.ldt_ents
                        : VAR_1->arch.pv.gdt_ents)) ||
         __get_user(VAR_5, VAR_6) )
        return 0;

    *VAR_2 = (VAR_5.a >> 16) & 0x0000fffc;
    *VAR_3 = (VAR_5.a & 0x0000ffff) | (VAR_5.b & 0xffff0000);
    *VAR_4 = VAR_5.b & 0x0000ffff;

    /* COMMENT_4 */
                                                             
                                                       
       
    if ( *VAR_4 & VAR_7 )
        return 0;
    *VAR_4 |= (VAR_5.a >> (16 - 13)) & VAR_7;

    if ( !is_pv_32bit_vcpu(VAR_1) )
    {
        if ( (*VAR_4 & 0x1f00) != 0x0c00 ||
             /* COMMENT_8 */
             __get_user(VAR_5, VAR_6 + 1) ||
             (VAR_5.b & 0x1f00) )
            return 0;

        *VAR_3 |= (unsigned long)VAR_5.a << 32;
        return 1;
    }

    switch ( *VAR_4 & 0x1f00 )
    {
    case 0x0400:
        *VAR_3 &= 0xffff;
        break;
    case 0x0c00:
        break;
    default:
        return 0;
    }

    return 1;
}",xen-project/xen/93021cbe880a8013691a48d0febef8ed7d3e3ebd/emul-gate-op.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,7 +8,13 @@
     const seg_desc_t *pdesc = gdt_ldt_desc_ptr(gate_sel);
 
     if ( (gate_sel < 4) ||
-         ((gate_sel >= FIRST_RESERVED_GDT_BYTE) && !(gate_sel & 4)) ||
+         /*
+          * We're interested in call gates only, which occupy a single
+          * seg_desc_t for 32-bit and a consecutive pair of them for 64-bit.
+          */
+         ((gate_sel >> 3) + !is_pv_32bit_vcpu(v) >=
+          (gate_sel & 4 ? v->arch.pv.ldt_ents
+                        : v->arch.pv.gdt_ents)) ||
          __get_user(desc, pdesc) )
         return 0;
 
@@ -27,7 +33,7 @@
     if ( !is_pv_32bit_vcpu(v) )
     {
         if ( (*ar & 0x1f00) != 0x0c00 ||
-             (gate_sel >= FIRST_RESERVED_GDT_BYTE - 8 && !(gate_sel & 4)) ||
+             /* Limit check done above already. */
              __get_user(desc, pdesc + 1) ||
              (desc.b & 0x1f00) )
             return 0;","{'deleted_lines': ['         ((gate_sel >= FIRST_RESERVED_GDT_BYTE) && !(gate_sel & 4)) ||', '             (gate_sel >= FIRST_RESERVED_GDT_BYTE - 8 && !(gate_sel & 4)) ||'], 'added_lines': ['         /*', ""          * We're interested in call gates only, which occupy a single"", '          * seg_desc_t for 32-bit and a consecutive pair of them for 64-bit.', '          */', '         ((gate_sel >> 3) + !is_pv_32bit_vcpu(v) >=', '          (gate_sel & 4 ? v->arch.pv.ldt_ents', '                        : v->arch.pv.gdt_ents)) ||', '             /* Limit check done above already. */']}",True,"An issue was discovered in Xen through 4.12.x allowing 32-bit PV guest OS users to gain guest OS privileges by installing and using descriptors. There is missing descriptor table limit checking in x86 PV emulation. When emulating certain PV guest operations, descriptor table accesses are performed by the emulating code. Such accesses should respect the guest specified limits, unless otherwise guaranteed to fail in such a case. Without this, emulation of 32-bit guest user mode calls through call gates would allow guest user mode to install and then use descriptors of their choice, as long as the guest kernel did not itself install an LDT. (Most OSes don't install any LDT by default). 32-bit PV guest user mode can elevate its privileges to that of the guest kernel. Xen versions from at least 3.2 onwards are affected. Only 32-bit PV guest user mode can leverage this vulnerability. HVM, PVH, as well as 64-bit PV guests cannot leverage this vulnerability. Arm systems are unaffected.",9.8,CRITICAL,3,test,2019-10-31T15:08:16Z,3
CVE-2019-18425,['CWE-269'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/PV: check GDT/LDT limits during emulation

Accesses beyond the LDT limit originating from emulation would trigger
the ASSERT() in pv_map_ldt_shadow_page(). On production builds such
accesses would cause an attempt to promote the touched page (offset from
the present LDT base address) to a segment descriptor one. If this
happens to succeed, guest user mode would be able to elevate its
privileges to that of the guest kernel. This is particularly easy when
there's no LDT at all, in which case the LDT base stored internally to
Xen is simply zero.

Also adjust the ASSERT() that was triggering: It was off by one to
begin with, and for production builds we also better use
ASSERT_UNREACHABLE() instead with suitable recovery code afterwards.

This is XSA-298.

Reported-by: Andrew Cooper <andrew.cooper3@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>",93021cbe880a8013691a48d0febef8ed7d3e3ebd,https://github.com/xen-project/xen/commit/93021cbe880a8013691a48d0febef8ed7d3e3ebd,xen/arch/x86/pv/emulate.c,pv_emul_read_descriptor,"int pv_emul_read_descriptor(unsigned int sel, const struct vcpu *v,
unsigned long *base, unsigned long *limit,
unsigned int *ar, bool insn_fetch)
{
seg_desc_t desc;
if ( sel < 4)
desc.b = desc.a = 0;
else if ( __get_user(desc, gdt_ldt_desc_ptr(sel)) )
return 0;
if ( !insn_fetch )
desc.b &= ~_SEGMENT_L;
*ar = desc.b & 0x00f0ff00;
if ( !(desc.b & _SEGMENT_L) )
{
*base = ((desc.a >> 16) + ((desc.b & 0xff) << 16) +
(desc.b & 0xff000000));
*limit = (desc.a & 0xffff) | (desc.b & 0x000f0000);
if ( desc.b & _SEGMENT_G )
*limit = ((*limit + 1) << 12) - 1;
#ifndef NDEBUG
if ( sel > 3 )
{
unsigned int a, l;
unsigned char valid;
asm volatile (
""larl %2,%0 ; setz %1""
: ""=r"" (a), ""=qm"" (valid) : ""rm"" (sel));
BUG_ON(valid && ((a & 0x00f0ff00) != *ar));
asm volatile (
""lsll %2,%0 ; setz %1""
: ""=r"" (l), ""=qm"" (valid) : ""rm"" (sel));
BUG_ON(valid && (l != *limit));
}
#endif
}
else
{
*base = 0UL;
*limit = ~0UL;
}
return 1;
}","int pv_emul_read_descriptor(unsigned int VAR_0, const struct vcpu *VAR_1,
unsigned long *VAR_2, unsigned long *VAR_3,
unsigned int *VAR_4, bool VAR_5)
{
seg_desc_t VAR_6;
if ( VAR_0 < 4)
VAR_6.b = VAR_6.a = 0;
else if ( __get_user(VAR_6, gdt_ldt_desc_ptr(VAR_0)) )
return 0;
if ( !VAR_5 )
VAR_6.b &= ~VAR_7;
*VAR_4 = VAR_6.b & 0x00f0ff00;
if ( !(VAR_6.b & VAR_7) )
{
*VAR_2 = ((VAR_6.a >> 16) + ((VAR_6.b & 0xff) << 16) +
(VAR_6.b & 0xff000000));
*VAR_3 = (VAR_6.a & 0xffff) | (VAR_6.b & 0x000f0000);
if ( VAR_6.b & VAR_8 )
*VAR_3 = ((*VAR_3 + 1) << 12) - 1;
#ifndef VAR_9
if ( VAR_0 > 3 )
{
unsigned int VAR_10, VAR_11;
unsigned char VAR_12;
asm volatile (
""larl %2,%0 ; setz %1""
: ""=r"" (VAR_10), ""=qm"" (VAR_12) : ""rm"" (VAR_0));
BUG_ON(VAR_12 && ((VAR_10 & 0x00f0ff00) != *VAR_4));
asm volatile (
""lsll %2,%0 ; setz %1""
: ""=r"" (VAR_11), ""=qm"" (VAR_12) : ""rm"" (VAR_0));
BUG_ON(VAR_12 && (VAR_11 != *VAR_3));
}
#endif
}
else
{
*VAR_2 = 0UL;
*VAR_3 = ~0UL;
}
return 1;
}",xen-project/xen/93021cbe880a8013691a48d0febef8ed7d3e3ebd/emulate.c/vul/before/0.json,"int pv_emul_read_descriptor(unsigned int sel, const struct vcpu *v,
                            unsigned long *base, unsigned long *limit,
                            unsigned int *ar, bool insn_fetch)
{
    seg_desc_t desc;

    if ( sel < 4 ||
         /*
          * Don't apply the GDT limit here, as the selector may be a Xen
          * provided one. __get_user() will fail (without taking further
          * action) for ones falling in the gap between guest populated
          * and Xen ones.
          */
         ((sel & 4) && (sel >> 3) >= v->arch.pv.ldt_ents) )
        desc.b = desc.a = 0;
    else if ( __get_user(desc, gdt_ldt_desc_ptr(sel)) )
        return 0;
    if ( !insn_fetch )
        desc.b &= ~_SEGMENT_L;

    *ar = desc.b & 0x00f0ff00;
    if ( !(desc.b & _SEGMENT_L) )
    {
        *base = ((desc.a >> 16) + ((desc.b & 0xff) << 16) +
                 (desc.b & 0xff000000));
        *limit = (desc.a & 0xffff) | (desc.b & 0x000f0000);
        if ( desc.b & _SEGMENT_G )
            *limit = ((*limit + 1) << 12) - 1;
#ifndef NDEBUG
        if ( sel > 3 )
        {
            unsigned int a, l;
            unsigned char valid;

            asm volatile (
                ""larl %2,%0 ; setz %1""
                : ""=r"" (a), ""=qm"" (valid) : ""rm"" (sel));
            BUG_ON(valid && ((a & 0x00f0ff00) != *ar));
            asm volatile (
                ""lsll %2,%0 ; setz %1""
                : ""=r"" (l), ""=qm"" (valid) : ""rm"" (sel));
            BUG_ON(valid && (l != *limit));
        }
#endif
    }
    else
    {
        *base = 0UL;
        *limit = ~0UL;
    }

    return 1;
}","int pv_emul_read_descriptor(unsigned int VAR_0, const struct vcpu *VAR_1,
                            unsigned long *VAR_2, unsigned long *VAR_3,
                            unsigned int *VAR_4, bool VAR_5)
{
    seg_desc_t VAR_6;

    if ( VAR_0 < 4 ||
         /* COMMENT_0 */
                                                                        
                                                                        
                                                                       
                         
            
         ((VAR_0 & 4) && (VAR_0 >> 3) >= VAR_1->arch.pv.ldt_ents) )
        VAR_6.b = VAR_6.a = 0;
    else if ( __get_user(VAR_6, gdt_ldt_desc_ptr(VAR_0)) )
        return 0;
    if ( !VAR_5 )
        VAR_6.b &= ~VAR_7;

    *VAR_4 = VAR_6.b & 0x00f0ff00;
    if ( !(VAR_6.b & VAR_7) )
    {
        *VAR_2 = ((VAR_6.a >> 16) + ((VAR_6.b & 0xff) << 16) +
                 (VAR_6.b & 0xff000000));
        *VAR_3 = (VAR_6.a & 0xffff) | (VAR_6.b & 0x000f0000);
        if ( VAR_6.b & VAR_8 )
            *VAR_3 = ((*VAR_3 + 1) << 12) - 1;
#ifndef VAR_9
        if ( VAR_0 > 3 )
        {
            unsigned int VAR_10, VAR_11;
            unsigned char VAR_12;

            asm volatile (
                ""larl %2,%0 ; setz %1""
                : ""=r"" (VAR_10), ""=qm"" (VAR_12) : ""rm"" (VAR_0));
            BUG_ON(VAR_12 && ((VAR_10 & 0x00f0ff00) != *VAR_4));
            asm volatile (
                ""lsll %2,%0 ; setz %1""
                : ""=r"" (VAR_11), ""=qm"" (VAR_12) : ""rm"" (VAR_0));
            BUG_ON(VAR_12 && (VAR_11 != *VAR_3));
        }
#endif
    }
    else
    {
        *VAR_2 = 0UL;
        *VAR_3 = ~0UL;
    }

    return 1;
}",xen-project/xen/93021cbe880a8013691a48d0febef8ed7d3e3ebd/emulate.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,7 +4,14 @@
 {
     seg_desc_t desc;
 
-    if ( sel < 4)
+    if ( sel < 4 ||
+         /*
+          * Don't apply the GDT limit here, as the selector may be a Xen
+          * provided one. __get_user() will fail (without taking further
+          * action) for ones falling in the gap between guest populated
+          * and Xen ones.
+          */
+         ((sel & 4) && (sel >> 3) >= v->arch.pv.ldt_ents) )
         desc.b = desc.a = 0;
     else if ( __get_user(desc, gdt_ldt_desc_ptr(sel)) )
         return 0;","{'deleted_lines': ['    if ( sel < 4)'], 'added_lines': ['    if ( sel < 4 ||', '         /*', ""          * Don't apply the GDT limit here, as the selector may be a Xen"", '          * provided one. __get_user() will fail (without taking further', '          * action) for ones falling in the gap between guest populated', '          * and Xen ones.', '          */', '         ((sel & 4) && (sel >> 3) >= v->arch.pv.ldt_ents) )']}",True,"An issue was discovered in Xen through 4.12.x allowing 32-bit PV guest OS users to gain guest OS privileges by installing and using descriptors. There is missing descriptor table limit checking in x86 PV emulation. When emulating certain PV guest operations, descriptor table accesses are performed by the emulating code. Such accesses should respect the guest specified limits, unless otherwise guaranteed to fail in such a case. Without this, emulation of 32-bit guest user mode calls through call gates would allow guest user mode to install and then use descriptors of their choice, as long as the guest kernel did not itself install an LDT. (Most OSes don't install any LDT by default). 32-bit PV guest user mode can elevate its privileges to that of the guest kernel. Xen versions from at least 3.2 onwards are affected. Only 32-bit PV guest user mode can leverage this vulnerability. HVM, PVH, as well as 64-bit PV guests cannot leverage this vulnerability. Arm systems are unaffected.",9.8,CRITICAL,3,test,2019-10-31T15:08:16Z,3
CVE-2019-18425,['CWE-269'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/PV: check GDT/LDT limits during emulation

Accesses beyond the LDT limit originating from emulation would trigger
the ASSERT() in pv_map_ldt_shadow_page(). On production builds such
accesses would cause an attempt to promote the touched page (offset from
the present LDT base address) to a segment descriptor one. If this
happens to succeed, guest user mode would be able to elevate its
privileges to that of the guest kernel. This is particularly easy when
there's no LDT at all, in which case the LDT base stored internally to
Xen is simply zero.

Also adjust the ASSERT() that was triggering: It was off by one to
begin with, and for production builds we also better use
ASSERT_UNREACHABLE() instead with suitable recovery code afterwards.

This is XSA-298.

Reported-by: Andrew Cooper <andrew.cooper3@citrix.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>",93021cbe880a8013691a48d0febef8ed7d3e3ebd,https://github.com/xen-project/xen/commit/93021cbe880a8013691a48d0febef8ed7d3e3ebd,xen/arch/x86/pv/mm.c,pv_map_ldt_shadow_page,"bool pv_map_ldt_shadow_page(unsigned int offset)
{
struct vcpu *curr = current;
struct domain *currd = curr->domain;
struct page_info *page;
l1_pgentry_t gl1e, *pl1e;
unsigned long linear = curr->arch.pv.ldt_base + offset;
BUG_ON(unlikely(in_irq()));
ASSERT((offset >> 3) <= curr->arch.pv.ldt_ents);
if ( is_pv_32bit_domain(currd) )
linear = (uint32_t)linear;
gl1e = guest_get_eff_kern_l1e(linear);
if ( unlikely(!(l1e_get_flags(gl1e) & _PAGE_PRESENT)) )
return false;
page = get_page_from_gfn(currd, l1e_get_pfn(gl1e), NULL, P2M_ALLOC);
if ( unlikely(!page) )
return false;
if ( unlikely(!get_page_type(page, PGT_seg_desc_page)) )
{
put_page(page);
return false;
}
pl1e = &pv_ldt_ptes(curr)[offset >> PAGE_SHIFT];
l1e_add_flags(gl1e, _PAGE_RW);
#ifdef CONFIG_PV_LDT_PAGING
spin_lock(&curr->arch.pv.shadow_ldt_lock);
#endif
l1e_write(pl1e, gl1e);
#ifdef CONFIG_PV_LDT_PAGING
curr->arch.pv.shadow_ldt_mapcnt++;
spin_unlock(&curr->arch.pv.shadow_ldt_lock);
#endif
return true;
}","bool pv_map_ldt_shadow_page(unsigned int VAR_0)
{
struct vcpu *VAR_1 = VAR_2;
struct domain *VAR_3 = VAR_1->domain;
struct page_info *VAR_4;
l1_pgentry_t VAR_5, *VAR_6;
unsigned long VAR_7 = VAR_1->arch.pv.ldt_base + VAR_0;
BUG_ON(unlikely(in_irq()));
ASSERT((VAR_0 >> 3) <= VAR_1->arch.pv.ldt_ents);
if ( is_pv_32bit_domain(VAR_3) )
VAR_7 = (uint32_t)VAR_7;
VAR_5 = guest_get_eff_kern_l1e(VAR_7);
if ( unlikely(!(l1e_get_flags(VAR_5) & VAR_8)) )
return false;
VAR_4 = get_page_from_gfn(VAR_3, l1e_get_pfn(VAR_5), NULL, VAR_9);
if ( unlikely(!VAR_4) )
return false;
if ( unlikely(!get_page_type(VAR_4, VAR_10)) )
{
put_page(VAR_4);
return false;
}
VAR_6 = &pv_ldt_ptes(VAR_1)[VAR_0 >> VAR_11];
l1e_add_flags(VAR_5, VAR_12);
#ifdef VAR_13
spin_lock(&VAR_1->arch.pv.shadow_ldt_lock);
#endif
l1e_write(VAR_6, VAR_5);
#ifdef VAR_13
VAR_1->arch.pv.shadow_ldt_mapcnt++;
spin_unlock(&VAR_1->arch.pv.shadow_ldt_lock);
#endif
return true;
}",xen-project/xen/93021cbe880a8013691a48d0febef8ed7d3e3ebd/mm.c/vul/before/0.json,"bool pv_map_ldt_shadow_page(unsigned int offset)
{
    struct vcpu *curr = current;
    struct domain *currd = curr->domain;
    struct page_info *page;
    l1_pgentry_t gl1e, *pl1e;
    unsigned long linear = curr->arch.pv.ldt_base + offset;

    BUG_ON(unlikely(in_irq()));

    /*
     * Prior limit checking should guarantee this property.  NB. This is
     * safe as updates to the LDT can only be made by MMUEXT_SET_LDT to the
     * current vcpu, and vcpu_reset() will block until this vcpu has been
     * descheduled before continuing.
     */
    if ( unlikely((offset >> 3) >= curr->arch.pv.ldt_ents) )
    {
        ASSERT_UNREACHABLE();
        return false;
    }

    if ( is_pv_32bit_domain(currd) )
        linear = (uint32_t)linear;

    gl1e = guest_get_eff_kern_l1e(linear);
    if ( unlikely(!(l1e_get_flags(gl1e) & _PAGE_PRESENT)) )
        return false;

    page = get_page_from_gfn(currd, l1e_get_pfn(gl1e), NULL, P2M_ALLOC);
    if ( unlikely(!page) )
        return false;

    if ( unlikely(!get_page_type(page, PGT_seg_desc_page)) )
    {
        put_page(page);
        return false;
    }

    pl1e = &pv_ldt_ptes(curr)[offset >> PAGE_SHIFT];
    l1e_add_flags(gl1e, _PAGE_RW);

#ifdef CONFIG_PV_LDT_PAGING
    spin_lock(&curr->arch.pv.shadow_ldt_lock);
#endif

    l1e_write(pl1e, gl1e);

#ifdef CONFIG_PV_LDT_PAGING
    curr->arch.pv.shadow_ldt_mapcnt++;
    spin_unlock(&curr->arch.pv.shadow_ldt_lock);
#endif

    return true;
}","bool pv_map_ldt_shadow_page(unsigned int VAR_0)
{
    struct vcpu *VAR_1 = VAR_2;
    struct domain *VAR_3 = VAR_1->domain;
    struct page_info *VAR_4;
    l1_pgentry_t VAR_5, *VAR_6;
    unsigned long VAR_7 = VAR_1->arch.pv.ldt_base + VAR_0;

    BUG_ON(unlikely(in_irq()));

    /* COMMENT_0 */
                                                                        
                                                                           
                                                                         
                                     
       
    if ( unlikely((VAR_0 >> 3) >= VAR_1->arch.pv.ldt_ents) )
    {
        ASSERT_UNREACHABLE();
        return false;
    }

    if ( is_pv_32bit_domain(VAR_3) )
        VAR_7 = (uint32_t)VAR_7;

    VAR_5 = guest_get_eff_kern_l1e(VAR_7);
    if ( unlikely(!(l1e_get_flags(VAR_5) & VAR_8)) )
        return false;

    VAR_4 = get_page_from_gfn(VAR_3, l1e_get_pfn(VAR_5), NULL, VAR_9);
    if ( unlikely(!VAR_4) )
        return false;

    if ( unlikely(!get_page_type(VAR_4, VAR_10)) )
    {
        put_page(VAR_4);
        return false;
    }

    VAR_6 = &pv_ldt_ptes(VAR_1)[VAR_0 >> VAR_11];
    l1e_add_flags(VAR_5, VAR_12);

#ifdef VAR_13
    spin_lock(&VAR_1->arch.pv.shadow_ldt_lock);
#endif

    l1e_write(VAR_6, VAR_5);

#ifdef VAR_13
    VAR_1->arch.pv.shadow_ldt_mapcnt++;
    spin_unlock(&VAR_1->arch.pv.shadow_ldt_lock);
#endif

    return true;
}",xen-project/xen/93021cbe880a8013691a48d0febef8ed7d3e3ebd/mm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,12 +9,16 @@
     BUG_ON(unlikely(in_irq()));
 
     /*
-     * Hardware limit checking should guarantee this property.  NB. This is
+     * Prior limit checking should guarantee this property.  NB. This is
      * safe as updates to the LDT can only be made by MMUEXT_SET_LDT to the
      * current vcpu, and vcpu_reset() will block until this vcpu has been
      * descheduled before continuing.
      */
-    ASSERT((offset >> 3) <= curr->arch.pv.ldt_ents);
+    if ( unlikely((offset >> 3) >= curr->arch.pv.ldt_ents) )
+    {
+        ASSERT_UNREACHABLE();
+        return false;
+    }
 
     if ( is_pv_32bit_domain(currd) )
         linear = (uint32_t)linear;","{'deleted_lines': ['     * Hardware limit checking should guarantee this property.  NB. This is', '    ASSERT((offset >> 3) <= curr->arch.pv.ldt_ents);'], 'added_lines': ['     * Prior limit checking should guarantee this property.  NB. This is', '    if ( unlikely((offset >> 3) >= curr->arch.pv.ldt_ents) )', '    {', '        ASSERT_UNREACHABLE();', '        return false;', '    }']}",True,"An issue was discovered in Xen through 4.12.x allowing 32-bit PV guest OS users to gain guest OS privileges by installing and using descriptors. There is missing descriptor table limit checking in x86 PV emulation. When emulating certain PV guest operations, descriptor table accesses are performed by the emulating code. Such accesses should respect the guest specified limits, unless otherwise guaranteed to fail in such a case. Without this, emulation of 32-bit guest user mode calls through call gates would allow guest user mode to install and then use descriptors of their choice, as long as the guest kernel did not itself install an LDT. (Most OSes don't install any LDT by default). 32-bit PV guest user mode can elevate its privileges to that of the guest kernel. Xen versions from at least 3.2 onwards are affected. Only 32-bit PV guest user mode can leverage this vulnerability. HVM, PVH, as well as 64-bit PV guests cannot leverage this vulnerability. Arm systems are unaffected.",9.8,CRITICAL,3,test,2019-10-31T15:08:16Z,3
CVE-2019-18798,"['CWE-476', 'CWE-125']",AV:N/AC:M/Au:N/C:N/I:N/A:P,0,sass/libsass,"Fix nullptr access on interpolated parents

Fixes https://github.com/sass/libsass/issues/3024",d2390e54c4f1ab5c33a0e35e7b9264b36284fa91,https://github.com/sass/libsass/commit/d2390e54c4f1ab5c33a0e35e7b9264b36284fa91,src/eval.cpp,Eval::operator(),"Expression* Eval::operator()(Binary_Expression* b_in)
{
Expression_Obj lhs = b_in->left();
Expression_Obj rhs = b_in->right();
enum Sass_OP op_type = b_in->optype();
if (op_type == Sass_OP::AND) {
lhs = lhs->perform(this);
if (!*lhs) return lhs.detach();
return rhs->perform(this);
}
else if (op_type == Sass_OP::OR) {
lhs = lhs->perform(this);
if (*lhs) return lhs.detach();
return rhs->perform(this);
}
while (Variable* l_v = Cast<Variable>(lhs)) {
lhs = operator()(l_v);
}
while (Variable* r_v = Cast<Variable>(rhs)) {
rhs = operator()(r_v);
}
Binary_Expression_Obj b = b_in;
while (Binary_Expression* l_b = Cast<Binary_Expression>(lhs)) {
if (!force && l_b->is_delayed()) break;
lhs = operator()(l_b);
}
while (Binary_Expression* r_b = Cast<Binary_Expression>(rhs)) {
if (!force && r_b->is_delayed()) break;
rhs = operator()(r_b);
}
if (!force && op_type == Sass_OP::DIV && b->is_delayed()) {
b->right(b->right()->perform(this));
b->left(b->left()->perform(this));
return b.detach();
}
if (Number* l_n = Cast<Number>(lhs)) {
if (Number* r_n = Cast<Number>(rhs)) {
try {
switch (op_type) {
case Sass_OP::EQ: return *l_n == *r_n ? bool_true : bool_false;
case Sass_OP::NEQ: return *l_n == *r_n ? bool_false : bool_true;
case Sass_OP::LT: return *l_n < *r_n ? bool_true : bool_false;
case Sass_OP::GTE: return *l_n < *r_n ? bool_false : bool_true;
case Sass_OP::LTE: return *l_n < *r_n || *l_n == *r_n ? bool_true : bool_false;
case Sass_OP::GT: return *l_n < *r_n || *l_n == *r_n ? bool_false : bool_true;
case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:
return Operators::op_numbers(op_type, *l_n, *r_n, options(), b_in->pstate());
default: break;
}
}
catch (Exception::OperationError& err)
{
traces.push_back(Backtrace(b_in->pstate()));
throw Exception::SassValueError(traces, b_in->pstate(), err);
}
}
else if (Color* r_col = Cast<Color>(rhs)) {
Color_RGBA_Obj r_c = r_col->toRGBA();
try {
switch (op_type) {
case Sass_OP::EQ: return *l_n == *r_c ? bool_true : bool_false;
case Sass_OP::NEQ: return *l_n == *r_c ? bool_false : bool_true;
case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:
return Operators::op_number_color(op_type, *l_n, *r_c, options(), b_in->pstate());
default: break;
}
}
catch (Exception::OperationError& err)
{
traces.push_back(Backtrace(b_in->pstate()));
throw Exception::SassValueError(traces, b_in->pstate(), err);
}
}
}
else if (Color* l_col = Cast<Color>(lhs)) {
Color_RGBA_Obj l_c = l_col->toRGBA();
if (Color* r_col = Cast<Color>(rhs)) {
Color_RGBA_Obj r_c = r_col->toRGBA();
try {
switch (op_type) {
case Sass_OP::EQ: return *l_c == *r_c ? bool_true : bool_false;
case Sass_OP::NEQ: return *l_c == *r_c ? bool_false : bool_true;
case Sass_OP::LT: return *l_c < *r_c ? bool_true : bool_false;
case Sass_OP::GTE: return *l_c < *r_c ? bool_false : bool_true;
case Sass_OP::LTE: return *l_c < *r_c || *l_c == *r_c ? bool_true : bool_false;
case Sass_OP::GT: return *l_c < *r_c || *l_c == *r_c ? bool_false : bool_true;
case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:
return Operators::op_colors(op_type, *l_c, *r_c, options(), b_in->pstate());
default: break;
}
}
catch (Exception::OperationError& err)
{
traces.push_back(Backtrace(b_in->pstate()));
throw Exception::SassValueError(traces, b_in->pstate(), err);
}
}
else if (Number* r_n = Cast<Number>(rhs)) {
try {
switch (op_type) {
case Sass_OP::EQ: return *l_c == *r_n ? bool_true : bool_false;
case Sass_OP::NEQ: return *l_c == *r_n ? bool_false : bool_true;
case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:
return Operators::op_color_number(op_type, *l_c, *r_n, options(), b_in->pstate());
default: break;
}
}
catch (Exception::OperationError& err)
{
traces.push_back(Backtrace(b_in->pstate()));
throw Exception::SassValueError(traces, b_in->pstate(), err);
}
}
}
String_Schema_Obj ret_schema;
if (String_Schema* s_l = Cast<String_Schema>(b->left())) {
if (!s_l->has_interpolant() && (!s_l->is_right_interpolant())) {
ret_schema = SASS_MEMORY_NEW(String_Schema, b->pstate());
Binary_Expression_Obj bin_ex = SASS_MEMORY_NEW(Binary_Expression, b->pstate(),
b->op(), s_l->last(), b->right());
bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed());         for (size_t i = 0; i < s_l->length() - 1; ++i) {
ret_schema->append(Cast<PreValue>(s_l->at(i)->perform(this)));
}
ret_schema->append(Cast<PreValue>(bin_ex->perform(this)));
return ret_schema->perform(this);
}
}
if (String_Schema* s_r = Cast<String_Schema>(b->right())) {
if (!s_r->has_interpolant() && (!s_r->is_left_interpolant() || op_type == Sass_OP::DIV)) {
ret_schema = SASS_MEMORY_NEW(String_Schema, b->pstate());
Binary_Expression_Obj bin_ex = SASS_MEMORY_NEW(Binary_Expression, b->pstate(),
b->op(), b->left(), s_r->first());
bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed());         ret_schema->append(Cast<PreValue>(bin_ex->perform(this)));
for (size_t i = 1; i < s_r->length(); ++i) {
ret_schema->append(Cast<PreValue>(s_r->at(i)->perform(this)));
}
return ret_schema->perform(this);
}
}
if (op_type == Sass_OP::EQ ||
op_type == Sass_OP::NEQ ||
op_type == Sass_OP::GT ||
op_type == Sass_OP::GTE ||
op_type == Sass_OP::LT ||
op_type == Sass_OP::LTE)
{
LOCAL_FLAG(force, true);
lhs->is_expanded(false);
lhs->set_delayed(false);
lhs = lhs->perform(this);
rhs->is_expanded(false);
rhs->set_delayed(false);
rhs = rhs->perform(this);
}
else {
lhs = lhs->perform(this);
}
rhs = rhs->perform(this);
AST_Node_Obj lu = lhs;
AST_Node_Obj ru = rhs;
Expression::Type l_type;
Expression::Type r_type;
String_Schema_Obj s1 = Cast<String_Schema>(b->left());
String_Schema_Obj s2 = Cast<String_Schema>(b->right());
Binary_Expression_Obj b1 = Cast<Binary_Expression>(b->left());
Binary_Expression_Obj b2 = Cast<Binary_Expression>(b->right());
bool schema_op = false;
bool force_delay = (s2 && s2->is_left_interpolant()) ||
(s1 && s1->is_right_interpolant()) ||
(b1 && b1->is_right_interpolant()) ||
(b2 && b2->is_left_interpolant());
if ((s1 && s1->has_interpolants()) || (s2 && s2->has_interpolants()) || force_delay)
{
if (op_type == Sass_OP::DIV || op_type == Sass_OP::MUL || op_type == Sass_OP::MOD || op_type == Sass_OP::ADD || op_type == Sass_OP::SUB ||
op_type == Sass_OP::EQ) {
if (String_Constant* str = Cast<String_Constant>(lhs)) {
std::string value(str->value());
const char* start = value.c_str();
if (Prelexer::sequence < Prelexer::dimension, Prelexer::end_of_file >(start) != 0) {
lhs = Parser::lexed_dimension(b->pstate(), str->value());
}
}
if (String_Constant* str = Cast<String_Constant>(rhs)) {
std::string value(str->value());
const char* start = value.c_str();
if (Prelexer::sequence < Prelexer::dimension, Prelexer::number >(start) != 0) {
rhs = Parser::lexed_dimension(b->pstate(), str->value());
}
}
}
To_Value to_value(ctx);
Value_Obj v_l = Cast<Value>(lhs->perform(&to_value));
Value_Obj v_r = Cast<Value>(rhs->perform(&to_value));
if (force_delay) {
std::string str("""");
str += v_l->to_string(options());
if (b->op().ws_before) str += "" "";
str += b->separator();
if (b->op().ws_after) str += "" "";
str += v_r->to_string(options());
String_Constant* val = SASS_MEMORY_NEW(String_Constant, b->pstate(), str);
val->is_interpolant(b->left()->has_interpolant());
return val;
}
}
try {
switch(op_type) {
case Sass_OP::EQ:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::eq(lhs, rhs));
case Sass_OP::NEQ: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::neq(lhs, rhs));
case Sass_OP::GT:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::gt(lhs, rhs));
case Sass_OP::GTE: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::gte(lhs, rhs));
case Sass_OP::LT:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::lt(lhs, rhs));
case Sass_OP::LTE: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::lte(lhs, rhs));
default: break;
}
}
catch (Exception::OperationError& err)
{
traces.push_back(Backtrace(b->pstate()));
throw Exception::SassValueError(traces, b->pstate(), err);
}
l_type = lhs->concrete_type();
r_type = rhs->concrete_type();
Expression_Obj rv;
try {
ParserState pstate(b->pstate());
if (l_type == Expression::NUMBER && r_type == Expression::NUMBER) {
Number* l_n = Cast<Number>(lhs);
Number* r_n = Cast<Number>(rhs);
l_n->reduce(); r_n->reduce();
rv = Operators::op_numbers(op_type, *l_n, *r_n, options(), pstate);
}
else if (l_type == Expression::NUMBER && r_type == Expression::COLOR) {
Number* l_n = Cast<Number>(lhs);
Color_RGBA_Obj r_c = Cast<Color>(rhs)->toRGBA();
rv = Operators::op_number_color(op_type, *l_n, *r_c, options(), pstate);
}
else if (l_type == Expression::COLOR && r_type == Expression::NUMBER) {
Color_RGBA_Obj l_c = Cast<Color>(lhs)->toRGBA();
Number* r_n = Cast<Number>(rhs);
rv = Operators::op_color_number(op_type, *l_c, *r_n, options(), pstate);
}
else if (l_type == Expression::COLOR && r_type == Expression::COLOR) {
Color_RGBA_Obj l_c = Cast<Color>(lhs)->toRGBA();
Color_RGBA_Obj r_c = Cast<Color>(rhs)->toRGBA();
rv = Operators::op_colors(op_type, *l_c, *r_c, options(), pstate);
}
else {
To_Value to_value(ctx);
Value_Obj v_l = Cast<Value>(lhs->perform(&to_value));
Value_Obj v_r = Cast<Value>(rhs->perform(&to_value));
bool interpolant = b->is_right_interpolant() ||
b->is_left_interpolant() ||
b->is_interpolant();
if (op_type == Sass_OP::SUB) interpolant = false;
if (l_type == Expression::MAP || l_type == Expression::FUNCTION_VAL) {
traces.push_back(Backtrace(v_l->pstate()));
throw Exception::InvalidValue(traces, *v_l);
}
if (r_type == Expression::MAP || l_type == Expression::FUNCTION_VAL) {
traces.push_back(Backtrace(v_r->pstate()));
throw Exception::InvalidValue(traces, *v_r);
}
Value* ex = Operators::op_strings(b->op(), *v_l, *v_r, options(), pstate, !interpolant);         if (String_Constant* str = Cast<String_Constant>(ex))
{
if (str->concrete_type() == Expression::STRING)
{
String_Constant* lstr = Cast<String_Constant>(lhs);
String_Constant* rstr = Cast<String_Constant>(rhs);
if (op_type != Sass_OP::SUB) {
if (String_Constant* org = lstr ? lstr : rstr)
{ str->quote_mark(org->quote_mark()); }
}
}
}
ex->is_interpolant(b->is_interpolant());
rv = ex;
}
}
catch (Exception::OperationError& err)
{
traces.push_back(Backtrace(b->pstate()));
throw Exception::SassValueError(traces, b->pstate(), err);
}
if (rv) {
if (schema_op) {
(*s2)[0] = rv;
rv = s2->perform(this);
}
}
return rv.detach();
}","Expression* Eval::operator()(Binary_Expression* VAR_0)
{
Expression_Obj VAR_1 = VAR_0->left();
Expression_Obj VAR_2 = VAR_0->right();
enum Sass_OP VAR_3 = VAR_0->optype();
if (VAR_3 == Sass_OP::AND) {
VAR_1 = VAR_1->perform(this);
if (!*VAR_1) return VAR_1.detach();
return VAR_2->perform(this);
}
else if (VAR_3 == Sass_OP::OR) {
VAR_1 = VAR_1->perform(this);
if (*VAR_1) return VAR_1.detach();
return VAR_2->perform(this);
}
while (Variable* VAR_4 = VAR_5<Variable>(VAR_1)) {
VAR_1 = operator()(VAR_4);
}
while (Variable* VAR_6 = VAR_5<Variable>(VAR_2)) {
VAR_2 = operator()(VAR_6);
}
Binary_Expression_Obj VAR_7 = VAR_0;
while (Binary_Expression* VAR_8 = VAR_5<Binary_Expression>(VAR_1)) {
if (!VAR_9 && VAR_8->is_delayed()) break;
VAR_1 = operator()(VAR_8);
}
while (Binary_Expression* VAR_10 = VAR_5<Binary_Expression>(VAR_2)) {
if (!VAR_9 && VAR_10->is_delayed()) break;
VAR_2 = operator()(VAR_10);
}
if (!VAR_9 && VAR_3 == Sass_OP::DIV && VAR_7->is_delayed()) {
VAR_7->right(VAR_7->right()->perform(this));
VAR_7->left(VAR_7->left()->perform(this));
return VAR_7.detach();
}
if (Number* VAR_11 = VAR_5<Number>(VAR_1)) {
if (Number* VAR_12 = VAR_5<Number>(VAR_2)) {
try {
switch (VAR_3) {
case Sass_OP::EQ: return *VAR_11 == *VAR_12 ? VAR_13 : VAR_14;
case Sass_OP::NEQ: return *VAR_11 == *VAR_12 ? VAR_14 : VAR_13;
case Sass_OP::LT: return *VAR_11 < *VAR_12 ? VAR_13 : VAR_14;
case Sass_OP::GTE: return *VAR_11 < *VAR_12 ? VAR_14 : VAR_13;
case Sass_OP::LTE: return *VAR_11 < *VAR_12 || *VAR_11 == *VAR_12 ? VAR_13 : VAR_14;
case Sass_OP::GT: return *VAR_11 < *VAR_12 || *VAR_11 == *VAR_12 ? VAR_14 : VAR_13;
case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:
return Operators::op_numbers(VAR_3, *VAR_11, *VAR_12, options(), VAR_0->pstate());
default: break;
}
}
catch (Exception::OperationError& VAR_15)
{
VAR_16.push_back(Backtrace(VAR_0->pstate()));
throw Exception::SassValueError(VAR_16, VAR_0->pstate(), VAR_15);
}
}
else if (Color* VAR_17 = VAR_5<Color>(VAR_2)) {
Color_RGBA_Obj VAR_18 = VAR_17->toRGBA();
try {
switch (VAR_3) {
case Sass_OP::EQ: return *VAR_11 == *VAR_18 ? VAR_13 : VAR_14;
case Sass_OP::NEQ: return *VAR_11 == *VAR_18 ? VAR_14 : VAR_13;
case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:
return Operators::op_number_color(VAR_3, *VAR_11, *VAR_18, options(), VAR_0->pstate());
default: break;
}
}
catch (Exception::OperationError& VAR_15)
{
VAR_16.push_back(Backtrace(VAR_0->pstate()));
throw Exception::SassValueError(VAR_16, VAR_0->pstate(), VAR_15);
}
}
}
else if (Color* VAR_19 = VAR_5<Color>(VAR_1)) {
Color_RGBA_Obj VAR_20 = VAR_19->toRGBA();
if (Color* VAR_17 = VAR_5<Color>(VAR_2)) {
Color_RGBA_Obj VAR_18 = VAR_17->toRGBA();
try {
switch (VAR_3) {
case Sass_OP::EQ: return *VAR_20 == *VAR_18 ? VAR_13 : VAR_14;
case Sass_OP::NEQ: return *VAR_20 == *VAR_18 ? VAR_14 : VAR_13;
case Sass_OP::LT: return *VAR_20 < *VAR_18 ? VAR_13 : VAR_14;
case Sass_OP::GTE: return *VAR_20 < *VAR_18 ? VAR_14 : VAR_13;
case Sass_OP::LTE: return *VAR_20 < *VAR_18 || *VAR_20 == *VAR_18 ? VAR_13 : VAR_14;
case Sass_OP::GT: return *VAR_20 < *VAR_18 || *VAR_20 == *VAR_18 ? VAR_14 : VAR_13;
case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:
return Operators::op_colors(VAR_3, *VAR_20, *VAR_18, options(), VAR_0->pstate());
default: break;
}
}
catch (Exception::OperationError& VAR_15)
{
VAR_16.push_back(Backtrace(VAR_0->pstate()));
throw Exception::SassValueError(VAR_16, VAR_0->pstate(), VAR_15);
}
}
else if (Number* VAR_12 = VAR_5<Number>(VAR_2)) {
try {
switch (VAR_3) {
case Sass_OP::EQ: return *VAR_20 == *VAR_12 ? VAR_13 : VAR_14;
case Sass_OP::NEQ: return *VAR_20 == *VAR_12 ? VAR_14 : VAR_13;
case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:
return Operators::op_color_number(VAR_3, *VAR_20, *VAR_12, options(), VAR_0->pstate());
default: break;
}
}
catch (Exception::OperationError& VAR_15)
{
VAR_16.push_back(Backtrace(VAR_0->pstate()));
throw Exception::SassValueError(VAR_16, VAR_0->pstate(), VAR_15);
}
}
}
String_Schema_Obj VAR_21;
if (String_Schema* VAR_22 = VAR_5<String_Schema>(VAR_7->left())) {
if (!VAR_22->has_interpolant() && (!VAR_22->is_right_interpolant())) {
VAR_21 = SASS_MEMORY_NEW(String_Schema, VAR_7->pstate());
Binary_Expression_Obj VAR_23 = SASS_MEMORY_NEW(Binary_Expression, VAR_7->pstate(),
VAR_7->op(), VAR_22->last(), VAR_7->right());
VAR_23->is_delayed(VAR_7->left()->is_delayed() || VAR_7->right()->is_delayed()); 
for (size_t VAR_24 = 0; VAR_24 < VAR_22->length() - 1; ++VAR_24) {
VAR_21->append(VAR_5<PreValue>(VAR_22->at(VAR_24)->perform(this)));
}
VAR_21->append(VAR_5<PreValue>(VAR_23->perform(this)));
return VAR_21->perform(this);
}
}
if (String_Schema* VAR_25 = VAR_5<String_Schema>(VAR_7->right())) {
if (!VAR_25->has_interpolant() && (!VAR_25->is_left_interpolant() || VAR_3 == Sass_OP::DIV)) {
VAR_21 = SASS_MEMORY_NEW(String_Schema, VAR_7->pstate());
Binary_Expression_Obj VAR_23 = SASS_MEMORY_NEW(Binary_Expression, VAR_7->pstate(),
VAR_7->op(), VAR_7->left(), VAR_25->first());
VAR_23->is_delayed(VAR_7->left()->is_delayed() || VAR_7->right()->is_delayed()); 
VAR_21->append(VAR_5<PreValue>(VAR_23->perform(this)));
for (size_t VAR_24 = 1; VAR_24 < VAR_25->length(); ++VAR_24) {
VAR_21->append(VAR_5<PreValue>(VAR_25->at(VAR_24)->perform(this)));
}
return VAR_21->perform(this);
}
}
if (VAR_3 == Sass_OP::EQ ||
VAR_3 == Sass_OP::NEQ ||
VAR_3 == Sass_OP::GT ||
VAR_3 == Sass_OP::GTE ||
VAR_3 == Sass_OP::LT ||
VAR_3 == Sass_OP::LTE)
{
LOCAL_FLAG(VAR_9, true);
VAR_1->is_expanded(false);
VAR_1->set_delayed(false);
VAR_1 = VAR_1->perform(this);
VAR_2->is_expanded(false);
VAR_2->set_delayed(false);
VAR_2 = VAR_2->perform(this);
}
else {
VAR_1 = VAR_1->perform(this);
}
VAR_2 = VAR_2->perform(this);
AST_Node_Obj VAR_26 = VAR_1;
AST_Node_Obj VAR_27 = VAR_2;
Expression::Type VAR_28;
Expression::Type VAR_29;
String_Schema_Obj VAR_30 = VAR_5<String_Schema>(VAR_7->left());
String_Schema_Obj VAR_31 = VAR_5<String_Schema>(VAR_7->right());
Binary_Expression_Obj VAR_32 = VAR_5<Binary_Expression>(VAR_7->left());
Binary_Expression_Obj VAR_33 = VAR_5<Binary_Expression>(VAR_7->right());
bool VAR_34 = false;
bool VAR_35 = (VAR_31 && VAR_31->is_left_interpolant()) ||
(VAR_30 && VAR_30->is_right_interpolant()) ||
(VAR_32 && VAR_32->is_right_interpolant()) ||
(VAR_33 && VAR_33->is_left_interpolant());
if ((VAR_30 && VAR_30->has_interpolants()) || (VAR_31 && VAR_31->has_interpolants()) || VAR_35)
{
if (VAR_3 == Sass_OP::DIV || VAR_3 == Sass_OP::MUL || VAR_3 == Sass_OP::MOD || VAR_3 == Sass_OP::ADD || VAR_3 == Sass_OP::SUB ||
VAR_3 == Sass_OP::EQ) {
if (String_Constant* VAR_36 = VAR_5<String_Constant>(VAR_1)) {
std::string VAR_37(VAR_36->value());
const char* VAR_38 = VAR_37.c_str();
if (Prelexer::VAR_39 < Prelexer::dimension, Prelexer::end_of_file >(VAR_38) != 0) {
VAR_1 = Parser::lexed_dimension(VAR_7->pstate(), VAR_36->value());
}
}
if (String_Constant* VAR_36 = VAR_5<String_Constant>(VAR_2)) {
std::string VAR_37(VAR_36->value());
const char* VAR_38 = VAR_37.c_str();
if (Prelexer::VAR_39 < Prelexer::dimension, Prelexer::number >(VAR_38) != 0) {
VAR_2 = Parser::lexed_dimension(VAR_7->pstate(), VAR_36->value());
}
}
}
To_Value to_value(ctx);
Value_Obj VAR_40 = VAR_5<Value>(VAR_1->perform(&VAR_41));
Value_Obj VAR_42 = VAR_5<Value>(VAR_2->perform(&VAR_41));
if (VAR_35) {
std::string VAR_36("""");
VAR_36 += VAR_40->to_string(options());
if (VAR_7->op().ws_before) VAR_36 += "" "";
VAR_36 += VAR_7->separator();
if (VAR_7->op().ws_after) VAR_36 += "" "";
VAR_36 += VAR_42->to_string(options());
String_Constant* VAR_43 = SASS_MEMORY_NEW(String_Constant, VAR_7->pstate(), VAR_36);
VAR_43->is_interpolant(VAR_7->left()->has_interpolant());
return VAR_43;
}
}
try {
switch(VAR_3) {
case Sass_OP::EQ:  return SASS_MEMORY_NEW(VAR_44, VAR_7->pstate(), Operators::eq(VAR_1, VAR_2));
case Sass_OP::NEQ: return SASS_MEMORY_NEW(VAR_44, VAR_7->pstate(), Operators::neq(VAR_1, VAR_2));
case Sass_OP::GT:  return SASS_MEMORY_NEW(VAR_44, VAR_7->pstate(), Operators::gt(VAR_1, VAR_2));
case Sass_OP::GTE: return SASS_MEMORY_NEW(VAR_44, VAR_7->pstate(), Operators::gte(VAR_1, VAR_2));
case Sass_OP::LT:  return SASS_MEMORY_NEW(VAR_44, VAR_7->pstate(), Operators::lt(VAR_1, VAR_2));
case Sass_OP::LTE: return SASS_MEMORY_NEW(VAR_44, VAR_7->pstate(), Operators::lte(VAR_1, VAR_2));
default: break;
}
}
catch (Exception::OperationError& VAR_15)
{
VAR_16.push_back(Backtrace(VAR_7->pstate()));
throw Exception::SassValueError(VAR_16, VAR_7->pstate(), VAR_15);
}
VAR_28 = VAR_1->concrete_type();
VAR_29 = VAR_2->concrete_type();
Expression_Obj VAR_45;
try {
ParserState VAR_46(VAR_7->pstate());
if (VAR_28 == Expression::NUMBER && VAR_29 == Expression::NUMBER) {
Number* VAR_11 = VAR_5<Number>(VAR_1);
Number* VAR_12 = VAR_5<Number>(VAR_2);
VAR_11->reduce(); VAR_12->reduce();
VAR_45 = Operators::op_numbers(VAR_3, *VAR_11, *VAR_12, options(), VAR_46);
}
else if (VAR_28 == Expression::NUMBER && VAR_29 == Expression::COLOR) {
Number* VAR_11 = VAR_5<Number>(VAR_1);
Color_RGBA_Obj VAR_18 = VAR_5<Color>(VAR_2)->toRGBA();
VAR_45 = Operators::op_number_color(VAR_3, *VAR_11, *VAR_18, options(), VAR_46);
}
else if (VAR_28 == Expression::COLOR && VAR_29 == Expression::NUMBER) {
Color_RGBA_Obj VAR_20 = VAR_5<Color>(VAR_1)->toRGBA();
Number* VAR_12 = VAR_5<Number>(VAR_2);
VAR_45 = Operators::op_color_number(VAR_3, *VAR_20, *VAR_12, options(), VAR_46);
}
else if (VAR_28 == Expression::COLOR && VAR_29 == Expression::COLOR) {
Color_RGBA_Obj VAR_20 = VAR_5<Color>(VAR_1)->toRGBA();
Color_RGBA_Obj VAR_18 = VAR_5<Color>(VAR_2)->toRGBA();
VAR_45 = Operators::op_colors(VAR_3, *VAR_20, *VAR_18, options(), VAR_46);
}
else {
To_Value to_value(ctx);
Value_Obj VAR_40 = VAR_5<Value>(VAR_1->perform(&VAR_41));
Value_Obj VAR_42 = VAR_5<Value>(VAR_2->perform(&VAR_41));
bool VAR_47 = VAR_7->is_right_interpolant() ||
VAR_7->is_left_interpolant() ||
VAR_7->is_interpolant();
if (VAR_3 == Sass_OP::SUB) VAR_47 = false;
if (VAR_28 == Expression::MAP || VAR_28 == Expression::FUNCTION_VAL) {
VAR_16.push_back(Backtrace(VAR_40->pstate()));
throw Exception::InvalidValue(VAR_16, *VAR_40);
}
if (VAR_29 == Expression::MAP || VAR_28 == Expression::FUNCTION_VAL) {
VAR_16.push_back(Backtrace(VAR_42->pstate()));
throw Exception::InvalidValue(VAR_16, *VAR_42);
}
Value* VAR_48 = Operators::op_strings(VAR_7->op(), *VAR_40, *VAR_42, options(), VAR_46, !VAR_47); 
if (String_Constant* VAR_36 = VAR_5<String_Constant>(VAR_48))
{
if (VAR_36->concrete_type() == Expression::STRING)
{
String_Constant* VAR_49 = VAR_5<String_Constant>(VAR_1);
String_Constant* VAR_50 = VAR_5<String_Constant>(VAR_2);
if (VAR_3 != Sass_OP::SUB) {
if (String_Constant* VAR_51 = VAR_49 ? VAR_49 : VAR_50)
{ VAR_36->quote_mark(VAR_51->quote_mark()); }
}
}
}
VAR_48->is_interpolant(VAR_7->is_interpolant());
VAR_45 = VAR_48;
}
}
catch (Exception::OperationError& VAR_15)
{
VAR_16.push_back(Backtrace(VAR_7->pstate()));
throw Exception::SassValueError(VAR_16, VAR_7->pstate(), VAR_15);
}
if (VAR_45) {
if (VAR_34) {
(*VAR_31)[0] = VAR_45;
VAR_45 = VAR_31->perform(this);
}
}
return VAR_45.detach();
}",sass/libsass/d2390e54c4f1ab5c33a0e35e7b9264b36284fa91/eval.cpp/vul/before/0.json,"Expression* Eval::operator()(Binary_Expression* b_in)
  {

    Expression_Obj lhs = b_in->left();
    Expression_Obj rhs = b_in->right();
    enum Sass_OP op_type = b_in->optype();

    if (op_type == Sass_OP::AND) {
      // LOCAL_FLAG(force, true);
      lhs = lhs->perform(this);
      if (!*lhs) return lhs.detach();
      return rhs->perform(this);
    }
    else if (op_type == Sass_OP::OR) {
      // LOCAL_FLAG(force, true);
      lhs = lhs->perform(this);
      if (*lhs) return lhs.detach();
      return rhs->perform(this);
    }

    // Evaluate variables as early o
    while (Variable* l_v = Cast<Variable>(lhs)) {
      lhs = operator()(l_v);
    }
    while (Variable* r_v = Cast<Variable>(rhs)) {
      rhs = operator()(r_v);
    }

    Binary_Expression_Obj b = b_in;

    // Evaluate sub-expressions early on
    while (Binary_Expression* l_b = Cast<Binary_Expression>(lhs)) {
      if (!force && l_b->is_delayed()) break;
      lhs = operator()(l_b);
    }
    while (Binary_Expression* r_b = Cast<Binary_Expression>(rhs)) {
      if (!force && r_b->is_delayed()) break;
      rhs = operator()(r_b);
    }

    // don't eval delayed expressions (the '/' when used as a separator)
    if (!force && op_type == Sass_OP::DIV && b->is_delayed()) {
      b->right(b->right()->perform(this));
      b->left(b->left()->perform(this));
      return b.detach();
    }

    // specific types we know are final
    // handle them early to avoid overhead
    if (Number* l_n = Cast<Number>(lhs)) {
      // lhs is number and rhs is number
      if (Number* r_n = Cast<Number>(rhs)) {
        try {
          switch (op_type) {
            case Sass_OP::EQ: return *l_n == *r_n ? bool_true : bool_false;
            case Sass_OP::NEQ: return *l_n == *r_n ? bool_false : bool_true;
            case Sass_OP::LT: return *l_n < *r_n ? bool_true : bool_false;
            case Sass_OP::GTE: return *l_n < *r_n ? bool_false : bool_true;
            case Sass_OP::LTE: return *l_n < *r_n || *l_n == *r_n ? bool_true : bool_false;
            case Sass_OP::GT: return *l_n < *r_n || *l_n == *r_n ? bool_false : bool_true;
            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:
              return Operators::op_numbers(op_type, *l_n, *r_n, options(), b_in->pstate());
            default: break;
          }
        }
        catch (Exception::OperationError& err)
        {
          traces.push_back(Backtrace(b_in->pstate()));
          throw Exception::SassValueError(traces, b_in->pstate(), err);
        }
      }
      // lhs is number and rhs is color
      // Todo: allow to work with HSLA colors
      else if (Color* r_col = Cast<Color>(rhs)) {
        Color_RGBA_Obj r_c = r_col->toRGBA();
        try {
          switch (op_type) {
            case Sass_OP::EQ: return *l_n == *r_c ? bool_true : bool_false;
            case Sass_OP::NEQ: return *l_n == *r_c ? bool_false : bool_true;
            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:
              return Operators::op_number_color(op_type, *l_n, *r_c, options(), b_in->pstate());
            default: break;
          }
        }
        catch (Exception::OperationError& err)
        {
          traces.push_back(Backtrace(b_in->pstate()));
          throw Exception::SassValueError(traces, b_in->pstate(), err);
        }
      }
    }
    else if (Color* l_col = Cast<Color>(lhs)) {
      Color_RGBA_Obj l_c = l_col->toRGBA();
      // lhs is color and rhs is color
      if (Color* r_col = Cast<Color>(rhs)) {
        Color_RGBA_Obj r_c = r_col->toRGBA();
        try {
          switch (op_type) {
            case Sass_OP::EQ: return *l_c == *r_c ? bool_true : bool_false;
            case Sass_OP::NEQ: return *l_c == *r_c ? bool_false : bool_true;
            case Sass_OP::LT: return *l_c < *r_c ? bool_true : bool_false;
            case Sass_OP::GTE: return *l_c < *r_c ? bool_false : bool_true;
            case Sass_OP::LTE: return *l_c < *r_c || *l_c == *r_c ? bool_true : bool_false;
            case Sass_OP::GT: return *l_c < *r_c || *l_c == *r_c ? bool_false : bool_true;
            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:
              return Operators::op_colors(op_type, *l_c, *r_c, options(), b_in->pstate());
            default: break;
          }
        }
        catch (Exception::OperationError& err)
        {
          traces.push_back(Backtrace(b_in->pstate()));
          throw Exception::SassValueError(traces, b_in->pstate(), err);
        }
      }
      // lhs is color and rhs is number
      else if (Number* r_n = Cast<Number>(rhs)) {
        try {
          switch (op_type) {
            case Sass_OP::EQ: return *l_c == *r_n ? bool_true : bool_false;
            case Sass_OP::NEQ: return *l_c == *r_n ? bool_false : bool_true;
            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:
              return Operators::op_color_number(op_type, *l_c, *r_n, options(), b_in->pstate());
            default: break;
          }
        }
        catch (Exception::OperationError& err)
        {
          traces.push_back(Backtrace(b_in->pstate()));
          throw Exception::SassValueError(traces, b_in->pstate(), err);
        }
      }
    }

    String_Schema_Obj ret_schema;

    // only the last item will be used to eval the binary expression
    if (String_Schema* s_l = Cast<String_Schema>(b->left())) {
      if (!s_l->has_interpolant() && (!s_l->is_right_interpolant())) {
        ret_schema = SASS_MEMORY_NEW(String_Schema, b->pstate());
        Binary_Expression_Obj bin_ex = SASS_MEMORY_NEW(Binary_Expression, b->pstate(),
                                                    b->op(), s_l->last(), b->right());
        bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed()); // unverified
        for (size_t i = 0; i < s_l->length() - 1; ++i) {
          ret_schema->append(s_l->at(i)->perform(this));
        }
        ret_schema->append(bin_ex->perform(this));
        return ret_schema->perform(this);
      }
    }
    if (String_Schema* s_r = Cast<String_Schema>(b->right())) {

      if (!s_r->has_interpolant() && (!s_r->is_left_interpolant() || op_type == Sass_OP::DIV)) {
        ret_schema = SASS_MEMORY_NEW(String_Schema, b->pstate());
        Binary_Expression_Obj bin_ex = SASS_MEMORY_NEW(Binary_Expression, b->pstate(),
                                                    b->op(), b->left(), s_r->first());
        bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed()); // verified
        ret_schema->append(bin_ex->perform(this));
        for (size_t i = 1; i < s_r->length(); ++i) {
          ret_schema->append(s_r->at(i)->perform(this));
        }
        return ret_schema->perform(this);
      }
    }

    // fully evaluate their values
    if (op_type == Sass_OP::EQ ||
        op_type == Sass_OP::NEQ ||
        op_type == Sass_OP::GT ||
        op_type == Sass_OP::GTE ||
        op_type == Sass_OP::LT ||
        op_type == Sass_OP::LTE)
    {
      LOCAL_FLAG(force, true);
      lhs->is_expanded(false);
      lhs->set_delayed(false);
      lhs = lhs->perform(this);
      rhs->is_expanded(false);
      rhs->set_delayed(false);
      rhs = rhs->perform(this);
    }
    else {
      lhs = lhs->perform(this);
    }

    // not a logical connective, so go ahead and eval the rhs
    rhs = rhs->perform(this);
    AST_Node_Obj lu = lhs;
    AST_Node_Obj ru = rhs;

    Expression::Type l_type;
    Expression::Type r_type;

    // Is one of the operands an interpolant?
    String_Schema_Obj s1 = Cast<String_Schema>(b->left());
    String_Schema_Obj s2 = Cast<String_Schema>(b->right());
    Binary_Expression_Obj b1 = Cast<Binary_Expression>(b->left());
    Binary_Expression_Obj b2 = Cast<Binary_Expression>(b->right());

    bool schema_op = false;

    bool force_delay = (s2 && s2->is_left_interpolant()) ||
                       (s1 && s1->is_right_interpolant()) ||
                       (b1 && b1->is_right_interpolant()) ||
                       (b2 && b2->is_left_interpolant());

    if ((s1 && s1->has_interpolants()) || (s2 && s2->has_interpolants()) || force_delay)
    {
      if (op_type == Sass_OP::DIV || op_type == Sass_OP::MUL || op_type == Sass_OP::MOD || op_type == Sass_OP::ADD || op_type == Sass_OP::SUB ||
          op_type == Sass_OP::EQ) {
        // If possible upgrade LHS to a number (for number to string compare)
        if (String_Constant* str = Cast<String_Constant>(lhs)) {
          std::string value(str->value());
          const char* start = value.c_str();
          if (Prelexer::sequence < Prelexer::dimension, Prelexer::end_of_file >(start) != 0) {
            lhs = Parser::lexed_dimension(b->pstate(), str->value());
          }
        }
        // If possible upgrade RHS to a number (for string to number compare)
        if (String_Constant* str = Cast<String_Constant>(rhs)) {
          std::string value(str->value());
          const char* start = value.c_str();
          if (Prelexer::sequence < Prelexer::dimension, Prelexer::number >(start) != 0) {
            rhs = Parser::lexed_dimension(b->pstate(), str->value());
          }
        }
      }

      To_Value to_value(ctx);
      Value_Obj v_l = Cast<Value>(lhs->perform(&to_value));
      Value_Obj v_r = Cast<Value>(rhs->perform(&to_value));

      if (force_delay) {
        std::string str("""");
        str += v_l->to_string(options());
        if (b->op().ws_before) str += "" "";
        str += b->separator();
        if (b->op().ws_after) str += "" "";
        str += v_r->to_string(options());
        String_Constant* val = SASS_MEMORY_NEW(String_Constant, b->pstate(), str);
        val->is_interpolant(b->left()->has_interpolant());
        return val;
      }
    }

    // see if it's a relational expression
    try {
      switch(op_type) {
        case Sass_OP::EQ:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::eq(lhs, rhs));
        case Sass_OP::NEQ: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::neq(lhs, rhs));
        case Sass_OP::GT:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::gt(lhs, rhs));
        case Sass_OP::GTE: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::gte(lhs, rhs));
        case Sass_OP::LT:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::lt(lhs, rhs));
        case Sass_OP::LTE: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::lte(lhs, rhs));
        default: break;
      }
    }
    catch (Exception::OperationError& err)
    {
      traces.push_back(Backtrace(b->pstate()));
      throw Exception::SassValueError(traces, b->pstate(), err);
    }

    l_type = lhs->concrete_type();
    r_type = rhs->concrete_type();

    // ToDo: throw error in op functions
    // ToDo: then catch and re-throw them
    Expression_Obj rv;
    try {
      ParserState pstate(b->pstate());
      if (l_type == Expression::NUMBER && r_type == Expression::NUMBER) {
        Number* l_n = Cast<Number>(lhs);
        Number* r_n = Cast<Number>(rhs);
        l_n->reduce(); r_n->reduce();
        rv = Operators::op_numbers(op_type, *l_n, *r_n, options(), pstate);
      }
      else if (l_type == Expression::NUMBER && r_type == Expression::COLOR) {
        Number* l_n = Cast<Number>(lhs);
        Color_RGBA_Obj r_c = Cast<Color>(rhs)->toRGBA();
        rv = Operators::op_number_color(op_type, *l_n, *r_c, options(), pstate);
      }
      else if (l_type == Expression::COLOR && r_type == Expression::NUMBER) {
        Color_RGBA_Obj l_c = Cast<Color>(lhs)->toRGBA();
        Number* r_n = Cast<Number>(rhs);
        rv = Operators::op_color_number(op_type, *l_c, *r_n, options(), pstate);
      }
      else if (l_type == Expression::COLOR && r_type == Expression::COLOR) {
        Color_RGBA_Obj l_c = Cast<Color>(lhs)->toRGBA();
        Color_RGBA_Obj r_c = Cast<Color>(rhs)->toRGBA();
        rv = Operators::op_colors(op_type, *l_c, *r_c, options(), pstate);
      }
      else {
        To_Value to_value(ctx);
        // this will leak if perform does not return a value!
        Value_Obj v_l = Cast<Value>(lhs->perform(&to_value));
        Value_Obj v_r = Cast<Value>(rhs->perform(&to_value));
        bool interpolant = b->is_right_interpolant() ||
                           b->is_left_interpolant() ||
                           b->is_interpolant();
        if (op_type == Sass_OP::SUB) interpolant = false;
        // if (op_type == Sass_OP::DIV) interpolant = true;
        // check for type violations
        if (l_type == Expression::MAP || l_type == Expression::FUNCTION_VAL) {
          traces.push_back(Backtrace(v_l->pstate()));
          throw Exception::InvalidValue(traces, *v_l);
        }
        if (r_type == Expression::MAP || l_type == Expression::FUNCTION_VAL) {
          traces.push_back(Backtrace(v_r->pstate()));
          throw Exception::InvalidValue(traces, *v_r);
        }
        Value* ex = Operators::op_strings(b->op(), *v_l, *v_r, options(), pstate, !interpolant); // pass true to compress
        if (String_Constant* str = Cast<String_Constant>(ex))
        {
          if (str->concrete_type() == Expression::STRING)
          {
            String_Constant* lstr = Cast<String_Constant>(lhs);
            String_Constant* rstr = Cast<String_Constant>(rhs);
            if (op_type != Sass_OP::SUB) {
              if (String_Constant* org = lstr ? lstr : rstr)
              { str->quote_mark(org->quote_mark()); }
            }
          }
        }
        ex->is_interpolant(b->is_interpolant());
        rv = ex;
      }
    }
    catch (Exception::OperationError& err)
    {
      traces.push_back(Backtrace(b->pstate()));
      // throw Exception::Base(b->pstate(), err.what());
      throw Exception::SassValueError(traces, b->pstate(), err);
    }

    if (rv) {
      if (schema_op) {
        // XXX: this is never hit via spec tests
        (*s2)[0] = rv;
        rv = s2->perform(this);
      }
    }

    return rv.detach();

  }","Expression* Eval::operator()(Binary_Expression* VAR_0)
  {

    Expression_Obj VAR_1 = VAR_0->left();
    Expression_Obj VAR_2 = VAR_0->right();
    enum Sass_OP VAR_3 = VAR_0->optype();

    if (VAR_3 == Sass_OP::AND) {
      /* COMMENT_0 */
      VAR_1 = VAR_1->perform(this);
      if (!*VAR_1) return VAR_1.detach();
      return VAR_2->perform(this);
    }
    else if (VAR_3 == Sass_OP::OR) {
      /* COMMENT_0 */
      VAR_1 = VAR_1->perform(this);
      if (*VAR_1) return VAR_1.detach();
      return VAR_2->perform(this);
    }

    /* COMMENT_1 */
    while (Variable* VAR_4 = VAR_5<Variable>(VAR_1)) {
      VAR_1 = operator()(VAR_4);
    }
    while (Variable* VAR_6 = VAR_5<Variable>(VAR_2)) {
      VAR_2 = operator()(VAR_6);
    }

    Binary_Expression_Obj VAR_7 = VAR_0;

    /* COMMENT_2 */
    while (Binary_Expression* VAR_8 = VAR_5<Binary_Expression>(VAR_1)) {
      if (!VAR_9 && VAR_8->is_delayed()) break;
      VAR_1 = operator()(VAR_8);
    }
    while (Binary_Expression* VAR_10 = VAR_5<Binary_Expression>(VAR_2)) {
      if (!VAR_9 && VAR_10->is_delayed()) break;
      VAR_2 = operator()(VAR_10);
    }

    /* COMMENT_3 */
    if (!VAR_9 && VAR_3 == Sass_OP::DIV && VAR_7->is_delayed()) {
      VAR_7->right(VAR_7->right()->perform(this));
      VAR_7->left(VAR_7->left()->perform(this));
      return VAR_7.detach();
    }

    /* COMMENT_4 */
    /* COMMENT_5 */
    if (Number* VAR_11 = VAR_5<Number>(VAR_1)) {
      /* COMMENT_6 */
      if (Number* VAR_12 = VAR_5<Number>(VAR_2)) {
        try {
          switch (VAR_3) {
            case Sass_OP::EQ: return *VAR_11 == *VAR_12 ? VAR_13 : VAR_14;
            case Sass_OP::NEQ: return *VAR_11 == *VAR_12 ? VAR_14 : VAR_13;
            case Sass_OP::LT: return *VAR_11 < *VAR_12 ? VAR_13 : VAR_14;
            case Sass_OP::GTE: return *VAR_11 < *VAR_12 ? VAR_14 : VAR_13;
            case Sass_OP::LTE: return *VAR_11 < *VAR_12 || *VAR_11 == *VAR_12 ? VAR_13 : VAR_14;
            case Sass_OP::GT: return *VAR_11 < *VAR_12 || *VAR_11 == *VAR_12 ? VAR_14 : VAR_13;
            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:
              return Operators::op_numbers(VAR_3, *VAR_11, *VAR_12, options(), VAR_0->pstate());
            default: break;
          }
        }
        catch (Exception::OperationError& VAR_15)
        {
          VAR_16.push_back(Backtrace(VAR_0->pstate()));
          throw Exception::SassValueError(VAR_16, VAR_0->pstate(), VAR_15);
        }
      }
      /* COMMENT_7 */
      /* COMMENT_8 */
      else if (Color* VAR_17 = VAR_5<Color>(VAR_2)) {
        Color_RGBA_Obj VAR_18 = VAR_17->toRGBA();
        try {
          switch (VAR_3) {
            case Sass_OP::EQ: return *VAR_11 == *VAR_18 ? VAR_13 : VAR_14;
            case Sass_OP::NEQ: return *VAR_11 == *VAR_18 ? VAR_14 : VAR_13;
            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:
              return Operators::op_number_color(VAR_3, *VAR_11, *VAR_18, options(), VAR_0->pstate());
            default: break;
          }
        }
        catch (Exception::OperationError& VAR_15)
        {
          VAR_16.push_back(Backtrace(VAR_0->pstate()));
          throw Exception::SassValueError(VAR_16, VAR_0->pstate(), VAR_15);
        }
      }
    }
    else if (Color* VAR_19 = VAR_5<Color>(VAR_1)) {
      Color_RGBA_Obj VAR_20 = VAR_19->toRGBA();
      /* COMMENT_9 */
      if (Color* VAR_17 = VAR_5<Color>(VAR_2)) {
        Color_RGBA_Obj VAR_18 = VAR_17->toRGBA();
        try {
          switch (VAR_3) {
            case Sass_OP::EQ: return *VAR_20 == *VAR_18 ? VAR_13 : VAR_14;
            case Sass_OP::NEQ: return *VAR_20 == *VAR_18 ? VAR_14 : VAR_13;
            case Sass_OP::LT: return *VAR_20 < *VAR_18 ? VAR_13 : VAR_14;
            case Sass_OP::GTE: return *VAR_20 < *VAR_18 ? VAR_14 : VAR_13;
            case Sass_OP::LTE: return *VAR_20 < *VAR_18 || *VAR_20 == *VAR_18 ? VAR_13 : VAR_14;
            case Sass_OP::GT: return *VAR_20 < *VAR_18 || *VAR_20 == *VAR_18 ? VAR_14 : VAR_13;
            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:
              return Operators::op_colors(VAR_3, *VAR_20, *VAR_18, options(), VAR_0->pstate());
            default: break;
          }
        }
        catch (Exception::OperationError& VAR_15)
        {
          VAR_16.push_back(Backtrace(VAR_0->pstate()));
          throw Exception::SassValueError(VAR_16, VAR_0->pstate(), VAR_15);
        }
      }
      /* COMMENT_10 */
      else if (Number* VAR_12 = VAR_5<Number>(VAR_2)) {
        try {
          switch (VAR_3) {
            case Sass_OP::EQ: return *VAR_20 == *VAR_12 ? VAR_13 : VAR_14;
            case Sass_OP::NEQ: return *VAR_20 == *VAR_12 ? VAR_14 : VAR_13;
            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:
              return Operators::op_color_number(VAR_3, *VAR_20, *VAR_12, options(), VAR_0->pstate());
            default: break;
          }
        }
        catch (Exception::OperationError& VAR_15)
        {
          VAR_16.push_back(Backtrace(VAR_0->pstate()));
          throw Exception::SassValueError(VAR_16, VAR_0->pstate(), VAR_15);
        }
      }
    }

    String_Schema_Obj VAR_21;

    /* COMMENT_11 */
    if (String_Schema* VAR_22 = VAR_5<String_Schema>(VAR_7->left())) {
      if (!VAR_22->has_interpolant() && (!VAR_22->is_right_interpolant())) {
        VAR_21 = SASS_MEMORY_NEW(String_Schema, VAR_7->pstate());
        Binary_Expression_Obj VAR_23 = SASS_MEMORY_NEW(Binary_Expression, VAR_7->pstate(),
                                                    VAR_7->op(), VAR_22->last(), VAR_7->right());
        VAR_23->is_delayed(VAR_7->left()->is_delayed() || VAR_7->right()->is_delayed()); /* COMMENT_12 */
        for (size_t VAR_24 = 0; VAR_24 < VAR_22->length() - 1; ++VAR_24) {
          VAR_21->append(VAR_22->at(VAR_24)->perform(this));
        }
        VAR_21->append(VAR_23->perform(this));
        return VAR_21->perform(this);
      }
    }
    if (String_Schema* VAR_25 = VAR_5<String_Schema>(VAR_7->right())) {

      if (!VAR_25->has_interpolant() && (!VAR_25->is_left_interpolant() || VAR_3 == Sass_OP::DIV)) {
        VAR_21 = SASS_MEMORY_NEW(String_Schema, VAR_7->pstate());
        Binary_Expression_Obj VAR_23 = SASS_MEMORY_NEW(Binary_Expression, VAR_7->pstate(),
                                                    VAR_7->op(), VAR_7->left(), VAR_25->first());
        VAR_23->is_delayed(VAR_7->left()->is_delayed() || VAR_7->right()->is_delayed()); /* COMMENT_13 */
        VAR_21->append(VAR_23->perform(this));
        for (size_t VAR_24 = 1; VAR_24 < VAR_25->length(); ++VAR_24) {
          VAR_21->append(VAR_25->at(VAR_24)->perform(this));
        }
        return VAR_21->perform(this);
      }
    }

    /* COMMENT_14 */
    if (VAR_3 == Sass_OP::EQ ||
        VAR_3 == Sass_OP::NEQ ||
        VAR_3 == Sass_OP::GT ||
        VAR_3 == Sass_OP::GTE ||
        VAR_3 == Sass_OP::LT ||
        VAR_3 == Sass_OP::LTE)
    {
      LOCAL_FLAG(VAR_9, true);
      VAR_1->is_expanded(false);
      VAR_1->set_delayed(false);
      VAR_1 = VAR_1->perform(this);
      VAR_2->is_expanded(false);
      VAR_2->set_delayed(false);
      VAR_2 = VAR_2->perform(this);
    }
    else {
      VAR_1 = VAR_1->perform(this);
    }

    /* COMMENT_15 */
    VAR_2 = VAR_2->perform(this);
    AST_Node_Obj VAR_26 = VAR_1;
    AST_Node_Obj VAR_27 = VAR_2;

    Expression::Type VAR_28;
    Expression::Type VAR_29;

    /* COMMENT_16 */
    String_Schema_Obj VAR_30 = VAR_5<String_Schema>(VAR_7->left());
    String_Schema_Obj VAR_31 = VAR_5<String_Schema>(VAR_7->right());
    Binary_Expression_Obj VAR_32 = VAR_5<Binary_Expression>(VAR_7->left());
    Binary_Expression_Obj VAR_33 = VAR_5<Binary_Expression>(VAR_7->right());

    bool VAR_34 = false;

    bool VAR_35 = (VAR_31 && VAR_31->is_left_interpolant()) ||
                       (VAR_30 && VAR_30->is_right_interpolant()) ||
                       (VAR_32 && VAR_32->is_right_interpolant()) ||
                       (VAR_33 && VAR_33->is_left_interpolant());

    if ((VAR_30 && VAR_30->has_interpolants()) || (VAR_31 && VAR_31->has_interpolants()) || VAR_35)
    {
      if (VAR_3 == Sass_OP::DIV || VAR_3 == Sass_OP::MUL || VAR_3 == Sass_OP::MOD || VAR_3 == Sass_OP::ADD || VAR_3 == Sass_OP::SUB ||
          VAR_3 == Sass_OP::EQ) {
        /* COMMENT_17 */
        if (String_Constant* VAR_36 = VAR_5<String_Constant>(VAR_1)) {
          std::string VAR_37(VAR_36->value());
          const char* VAR_38 = VAR_37.c_str();
          if (Prelexer::VAR_39 < Prelexer::dimension, Prelexer::end_of_file >(VAR_38) != 0) {
            VAR_1 = Parser::lexed_dimension(VAR_7->pstate(), VAR_36->value());
          }
        }
        /* COMMENT_18 */
        if (String_Constant* VAR_36 = VAR_5<String_Constant>(VAR_2)) {
          std::string VAR_37(VAR_36->value());
          const char* VAR_38 = VAR_37.c_str();
          if (Prelexer::VAR_39 < Prelexer::dimension, Prelexer::number >(VAR_38) != 0) {
            VAR_2 = Parser::lexed_dimension(VAR_7->pstate(), VAR_36->value());
          }
        }
      }

      To_Value to_value(ctx);
      Value_Obj VAR_40 = VAR_5<Value>(VAR_1->perform(&VAR_41));
      Value_Obj VAR_42 = VAR_5<Value>(VAR_2->perform(&VAR_41));

      if (VAR_35) {
        std::string VAR_36("""");
        VAR_36 += VAR_40->to_string(options());
        if (VAR_7->op().ws_before) VAR_36 += "" "";
        VAR_36 += VAR_7->separator();
        if (VAR_7->op().ws_after) VAR_36 += "" "";
        VAR_36 += VAR_42->to_string(options());
        String_Constant* VAR_43 = SASS_MEMORY_NEW(String_Constant, VAR_7->pstate(), VAR_36);
        VAR_43->is_interpolant(VAR_7->left()->has_interpolant());
        return VAR_43;
      }
    }

    /* COMMENT_19 */
    try {
      switch(VAR_3) {
        case Sass_OP::EQ:  return SASS_MEMORY_NEW(VAR_44, VAR_7->pstate(), Operators::eq(VAR_1, VAR_2));
        case Sass_OP::NEQ: return SASS_MEMORY_NEW(VAR_44, VAR_7->pstate(), Operators::neq(VAR_1, VAR_2));
        case Sass_OP::GT:  return SASS_MEMORY_NEW(VAR_44, VAR_7->pstate(), Operators::gt(VAR_1, VAR_2));
        case Sass_OP::GTE: return SASS_MEMORY_NEW(VAR_44, VAR_7->pstate(), Operators::gte(VAR_1, VAR_2));
        case Sass_OP::LT:  return SASS_MEMORY_NEW(VAR_44, VAR_7->pstate(), Operators::lt(VAR_1, VAR_2));
        case Sass_OP::LTE: return SASS_MEMORY_NEW(VAR_44, VAR_7->pstate(), Operators::lte(VAR_1, VAR_2));
        default: break;
      }
    }
    catch (Exception::OperationError& VAR_15)
    {
      VAR_16.push_back(Backtrace(VAR_7->pstate()));
      throw Exception::SassValueError(VAR_16, VAR_7->pstate(), VAR_15);
    }

    VAR_28 = VAR_1->concrete_type();
    VAR_29 = VAR_2->concrete_type();

    /* COMMENT_20 */
    /* COMMENT_21 */
    Expression_Obj VAR_45;
    try {
      ParserState VAR_46(VAR_7->pstate());
      if (VAR_28 == Expression::NUMBER && VAR_29 == Expression::NUMBER) {
        Number* VAR_11 = VAR_5<Number>(VAR_1);
        Number* VAR_12 = VAR_5<Number>(VAR_2);
        VAR_11->reduce(); VAR_12->reduce();
        VAR_45 = Operators::op_numbers(VAR_3, *VAR_11, *VAR_12, options(), VAR_46);
      }
      else if (VAR_28 == Expression::NUMBER && VAR_29 == Expression::COLOR) {
        Number* VAR_11 = VAR_5<Number>(VAR_1);
        Color_RGBA_Obj VAR_18 = VAR_5<Color>(VAR_2)->toRGBA();
        VAR_45 = Operators::op_number_color(VAR_3, *VAR_11, *VAR_18, options(), VAR_46);
      }
      else if (VAR_28 == Expression::COLOR && VAR_29 == Expression::NUMBER) {
        Color_RGBA_Obj VAR_20 = VAR_5<Color>(VAR_1)->toRGBA();
        Number* VAR_12 = VAR_5<Number>(VAR_2);
        VAR_45 = Operators::op_color_number(VAR_3, *VAR_20, *VAR_12, options(), VAR_46);
      }
      else if (VAR_28 == Expression::COLOR && VAR_29 == Expression::COLOR) {
        Color_RGBA_Obj VAR_20 = VAR_5<Color>(VAR_1)->toRGBA();
        Color_RGBA_Obj VAR_18 = VAR_5<Color>(VAR_2)->toRGBA();
        VAR_45 = Operators::op_colors(VAR_3, *VAR_20, *VAR_18, options(), VAR_46);
      }
      else {
        To_Value to_value(ctx);
        /* COMMENT_22 */
        Value_Obj VAR_40 = VAR_5<Value>(VAR_1->perform(&VAR_41));
        Value_Obj VAR_42 = VAR_5<Value>(VAR_2->perform(&VAR_41));
        bool VAR_47 = VAR_7->is_right_interpolant() ||
                           VAR_7->is_left_interpolant() ||
                           VAR_7->is_interpolant();
        if (VAR_3 == Sass_OP::SUB) VAR_47 = false;
        /* COMMENT_23 */
        /* COMMENT_24 */
        if (VAR_28 == Expression::MAP || VAR_28 == Expression::FUNCTION_VAL) {
          VAR_16.push_back(Backtrace(VAR_40->pstate()));
          throw Exception::InvalidValue(VAR_16, *VAR_40);
        }
        if (VAR_29 == Expression::MAP || VAR_28 == Expression::FUNCTION_VAL) {
          VAR_16.push_back(Backtrace(VAR_42->pstate()));
          throw Exception::InvalidValue(VAR_16, *VAR_42);
        }
        Value* VAR_48 = Operators::op_strings(VAR_7->op(), *VAR_40, *VAR_42, options(), VAR_46, !VAR_47); /* COMMENT_25 */
        if (String_Constant* VAR_36 = VAR_5<String_Constant>(VAR_48))
        {
          if (VAR_36->concrete_type() == Expression::STRING)
          {
            String_Constant* VAR_49 = VAR_5<String_Constant>(VAR_1);
            String_Constant* VAR_50 = VAR_5<String_Constant>(VAR_2);
            if (VAR_3 != Sass_OP::SUB) {
              if (String_Constant* VAR_51 = VAR_49 ? VAR_49 : VAR_50)
              { VAR_36->quote_mark(VAR_51->quote_mark()); }
            }
          }
        }
        VAR_48->is_interpolant(VAR_7->is_interpolant());
        VAR_45 = VAR_48;
      }
    }
    catch (Exception::OperationError& VAR_15)
    {
      VAR_16.push_back(Backtrace(VAR_7->pstate()));
      /* COMMENT_26 */
      throw Exception::SassValueError(VAR_16, VAR_7->pstate(), VAR_15);
    }

    if (VAR_45) {
      if (VAR_34) {
        /* COMMENT_27 */
        (*VAR_31)[0] = VAR_45;
        VAR_45 = VAR_31->perform(this);
      }
    }

    return VAR_45.detach();

  }",sass/libsass/d2390e54c4f1ab5c33a0e35e7b9264b36284fa91/eval.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -142,9 +142,9 @@
                                                     b->op(), s_l->last(), b->right());
         bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed()); // unverified
         for (size_t i = 0; i < s_l->length() - 1; ++i) {
-          ret_schema->append(Cast<PreValue>(s_l->at(i)->perform(this)));
-        }
-        ret_schema->append(Cast<PreValue>(bin_ex->perform(this)));
+          ret_schema->append(s_l->at(i)->perform(this));
+        }
+        ret_schema->append(bin_ex->perform(this));
         return ret_schema->perform(this);
       }
     }
@@ -155,9 +155,9 @@
         Binary_Expression_Obj bin_ex = SASS_MEMORY_NEW(Binary_Expression, b->pstate(),
                                                     b->op(), b->left(), s_r->first());
         bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed()); // verified
-        ret_schema->append(Cast<PreValue>(bin_ex->perform(this)));
+        ret_schema->append(bin_ex->perform(this));
         for (size_t i = 1; i < s_r->length(); ++i) {
-          ret_schema->append(Cast<PreValue>(s_r->at(i)->perform(this)));
+          ret_schema->append(s_r->at(i)->perform(this));
         }
         return ret_schema->perform(this);
       }","{'deleted_lines': ['          ret_schema->append(Cast<PreValue>(s_l->at(i)->perform(this)));', '        }', '        ret_schema->append(Cast<PreValue>(bin_ex->perform(this)));', '        ret_schema->append(Cast<PreValue>(bin_ex->perform(this)));', '          ret_schema->append(Cast<PreValue>(s_r->at(i)->perform(this)));'], 'added_lines': ['          ret_schema->append(s_l->at(i)->perform(this));', '        }', '        ret_schema->append(bin_ex->perform(this));', '        ret_schema->append(bin_ex->perform(this));', '          ret_schema->append(s_r->at(i)->perform(this));']}",True,LibSass before 3.6.3 allows a heap-based buffer over-read in Sass::weaveParents in ast_sel_weave.cpp.,6.5,MEDIUM,1,test,2019-11-02T23:41:41Z,3
CVE-2019-18798,"['CWE-476', 'CWE-125']",AV:N/AC:M/Au:N/C:N/I:N/A:P,0,sass/libsass,"Fix out of boundary vector access

Fixes https://github.com/sass/libsass/issues/3001",994695c669085058c4a500f295a0531893eff77a,https://github.com/sass/libsass/commit/994695c669085058c4a500f295a0531893eff77a,src/parser_selectors.cpp,Parser::parseCompoundSelector,"CompoundSelectorObj Parser::parseCompoundSelector()
{
CompoundSelectorObj seq = SASS_MEMORY_NEW(CompoundSelector, pstate);
lex < block_comment >();
advanceToNextToken();
if (lex< exactly<'&'> >(false))
{
if (!allow_parent) error(""Parent selectors aren't allowed here."");
seq->hasRealParent(true);
}
while (true)
{
lex < block_comment >();
if (lex< exactly<'&'> >(false))
{
ParserState state(pstate);
SimpleSelectorObj prev = (*seq)[seq->length()-1];
std::string sel(prev->to_string({ NESTED, 5 }));
std::string found(""&"");
if (lex < identifier >()) { found += std::string(lexed); }
error(""Invalid CSS after \"""" + sel + ""\"": expected \""{\"", was \"""" + found + ""\""\n\n""
""\"""" + found + ""\"" may only be used at the beginning of a compound selector."", state);
}
else if (match < re_functional >())
{
seq->append(parse_simple_selector());
}
else if (lex< re_type_selector >(false))
{
seq->append(SASS_MEMORY_NEW(Type_Selector, pstate, lexed));
}
else if (peek< spaces >()) break;
else if (peek< end_of_file >()) { break; }
else if (peek_css < class_char < selector_combinator_ops > >()) break;
else if (peek_css < class_char < complex_selector_delims > >()) break;
else {
SimpleSelectorObj sel = parse_simple_selector();
if (!sel) return {};
seq->append(sel);
}
}
if (seq && !peek_css<alternatives<end_of_file,exactly<'{'>>>()) {
seq->hasPostLineBreak(peek_newline());
}
if (seq && seq->empty() && !seq->hasRealParent()) return {};
return seq;
}","CompoundSelectorObj Parser::parseCompoundSelector()
{
CompoundSelectorObj VAR_0 = SASS_MEMORY_NEW(VAR_1, VAR_2);
VAR_3 < block_comment >();
advanceToNextToken();
if (VAR_3< exactly<'&'> >(false))
{
if (!VAR_4) error(""Parent selectors aren't allowed here."");
VAR_0->hasRealParent(true);
}
while (true)
{
VAR_3 < block_comment >();
if (VAR_3< exactly<'&'> >(false))
{
ParserState state(pstate);
SimpleSelectorObj VAR_5 = (*VAR_0)[VAR_0->length()-1];
std::string VAR_6(VAR_5->to_string({ VAR_7, 5 }));
std::string VAR_8(""&"");
if (VAR_3 < identifier >()) { VAR_8 += std::string(VAR_9); }
error(""Invalid CSS after \"""" + VAR_6 + ""\"": expected \""{\"", was \"""" + VAR_8 + ""\""\n\n""
""\"""" + VAR_8 + ""\"" may only be used at the beginning of a compound selector."", VAR_10);
}
else if (VAR_11 < re_functional >())
{
VAR_0->append(parse_simple_selector());
}
else if (VAR_3< re_type_selector >(false))
{
VAR_0->append(SASS_MEMORY_NEW(VAR_12, pstate, VAR_9));
}
else if (VAR_13< spaces >()) break;
else if (VAR_13< end_of_file >()) { break; }
else if (VAR_14 < class_char < selector_combinator_ops > >()) break;
else if (VAR_14 < class_char < complex_selector_delims > >()) break;
else {
SimpleSelectorObj VAR_6 = parse_simple_selector();
if (!VAR_6) return {};
VAR_0->append(VAR_6);
}
}
if (VAR_0 && !VAR_14<alternatives<end_of_file,exactly<'{'>>>()) {
VAR_0->hasPostLineBreak(peek_newline());
}
if (VAR_0 && VAR_0->empty() && !VAR_0->hasRealParent()) return {};
return VAR_0;
}",sass/libsass/994695c669085058c4a500f295a0531893eff77a/parser_selectors.cpp/vul/before/0.json,"CompoundSelectorObj Parser::parseCompoundSelector()
  {
    // init an empty compound selector wrapper
    CompoundSelectorObj seq = SASS_MEMORY_NEW(CompoundSelector, pstate);

    // skip initial white-space
    lex < block_comment >();
    advanceToNextToken();

    if (lex< exactly<'&'> >(false))
    {
      // ToDo: check the conditions and try to simplify flag passing
      if (!allow_parent) error(""Parent selectors aren't allowed here."");
      // Create and append a new parent selector object
      seq->hasRealParent(true);
    }

    // parse list
    while (true)
    {
      // remove all block comments
      // leaves trailing white-space
      lex < block_comment >();
      // parse parent selector
      if (lex< exactly<'&'> >(false))
      {
        // parent selector only allowed at start
        // upcoming Sass may allow also trailing
        ParserState state(pstate);
        std::string found(""&"");
        if (lex < identifier >()) {
          found += std::string(lexed);
        }
        std::string sel(seq->hasRealParent() ? ""&"" : """");
        if (!seq->empty()) { sel = seq->last()->to_string({ NESTED, 5 }); }
        // ToDo: parser should throw parser exceptions
        error(""Invalid CSS after \"""" + sel + ""\"": expected \""{\"", was \"""" + found + ""\""\n\n""
          ""\"""" + found + ""\"" may only be used at the beginning of a compound selector."", state);
      }
      // parse functional
      else if (match < re_functional >())
        {
          seq->append(parse_simple_selector());
        }

      // parse type selector
      else if (lex< re_type_selector >(false))
      {
        seq->append(SASS_MEMORY_NEW(Type_Selector, pstate, lexed));
      }
      // peek for abort conditions
      else if (peek< spaces >()) break;
      else if (peek< end_of_file >()) { break; }
      else if (peek_css < class_char < selector_combinator_ops > >()) break;
      else if (peek_css < class_char < complex_selector_delims > >()) break;
      // otherwise parse another simple selector
      else {
        SimpleSelectorObj sel = parse_simple_selector();
        if (!sel) return {};
        seq->append(sel);
      }
    }
    // EO while true

    if (seq && !peek_css<alternatives<end_of_file,exactly<'{'>>>()) {
      seq->hasPostLineBreak(peek_newline());
    }

    // We may have set hasRealParent
    if (seq && seq->empty() && !seq->hasRealParent()) return {};

    return seq;
  }","CompoundSelectorObj Parser::parseCompoundSelector()
  {
    /* COMMENT_0 */
    CompoundSelectorObj VAR_0 = SASS_MEMORY_NEW(VAR_1, VAR_2);

    /* COMMENT_1 */
    VAR_3 < block_comment >();
    advanceToNextToken();

    if (VAR_3< exactly<'&'> >(false))
    {
      /* COMMENT_2 */
      if (!VAR_4) error(""Parent selectors aren't allowed here."");
      /* COMMENT_3 */
      VAR_0->hasRealParent(true);
    }

    /* COMMENT_4 */
    while (true)
    {
      /* COMMENT_5 */
      /* COMMENT_6 */
      VAR_3 < block_comment >();
      /* COMMENT_7 */
      if (VAR_3< exactly<'&'> >(false))
      {
        /* COMMENT_8 */
        /* COMMENT_9 */
        ParserState state(pstate);
        std::string VAR_5(""&"");
        if (VAR_3 < identifier >()) {
          VAR_5 += std::string(VAR_6);
        }
        std::string VAR_7(VAR_0->hasRealParent() ? ""&"" : """");
        if (!VAR_0->empty()) { VAR_7 = VAR_0->last()->to_string({ VAR_8, 5 }); }
        /* COMMENT_10 */
        error(""Invalid CSS after \"""" + VAR_7 + ""\"": expected \""{\"", was \"""" + VAR_5 + ""\""\n\n""
          ""\"""" + VAR_5 + ""\"" may only be used at the beginning of a compound selector."", VAR_9);
      }
      /* COMMENT_11 */
      else if (VAR_10 < re_functional >())
        {
          VAR_0->append(parse_simple_selector());
        }

      /* COMMENT_12 */
      else if (VAR_3< re_type_selector >(false))
      {
        VAR_0->append(SASS_MEMORY_NEW(VAR_11, pstate, VAR_6));
      }
      /* COMMENT_13 */
      else if (VAR_12< spaces >()) break;
      else if (VAR_12< end_of_file >()) { break; }
      else if (VAR_13 < class_char < selector_combinator_ops > >()) break;
      else if (VAR_13 < class_char < complex_selector_delims > >()) break;
      /* COMMENT_14 */
      else {
        SimpleSelectorObj VAR_7 = parse_simple_selector();
        if (!VAR_7) return {};
        VAR_0->append(VAR_7);
      }
    }
    /* COMMENT_15 */

    if (VAR_0 && !VAR_13<alternatives<end_of_file,exactly<'{'>>>()) {
      VAR_0->hasPostLineBreak(peek_newline());
    }

    /* COMMENT_16 */
    if (VAR_0 && VAR_0->empty() && !VAR_0->hasRealParent()) return {};

    return VAR_0;
  }",sass/libsass/994695c669085058c4a500f295a0531893eff77a/parser_selectors.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -27,10 +27,12 @@
         // parent selector only allowed at start
         // upcoming Sass may allow also trailing
         ParserState state(pstate);
-        SimpleSelectorObj prev = (*seq)[seq->length()-1];
-        std::string sel(prev->to_string({ NESTED, 5 }));
         std::string found(""&"");
-        if (lex < identifier >()) { found += std::string(lexed); }
+        if (lex < identifier >()) {
+          found += std::string(lexed);
+        }
+        std::string sel(seq->hasRealParent() ? ""&"" : """");
+        if (!seq->empty()) { sel = seq->last()->to_string({ NESTED, 5 }); }
         // ToDo: parser should throw parser exceptions
         error(""Invalid CSS after \"""" + sel + ""\"": expected \""{\"", was \"""" + found + ""\""\n\n""
           ""\"""" + found + ""\"" may only be used at the beginning of a compound selector."", state);","{'deleted_lines': ['        SimpleSelectorObj prev = (*seq)[seq->length()-1];', '        std::string sel(prev->to_string({ NESTED, 5 }));', '        if (lex < identifier >()) { found += std::string(lexed); }'], 'added_lines': ['        if (lex < identifier >()) {', '          found += std::string(lexed);', '        }', '        std::string sel(seq->hasRealParent() ? ""&"" : """");', '        if (!seq->empty()) { sel = seq->last()->to_string({ NESTED, 5 }); }']}",True,LibSass before 3.6.3 allows a heap-based buffer over-read in Sass::weaveParents in ast_sel_weave.cpp.,6.5,MEDIUM,1,test,2019-11-02T23:42:10Z,3
CVE-2019-18798,"['CWE-476', 'CWE-125']",AV:N/AC:M/Au:N/C:N/I:N/A:P,0,sass/libsass,"Fix out of boundary vector access

Fixes https://github.com/sass/libsass/issues/2999",0b721e0f37fc69ab197ec956a923e036e3b05ca6,https://github.com/sass/libsass/commit/0b721e0f37fc69ab197ec956a923e036e3b05ca6,src/ast_sel_weave.cpp,weaveParents,"std::vector<std::vector<SelectorComponentObj>> weaveParents(
std::vector<SelectorComponentObj> queue1,
std::vector<SelectorComponentObj> queue2)
{
std::vector<SelectorComponentObj> leads;
std::vector<std::vector<std::vector<SelectorComponentObj>>> trails;
if (!mergeInitialCombinators(queue1, queue2, leads)) return {};
if (!mergeFinalCombinators(queue1, queue2, trails)) return {};
std::reverse(trails.begin(), trails.end());
CompoundSelectorObj root1 = getFirstIfRoot(queue1);
CompoundSelectorObj root2 = getFirstIfRoot(queue2);
if (!root1.isNull() && !root2.isNull()) {
CompoundSelectorObj root = root1->unifyWith(root2);
if (root.isNull()) return {};       queue1.insert(queue1.begin(), root);
queue2.insert(queue2.begin(), root);
}
else if (!root1.isNull()) {
queue2.insert(queue2.begin(), root1);
}
else if (!root2.isNull()) {
queue1.insert(queue1.begin(), root2);
}
std::vector<std::vector<SelectorComponentObj>> groups1 = groupSelectors(queue1);
std::vector<std::vector<SelectorComponentObj>> groups2 = groupSelectors(queue2);
std::vector<std::vector<std::vector<SelectorComponentObj>>> choices;
choices.push_back({ leads });
std::vector<std::vector<SelectorComponentObj>> LCS =
lcs<std::vector<SelectorComponentObj>>(groups1, groups2, cmpGroups);
for (auto group : LCS) {
std::vector<std::vector<std::vector<SelectorComponentObj>>>
chunks = getChunks<std::vector<SelectorComponentObj>>(
groups1, groups2, group, cmpChunkForParentSuperselector);
std::vector<std::vector<SelectorComponentObj>>
expanded = flattenInner(chunks);
choices.push_back(expanded);
choices.push_back({ group });
groups1.erase(groups1.begin());
groups2.erase(groups2.begin());
}
std::vector<std::vector<std::vector<SelectorComponentObj>>>
chunks = getChunks<std::vector<SelectorComponentObj>>(
groups1, groups2, {}, cmpChunkForEmptySequence);
choices.emplace_back(flattenInner(chunks));
std::move(std::begin(trails), std::end(trails),
std::inserter(choices, std::end(choices)));
choices.erase(std::remove_if(choices.begin(), choices.end(), checkForEmptyChild
<std::vector<std::vector<SelectorComponentObj>>>), choices.end());
std::vector<std::vector<SelectorComponentObj>>
results = flattenInner(permutate(choices));
return results;
}","std::vector<std::vector<SelectorComponentObj>> weaveParents(
std::vector<SelectorComponentObj> VAR_0,
std::vector<SelectorComponentObj> VAR_1)
{
std::vector<SelectorComponentObj> VAR_2;
std::vector<std::vector<std::vector<SelectorComponentObj>>> VAR_3;
if (!mergeInitialCombinators(VAR_0, VAR_1, VAR_2)) return {};
if (!mergeFinalCombinators(VAR_0, VAR_1, VAR_3)) return {};
std::reverse(VAR_3.begin(), VAR_3.end());
CompoundSelectorObj VAR_4 = getFirstIfRoot(VAR_0);
CompoundSelectorObj VAR_5 = getFirstIfRoot(VAR_1);
if (!VAR_4.isNull() && !VAR_5.isNull()) {
CompoundSelectorObj VAR_6 = VAR_4->unifyWith(VAR_5);
if (VAR_6.isNull()) return {}; 
VAR_0.insert(VAR_0.begin(), VAR_6);
VAR_1.insert(VAR_1.begin(), VAR_6);
}
else if (!VAR_4.isNull()) {
VAR_1.insert(VAR_1.begin(), VAR_4);
}
else if (!VAR_5.isNull()) {
VAR_0.insert(VAR_0.begin(), VAR_5);
}
std::vector<std::vector<SelectorComponentObj>> VAR_7 = groupSelectors(VAR_0);
std::vector<std::vector<SelectorComponentObj>> VAR_8 = groupSelectors(VAR_1);
std::vector<std::vector<std::vector<SelectorComponentObj>>> VAR_9;
VAR_9.push_back({ VAR_2 });
std::vector<std::vector<SelectorComponentObj>> VAR_10 =
VAR_11<std::vector<SelectorComponentObj>>(VAR_7, VAR_8, VAR_12);
for (auto VAR_13 : VAR_10) {
std::vector<std::vector<std::vector<SelectorComponentObj>>>
VAR_14 = VAR_15<std::vector<SelectorComponentObj>>(
VAR_7, VAR_8, VAR_13, VAR_16);
std::vector<std::vector<SelectorComponentObj>>
VAR_17 = flattenInner(VAR_14);
VAR_9.push_back(VAR_17);
VAR_9.push_back({ VAR_13 });
VAR_7.erase(VAR_7.begin());
VAR_8.erase(VAR_8.begin());
}
std::vector<std::vector<std::vector<SelectorComponentObj>>>
VAR_14 = VAR_15<std::vector<SelectorComponentObj>>(
VAR_7, VAR_8, {}, VAR_18);
VAR_9.emplace_back(flattenInner(VAR_14));
std::move(std::begin(VAR_3), std::end(VAR_3),
std::inserter(VAR_9, std::end(VAR_9)));
VAR_9.erase(std::remove_if(VAR_9.begin(), VAR_9.end(), VAR_19
<std::vector<std::vector<SelectorComponentObj>>>), VAR_9.end());
std::vector<std::vector<SelectorComponentObj>>
VAR_20 = flattenInner(permutate(VAR_9));
return VAR_20;
}",sass/libsass/0b721e0f37fc69ab197ec956a923e036e3b05ca6/ast_sel_weave.cpp/vul/before/0.json,"std::vector<std::vector<SelectorComponentObj>> weaveParents(
    std::vector<SelectorComponentObj> queue1,
    std::vector<SelectorComponentObj> queue2)
  {

    std::vector<SelectorComponentObj> leads;
    std::vector<std::vector<std::vector<SelectorComponentObj>>> trails;
    if (!mergeInitialCombinators(queue1, queue2, leads)) return {};
    if (!mergeFinalCombinators(queue1, queue2, trails)) return {};
    // list comes out in reverse order for performance
    std::reverse(trails.begin(), trails.end());

    // Make sure there's at most one `:root` in the output.
    // Note: does not yet do anything in libsass (no root selector)
    CompoundSelectorObj root1 = getFirstIfRoot(queue1);
    CompoundSelectorObj root2 = getFirstIfRoot(queue2);

    if (!root1.isNull() && !root2.isNull()) {
      CompoundSelectorObj root = root1->unifyWith(root2);
      if (root.isNull()) return {}; // null
      queue1.insert(queue1.begin(), root);
      queue2.insert(queue2.begin(), root);
    }
    else if (!root1.isNull()) {
      queue2.insert(queue2.begin(), root1);
    }
    else if (!root2.isNull()) {
      queue1.insert(queue1.begin(), root2);
    }

    // group into sub-lists so no sub-list contains two adjacent ComplexSelectors.
    std::vector<std::vector<SelectorComponentObj>> groups1 = groupSelectors(queue1);
    std::vector<std::vector<SelectorComponentObj>> groups2 = groupSelectors(queue2);

    // The main array to store our choices that will be permutated
    std::vector<std::vector<std::vector<SelectorComponentObj>>> choices;

    // append initial combinators
    choices.push_back({ leads });

    std::vector<std::vector<SelectorComponentObj>> LCS =
      lcs<std::vector<SelectorComponentObj>>(groups1, groups2, cmpGroups);

    for (auto group : LCS) {

      // Create junks from groups1 and groups2
      std::vector<std::vector<std::vector<SelectorComponentObj>>>
        chunks = getChunks<std::vector<SelectorComponentObj>>(
          groups1, groups2, group, cmpChunkForParentSuperselector);

      // Create expanded array by flattening chunks2 inner
      std::vector<std::vector<SelectorComponentObj>>
        expanded = flattenInner(chunks);

      // Prepare data structures
      choices.push_back(expanded);
      choices.push_back({ group });
      if (!groups1.empty()) {
        groups1.erase(groups1.begin());
      }
      if (!groups2.empty()) {
        groups2.erase(groups2.begin());
      }

    }

    // Create junks from groups1 and groups2
    std::vector<std::vector<std::vector<SelectorComponentObj>>>
      chunks = getChunks<std::vector<SelectorComponentObj>>(
        groups1, groups2, {}, cmpChunkForEmptySequence);

    // Append chunks with inner arrays flattened
    choices.emplace_back(flattenInner(chunks));

    // append all trailing selectors to choices
    std::move(std::begin(trails), std::end(trails),
      std::inserter(choices, std::end(choices)));

    // move all non empty items to the front, then erase the trailing ones
    choices.erase(std::remove_if(choices.begin(), choices.end(), checkForEmptyChild
      <std::vector<std::vector<SelectorComponentObj>>>), choices.end());

    // permutate all possible paths through selectors
    std::vector<std::vector<SelectorComponentObj>>
      results = flattenInner(permutate(choices));

    return results;

  }","std::vector<std::vector<SelectorComponentObj>> weaveParents(
    std::vector<SelectorComponentObj> VAR_0,
    std::vector<SelectorComponentObj> VAR_1)
  {

    std::vector<SelectorComponentObj> VAR_2;
    std::vector<std::vector<std::vector<SelectorComponentObj>>> VAR_3;
    if (!mergeInitialCombinators(VAR_0, VAR_1, VAR_2)) return {};
    if (!mergeFinalCombinators(VAR_0, VAR_1, VAR_3)) return {};
    /* COMMENT_0 */
    std::reverse(VAR_3.begin(), VAR_3.end());

    /* COMMENT_1 */
    /* COMMENT_2 */
    CompoundSelectorObj VAR_4 = getFirstIfRoot(VAR_0);
    CompoundSelectorObj VAR_5 = getFirstIfRoot(VAR_1);

    if (!VAR_4.isNull() && !VAR_5.isNull()) {
      CompoundSelectorObj VAR_6 = VAR_4->unifyWith(VAR_5);
      if (VAR_6.isNull()) return {}; /* COMMENT_3 */
      VAR_0.insert(VAR_0.begin(), VAR_6);
      VAR_1.insert(VAR_1.begin(), VAR_6);
    }
    else if (!VAR_4.isNull()) {
      VAR_1.insert(VAR_1.begin(), VAR_4);
    }
    else if (!VAR_5.isNull()) {
      VAR_0.insert(VAR_0.begin(), VAR_5);
    }

    /* COMMENT_4 */
    std::vector<std::vector<SelectorComponentObj>> VAR_7 = groupSelectors(VAR_0);
    std::vector<std::vector<SelectorComponentObj>> VAR_8 = groupSelectors(VAR_1);

    /* COMMENT_5 */
    std::vector<std::vector<std::vector<SelectorComponentObj>>> VAR_9;

    /* COMMENT_6 */
    VAR_9.push_back({ VAR_2 });

    std::vector<std::vector<SelectorComponentObj>> VAR_10 =
      VAR_11<std::vector<SelectorComponentObj>>(VAR_7, VAR_8, VAR_12);

    for (auto VAR_13 : VAR_10) {

      /* COMMENT_7 */
      std::vector<std::vector<std::vector<SelectorComponentObj>>>
        VAR_14 = VAR_15<std::vector<SelectorComponentObj>>(
          VAR_7, VAR_8, VAR_13, VAR_16);

      /* COMMENT_8 */
      std::vector<std::vector<SelectorComponentObj>>
        VAR_17 = flattenInner(VAR_14);

      /* COMMENT_9 */
      VAR_9.push_back(VAR_17);
      VAR_9.push_back({ VAR_13 });
      if (!VAR_7.empty()) {
        VAR_7.erase(VAR_7.begin());
      }
      if (!VAR_8.empty()) {
        VAR_8.erase(VAR_8.begin());
      }

    }

    /* COMMENT_7 */
    std::vector<std::vector<std::vector<SelectorComponentObj>>>
      VAR_14 = VAR_15<std::vector<SelectorComponentObj>>(
        VAR_7, VAR_8, {}, VAR_18);

    /* COMMENT_10 */
    VAR_9.emplace_back(flattenInner(VAR_14));

    /* COMMENT_11 */
    std::move(std::begin(VAR_3), std::end(VAR_3),
      std::inserter(VAR_9, std::end(VAR_9)));

    /* COMMENT_12 */
    VAR_9.erase(std::remove_if(VAR_9.begin(), VAR_9.end(), VAR_19
      <std::vector<std::vector<SelectorComponentObj>>>), VAR_9.end());

    /* COMMENT_13 */
    std::vector<std::vector<SelectorComponentObj>>
      VAR_20 = flattenInner(permutate(VAR_9));

    return VAR_20;

  }",sass/libsass/0b721e0f37fc69ab197ec956a923e036e3b05ca6/ast_sel_weave.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -55,8 +55,12 @@
       // Prepare data structures
       choices.push_back(expanded);
       choices.push_back({ group });
-      groups1.erase(groups1.begin());
-      groups2.erase(groups2.begin());
+      if (!groups1.empty()) {
+        groups1.erase(groups1.begin());
+      }
+      if (!groups2.empty()) {
+        groups2.erase(groups2.begin());
+      }
 
     }
 ","{'deleted_lines': ['      groups1.erase(groups1.begin());', '      groups2.erase(groups2.begin());'], 'added_lines': ['      if (!groups1.empty()) {', '        groups1.erase(groups1.begin());', '      }', '      if (!groups2.empty()) {', '        groups2.erase(groups2.begin());', '      }']}",True,LibSass before 3.6.3 allows a heap-based buffer over-read in Sass::weaveParents in ast_sel_weave.cpp.,6.5,MEDIUM,1,test,2019-11-03T00:06:18Z,3
CVE-2019-19553,['CWE-909'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"CMS: reset object_identifier_id after dissecting ContentInfo

Bug: 15961
Change-Id: I3d6b3e96103b69f88fcb512da81fa20ff6a1c40e
Reviewed-on: https://code.wireshark.org/review/34960
Petri-Dish: Pascal Quantin <pascal@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Stig Bjørlykke <stig@bjorlykke.org>
Reviewed-by: Roland Knall <rknall@gmail.com>
(cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08)
Conflicts:
	epan/dissectors/packet-cms.c
Reviewed-on: https://code.wireshark.org/review/34975
Reviewed-by: Pascal Quantin <pascal@wireshark.org>",34d2e0d5318d0a7e9889498c721639e5cbf4ce45,https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45,epan/dissectors/packet-cms.c,dissect_cms_ContentInfo,"int
dissect_cms_ContentInfo(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 97 ""./asn1/cms/cms.cnf""
top_tree = tree;
offset = dissect_ber_sequence(implicit_tag, actx, tree, tvb, offset,
ContentInfo_sequence, hf_index, ett_cms_ContentInfo);
content_tvb = NULL;
top_tree = NULL;
return offset;
}","int
dissect_cms_ContentInfo(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 97 ""./asn1/cms/cms.cnf""
VAR_6 = VAR_4;
VAR_2 = dissect_ber_sequence(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2,
VAR_7, VAR_5, VAR_8);
VAR_9 = NULL;
VAR_6 = NULL;
return VAR_2;
}",,"int
dissect_cms_ContentInfo(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 97 ""./asn1/cms/cms.cnf""
  top_tree = tree;
    offset = dissect_ber_sequence(implicit_tag, actx, tree, tvb, offset,
                                   ContentInfo_sequence, hf_index, ett_cms_ContentInfo);

  content_tvb = NULL;
  object_identifier_id = NULL;
  top_tree = NULL;



  return offset;
}","int
dissect_cms_ContentInfo(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 97 ""./asn1/cms/cms.cnf""
  VAR_6 = VAR_4;
    VAR_2 = dissect_ber_sequence(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2,
                                   VAR_7, VAR_5, VAR_8);

  VAR_9 = NULL;
  VAR_10 = NULL;
  VAR_6 = NULL;



  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -6,6 +6,7 @@
                                    ContentInfo_sequence, hf_index, ett_cms_ContentInfo);
 
   content_tvb = NULL;
+  object_identifier_id = NULL;
   top_tree = NULL;
 
 ","{'deleted_lines': [], 'added_lines': ['  object_identifier_id = NULL;']}",True,"In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",7.5,HIGH,2,test,2019-11-04T14:08:22Z,3
CVE-2019-19553,['CWE-909'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"CMS: reset object_identifier_id after dissecting ContentInfo

Bug: 15961
Change-Id: I3d6b3e96103b69f88fcb512da81fa20ff6a1c40e
Reviewed-on: https://code.wireshark.org/review/34960
Petri-Dish: Pascal Quantin <pascal@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Stig Bjørlykke <stig@bjorlykke.org>
Reviewed-by: Roland Knall <rknall@gmail.com>
(cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08)
Conflicts:
	epan/dissectors/packet-cms.c
Reviewed-on: https://code.wireshark.org/review/34975
Reviewed-by: Pascal Quantin <pascal@wireshark.org>",34d2e0d5318d0a7e9889498c721639e5cbf4ce45,https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45,epan/dissectors/packet-cms.c,dissect_cms_AttributeValue,"static int
dissect_cms_AttributeValue(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 160 ""./asn1/cms/cms.cnf""
offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);
return offset;
}","static int
dissect_cms_AttributeValue(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 160 ""./asn1/cms/cms.cnf""
VAR_2=call_ber_oid_callback(VAR_6, VAR_1, VAR_2, VAR_3->pinfo, VAR_4, NULL);
return VAR_2;
}",,"static int
dissect_cms_AttributeValue(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 161 ""./asn1/cms/cms.cnf""

  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);



  return offset;
}","static int
dissect_cms_AttributeValue(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 161 ""./asn1/cms/cms.cnf""

  VAR_2=call_ber_oid_callback(VAR_6, VAR_1, VAR_2, VAR_3->pinfo, VAR_4, NULL);



  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 dissect_cms_AttributeValue(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 160 ""./asn1/cms/cms.cnf""
+#line 161 ""./asn1/cms/cms.cnf""
 
   offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);
 ","{'deleted_lines': ['#line 160 ""./asn1/cms/cms.cnf""'], 'added_lines': ['#line 161 ""./asn1/cms/cms.cnf""']}",True,"In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",7.5,HIGH,2,test,2019-11-04T14:08:22Z,3
CVE-2019-19553,['CWE-909'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"CMS: reset object_identifier_id after dissecting ContentInfo

Bug: 15961
Change-Id: I3d6b3e96103b69f88fcb512da81fa20ff6a1c40e
Reviewed-on: https://code.wireshark.org/review/34960
Petri-Dish: Pascal Quantin <pascal@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Stig Bjørlykke <stig@bjorlykke.org>
Reviewed-by: Roland Knall <rknall@gmail.com>
(cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08)
Conflicts:
	epan/dissectors/packet-cms.c
Reviewed-on: https://code.wireshark.org/review/34975
Reviewed-by: Pascal Quantin <pascal@wireshark.org>",34d2e0d5318d0a7e9889498c721639e5cbf4ce45,https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45,epan/dissectors/packet-cms.c,dissect_cms_MessageDigest,"static int
dissect_cms_MessageDigest(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 164 ""./asn1/cms/cms.cnf""
proto_item *pi;
int old_offset = offset;
offset = dissect_ber_octet_string(implicit_tag, actx, tree, tvb, offset, hf_index,
NULL);
pi = actx->created_item;
old_offset = get_ber_identifier(tvb, old_offset, NULL, NULL, NULL);
old_offset = get_ber_length(tvb, old_offset, NULL, NULL);
if(content_tvb)
cms_verify_msg_digest(pi, content_tvb, x509af_get_last_algorithm_id(), tvb, old_offset);
return offset;
}","static int
dissect_cms_MessageDigest(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 164 ""./asn1/cms/cms.cnf""
proto_item *VAR_6;
int VAR_7 = VAR_2;
VAR_2 = dissect_ber_octet_string(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2, VAR_5,
NULL);
VAR_6 = VAR_3->created_item;
VAR_7 = get_ber_identifier(VAR_1, VAR_7, NULL, NULL, NULL);
VAR_7 = get_ber_length(VAR_1, VAR_7, NULL, NULL);
if(VAR_8)
cms_verify_msg_digest(VAR_6, VAR_8, x509af_get_last_algorithm_id(), VAR_1, VAR_7);
return VAR_2;
}",,"static int
dissect_cms_MessageDigest(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 165 ""./asn1/cms/cms.cnf""
  proto_item *pi;
  int old_offset = offset;

    offset = dissect_ber_octet_string(implicit_tag, actx, tree, tvb, offset, hf_index,
                                       NULL);


  pi = actx->created_item;

  /* move past TLV */
  old_offset = get_ber_identifier(tvb, old_offset, NULL, NULL, NULL);
  old_offset = get_ber_length(tvb, old_offset, NULL, NULL);

  if(content_tvb)
    cms_verify_msg_digest(pi, content_tvb, x509af_get_last_algorithm_id(), tvb, old_offset);



  return offset;
}","static int
dissect_cms_MessageDigest(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 165 ""./asn1/cms/cms.cnf""
  proto_item *VAR_6;
  int VAR_7 = VAR_2;

    VAR_2 = dissect_ber_octet_string(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2, VAR_5,
                                       NULL);


  VAR_6 = VAR_3->created_item;

  /* COMMENT_0 */
  VAR_7 = get_ber_identifier(VAR_1, VAR_7, NULL, NULL, NULL);
  VAR_7 = get_ber_length(VAR_1, VAR_7, NULL, NULL);

  if(VAR_8)
    cms_verify_msg_digest(VAR_6, VAR_8, x509af_get_last_algorithm_id(), VAR_1, VAR_7);



  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 dissect_cms_MessageDigest(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 164 ""./asn1/cms/cms.cnf""
+#line 165 ""./asn1/cms/cms.cnf""
   proto_item *pi;
   int old_offset = offset;
 ","{'deleted_lines': ['#line 164 ""./asn1/cms/cms.cnf""'], 'added_lines': ['#line 165 ""./asn1/cms/cms.cnf""']}",True,"In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",7.5,HIGH,2,test,2019-11-04T14:08:22Z,3
CVE-2019-19553,['CWE-909'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"CMS: reset object_identifier_id after dissecting ContentInfo

Bug: 15961
Change-Id: I3d6b3e96103b69f88fcb512da81fa20ff6a1c40e
Reviewed-on: https://code.wireshark.org/review/34960
Petri-Dish: Pascal Quantin <pascal@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Stig Bjørlykke <stig@bjorlykke.org>
Reviewed-by: Roland Knall <rknall@gmail.com>
(cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08)
Conflicts:
	epan/dissectors/packet-cms.c
Reviewed-on: https://code.wireshark.org/review/34975
Reviewed-by: Pascal Quantin <pascal@wireshark.org>",34d2e0d5318d0a7e9889498c721639e5cbf4ce45,https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45,epan/dissectors/packet-cms.c,dissect_cms_RC2ParameterVersion,"static int
dissect_cms_RC2ParameterVersion(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 200 ""./asn1/cms/cms.cnf""
guint32 length = 0;
offset = dissect_ber_integer(implicit_tag, actx, tree, tvb, offset, hf_index,
&length);
if(cap_tree != NULL)
proto_item_append_text(cap_tree, "" (%d bits)"", length);
return offset;
}","static int
dissect_cms_RC2ParameterVersion(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 200 ""./asn1/cms/cms.cnf""
guint32 VAR_6 = 0;
VAR_2 = dissect_ber_integer(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2, VAR_5,
&VAR_6);
if(VAR_7 != NULL)
proto_item_append_text(VAR_7, "" (%d bits)"", VAR_6);
return VAR_2;
}",,"static int
dissect_cms_RC2ParameterVersion(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 201 ""./asn1/cms/cms.cnf""
  guint32 length = 0;

    offset = dissect_ber_integer(implicit_tag, actx, tree, tvb, offset, hf_index,
                                                &length);


  if(cap_tree != NULL)
    proto_item_append_text(cap_tree, "" (%d bits)"", length);



  return offset;
}","static int
dissect_cms_RC2ParameterVersion(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 201 ""./asn1/cms/cms.cnf""
  guint32 VAR_6 = 0;

    VAR_2 = dissect_ber_integer(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2, VAR_5,
                                                &VAR_6);


  if(VAR_7 != NULL)
    proto_item_append_text(VAR_7, "" (%d bits)"", VAR_6);



  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 dissect_cms_RC2ParameterVersion(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 200 ""./asn1/cms/cms.cnf""
+#line 201 ""./asn1/cms/cms.cnf""
   guint32 length = 0;
 
     offset = dissect_ber_integer(implicit_tag, actx, tree, tvb, offset, hf_index,","{'deleted_lines': ['#line 200 ""./asn1/cms/cms.cnf""'], 'added_lines': ['#line 201 ""./asn1/cms/cms.cnf""']}",True,"In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",7.5,HIGH,2,test,2019-11-04T14:08:22Z,3
CVE-2019-19553,['CWE-909'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"CMS: reset object_identifier_id after dissecting ContentInfo

Bug: 15961
Change-Id: I3d6b3e96103b69f88fcb512da81fa20ff6a1c40e
Reviewed-on: https://code.wireshark.org/review/34960
Petri-Dish: Pascal Quantin <pascal@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Stig Bjørlykke <stig@bjorlykke.org>
Reviewed-by: Roland Knall <rknall@gmail.com>
(cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08)
Conflicts:
	epan/dissectors/packet-cms.c
Reviewed-on: https://code.wireshark.org/review/34975
Reviewed-by: Pascal Quantin <pascal@wireshark.org>",34d2e0d5318d0a7e9889498c721639e5cbf4ce45,https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45,epan/dissectors/packet-cms.c,dissect_cms_T_oriValue,"static int
dissect_cms_T_oriValue(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 133 ""./asn1/cms/cms.cnf""
offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);
return offset;
}","static int
dissect_cms_T_oriValue(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 133 ""./asn1/cms/cms.cnf""
VAR_2=call_ber_oid_callback(VAR_6, VAR_1, VAR_2, VAR_3->pinfo, VAR_4, NULL);
return VAR_2;
}",,"static int
dissect_cms_T_oriValue(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 134 ""./asn1/cms/cms.cnf""
  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);



  return offset;
}","static int
dissect_cms_T_oriValue(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 134 ""./asn1/cms/cms.cnf""
  VAR_2=call_ber_oid_callback(VAR_6, VAR_1, VAR_2, VAR_3->pinfo, VAR_4, NULL);



  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 dissect_cms_T_oriValue(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 133 ""./asn1/cms/cms.cnf""
+#line 134 ""./asn1/cms/cms.cnf""
   offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);
 
 ","{'deleted_lines': ['#line 133 ""./asn1/cms/cms.cnf""'], 'added_lines': ['#line 134 ""./asn1/cms/cms.cnf""']}",True,"In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",7.5,HIGH,2,test,2019-11-04T14:08:22Z,3
CVE-2019-19553,['CWE-909'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"CMS: reset object_identifier_id after dissecting ContentInfo

Bug: 15961
Change-Id: I3d6b3e96103b69f88fcb512da81fa20ff6a1c40e
Reviewed-on: https://code.wireshark.org/review/34960
Petri-Dish: Pascal Quantin <pascal@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Stig Bjørlykke <stig@bjorlykke.org>
Reviewed-by: Roland Knall <rknall@gmail.com>
(cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08)
Conflicts:
	epan/dissectors/packet-cms.c
Reviewed-on: https://code.wireshark.org/review/34975
Reviewed-by: Pascal Quantin <pascal@wireshark.org>",34d2e0d5318d0a7e9889498c721639e5cbf4ce45,https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45,epan/dissectors/packet-cms.c,dissect_cms_T_parameters,"static int
dissect_cms_T_parameters(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 193 ""./asn1/cms/cms.cnf""
offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);
return offset;
}","static int
dissect_cms_T_parameters(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 193 ""./asn1/cms/cms.cnf""
VAR_2=call_ber_oid_callback(VAR_6, VAR_1, VAR_2, VAR_3->pinfo, VAR_4, NULL);
return VAR_2;
}",,"static int
dissect_cms_T_parameters(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 194 ""./asn1/cms/cms.cnf""

  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);



  return offset;
}","static int
dissect_cms_T_parameters(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 194 ""./asn1/cms/cms.cnf""

  VAR_2=call_ber_oid_callback(VAR_6, VAR_1, VAR_2, VAR_3->pinfo, VAR_4, NULL);



  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 dissect_cms_T_parameters(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 193 ""./asn1/cms/cms.cnf""
+#line 194 ""./asn1/cms/cms.cnf""
 
   offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);
 ","{'deleted_lines': ['#line 193 ""./asn1/cms/cms.cnf""'], 'added_lines': ['#line 194 ""./asn1/cms/cms.cnf""']}",True,"In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",7.5,HIGH,2,test,2019-11-04T14:08:22Z,3
CVE-2019-19553,['CWE-909'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"CMS: reset object_identifier_id after dissecting ContentInfo

Bug: 15961
Change-Id: I3d6b3e96103b69f88fcb512da81fa20ff6a1c40e
Reviewed-on: https://code.wireshark.org/review/34960
Petri-Dish: Pascal Quantin <pascal@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Stig Bjørlykke <stig@bjorlykke.org>
Reviewed-by: Roland Knall <rknall@gmail.com>
(cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08)
Conflicts:
	epan/dissectors/packet-cms.c
Reviewed-on: https://code.wireshark.org/review/34975
Reviewed-by: Pascal Quantin <pascal@wireshark.org>",34d2e0d5318d0a7e9889498c721639e5cbf4ce45,https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45,epan/dissectors/packet-cms.c,dissect_cms_EncryptedContent,"static int
dissect_cms_EncryptedContent(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 210 ""./asn1/cms/cms.cnf""
tvbuff_t *encrypted_tvb;
proto_item *item;
offset = dissect_ber_octet_string(implicit_tag, actx, tree, tvb, offset, hf_index,
&encrypted_tvb);
#line 215 ""./asn1/cms/cms.cnf""
item = actx->created_item;
PBE_decrypt_data(object_identifier_id, encrypted_tvb, actx->pinfo, actx, item);
return offset;
}","static int
dissect_cms_EncryptedContent(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 210 ""./asn1/cms/cms.cnf""
tvbuff_t *VAR_6;
proto_item *VAR_7;
VAR_2 = dissect_ber_octet_string(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2, VAR_5,
&VAR_6);
#line 215 ""./asn1/cms/cms.cnf""
VAR_7 = VAR_3->created_item;
PBE_decrypt_data(VAR_8, VAR_6, VAR_3->pinfo, VAR_3, VAR_7);
return VAR_2;
}",,"static int
dissect_cms_EncryptedContent(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 211 ""./asn1/cms/cms.cnf""
	tvbuff_t *encrypted_tvb;
	proto_item *item;

  offset = dissect_ber_octet_string(implicit_tag, actx, tree, tvb, offset, hf_index,
                                       &encrypted_tvb);

#line 216 ""./asn1/cms/cms.cnf""

	item = actx->created_item;

	PBE_decrypt_data(object_identifier_id, encrypted_tvb, actx->pinfo, actx, item);


  return offset;
}","static int
dissect_cms_EncryptedContent(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 211 ""./asn1/cms/cms.cnf""
	tvbuff_t *VAR_6;
	proto_item *VAR_7;

  VAR_2 = dissect_ber_octet_string(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2, VAR_5,
                                       &VAR_6);

#line 216 ""./asn1/cms/cms.cnf""

	VAR_7 = VAR_3->created_item;

	PBE_decrypt_data(VAR_8, VAR_6, VAR_3->pinfo, VAR_3, VAR_7);


  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,13 +1,13 @@
 static int
 dissect_cms_EncryptedContent(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 210 ""./asn1/cms/cms.cnf""
+#line 211 ""./asn1/cms/cms.cnf""
 	tvbuff_t *encrypted_tvb;
 	proto_item *item;
 
   offset = dissect_ber_octet_string(implicit_tag, actx, tree, tvb, offset, hf_index,
                                        &encrypted_tvb);
 
-#line 215 ""./asn1/cms/cms.cnf""
+#line 216 ""./asn1/cms/cms.cnf""
 
 	item = actx->created_item;
 ","{'deleted_lines': ['#line 210 ""./asn1/cms/cms.cnf""', '#line 215 ""./asn1/cms/cms.cnf""'], 'added_lines': ['#line 211 ""./asn1/cms/cms.cnf""', '#line 216 ""./asn1/cms/cms.cnf""']}",True,"In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",7.5,HIGH,2,test,2019-11-04T14:08:22Z,3
CVE-2019-19553,['CWE-909'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"CMS: reset object_identifier_id after dissecting ContentInfo

Bug: 15961
Change-Id: I3d6b3e96103b69f88fcb512da81fa20ff6a1c40e
Reviewed-on: https://code.wireshark.org/review/34960
Petri-Dish: Pascal Quantin <pascal@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Stig Bjørlykke <stig@bjorlykke.org>
Reviewed-by: Roland Knall <rknall@gmail.com>
(cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08)
Conflicts:
	epan/dissectors/packet-cms.c
Reviewed-on: https://code.wireshark.org/review/34975
Reviewed-by: Pascal Quantin <pascal@wireshark.org>",34d2e0d5318d0a7e9889498c721639e5cbf4ce45,https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45,epan/dissectors/packet-cms.c,dissect_cms_T_capability,"static int
dissect_cms_T_capability(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 182 ""./asn1/cms/cms.cnf""
const char *name = NULL;
offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_cms_attrType, &object_identifier_id);
if(object_identifier_id) {
name = oid_resolved_from_string(wmem_packet_scope(), object_identifier_id);
proto_item_append_text(tree, "" %s"", name ? name : object_identifier_id);
cap_tree = tree;
}
return offset;
}","static int
dissect_cms_T_capability(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 182 ""./asn1/cms/cms.cnf""
const char *VAR_6 = NULL;
VAR_2 = dissect_ber_object_identifier_str(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2, VAR_7, &VAR_8);
if(VAR_8) {
VAR_6 = oid_resolved_from_string(wmem_packet_scope(), VAR_8);
proto_item_append_text(VAR_4, "" %s"", VAR_6 ? VAR_6 : VAR_8);
VAR_9 = VAR_4;
}
return VAR_2;
}",,"static int
dissect_cms_T_capability(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 183 ""./asn1/cms/cms.cnf""
  const char *name = NULL;

    offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_cms_attrType, &object_identifier_id);


  if(object_identifier_id) {
    name = oid_resolved_from_string(wmem_packet_scope(), object_identifier_id);
    proto_item_append_text(tree, "" %s"", name ? name : object_identifier_id);
    cap_tree = tree;
  }



  return offset;
}","static int
dissect_cms_T_capability(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 183 ""./asn1/cms/cms.cnf""
  const char *VAR_6 = NULL;

    VAR_2 = dissect_ber_object_identifier_str(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2, VAR_7, &VAR_8);


  if(VAR_8) {
    VAR_6 = oid_resolved_from_string(wmem_packet_scope(), VAR_8);
    proto_item_append_text(VAR_4, "" %s"", VAR_6 ? VAR_6 : VAR_8);
    VAR_9 = VAR_4;
  }



  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 dissect_cms_T_capability(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 182 ""./asn1/cms/cms.cnf""
+#line 183 ""./asn1/cms/cms.cnf""
   const char *name = NULL;
 
     offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_cms_attrType, &object_identifier_id);","{'deleted_lines': ['#line 182 ""./asn1/cms/cms.cnf""'], 'added_lines': ['#line 183 ""./asn1/cms/cms.cnf""']}",True,"In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",7.5,HIGH,2,test,2019-11-04T14:08:22Z,3
CVE-2019-19553,['CWE-909'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"CMS: reset object_identifier_id after dissecting ContentInfo

Bug: 15961
Change-Id: I3d6b3e96103b69f88fcb512da81fa20ff6a1c40e
Reviewed-on: https://code.wireshark.org/review/34960
Petri-Dish: Pascal Quantin <pascal@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Stig Bjørlykke <stig@bjorlykke.org>
Reviewed-by: Roland Knall <rknall@gmail.com>
(cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08)
Conflicts:
	epan/dissectors/packet-cms.c
Reviewed-on: https://code.wireshark.org/review/34975
Reviewed-by: Pascal Quantin <pascal@wireshark.org>",34d2e0d5318d0a7e9889498c721639e5cbf4ce45,https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45,epan/dissectors/packet-cms.c,dissect_cms_T_eContent,"static int
dissect_cms_T_eContent(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 120 ""./asn1/cms/cms.cnf""
offset = dissect_ber_octet_string(FALSE, actx, tree, tvb, offset, hf_index, &content_tvb);
if(content_tvb) {
proto_item_set_text(actx->created_item, ""eContent (%u bytes)"", tvb_reported_length (content_tvb));
call_ber_oid_callback(object_identifier_id, content_tvb, 0, actx->pinfo, top_tree ? top_tree : tree, NULL);
}
return offset;
}","static int
dissect_cms_T_eContent(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 120 ""./asn1/cms/cms.cnf""
VAR_2 = dissect_ber_octet_string(FALSE, VAR_3, VAR_4, VAR_1, VAR_2, VAR_5, &VAR_6);
if(VAR_6) {
proto_item_set_text(VAR_3->created_item, ""eContent (%u bytes)"", tvb_reported_length (VAR_6));
call_ber_oid_callback(VAR_7, VAR_6, 0, VAR_3->pinfo, VAR_8 ? VAR_8 : VAR_4, NULL);
}
return VAR_2;
}",,"static int
dissect_cms_T_eContent(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 121 ""./asn1/cms/cms.cnf""

  offset = dissect_ber_octet_string(FALSE, actx, tree, tvb, offset, hf_index, &content_tvb);

  if(content_tvb) {
    proto_item_set_text(actx->created_item, ""eContent (%u bytes)"", tvb_reported_length (content_tvb));

    call_ber_oid_callback(object_identifier_id, content_tvb, 0, actx->pinfo, top_tree ? top_tree : tree, NULL);
  }



  return offset;
}","static int
dissect_cms_T_eContent(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 121 ""./asn1/cms/cms.cnf""

  VAR_2 = dissect_ber_octet_string(FALSE, VAR_3, VAR_4, VAR_1, VAR_2, VAR_5, &VAR_6);

  if(VAR_6) {
    proto_item_set_text(VAR_3->created_item, ""eContent (%u bytes)"", tvb_reported_length (VAR_6));

    call_ber_oid_callback(VAR_7, VAR_6, 0, VAR_3->pinfo, VAR_8 ? VAR_8 : VAR_4, NULL);
  }



  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 dissect_cms_T_eContent(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 120 ""./asn1/cms/cms.cnf""
+#line 121 ""./asn1/cms/cms.cnf""
 
   offset = dissect_ber_octet_string(FALSE, actx, tree, tvb, offset, hf_index, &content_tvb);
 ","{'deleted_lines': ['#line 120 ""./asn1/cms/cms.cnf""'], 'added_lines': ['#line 121 ""./asn1/cms/cms.cnf""']}",True,"In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",7.5,HIGH,2,test,2019-11-04T14:08:22Z,3
CVE-2019-19553,['CWE-909'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"CMS: reset object_identifier_id after dissecting ContentInfo

Bug: 15961
Change-Id: I3d6b3e96103b69f88fcb512da81fa20ff6a1c40e
Reviewed-on: https://code.wireshark.org/review/34960
Petri-Dish: Pascal Quantin <pascal@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Stig Bjørlykke <stig@bjorlykke.org>
Reviewed-by: Roland Knall <rknall@gmail.com>
(cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08)
Conflicts:
	epan/dissectors/packet-cms.c
Reviewed-on: https://code.wireshark.org/review/34975
Reviewed-by: Pascal Quantin <pascal@wireshark.org>",34d2e0d5318d0a7e9889498c721639e5cbf4ce45,https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45,epan/dissectors/packet-cms.c,dissect_cms_ContentType,"int
dissect_cms_ContentType(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 106 ""./asn1/cms/cms.cnf""
const char *name = NULL;
offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_index, &object_identifier_id);
if(object_identifier_id) {
name = oid_resolved_from_string(wmem_packet_scope(), object_identifier_id);
proto_item_append_text(tree, "" (%s)"", name ? name : object_identifier_id);
}
return offset;
}","int
dissect_cms_ContentType(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 106 ""./asn1/cms/cms.cnf""
const char *VAR_6 = NULL;
VAR_2 = dissect_ber_object_identifier_str(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2, VAR_5, &VAR_7);
if(VAR_7) {
VAR_6 = oid_resolved_from_string(wmem_packet_scope(), VAR_7);
proto_item_append_text(VAR_4, "" (%s)"", VAR_6 ? VAR_6 : VAR_7);
}
return VAR_2;
}",,"int
dissect_cms_ContentType(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 107 ""./asn1/cms/cms.cnf""
  	const char *name = NULL;

	  offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_index, &object_identifier_id);


	if(object_identifier_id) {
		name = oid_resolved_from_string(wmem_packet_scope(), object_identifier_id);
		proto_item_append_text(tree, "" (%s)"", name ? name : object_identifier_id);
	}



  return offset;
}","int
dissect_cms_ContentType(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 107 ""./asn1/cms/cms.cnf""
  	const char *VAR_6 = NULL;

	  VAR_2 = dissect_ber_object_identifier_str(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2, VAR_5, &VAR_7);


	if(VAR_7) {
		VAR_6 = oid_resolved_from_string(wmem_packet_scope(), VAR_7);
		proto_item_append_text(VAR_4, "" (%s)"", VAR_6 ? VAR_6 : VAR_7);
	}



  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 int
 dissect_cms_ContentType(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 106 ""./asn1/cms/cms.cnf""
+#line 107 ""./asn1/cms/cms.cnf""
   	const char *name = NULL;
 
 	  offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_index, &object_identifier_id);","{'deleted_lines': ['#line 106 ""./asn1/cms/cms.cnf""'], 'added_lines': ['#line 107 ""./asn1/cms/cms.cnf""']}",True,"In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",7.5,HIGH,2,test,2019-11-04T14:08:22Z,3
CVE-2019-19553,['CWE-909'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"CMS: reset object_identifier_id after dissecting ContentInfo

Bug: 15961
Change-Id: I3d6b3e96103b69f88fcb512da81fa20ff6a1c40e
Reviewed-on: https://code.wireshark.org/review/34960
Petri-Dish: Pascal Quantin <pascal@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Stig Bjørlykke <stig@bjorlykke.org>
Reviewed-by: Roland Knall <rknall@gmail.com>
(cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08)
Conflicts:
	epan/dissectors/packet-cms.c
Reviewed-on: https://code.wireshark.org/review/34975
Reviewed-by: Pascal Quantin <pascal@wireshark.org>",34d2e0d5318d0a7e9889498c721639e5cbf4ce45,https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45,epan/dissectors/packet-cms.c,dissect_cms_T_otherRevInfo,"static int
dissect_cms_T_otherRevInfo(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 144 ""./asn1/cms/cms.cnf""
offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);
return offset;
}","static int
dissect_cms_T_otherRevInfo(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 144 ""./asn1/cms/cms.cnf""
VAR_2=call_ber_oid_callback(VAR_6, VAR_1, VAR_2, VAR_3->pinfo, VAR_4, NULL);
return VAR_2;
}",,"static int
dissect_cms_T_otherRevInfo(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 145 ""./asn1/cms/cms.cnf""
  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);



  return offset;
}","static int
dissect_cms_T_otherRevInfo(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 145 ""./asn1/cms/cms.cnf""
  VAR_2=call_ber_oid_callback(VAR_6, VAR_1, VAR_2, VAR_3->pinfo, VAR_4, NULL);



  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 dissect_cms_T_otherRevInfo(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 144 ""./asn1/cms/cms.cnf""
+#line 145 ""./asn1/cms/cms.cnf""
   offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);
 
 ","{'deleted_lines': ['#line 144 ""./asn1/cms/cms.cnf""'], 'added_lines': ['#line 145 ""./asn1/cms/cms.cnf""']}",True,"In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",7.5,HIGH,2,test,2019-11-04T14:08:22Z,3
CVE-2019-19553,['CWE-909'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"CMS: reset object_identifier_id after dissecting ContentInfo

Bug: 15961
Change-Id: I3d6b3e96103b69f88fcb512da81fa20ff6a1c40e
Reviewed-on: https://code.wireshark.org/review/34960
Petri-Dish: Pascal Quantin <pascal@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Stig Bjørlykke <stig@bjorlykke.org>
Reviewed-by: Roland Knall <rknall@gmail.com>
(cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08)
Conflicts:
	epan/dissectors/packet-cms.c
Reviewed-on: https://code.wireshark.org/review/34975
Reviewed-by: Pascal Quantin <pascal@wireshark.org>",34d2e0d5318d0a7e9889498c721639e5cbf4ce45,https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45,epan/dissectors/packet-cms.c,dissect_cms_T_attrType,"static int
dissect_cms_T_attrType(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 150 ""./asn1/cms/cms.cnf""
const char *name = NULL;
offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_cms_attrType, &object_identifier_id);
if(object_identifier_id) {
name = oid_resolved_from_string(wmem_packet_scope(), object_identifier_id);
proto_item_append_text(tree, "" (%s)"", name ? name : object_identifier_id);
}
return offset;
}","static int
dissect_cms_T_attrType(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 150 ""./asn1/cms/cms.cnf""
const char *VAR_6 = NULL;
VAR_2 = dissect_ber_object_identifier_str(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2, VAR_7, &VAR_8);
if(VAR_8) {
VAR_6 = oid_resolved_from_string(wmem_packet_scope(), VAR_8);
proto_item_append_text(VAR_4, "" (%s)"", VAR_6 ? VAR_6 : VAR_8);
}
return VAR_2;
}",,"static int
dissect_cms_T_attrType(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 151 ""./asn1/cms/cms.cnf""
  const char *name = NULL;

    offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_cms_attrType, &object_identifier_id);


  if(object_identifier_id) {
    name = oid_resolved_from_string(wmem_packet_scope(), object_identifier_id);
    proto_item_append_text(tree, "" (%s)"", name ? name : object_identifier_id);
  }



  return offset;
}","static int
dissect_cms_T_attrType(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 151 ""./asn1/cms/cms.cnf""
  const char *VAR_6 = NULL;

    VAR_2 = dissect_ber_object_identifier_str(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2, VAR_7, &VAR_8);


  if(VAR_8) {
    VAR_6 = oid_resolved_from_string(wmem_packet_scope(), VAR_8);
    proto_item_append_text(VAR_4, "" (%s)"", VAR_6 ? VAR_6 : VAR_8);
  }



  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 dissect_cms_T_attrType(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 150 ""./asn1/cms/cms.cnf""
+#line 151 ""./asn1/cms/cms.cnf""
   const char *name = NULL;
 
     offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_cms_attrType, &object_identifier_id);","{'deleted_lines': ['#line 150 ""./asn1/cms/cms.cnf""'], 'added_lines': ['#line 151 ""./asn1/cms/cms.cnf""']}",True,"In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",7.5,HIGH,2,test,2019-11-04T14:08:22Z,3
CVE-2019-19553,['CWE-909'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"CMS: reset object_identifier_id after dissecting ContentInfo

Bug: 15961
Change-Id: I3d6b3e96103b69f88fcb512da81fa20ff6a1c40e
Reviewed-on: https://code.wireshark.org/review/34960
Petri-Dish: Pascal Quantin <pascal@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Stig Bjørlykke <stig@bjorlykke.org>
Reviewed-by: Roland Knall <rknall@gmail.com>
(cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08)
Conflicts:
	epan/dissectors/packet-cms.c
Reviewed-on: https://code.wireshark.org/review/34975
Reviewed-by: Pascal Quantin <pascal@wireshark.org>",34d2e0d5318d0a7e9889498c721639e5cbf4ce45,https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45,epan/dissectors/packet-cms.c,dissect_cms_T_content,"static int
dissect_cms_T_content(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 116 ""./asn1/cms/cms.cnf""
offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);
return offset;
}","static int
dissect_cms_T_content(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 116 ""./asn1/cms/cms.cnf""
VAR_2=call_ber_oid_callback(VAR_6, VAR_1, VAR_2, VAR_3->pinfo, VAR_4, NULL);
return VAR_2;
}",,"static int
dissect_cms_T_content(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 117 ""./asn1/cms/cms.cnf""
  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);




  return offset;
}","static int
dissect_cms_T_content(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 117 ""./asn1/cms/cms.cnf""
  VAR_2=call_ber_oid_callback(VAR_6, VAR_1, VAR_2, VAR_3->pinfo, VAR_4, NULL);




  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 dissect_cms_T_content(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 116 ""./asn1/cms/cms.cnf""
+#line 117 ""./asn1/cms/cms.cnf""
   offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);
 
 ","{'deleted_lines': ['#line 116 ""./asn1/cms/cms.cnf""'], 'added_lines': ['#line 117 ""./asn1/cms/cms.cnf""']}",True,"In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",7.5,HIGH,2,test,2019-11-04T14:08:22Z,3
CVE-2019-19553,['CWE-909'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"CMS: reset object_identifier_id after dissecting ContentInfo

Bug: 15961
Change-Id: I3d6b3e96103b69f88fcb512da81fa20ff6a1c40e
Reviewed-on: https://code.wireshark.org/review/34960
Petri-Dish: Pascal Quantin <pascal@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Stig Bjørlykke <stig@bjorlykke.org>
Reviewed-by: Roland Knall <rknall@gmail.com>
(cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08)
Conflicts:
	epan/dissectors/packet-cms.c
Reviewed-on: https://code.wireshark.org/review/34975
Reviewed-by: Pascal Quantin <pascal@wireshark.org>",34d2e0d5318d0a7e9889498c721639e5cbf4ce45,https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45,epan/dissectors/packet-cms.c,dissect_cms_T_keyAttr,"static int
dissect_cms_T_keyAttr(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 139 ""./asn1/cms/cms.cnf""
offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);
return offset;
}","static int
dissect_cms_T_keyAttr(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 139 ""./asn1/cms/cms.cnf""
VAR_2=call_ber_oid_callback(VAR_6, VAR_1, VAR_2, VAR_3->pinfo, VAR_4, NULL);
return VAR_2;
}",,"static int
dissect_cms_T_keyAttr(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 140 ""./asn1/cms/cms.cnf""
  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);


  return offset;
}","static int
dissect_cms_T_keyAttr(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 140 ""./asn1/cms/cms.cnf""
  VAR_2=call_ber_oid_callback(VAR_6, VAR_1, VAR_2, VAR_3->pinfo, VAR_4, NULL);


  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 dissect_cms_T_keyAttr(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 139 ""./asn1/cms/cms.cnf""
+#line 140 ""./asn1/cms/cms.cnf""
   offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);
 
 ","{'deleted_lines': ['#line 139 ""./asn1/cms/cms.cnf""'], 'added_lines': ['#line 140 ""./asn1/cms/cms.cnf""']}",True,"In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",7.5,HIGH,2,test,2019-11-04T14:08:22Z,3
CVE-2020-27792,['CWE-119'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:H,1,ArtifexSoftware/ghostpdl,"Bug 701844: fixed output buffer size worst case in lp8000_print_page().

Fixes:
    ./sanbin/gs -dBATCH -dNOPAUSE -dSAFER -dFIXEDMEDIA -sPAPERSIZE=legal -sOutputFile=tmp -sDEVICE=lp8000 ../bug-701844.pdf",4f6bc662909ab79e8fbe9822afb36e8a0eafc2b7,https://github.com/ArtifexSoftware/ghostpdl/commit/4f6bc662909ab79e8fbe9822afb36e8a0eafc2b7,devices/gdevlp8k.c,lp8000_print_page,"static int
lp8000_print_page(gx_device_printer *pdev, gp_file *prn_stream)
{
int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);
int in_size = line_size;
unsigned int report_size;
byte *buf1 = (byte *)gs_malloc(pdev->memory, in_size, 1, ""lp8000_print_page(buf1)"");
byte *buf2 = (byte *)gs_malloc(pdev->memory, in_size, 1, ""lp8000_print_page(buf2)"");
byte *in = buf1;
byte *out = buf2;
int lnum, top, bottom, left, width;
int count, left1, left2, left0;
if ( buf1 == 0 || buf2 == 0 )
{       if ( buf1 )
gs_free(pdev->memory, (char *)buf1, in_size, 1, ""lp8000_print_page(buf1)"");
if ( buf2 )
gs_free(pdev->memory, (char *)buf2, in_size, 1, ""lp8000_print_page(buf2)"");
return_error(gs_error_VMerror);
}
gp_fwrite(""\033\001@EJL \n"",1,8,prn_stream);
gp_fwrite(""@EJL EN LA=ESC/PAGE\n"",1,20,prn_stream);
gp_fwrite(""\035rhE\033\001@EJL \n"",1,12,prn_stream);
gp_fwrite(""@EJL SE LA=ESC/PAGE\n"",1,20,prn_stream);
gp_fwrite(""@EJL SET PU=1 PS=A4 ZO=OFF\n"",1,27,prn_stream);
gp_fwrite(""@EJL EN LA=ESC/PAGE\n"",1,20,prn_stream);
gp_fwrite(""\0350;0.24muE\0352;300;300drE"",1,23,prn_stream);
gp_fwrite(""\0350;300;300drE\0351tsE\0351mmE"",1,23,prn_stream);
gp_fwrite(""\0357isE\0355iaF\0355ipP\03514psE\0350poE"",1,26,prn_stream);
gp_fwrite(""\03560;60loE\0350X\0350Y"",1,15,prn_stream);
gp_fwrite(""\0350;0;2360;3388caE"",1,17,prn_stream);
gp_fwrite(""\0351cmE\0350alfP"",1,11,prn_stream);
gp_fwrite(""\0350affP\0350boP\0350abP"",1,16,prn_stream);
gp_fwrite(""\0354ilG\0350bcI\0350sarG"",1,16,prn_stream);
gp_fwrite(""\0351;0;100spE\0352owE"",1,16,prn_stream);
left1  =  (int) (L_MARGIN * pdev->x_pixels_per_inch) - 60;
left1 = (left1 >> 3) << 3;
left0 = left1;
gp_fwrite(""\035"",1,1,prn_stream);
gp_fprintf(prn_stream,""%d"",left1);
gp_fwrite(""X"",1,1,prn_stream);
gp_fwrite(""\0353bcI"",1,5,prn_stream);
top = T_MARGIN * pdev->y_pixels_per_inch;
bottom = pdev->height - B_MARGIN * pdev->y_pixels_per_inch;
left  = ( (int) (L_MARGIN * pdev->x_pixels_per_inch) ) >> 3 ;
width = ((pdev->width - (int)(R_MARGIN * pdev->x_pixels_per_inch)) >> 3) - left;
for ( lnum = top; lnum < bottom ; )
{
byte *in_data;
byte *inp;
byte *in_end;
byte *outp;
register byte *p, *q;
gdev_prn_get_bits(pdev, lnum, in, &in_data);
while ( in_data[0] == 0 &&
!memcmp((char *)in_data, (char *)in_data + 1, line_size - 1) &&
lnum < bottom )
{
lnum++;
gdev_prn_get_bits(pdev, lnum, in, &in_data);
}
if(lnum == bottom ) break;
(void)gdev_prn_copy_scan_lines(pdev, lnum, in, in_size);
inp = in  + left;
in_end = inp + width;
while (in_end > inp &&  in_end[-1] == 0)
{
in_end--;
}
for(left2 = 0; inp < in_end && inp[0] == 0; inp++,left2++);
left2 = left1 + (left2 << 3);
outp = out;
for( p = inp, q = inp + 1 ; q < in_end ; )
{
if( *p != *q++ )
{
*outp++ = *p++;
}
else
{
for (count = 2; ( *p == *q ) && (q < in_end); q++, count++)
{}
while (count > 257)
{
*outp++ = *p;
*outp++ = *p;
*outp++ = 255;
p += 257;
count -=257;
}
*outp++ = *p;
*outp++ = *p;
*outp++ = count - 2;
p += count;
q = p+1;
}
}
if (p == (in_end - 1)) *outp++ = *p;
if (left2 != left0)
{
left0 = left2;
gp_fwrite(""\035"",1,1,prn_stream);
gp_fprintf(prn_stream,""%d"",left2);
gp_fwrite(""X"",1,1,prn_stream);
}
gp_fwrite(""\035"",1,1,prn_stream);
gp_fprintf(prn_stream,""%d"",lnum-60);
gp_fwrite(""Y\035"",1,2,prn_stream);
report_size = outp - out;
gp_fprintf(prn_stream,""%d;"",report_size);
report_size = (in_end - inp) << 3;
gp_fprintf(prn_stream,""%d;"",report_size);
gp_fwrite(""1;0bi{I"",1,7,prn_stream);
gp_fwrite(out,1,(outp - out),prn_stream);
lnum++;
}
gp_fwrite(""\0350bcI"",1,5,prn_stream);
gp_fwrite(""\0351coO"",1,5,prn_stream);
gp_fwrite(""\035rhE"",1,4,prn_stream);
gp_fwrite(""\033\001@EJL \n"",1,8,prn_stream);
gp_fwrite(""@EJL SE LA=ESC/PAGE\n"",1,20,prn_stream);
gp_fwrite(""@EJL SET PU=1 PS=A4 ZO=OFF\n"",1,27,prn_stream);
gp_fwrite(""@EJL EN LA=ESC/PAGE\n"",1,20,prn_stream);
gp_fwrite(""\0350;0.24muE\0352;300;300drE"",1,23,prn_stream);
gp_fwrite(""\0350;300;300drE\0351tsE\0351mmE"",1,23,prn_stream);
gp_fwrite(""\0357isE\0355iaF\0355ipP\03514psE\0350poE"",1,26,prn_stream);
gp_fwrite(""\03560;60loE\0350X\0350Y"",1,15,prn_stream);
gp_fwrite(""\0350;0;2360;3388caE"",1,17,prn_stream);
gp_fwrite(""\0351cmE\0350alfP"",1,11,prn_stream);
gp_fwrite(""\0350affP\0350boP\0350abP"",1,16,prn_stream);
gp_fwrite(""\0354ilG\0350bcI\0350sarG"",1,16,prn_stream);
gp_fwrite(""\035rhE"",1,4,prn_stream);
gp_fwrite(""\033\001@EJL \n"",1,8,prn_stream);
gp_fwrite(""\033\001@EJL \n"",1,8,prn_stream);
gp_fflush(prn_stream);
gs_free(pdev->memory, (char *)buf2, in_size, 1, ""lp8000_print_page(buf2)"");
gs_free(pdev->memory, (char *)buf1, in_size, 1, ""lp8000_print_page(buf1)"");
return 0;
}","static int
lp8000_print_page(gx_device_printer *VAR_0, gp_file *VAR_1)
{
int VAR_2 = gdev_mem_bytes_per_scan_line((gx_device *)VAR_0);
int VAR_3 = VAR_2;
unsigned int VAR_4;
byte *VAR_5 = (byte *)gs_malloc(VAR_0->memory, VAR_3, 1, ""lp8000_print_page(buf1)"");
byte *VAR_6 = (byte *)gs_malloc(VAR_0->memory, VAR_3, 1, ""lp8000_print_page(buf2)"");
byte *VAR_7 = VAR_5;
byte *VAR_8 = VAR_6;
int VAR_9, VAR_10, VAR_11, VAR_12, VAR_13;
int VAR_14, VAR_15, VAR_16, VAR_17;
if ( VAR_5 == 0 || VAR_6 == 0 )
{       if ( VAR_5 )
gs_free(VAR_0->memory, (char *)VAR_5, VAR_3, 1, ""lp8000_print_page(buf1)"");
if ( VAR_6 )
gs_free(VAR_0->memory, (char *)VAR_6, VAR_3, 1, ""lp8000_print_page(buf2)"");
return_error(VAR_18);
}
gp_fwrite(""\033\001@EJL \n"",1,8,VAR_1);
gp_fwrite(""@EJL EN LA=ESC/PAGE\n"",1,20,VAR_1);
gp_fwrite(""\035rhE\033\001@EJL \n"",1,12,VAR_1);
gp_fwrite(""@EJL SE LA=ESC/PAGE\n"",1,20,VAR_1);
gp_fwrite(""@EJL SET PU=1 PS=A4 ZO=OFF\n"",1,27,VAR_1);
gp_fwrite(""@EJL EN LA=ESC/PAGE\n"",1,20,VAR_1);
gp_fwrite(""\0350;0.24muE\0352;300;300drE"",1,23,VAR_1);
gp_fwrite(""\0350;300;300drE\0351tsE\0351mmE"",1,23,VAR_1);
gp_fwrite(""\0357isE\0355iaF\0355ipP\03514psE\0350poE"",1,26,VAR_1);
gp_fwrite(""\03560;60loE\0350X\0350Y"",1,15,VAR_1);
gp_fwrite(""\0350;0;2360;3388caE"",1,17,VAR_1);
gp_fwrite(""\0351cmE\0350alfP"",1,11,VAR_1);
gp_fwrite(""\0350affP\0350boP\0350abP"",1,16,VAR_1);
gp_fwrite(""\0354ilG\0350bcI\0350sarG"",1,16,VAR_1);
gp_fwrite(""\0351;0;100spE\0352owE"",1,16,VAR_1);
VAR_15  =  (int) (VAR_19 * VAR_0->x_pixels_per_inch) - 60;
VAR_15 = (VAR_15 >> 3) << 3;
VAR_17 = VAR_15;
gp_fwrite(""\035"",1,1,VAR_1);
gp_fprintf(VAR_1,""%d"",VAR_15);
gp_fwrite(""X"",1,1,VAR_1);
gp_fwrite(""\0353bcI"",1,5,VAR_1);
VAR_10 = VAR_20 * VAR_0->y_pixels_per_inch;
VAR_11 = VAR_0->height - VAR_21 * VAR_0->y_pixels_per_inch;
VAR_12  = ( (int) (VAR_19 * VAR_0->x_pixels_per_inch) ) >> 3 ;
VAR_13 = ((VAR_0->width - (int)(VAR_22 * VAR_0->x_pixels_per_inch)) >> 3) - VAR_12;
for ( VAR_9 = VAR_10; VAR_9 < VAR_11 ; )
{
byte *VAR_23;
byte *VAR_24;
byte *VAR_25;
byte *VAR_26;
register byte *VAR_27, *VAR_28;
gdev_prn_get_bits(VAR_0, VAR_9, VAR_7, &VAR_23);
while ( VAR_23[0] == 0 &&
!memcmp((char *)VAR_23, (char *)VAR_23 + 1, VAR_2 - 1) &&
VAR_9 < VAR_11 )
{
VAR_9++;
gdev_prn_get_bits(VAR_0, VAR_9, VAR_7, &VAR_23);
}
if(VAR_9 == VAR_11 ) break;
(void)gdev_prn_copy_scan_lines(VAR_0, VAR_9, VAR_7, VAR_3);
VAR_24 = VAR_7  + VAR_12;
VAR_25 = VAR_24 + VAR_13;
while (VAR_25 > VAR_24 &&  VAR_25[-1] == 0)
{
VAR_25--;
}
for(VAR_16 = 0; VAR_24 < VAR_25 && VAR_24[0] == 0; VAR_24++,VAR_16++);
VAR_16 = VAR_15 + (VAR_16 << 3);
VAR_26 = VAR_8;
for( VAR_27 = VAR_24, VAR_28 = VAR_24 + 1 ; VAR_28 < VAR_25 ; )
{
if( *VAR_27 != *VAR_28++ )
{
*VAR_26++ = *VAR_27++;
}
else
{
for (VAR_14 = 2; ( *VAR_27 == *VAR_28 ) && (VAR_28 < VAR_25); VAR_28++, VAR_14++)
{}
while (VAR_14 > 257)
{
*VAR_26++ = *VAR_27;
*VAR_26++ = *VAR_27;
*VAR_26++ = 255;
VAR_27 += 257;
VAR_14 -=257;
}
*VAR_26++ = *VAR_27;
*VAR_26++ = *VAR_27;
*VAR_26++ = VAR_14 - 2;
VAR_27 += VAR_14;
VAR_28 = VAR_27+1;
}
}
if (VAR_27 == (VAR_25 - 1)) *VAR_26++ = *VAR_27;
if (VAR_16 != VAR_17)
{
VAR_17 = VAR_16;
gp_fwrite(""\035"",1,1,VAR_1);
gp_fprintf(VAR_1,""%d"",VAR_16);
gp_fwrite(""X"",1,1,VAR_1);
}
gp_fwrite(""\035"",1,1,VAR_1);
gp_fprintf(VAR_1,""%d"",VAR_9-60);
gp_fwrite(""Y\035"",1,2,VAR_1);
VAR_4 = VAR_26 - VAR_8;
gp_fprintf(VAR_1,""%d;"",VAR_4);
VAR_4 = (VAR_25 - VAR_24) << 3;
gp_fprintf(VAR_1,""%d;"",VAR_4);
gp_fwrite(""1;0bi{I"",1,7,VAR_1);
gp_fwrite(VAR_8,1,(VAR_26 - VAR_8),VAR_1);
VAR_9++;
}
gp_fwrite(""\0350bcI"",1,5,VAR_1);
gp_fwrite(""\0351coO"",1,5,VAR_1);
gp_fwrite(""\035rhE"",1,4,VAR_1);
gp_fwrite(""\033\001@EJL \n"",1,8,VAR_1);
gp_fwrite(""@EJL SE LA=ESC/PAGE\n"",1,20,VAR_1);
gp_fwrite(""@EJL SET PU=1 PS=A4 ZO=OFF\n"",1,27,VAR_1);
gp_fwrite(""@EJL EN LA=ESC/PAGE\n"",1,20,VAR_1);
gp_fwrite(""\0350;0.24muE\0352;300;300drE"",1,23,VAR_1);
gp_fwrite(""\0350;300;300drE\0351tsE\0351mmE"",1,23,VAR_1);
gp_fwrite(""\0357isE\0355iaF\0355ipP\03514psE\0350poE"",1,26,VAR_1);
gp_fwrite(""\03560;60loE\0350X\0350Y"",1,15,VAR_1);
gp_fwrite(""\0350;0;2360;3388caE"",1,17,VAR_1);
gp_fwrite(""\0351cmE\0350alfP"",1,11,VAR_1);
gp_fwrite(""\0350affP\0350boP\0350abP"",1,16,VAR_1);
gp_fwrite(""\0354ilG\0350bcI\0350sarG"",1,16,VAR_1);
gp_fwrite(""\035rhE"",1,4,VAR_1);
gp_fwrite(""\033\001@EJL \n"",1,8,VAR_1);
gp_fwrite(""\033\001@EJL \n"",1,8,VAR_1);
gp_fflush(VAR_1);
gs_free(VAR_0->memory, (char *)VAR_6, VAR_3, 1, ""lp8000_print_page(buf2)"");
gs_free(VAR_0->memory, (char *)VAR_5, VAR_3, 1, ""lp8000_print_page(buf1)"");
return 0;
}",ArtifexSoftware/ghostpdl/4f6bc662909ab79e8fbe9822afb36e8a0eafc2b7/gdevlp8k.c/vul/before/0.json,"static int
lp8000_print_page(gx_device_printer *pdev, gp_file *prn_stream)
{

        int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);
        int in_size = line_size;
        unsigned int report_size;

        byte *buf1 = (byte *)gs_malloc(pdev->memory, in_size, 1, ""lp8000_print_page(buf1)"");

        /* Worst case for rle compression below is 3 bytes for each 2 bytes of
        input, with extra final byte. */
        byte *buf2 = (byte *)gs_malloc(pdev->memory, in_size * 3 / 2 + 2, 1, ""lp8000_print_page(buf2)"");
        byte *in = buf1;
        byte *out = buf2;

        int lnum, top, bottom, left, width;
        int count, left1, left2, left0;

/* Check  memory allocations  */

        if ( buf1 == 0 || buf2 == 0 )
        {       if ( buf1 )
                gs_free(pdev->memory, (char *)buf1, in_size, 1, ""lp8000_print_page(buf1)"");

                if ( buf2 )
                gs_free(pdev->memory, (char *)buf2, in_size, 1, ""lp8000_print_page(buf2)"");

          return_error(gs_error_VMerror);
        }

/* Initialize the printer */

        gp_fwrite(""\033\001@EJL \n"",1,8,prn_stream);
        gp_fwrite(""@EJL EN LA=ESC/PAGE\n"",1,20,prn_stream);
        gp_fwrite(""\035rhE\033\001@EJL \n"",1,12,prn_stream);
        gp_fwrite(""@EJL SE LA=ESC/PAGE\n"",1,20,prn_stream);
        gp_fwrite(""@EJL SET PU=1 PS=A4 ZO=OFF\n"",1,27,prn_stream);
        gp_fwrite(""@EJL EN LA=ESC/PAGE\n"",1,20,prn_stream);
        gp_fwrite(""\0350;0.24muE\0352;300;300drE"",1,23,prn_stream);
        gp_fwrite(""\0350;300;300drE\0351tsE\0351mmE"",1,23,prn_stream);
        gp_fwrite(""\0357isE\0355iaF\0355ipP\03514psE\0350poE"",1,26,prn_stream);
        gp_fwrite(""\03560;60loE\0350X\0350Y"",1,15,prn_stream);
        gp_fwrite(""\0350;0;2360;3388caE"",1,17,prn_stream);
        gp_fwrite(""\0351cmE\0350alfP"",1,11,prn_stream);
        gp_fwrite(""\0350affP\0350boP\0350abP"",1,16,prn_stream);
        gp_fwrite(""\0354ilG\0350bcI\0350sarG"",1,16,prn_stream);
        gp_fwrite(""\0351;0;100spE\0352owE"",1,16,prn_stream);

/* Here the common part of the initialization string ends */

/* Calculate the PRINTER_LEFT_MARGIN = device_left_margin - 60 adjusted to
the byte boundary. Save this value for future comparison and set the
starting X value of the printer line.
*/
        left1  =  (int) (L_MARGIN * pdev->x_pixels_per_inch) - 60;
        left1 = (left1 >> 3) << 3;
        left0 = left1;

        gp_fwrite(""\035"",1,1,prn_stream);
        gp_fprintf(prn_stream,""%d"",left1);
        gp_fwrite(""X"",1,1,prn_stream);

        /* Set the compressed data format */
        gp_fwrite(""\0353bcI"",1,5,prn_stream);

        top = T_MARGIN * pdev->y_pixels_per_inch;
        bottom = pdev->height - B_MARGIN * pdev->y_pixels_per_inch;

        left  = ( (int) (L_MARGIN * pdev->x_pixels_per_inch) ) >> 3 ;
        width = ((pdev->width - (int)(R_MARGIN * pdev->x_pixels_per_inch)) >> 3) - left;

        /*
        ** Print the page:
        */

        for ( lnum = top; lnum < bottom ; )

        {
                byte *in_data;
                byte *inp;
                byte *in_end;
                byte *outp;
                register byte *p, *q;

                /*
                ** Check buffer for 0 data.
                */

                gdev_prn_get_bits(pdev, lnum, in, &in_data);
                while ( in_data[0] == 0 &&
                        !memcmp((char *)in_data, (char *)in_data + 1, line_size - 1) &&
                        lnum < bottom )
                {
                        lnum++;
                        gdev_prn_get_bits(pdev, lnum, in, &in_data);
                }

                if(lnum == bottom ) break;
                /* finished with this page */

                (void)gdev_prn_copy_scan_lines(pdev, lnum, in, in_size);

                inp = in  + left;
                in_end = inp + width;

/* Remove trailing 0s form the scan line data */

                while (in_end > inp &&  in_end[-1] == 0)
                {
                in_end--;
                }

/* Remove leading 0s form the scan line data */

        for(left2 = 0; inp < in_end && inp[0] == 0; inp++,left2++);

/* Recalculate starting X value */

        left2 = left1 + (left2 << 3);

/* Compress  non-zero data for this line*/

                outp = out;

 for( p = inp, q = inp + 1 ; q < in_end ; )
        {
        if( *p != *q++ )
          {
          /*
          Copy non-repeated bytes
          to the output buffer
          */
          *outp++ = *p++;
          }
          else
            {
                for (count = 2; ( *p == *q ) && (q < in_end); q++, count++)
                {}

                /*
                Copy repeated bytes and counts to the output buffer.
                As long as count is <= 255, additional step is necessary
                for a long repeated sequence
                */

                while (count > 257)
                {
                *outp++ = *p;
                *outp++ = *p;
                *outp++ = 255;
                p += 257;
                count -=257;
                }
                *outp++ = *p;
                *outp++ = *p;
                *outp++ = count - 2;
                p += count;
                q = p+1;
            }
        }

/* The next line is necessary just in case of a single non-repeated byte at
the end of the input buffer */

if (p == (in_end - 1)) *outp++ = *p;

/* End of the compression procedure */

/* Set a new value of the starting X point, if necessary  */

if (left2 != left0)
        {
        left0 = left2;
        gp_fwrite(""\035"",1,1,prn_stream);
        gp_fprintf(prn_stream,""%d"",left2);
        gp_fwrite(""X"",1,1,prn_stream);
        }

/* Output the data string to the printer.
Y coordinate of the printer equals (lnum - 60)
*/

        gp_fwrite(""\035"",1,1,prn_stream);
        gp_fprintf(prn_stream,""%d"",lnum-60);
        gp_fwrite(""Y\035"",1,2,prn_stream);
        report_size = outp - out;
        gp_fprintf(prn_stream,""%d;"",report_size);
        report_size = (in_end - inp) << 3;
        gp_fprintf(prn_stream,""%d;"",report_size);
        gp_fwrite(""1;0bi{I"",1,7,prn_stream);
        gp_fwrite(out,1,(outp - out),prn_stream);

        lnum++;

        }

/* Send the termination string */

        gp_fwrite(""\0350bcI"",1,5,prn_stream);
        gp_fwrite(""\0351coO"",1,5,prn_stream);
        gp_fwrite(""\035rhE"",1,4,prn_stream);

        gp_fwrite(""\033\001@EJL \n"",1,8,prn_stream);
        gp_fwrite(""@EJL SE LA=ESC/PAGE\n"",1,20,prn_stream);
        gp_fwrite(""@EJL SET PU=1 PS=A4 ZO=OFF\n"",1,27,prn_stream);
        gp_fwrite(""@EJL EN LA=ESC/PAGE\n"",1,20,prn_stream);
        gp_fwrite(""\0350;0.24muE\0352;300;300drE"",1,23,prn_stream);
        gp_fwrite(""\0350;300;300drE\0351tsE\0351mmE"",1,23,prn_stream);
        gp_fwrite(""\0357isE\0355iaF\0355ipP\03514psE\0350poE"",1,26,prn_stream);
        gp_fwrite(""\03560;60loE\0350X\0350Y"",1,15,prn_stream);
        gp_fwrite(""\0350;0;2360;3388caE"",1,17,prn_stream);
        gp_fwrite(""\0351cmE\0350alfP"",1,11,prn_stream);
        gp_fwrite(""\0350affP\0350boP\0350abP"",1,16,prn_stream);
        gp_fwrite(""\0354ilG\0350bcI\0350sarG"",1,16,prn_stream);
        gp_fwrite(""\035rhE"",1,4,prn_stream);
        gp_fwrite(""\033\001@EJL \n"",1,8,prn_stream);
        gp_fwrite(""\033\001@EJL \n"",1,8,prn_stream);

        gp_fflush(prn_stream);

        gs_free(pdev->memory, (char *)buf2, in_size, 1, ""lp8000_print_page(buf2)"");
        gs_free(pdev->memory, (char *)buf1, in_size, 1, ""lp8000_print_page(buf1)"");
        return 0;
}","static int
lp8000_print_page(gx_device_printer *VAR_0, gp_file *VAR_1)
{

        int VAR_2 = gdev_mem_bytes_per_scan_line((gx_device *)VAR_0);
        int VAR_3 = VAR_2;
        unsigned int VAR_4;

        byte *VAR_5 = (byte *)gs_malloc(VAR_0->memory, VAR_3, 1, ""lp8000_print_page(buf1)"");

        /* COMMENT_0 */
                                        
        byte *VAR_6 = (byte *)gs_malloc(VAR_0->memory, VAR_3 * 3 / 2 + 2, 1, ""lp8000_print_page(buf2)"");
        byte *VAR_7 = VAR_5;
        byte *VAR_8 = VAR_6;

        int VAR_9, VAR_10, VAR_11, VAR_12, VAR_13;
        int VAR_14, VAR_15, VAR_16, VAR_17;

/* COMMENT_2 */

        if ( VAR_5 == 0 || VAR_6 == 0 )
        {       if ( VAR_5 )
                gs_free(VAR_0->memory, (char *)VAR_5, VAR_3, 1, ""lp8000_print_page(buf1)"");

                if ( VAR_6 )
                gs_free(VAR_0->memory, (char *)VAR_6, VAR_3, 1, ""lp8000_print_page(buf2)"");

          return_error(VAR_18);
        }

/* COMMENT_3 */

        gp_fwrite(""\033\001@EJL \n"",1,8,VAR_1);
        gp_fwrite(""@EJL EN LA=ESC/PAGE\n"",1,20,VAR_1);
        gp_fwrite(""\035rhE\033\001@EJL \n"",1,12,VAR_1);
        gp_fwrite(""@EJL SE LA=ESC/PAGE\n"",1,20,VAR_1);
        gp_fwrite(""@EJL SET PU=1 PS=A4 ZO=OFF\n"",1,27,VAR_1);
        gp_fwrite(""@EJL EN LA=ESC/PAGE\n"",1,20,VAR_1);
        gp_fwrite(""\0350;0.24muE\0352;300;300drE"",1,23,VAR_1);
        gp_fwrite(""\0350;300;300drE\0351tsE\0351mmE"",1,23,VAR_1);
        gp_fwrite(""\0357isE\0355iaF\0355ipP\03514psE\0350poE"",1,26,VAR_1);
        gp_fwrite(""\03560;60loE\0350X\0350Y"",1,15,VAR_1);
        gp_fwrite(""\0350;0;2360;3388caE"",1,17,VAR_1);
        gp_fwrite(""\0351cmE\0350alfP"",1,11,VAR_1);
        gp_fwrite(""\0350affP\0350boP\0350abP"",1,16,VAR_1);
        gp_fwrite(""\0354ilG\0350bcI\0350sarG"",1,16,VAR_1);
        gp_fwrite(""\0351;0;100spE\0352owE"",1,16,VAR_1);

/* COMMENT_4 */

/* COMMENT_5 */
                                                                    
                                     
  
        VAR_15  =  (int) (VAR_19 * VAR_0->x_pixels_per_inch) - 60;
        VAR_15 = (VAR_15 >> 3) << 3;
        VAR_17 = VAR_15;

        gp_fwrite(""\035"",1,1,VAR_1);
        gp_fprintf(VAR_1,""%d"",VAR_15);
        gp_fwrite(""X"",1,1,VAR_1);

        /* COMMENT_9 */
        gp_fwrite(""\0353bcI"",1,5,VAR_1);

        VAR_10 = VAR_20 * VAR_0->y_pixels_per_inch;
        VAR_11 = VAR_0->height - VAR_21 * VAR_0->y_pixels_per_inch;

        VAR_12  = ( (int) (VAR_19 * VAR_0->x_pixels_per_inch) ) >> 3 ;
        VAR_13 = ((VAR_0->width - (int)(VAR_22 * VAR_0->x_pixels_per_inch)) >> 3) - VAR_12;

        /* COMMENT_10 */
                          
          

        for ( VAR_9 = VAR_10; VAR_9 < VAR_11 ; )

        {
                byte *VAR_23;
                byte *VAR_24;
                byte *VAR_25;
                byte *VAR_26;
                register byte *VAR_27, *VAR_28;

                /* COMMENT_13 */
                                           
                  

                gdev_prn_get_bits(VAR_0, VAR_9, VAR_7, &VAR_23);
                while ( VAR_23[0] == 0 &&
                        !memcmp((char *)VAR_23, (char *)VAR_23 + 1, VAR_2 - 1) &&
                        VAR_9 < VAR_11 )
                {
                        VAR_9++;
                        gdev_prn_get_bits(VAR_0, VAR_9, VAR_7, &VAR_23);
                }

                if(VAR_9 == VAR_11 ) break;
                /* COMMENT_16 */

                (void)gdev_prn_copy_scan_lines(VAR_0, VAR_9, VAR_7, VAR_3);

                VAR_24 = VAR_7  + VAR_12;
                VAR_25 = VAR_24 + VAR_13;

/* COMMENT_17 */

                while (VAR_25 > VAR_24 &&  VAR_25[-1] == 0)
                {
                VAR_25--;
                }

/* COMMENT_18 */

        for(VAR_16 = 0; VAR_24 < VAR_25 && VAR_24[0] == 0; VAR_24++,VAR_16++);

/* COMMENT_19 */

        VAR_16 = VAR_15 + (VAR_16 << 3);

/* COMMENT_20 */

                VAR_26 = VAR_8;

 for( VAR_27 = VAR_24, VAR_28 = VAR_24 + 1 ; VAR_28 < VAR_25 ; )
        {
        if( *VAR_27 != *VAR_28++ )
          {
          /* COMMENT_21 */
                                 
                              
            
          *VAR_26++ = *VAR_27++;
          }
          else
            {
                for (VAR_14 = 2; ( *VAR_27 == *VAR_28 ) && (VAR_28 < VAR_25); VAR_28++, VAR_14++)
                {}

                /* COMMENT_25 */
                                                                    
                                                                        
                                            
                  

                while (VAR_14 > 257)
                {
                *VAR_26++ = *VAR_27;
                *VAR_26++ = *VAR_27;
                *VAR_26++ = 255;
                VAR_27 += 257;
                VAR_14 -=257;
                }
                *VAR_26++ = *VAR_27;
                *VAR_26++ = *VAR_27;
                *VAR_26++ = VAR_14 - 2;
                VAR_27 += VAR_14;
                VAR_28 = VAR_27+1;
            }
        }

/* COMMENT_30 */
                              

if (VAR_27 == (VAR_25 - 1)) *VAR_26++ = *VAR_27;

/* COMMENT_32 */

/* COMMENT_33 */

if (VAR_16 != VAR_17)
        {
        VAR_17 = VAR_16;
        gp_fwrite(""\035"",1,1,VAR_1);
        gp_fprintf(VAR_1,""%d"",VAR_16);
        gp_fwrite(""X"",1,1,VAR_1);
        }

/* COMMENT_34 */
                                              
  

        gp_fwrite(""\035"",1,1,VAR_1);
        gp_fprintf(VAR_1,""%d"",VAR_9-60);
        gp_fwrite(""Y\035"",1,2,VAR_1);
        VAR_4 = VAR_26 - VAR_8;
        gp_fprintf(VAR_1,""%d;"",VAR_4);
        VAR_4 = (VAR_25 - VAR_24) << 3;
        gp_fprintf(VAR_1,""%d;"",VAR_4);
        gp_fwrite(""1;0bi{I"",1,7,VAR_1);
        gp_fwrite(VAR_8,1,(VAR_26 - VAR_8),VAR_1);

        VAR_9++;

        }

/* COMMENT_37 */

        gp_fwrite(""\0350bcI"",1,5,VAR_1);
        gp_fwrite(""\0351coO"",1,5,VAR_1);
        gp_fwrite(""\035rhE"",1,4,VAR_1);

        gp_fwrite(""\033\001@EJL \n"",1,8,VAR_1);
        gp_fwrite(""@EJL SE LA=ESC/PAGE\n"",1,20,VAR_1);
        gp_fwrite(""@EJL SET PU=1 PS=A4 ZO=OFF\n"",1,27,VAR_1);
        gp_fwrite(""@EJL EN LA=ESC/PAGE\n"",1,20,VAR_1);
        gp_fwrite(""\0350;0.24muE\0352;300;300drE"",1,23,VAR_1);
        gp_fwrite(""\0350;300;300drE\0351tsE\0351mmE"",1,23,VAR_1);
        gp_fwrite(""\0357isE\0355iaF\0355ipP\03514psE\0350poE"",1,26,VAR_1);
        gp_fwrite(""\03560;60loE\0350X\0350Y"",1,15,VAR_1);
        gp_fwrite(""\0350;0;2360;3388caE"",1,17,VAR_1);
        gp_fwrite(""\0351cmE\0350alfP"",1,11,VAR_1);
        gp_fwrite(""\0350affP\0350boP\0350abP"",1,16,VAR_1);
        gp_fwrite(""\0354ilG\0350bcI\0350sarG"",1,16,VAR_1);
        gp_fwrite(""\035rhE"",1,4,VAR_1);
        gp_fwrite(""\033\001@EJL \n"",1,8,VAR_1);
        gp_fwrite(""\033\001@EJL \n"",1,8,VAR_1);

        gp_fflush(VAR_1);

        gs_free(VAR_0->memory, (char *)VAR_6, VAR_3, 1, ""lp8000_print_page(buf2)"");
        gs_free(VAR_0->memory, (char *)VAR_5, VAR_3, 1, ""lp8000_print_page(buf1)"");
        return 0;
}",ArtifexSoftware/ghostpdl/4f6bc662909ab79e8fbe9822afb36e8a0eafc2b7/gdevlp8k.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,7 +7,10 @@
         unsigned int report_size;
 
         byte *buf1 = (byte *)gs_malloc(pdev->memory, in_size, 1, ""lp8000_print_page(buf1)"");
-        byte *buf2 = (byte *)gs_malloc(pdev->memory, in_size, 1, ""lp8000_print_page(buf2)"");
+
+        /* Worst case for rle compression below is 3 bytes for each 2 bytes of
+        input, with extra final byte. */
+        byte *buf2 = (byte *)gs_malloc(pdev->memory, in_size * 3 / 2 + 2, 1, ""lp8000_print_page(buf2)"");
         byte *in = buf1;
         byte *out = buf2;
 ","{'deleted_lines': ['        byte *buf2 = (byte *)gs_malloc(pdev->memory, in_size, 1, ""lp8000_print_page(buf2)"");'], 'added_lines': ['', '        /* Worst case for rle compression below is 3 bytes for each 2 bytes of', '        input, with extra final byte. */', '        byte *buf2 = (byte *)gs_malloc(pdev->memory, in_size * 3 / 2 + 2, 1, ""lp8000_print_page(buf2)"");']}",True,"A heap-based buffer overwrite vulnerability was found in GhostScript's lp8000_print_page() function in the gdevlp8k.c file. This flaw allows an attacker to trick a user into opening a crafted PDF file, triggering the heap buffer overflow that could lead to memory corruption or a denial of service.",7.1,HIGH,2,test,2019-11-06T12:41:28Z,3
CVE-2019-19391,['CWE-843'],AV:N/AC:L/Au:N/C:P/I:P/A:N,0,LuaJIT,Fix vulnerability in debug.getinfo,c017b2bafc24f71620de7225c5fdcd4a71ff2593,https://github.com/LuaJIT/LuaJIT/commit/c017b2bafc24f71620de7225c5fdcd4a71ff2593,src/lj_debug.c,lj_debug_getinfo,"int lj_debug_getinfo(lua_State *L, const char *what, lj_Debug *ar, int ext)
{
int opt_f = 0, opt_L = 0;
TValue *frame = NULL;
TValue *nextframe = NULL;
GCfunc *fn;
if (*what == '>') {
TValue *func = L->top - 1;
api_check(L, tvisfunc(func));
fn = funcV(func);
L->top--;
what++;
} else {
uint32_t offset = (uint32_t)ar->i_ci & 0xffff;
uint32_t size = (uint32_t)ar->i_ci >> 16;
lua_assert(offset != 0);
frame = tvref(L->stack) + offset;
if (size) nextframe = frame + size;
lua_assert(frame <= tvref(L->maxstack) &&
(!nextframe || nextframe <= tvref(L->maxstack)));
fn = frame_func(frame);
lua_assert(fn->c.gct == ~LJ_TFUNC);
}
for (; *what; what++) {
if (*what == 'S') {
if (isluafunc(fn)) {
GCproto *pt = funcproto(fn);
BCLine firstline = pt->firstline;
GCstr *name = proto_chunkname(pt);
ar->source = strdata(name);
lj_debug_shortname(ar->short_src, name, pt->firstline);
ar->linedefined = (int)firstline;
ar->lastlinedefined = (int)(firstline + pt->numline);
ar->what = (firstline || !pt->numline) ? ""Lua"" : ""main"";
} else {
ar->source = ""=[C]"";
ar->short_src[0] = '[';
ar->short_src[1] = 'C';
ar->short_src[2] = ']';
ar->short_src[3] = '\0';
ar->linedefined = -1;
ar->lastlinedefined = -1;
ar->what = ""C"";
}
} else if (*what == 'l') {
ar->currentline = frame ? debug_frameline(L, fn, nextframe) : -1;
} else if (*what == 'u') {
ar->nups = fn->c.nupvalues;
if (ext) {
if (isluafunc(fn)) {
GCproto *pt = funcproto(fn);
ar->nparams = pt->numparams;
ar->isvararg = !!(pt->flags & PROTO_VARARG);
} else {
ar->nparams = 0;
ar->isvararg = 1;
}
}
} else if (*what == 'n') {
ar->namewhat = frame ? lj_debug_funcname(L, frame, &ar->name) : NULL;
if (ar->namewhat == NULL) {
ar->namewhat = """";
ar->name = NULL;
}
} else if (*what == 'f') {
opt_f = 1;
} else if (*what == 'L') {
opt_L = 1;
} else {
return 0;  
}
}
if (opt_f) {
setfuncV(L, L->top, fn);
incr_top(L);
}
if (opt_L) {
if (isluafunc(fn)) {
GCtab *t = lj_tab_new(L, 0, 0);
GCproto *pt = funcproto(fn);
const void *lineinfo = proto_lineinfo(pt);
if (lineinfo) {
BCLine first = pt->firstline;
int sz = pt->numline < 256 ? 1 : pt->numline < 65536 ? 2 : 4;
MSize i, szl = pt->sizebc-1;
for (i = 0; i < szl; i++) {
BCLine line = first +
(sz == 1 ? (BCLine)((const uint8_t *)lineinfo)[i] :
sz == 2 ? (BCLine)((const uint16_t *)lineinfo)[i] :
(BCLine)((const uint32_t *)lineinfo)[i]);
setboolV(lj_tab_setint(L, t, line), 1);
}
}
settabV(L, L->top, t);
} else {
setnilV(L->top);
}
incr_top(L);
}
return 1;  
}","int lj_debug_getinfo(lua_State *VAR_0, const char *VAR_1, lj_Debug *VAR_2, int VAR_3)
{
int VAR_4 = 0, VAR_5 = 0;
TValue *VAR_6 = NULL;
TValue *VAR_7 = NULL;
GCfunc *VAR_8;
if (*VAR_1 == '>') {
TValue *VAR_9 = VAR_0->top - 1;
api_check(VAR_0, tvisfunc(VAR_9));
VAR_8 = funcV(VAR_9);
VAR_0->top--;
VAR_1++;
} else {
uint32_t VAR_10 = (uint32_t)VAR_2->i_ci & 0xffff;
uint32_t VAR_11 = (uint32_t)VAR_2->i_ci >> 16;
lua_assert(VAR_10 != 0);
VAR_6 = tvref(VAR_0->stack) + VAR_10;
if (VAR_11) VAR_7 = VAR_6 + VAR_11;
lua_assert(VAR_6 <= tvref(VAR_0->maxstack) &&
(!VAR_7 || VAR_7 <= tvref(VAR_0->maxstack)));
VAR_8 = frame_func(VAR_6);
lua_assert(VAR_8->c.gct == ~VAR_12);
}
for (; *VAR_1; VAR_1++) {
if (*VAR_1 == 'S') {
if (isluafunc(VAR_8)) {
GCproto *VAR_13 = funcproto(VAR_8);
BCLine VAR_14 = VAR_13->firstline;
GCstr *VAR_15 = proto_chunkname(VAR_13);
VAR_2->source = strdata(VAR_15);
lj_debug_shortname(VAR_2->short_src, VAR_15, VAR_13->firstline);
VAR_2->linedefined = (int)VAR_14;
VAR_2->lastlinedefined = (int)(VAR_14 + VAR_13->numline);
VAR_2->what = (VAR_14 || !VAR_13->numline) ? ""Lua"" : ""main"";
} else {
VAR_2->source = ""=[C]"";
VAR_2->short_src[0] = '[';
VAR_2->short_src[1] = 'C';
VAR_2->short_src[2] = ']';
VAR_2->short_src[3] = '\0';
VAR_2->linedefined = -1;
VAR_2->lastlinedefined = -1;
VAR_2->what = ""C"";
}
} else if (*VAR_1 == 'l') {
VAR_2->currentline = VAR_6 ? debug_frameline(VAR_0, VAR_8, VAR_7) : -1;
} else if (*VAR_1 == 'u') {
VAR_2->nups = VAR_8->c.nupvalues;
if (VAR_3) {
if (isluafunc(VAR_8)) {
GCproto *VAR_13 = funcproto(VAR_8);
VAR_2->nparams = VAR_13->numparams;
VAR_2->isvararg = !!(VAR_13->flags & VAR_16);
} else {
VAR_2->nparams = 0;
VAR_2->isvararg = 1;
}
}
} else if (*VAR_1 == 'n') {
VAR_2->namewhat = VAR_6 ? lj_debug_funcname(VAR_0, VAR_6, &VAR_2->name) : NULL;
if (VAR_2->namewhat == NULL) {
VAR_2->namewhat = """";
VAR_2->name = NULL;
}
} else if (*VAR_1 == 'f') {
VAR_4 = 1;
} else if (*VAR_1 == 'L') {
VAR_5 = 1;
} else {
return 0;  
}
}
if (VAR_4) {
setfuncV(VAR_0, VAR_0->top, VAR_8);
incr_top(VAR_0);
}
if (VAR_5) {
if (isluafunc(VAR_8)) {
GCtab *VAR_17 = lj_tab_new(VAR_0, 0, 0);
GCproto *VAR_13 = funcproto(VAR_8);
const void *VAR_18 = proto_lineinfo(VAR_13);
if (VAR_18) {
BCLine VAR_19 = VAR_13->firstline;
int VAR_20 = VAR_13->numline < 256 ? 1 : VAR_13->numline < 65536 ? 2 : 4;
MSize VAR_21, VAR_22 = VAR_13->sizebc-1;
for (VAR_21 = 0; VAR_21 < VAR_22; VAR_21++) {
BCLine VAR_23 = VAR_19 +
(VAR_20 == 1 ? (BCLine)((const uint8_t *)VAR_18)[VAR_21] :
VAR_20 == 2 ? (BCLine)((const uint16_t *)VAR_18)[VAR_21] :
(BCLine)((const uint32_t *)VAR_18)[VAR_21]);
setboolV(lj_tab_setint(VAR_0, VAR_17, VAR_23), 1);
}
}
settabV(VAR_0, VAR_0->top, VAR_17);
} else {
setnilV(VAR_0->top);
}
incr_top(VAR_0);
}
return 1;  
}",LuaJIT/c017b2bafc24f71620de7225c5fdcd4a71ff2593/lj_debug.c/vul/before/0.json,"int lj_debug_getinfo(lua_State *L, const char *what, lj_Debug *ar, int ext)
{
  int opt_f = 0, opt_L = 0;
  TValue *frame = NULL;
  TValue *nextframe = NULL;
  GCfunc *fn;
  if (*what == '>') {
    TValue *func = L->top - 1;
    if (!tvisfunc(func))
	  return 0;
    fn = funcV(func);
    L->top--;
    what++;
  } else {
    uint32_t offset = (uint32_t)ar->i_ci & 0xffff;
    uint32_t size = (uint32_t)ar->i_ci >> 16;
    lua_assert(offset != 0);
    frame = tvref(L->stack) + offset;
    if (size) nextframe = frame + size;
    lua_assert(frame <= tvref(L->maxstack) &&
	       (!nextframe || nextframe <= tvref(L->maxstack)));
    fn = frame_func(frame);
    lua_assert(fn->c.gct == ~LJ_TFUNC);
  }
  for (; *what; what++) {
    if (*what == 'S') {
      if (isluafunc(fn)) {
	GCproto *pt = funcproto(fn);
	BCLine firstline = pt->firstline;
	GCstr *name = proto_chunkname(pt);
	ar->source = strdata(name);
	lj_debug_shortname(ar->short_src, name, pt->firstline);
	ar->linedefined = (int)firstline;
	ar->lastlinedefined = (int)(firstline + pt->numline);
	ar->what = (firstline || !pt->numline) ? ""Lua"" : ""main"";
      } else {
	ar->source = ""=[C]"";
	ar->short_src[0] = '[';
	ar->short_src[1] = 'C';
	ar->short_src[2] = ']';
	ar->short_src[3] = '\0';
	ar->linedefined = -1;
	ar->lastlinedefined = -1;
	ar->what = ""C"";
      }
    } else if (*what == 'l') {
      ar->currentline = frame ? debug_frameline(L, fn, nextframe) : -1;
    } else if (*what == 'u') {
      ar->nups = fn->c.nupvalues;
      if (ext) {
	if (isluafunc(fn)) {
	  GCproto *pt = funcproto(fn);
	  ar->nparams = pt->numparams;
	  ar->isvararg = !!(pt->flags & PROTO_VARARG);
	} else {
	  ar->nparams = 0;
	  ar->isvararg = 1;
	}
      }
    } else if (*what == 'n') {
      ar->namewhat = frame ? lj_debug_funcname(L, frame, &ar->name) : NULL;
      if (ar->namewhat == NULL) {
	ar->namewhat = """";
	ar->name = NULL;
      }
    } else if (*what == 'f') {
      opt_f = 1;
    } else if (*what == 'L') {
      opt_L = 1;
    } else {
      return 0;  /* Bad option. */
    }
  }
  if (opt_f) {
    setfuncV(L, L->top, fn);
    incr_top(L);
  }
  if (opt_L) {
    if (isluafunc(fn)) {
      GCtab *t = lj_tab_new(L, 0, 0);
      GCproto *pt = funcproto(fn);
      const void *lineinfo = proto_lineinfo(pt);
      if (lineinfo) {
	BCLine first = pt->firstline;
	int sz = pt->numline < 256 ? 1 : pt->numline < 65536 ? 2 : 4;
	MSize i, szl = pt->sizebc-1;
	for (i = 0; i < szl; i++) {
	  BCLine line = first +
	    (sz == 1 ? (BCLine)((const uint8_t *)lineinfo)[i] :
	     sz == 2 ? (BCLine)((const uint16_t *)lineinfo)[i] :
	     (BCLine)((const uint32_t *)lineinfo)[i]);
	  setboolV(lj_tab_setint(L, t, line), 1);
	}
      }
      settabV(L, L->top, t);
    } else {
      setnilV(L->top);
    }
    incr_top(L);
  }
  return 1;  /* Ok. */
}","int lj_debug_getinfo(lua_State *VAR_0, const char *VAR_1, lj_Debug *VAR_2, int VAR_3)
{
  int VAR_4 = 0, VAR_5 = 0;
  TValue *VAR_6 = NULL;
  TValue *VAR_7 = NULL;
  GCfunc *VAR_8;
  if (*VAR_1 == '>') {
    TValue *VAR_9 = VAR_0->top - 1;
    if (!tvisfunc(VAR_9))
	  return 0;
    VAR_8 = funcV(VAR_9);
    VAR_0->top--;
    VAR_1++;
  } else {
    uint32_t VAR_10 = (uint32_t)VAR_2->i_ci & 0xffff;
    uint32_t VAR_11 = (uint32_t)VAR_2->i_ci >> 16;
    lua_assert(VAR_10 != 0);
    VAR_6 = tvref(VAR_0->stack) + VAR_10;
    if (VAR_11) VAR_7 = VAR_6 + VAR_11;
    lua_assert(VAR_6 <= tvref(VAR_0->maxstack) &&
	       (!VAR_7 || VAR_7 <= tvref(VAR_0->maxstack)));
    VAR_8 = frame_func(VAR_6);
    lua_assert(VAR_8->c.gct == ~VAR_12);
  }
  for (; *VAR_1; VAR_1++) {
    if (*VAR_1 == 'S') {
      if (isluafunc(VAR_8)) {
	GCproto *VAR_13 = funcproto(VAR_8);
	BCLine VAR_14 = VAR_13->firstline;
	GCstr *VAR_15 = proto_chunkname(VAR_13);
	VAR_2->source = strdata(VAR_15);
	lj_debug_shortname(VAR_2->short_src, VAR_15, VAR_13->firstline);
	VAR_2->linedefined = (int)VAR_14;
	VAR_2->lastlinedefined = (int)(VAR_14 + VAR_13->numline);
	VAR_2->what = (VAR_14 || !VAR_13->numline) ? ""Lua"" : ""main"";
      } else {
	VAR_2->source = ""=[C]"";
	VAR_2->short_src[0] = '[';
	VAR_2->short_src[1] = 'C';
	VAR_2->short_src[2] = ']';
	VAR_2->short_src[3] = '\0';
	VAR_2->linedefined = -1;
	VAR_2->lastlinedefined = -1;
	VAR_2->what = ""C"";
      }
    } else if (*VAR_1 == 'l') {
      VAR_2->currentline = VAR_6 ? debug_frameline(VAR_0, VAR_8, VAR_7) : -1;
    } else if (*VAR_1 == 'u') {
      VAR_2->nups = VAR_8->c.nupvalues;
      if (VAR_3) {
	if (isluafunc(VAR_8)) {
	  GCproto *VAR_13 = funcproto(VAR_8);
	  VAR_2->nparams = VAR_13->numparams;
	  VAR_2->isvararg = !!(VAR_13->flags & VAR_16);
	} else {
	  VAR_2->nparams = 0;
	  VAR_2->isvararg = 1;
	}
      }
    } else if (*VAR_1 == 'n') {
      VAR_2->namewhat = VAR_6 ? lj_debug_funcname(VAR_0, VAR_6, &VAR_2->name) : NULL;
      if (VAR_2->namewhat == NULL) {
	VAR_2->namewhat = """";
	VAR_2->name = NULL;
      }
    } else if (*VAR_1 == 'f') {
      VAR_4 = 1;
    } else if (*VAR_1 == 'L') {
      VAR_5 = 1;
    } else {
      return 0;  /* COMMENT_0 */
    }
  }
  if (VAR_4) {
    setfuncV(VAR_0, VAR_0->top, VAR_8);
    incr_top(VAR_0);
  }
  if (VAR_5) {
    if (isluafunc(VAR_8)) {
      GCtab *VAR_17 = lj_tab_new(VAR_0, 0, 0);
      GCproto *VAR_13 = funcproto(VAR_8);
      const void *VAR_18 = proto_lineinfo(VAR_13);
      if (VAR_18) {
	BCLine VAR_19 = VAR_13->firstline;
	int VAR_20 = VAR_13->numline < 256 ? 1 : VAR_13->numline < 65536 ? 2 : 4;
	MSize VAR_21, VAR_22 = VAR_13->sizebc-1;
	for (VAR_21 = 0; VAR_21 < VAR_22; VAR_21++) {
	  BCLine VAR_23 = VAR_19 +
	    (VAR_20 == 1 ? (BCLine)((const uint8_t *)VAR_18)[VAR_21] :
	     VAR_20 == 2 ? (BCLine)((const uint16_t *)VAR_18)[VAR_21] :
	     (BCLine)((const uint32_t *)VAR_18)[VAR_21]);
	  setboolV(lj_tab_setint(VAR_0, VAR_17, VAR_23), 1);
	}
      }
      settabV(VAR_0, VAR_0->top, VAR_17);
    } else {
      setnilV(VAR_0->top);
    }
    incr_top(VAR_0);
  }
  return 1;  /* COMMENT_1 */
}",LuaJIT/c017b2bafc24f71620de7225c5fdcd4a71ff2593/lj_debug.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,8 @@
   GCfunc *fn;
   if (*what == '>') {
     TValue *func = L->top - 1;
-    api_check(L, tvisfunc(func));
+    if (!tvisfunc(func))
+	  return 0;
     fn = funcV(func);
     L->top--;
     what++;","{'deleted_lines': ['    api_check(L, tvisfunc(func));'], 'added_lines': ['    if (!tvisfunc(func))', '\t  return 0;']}",True,"In LuaJIT through 2.0.5, as used in Moonjit before 2.1.2 and other products, debug.getinfo has a type confusion issue that leads to arbitrary memory write or read operations, because certain cases involving valid stack levels and > options are mishandled. NOTE: The LuaJIT project owner states that the debug libary is unsafe by definition and that this is not a vulnerability. When LuaJIT was originally developed, the expectation was that the entire debug library had no security guarantees and thus it made no sense to assign CVEs. However, not all users of later LuaJIT derivatives share this perspective",9.1,CRITICAL,3,test,2019-11-13T09:51:40Z,3
CVE-2019-11046,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0,php/php-src,"Fix #78878: Buffer underflow in bc_shift_addsub

We must not rely on `isdigit()` to detect digits, since we only support
decimal ASCII digits in the following processing.

(cherry picked from commit eb23c6008753b1cdc5359dead3a096dce46c9018)",2d07f00b73d8f94099850e0f5983e1cc5817c196,https://github.com/php/php-src/commit/2d07f00b73d8f94099850e0f5983e1cc5817c196,ext/bcmath/libbcmath/src/str2num.c,bc_str2num,"void
bc_str2num (bc_num *num, char *str, int scale)
{
int digits, strscale;
char *ptr, *nptr;
char zero_int;
bc_free_num (num);
ptr = str;
digits = 0;
strscale = 0;
zero_int = FALSE;
if ( (*ptr == '+') || (*ptr == '-'))  ptr++;  
while (*ptr == '0') ptr++;
while (isdigit((int)*ptr)) ptr++, digits++;
if (*ptr == '.') ptr++;
while (isdigit((int)*ptr)) ptr++, strscale++;
if ((*ptr != '\0') || (digits+strscale == 0))
{
*num = bc_copy_num (BCG(_zero_));
return;
}
strscale = MIN(strscale, scale);
if (digits == 0)
{
zero_int = TRUE;
digits = 1;
}
*num = bc_new_num (digits, strscale);
ptr = str;
if (*ptr == '-')
{
(*num)->n_sign = MINUS;
ptr++;
}
else
{
(*num)->n_sign = PLUS;
if (*ptr == '+') ptr++;
}
while (*ptr == '0') ptr++;
nptr = (*num)->n_value;
if (zero_int)
{
*nptr++ = 0;
digits = 0;
}
for (;digits > 0; digits--)
*nptr++ = CH_VAL(*ptr++);
if (strscale > 0)
{
ptr++;  
for (;strscale > 0; strscale--)
*nptr++ = CH_VAL(*ptr++);
}
if (bc_is_zero (*num))
(*num)->n_sign = PLUS;
}","void
bc_str2num (bc_num *VAR_0, char *VAR_1, int VAR_2)
{
int VAR_3, VAR_4;
char *VAR_5, *VAR_6;
char VAR_7;
bc_free_num (VAR_0);
VAR_5 = VAR_1;
VAR_3 = 0;
VAR_4 = 0;
VAR_7 = FALSE;
if ( (*VAR_5 == '+') || (*VAR_5 == '-'))  VAR_5++;  
while (*VAR_5 == '0') VAR_5++;
while (isdigit((int)*VAR_5)) VAR_5++, VAR_3++;
if (*VAR_5 == '.') VAR_5++;
while (isdigit((int)*VAR_5)) VAR_5++, VAR_4++;
if ((*VAR_5 != '\0') || (VAR_3+VAR_4 == 0))
{
*VAR_0 = bc_copy_num (BCG(VAR_8));
return;
}
VAR_4 = MIN(VAR_4, VAR_2);
if (VAR_3 == 0)
{
VAR_7 = TRUE;
VAR_3 = 1;
}
*VAR_0 = bc_new_num (VAR_3, VAR_4);
VAR_5 = VAR_1;
if (*VAR_5 == '-')
{
(*VAR_0)->n_sign = VAR_9;
VAR_5++;
}
else
{
(*VAR_0)->n_sign = VAR_10;
if (*VAR_5 == '+') VAR_5++;
}
while (*VAR_5 == '0') VAR_5++;
VAR_6 = (*VAR_0)->n_value;
if (VAR_7)
{
*VAR_6++ = 0;
VAR_3 = 0;
}
for (;VAR_3 > 0; VAR_3--)
*VAR_6++ = CH_VAL(*VAR_5++);
if (VAR_4 > 0)
{
VAR_5++;  
for (;VAR_4 > 0; VAR_4--)
*VAR_6++ = CH_VAL(*VAR_5++);
}
if (bc_is_zero (*VAR_0))
(*VAR_0)->n_sign = VAR_10;
}",php/php-src/2d07f00b73d8f94099850e0f5983e1cc5817c196/str2num.c/vul/before/0.json,"void
bc_str2num (bc_num *num, char *str, int scale)
{
  int digits, strscale;
  char *ptr, *nptr;
  char zero_int;

  /* Prepare num. */
  bc_free_num (num);

  /* Check for valid number and count digits. */
  ptr = str;
  digits = 0;
  strscale = 0;
  zero_int = FALSE;
  if ( (*ptr == '+') || (*ptr == '-'))  ptr++;  /* Sign */
  while (*ptr == '0') ptr++;			/* Skip leading zeros. */
  while (*ptr >= '0' && *ptr <= '9') ptr++, digits++;	/* digits */
  if (*ptr == '.') ptr++;			/* decimal point */
  while (*ptr >= '0' && *ptr <= '9') ptr++, strscale++;	/* digits */
  if ((*ptr != '\0') || (digits+strscale == 0))
    {
      *num = bc_copy_num (BCG(_zero_));
      return;
    }

  /* Adjust numbers and allocate storage and initialize fields. */
  strscale = MIN(strscale, scale);
  if (digits == 0)
    {
      zero_int = TRUE;
      digits = 1;
    }
  *num = bc_new_num (digits, strscale);

  /* Build the whole number. */
  ptr = str;
  if (*ptr == '-')
    {
      (*num)->n_sign = MINUS;
      ptr++;
    }
  else
    {
      (*num)->n_sign = PLUS;
      if (*ptr == '+') ptr++;
    }
  while (*ptr == '0') ptr++;			/* Skip leading zeros. */
  nptr = (*num)->n_value;
  if (zero_int)
    {
      *nptr++ = 0;
      digits = 0;
    }
  for (;digits > 0; digits--)
    *nptr++ = CH_VAL(*ptr++);


  /* Build the fractional part. */
  if (strscale > 0)
    {
      ptr++;  /* skip the decimal point! */
      for (;strscale > 0; strscale--)
	*nptr++ = CH_VAL(*ptr++);
    }

  if (bc_is_zero (*num))
    (*num)->n_sign = PLUS;
}","void
bc_str2num (bc_num *VAR_0, char *VAR_1, int VAR_2)
{
  int VAR_3, VAR_4;
  char *VAR_5, *VAR_6;
  char VAR_7;

  /* COMMENT_0 */
  bc_free_num (VAR_0);

  /* COMMENT_1 */
  VAR_5 = VAR_1;
  VAR_3 = 0;
  VAR_4 = 0;
  VAR_7 = FALSE;
  if ( (*VAR_5 == '+') || (*VAR_5 == '-'))  VAR_5++;  /* COMMENT_2 */
  while (*VAR_5 == '0') VAR_5++;			/* COMMENT_3 */
  while (*VAR_5 >= '0' && *VAR_5 <= '9') VAR_5++, VAR_3++;	/* COMMENT_4 */
  if (*VAR_5 == '.') VAR_5++;			/* COMMENT_5 */
  while (*VAR_5 >= '0' && *VAR_5 <= '9') VAR_5++, VAR_4++;	/* COMMENT_4 */
  if ((*VAR_5 != '\0') || (VAR_3+VAR_4 == 0))
    {
      *VAR_0 = bc_copy_num (BCG(VAR_8));
      return;
    }

  /* COMMENT_6 */
  VAR_4 = MIN(VAR_4, VAR_2);
  if (VAR_3 == 0)
    {
      VAR_7 = TRUE;
      VAR_3 = 1;
    }
  *VAR_0 = bc_new_num (VAR_3, VAR_4);

  /* COMMENT_7 */
  VAR_5 = VAR_1;
  if (*VAR_5 == '-')
    {
      (*VAR_0)->n_sign = VAR_9;
      VAR_5++;
    }
  else
    {
      (*VAR_0)->n_sign = VAR_10;
      if (*VAR_5 == '+') VAR_5++;
    }
  while (*VAR_5 == '0') VAR_5++;			/* COMMENT_3 */
  VAR_6 = (*VAR_0)->n_value;
  if (VAR_7)
    {
      *VAR_6++ = 0;
      VAR_3 = 0;
    }
  for (;VAR_3 > 0; VAR_3--)
    *VAR_6++ = CH_VAL(*VAR_5++);


  /* COMMENT_8 */
  if (VAR_4 > 0)
    {
      VAR_5++;  /* COMMENT_9 */
      for (;VAR_4 > 0; VAR_4--)
	*VAR_6++ = CH_VAL(*VAR_5++);
    }

  if (bc_is_zero (*VAR_0))
    (*VAR_0)->n_sign = VAR_10;
}",php/php-src/2d07f00b73d8f94099850e0f5983e1cc5817c196/str2num.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,9 +15,9 @@
   zero_int = FALSE;
   if ( (*ptr == '+') || (*ptr == '-'))  ptr++;  /* Sign */
   while (*ptr == '0') ptr++;			/* Skip leading zeros. */
-  while (isdigit((int)*ptr)) ptr++, digits++;	/* digits */
+  while (*ptr >= '0' && *ptr <= '9') ptr++, digits++;	/* digits */
   if (*ptr == '.') ptr++;			/* decimal point */
-  while (isdigit((int)*ptr)) ptr++, strscale++;	/* digits */
+  while (*ptr >= '0' && *ptr <= '9') ptr++, strscale++;	/* digits */
   if ((*ptr != '\0') || (digits+strscale == 0))
     {
       *num = bc_copy_num (BCG(_zero_));","{'deleted_lines': ['  while (isdigit((int)*ptr)) ptr++, digits++;\t/* digits */', '  while (isdigit((int)*ptr)) ptr++, strscale++;\t/* digits */'], 'added_lines': [""  while (*ptr >= '0' && *ptr <= '9') ptr++, digits++;\t/* digits */"", ""  while (*ptr >= '0' && *ptr <= '9') ptr++, strscale++;\t/* digits */""]}",True,"In PHP versions 7.2.x below 7.2.26, 7.3.x below 7.3.13 and 7.4.0, PHP bcmath extension functions on some systems, including Windows, can be tricked into reading beyond the allocated space by supplying it with string containing characters that are identified as numeric by the OS but aren't ASCII numbers. This can read to disclosure of the content of some memory locations.",3.7,LOW,0,test,2019-11-30T11:26:37Z,3
CVE-2020-7045,['CWE-476'],AV:A/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"btatt: check the opcode against the current data.

While here:
- some indentation fixes
- add defines for missing ATT_OPCODEs

Bug: 16258
Change-Id: I2cd8172bcff9c209bbddc4729573c008a8e81fec
Reviewed-on: https://code.wireshark.org/review/35339
Petri-Dish: Dario Lombardo <lomato@gmail.com>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 68a7add68a725203cccf98d7d6c752a6bad866c0)
Reviewed-on: https://code.wireshark.org/review/35387
Reviewed-by: Dario Lombardo <lomato@gmail.com>",01f261de41f4dd3233ef578e5c0ffb9c25c7d14d,https://github.com/wireshark/wireshark/commit/01f261de41f4dd3233ef578e5c0ffb9c25c7d14d,epan/dissectors/packet-btatt.c,dissect_btatt,"static int
dissect_btatt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
proto_item        *main_item;
proto_tree        *main_tree;
proto_item        *sub_item;
proto_tree        *sub_tree;
int                offset = 0;
guint8             opcode;
guint8             request_opcode;
bluetooth_data_t  *bluetooth_data;
btatt_data_t       att_data;
request_data_t    *request_data;
guint16            handle;
bluetooth_uuid_t   uuid;
guint              mtu;
memset(&uuid, 0, sizeof uuid);
bluetooth_data = (bluetooth_data_t *) data;
if (tvb_reported_length_remaining(tvb, 0) < 1)
return 0;
att_data.bluetooth_data   = bluetooth_data;
main_item = proto_tree_add_item(tree, proto_btatt, tvb, 0, -1, ENC_NA);
main_tree = proto_item_add_subtree(main_item, ett_btatt);
col_set_str(pinfo->cinfo, COL_PROTOCOL, ""ATT"");
switch (pinfo->p2p_dir) {
case P2P_DIR_SENT:
col_set_str(pinfo->cinfo, COL_INFO, ""Sent "");
break;
case P2P_DIR_RECV:
col_set_str(pinfo->cinfo, COL_INFO, ""Rcvd "");
break;
default:
col_set_str(pinfo->cinfo, COL_INFO, ""UnknownDirection "");
break;
}
mtu = get_mtu(pinfo, bluetooth_data);
if (tvb_reported_length(tvb) > mtu)
expert_add_info(pinfo, main_item, &ei_btatt_mtu_exceeded);
proto_tree_add_bitmask_with_flags(main_tree, tvb, offset, hf_btatt_opcode, ett_btatt_opcode,  hfx_btatt_opcode, ENC_NA, BMT_NO_APPEND);
opcode = tvb_get_guint8(tvb, 0);
att_data.opcode = opcode;
offset++;
request_data = get_request(tvb, offset, pinfo, opcode, bluetooth_data);
col_append_str(pinfo->cinfo, COL_INFO, val_to_str_const(opcode, opcode_vals, ""<unknown>""));
switch (opcode) {
case 0x01: 
{
guint8               error_code;
bluetooth_uuid_t     service_uuid;
const value_string  *error_vals = error_code_vals;
gint                 hfx_btatt_error_code = hf_btatt_error_code;
proto_tree_add_bitmask_with_flags(main_tree, tvb, offset, hf_btatt_req_opcode_in_error, ett_btatt_opcode,  hfx_btatt_opcode, ENC_NA, BMT_NO_APPEND);
request_opcode = tvb_get_guint8(tvb, offset);
offset += 1;
offset = dissect_handle(main_tree, pinfo, hf_btatt_handle_in_error, tvb, offset, bluetooth_data, NULL, HANDLE_TVB);
handle = tvb_get_letohs(tvb, offset - 2);
error_code = tvb_get_guint8(tvb, offset);
if (error_code >= 0x80 && error_code <= 0x9F) {
service_uuid = get_service_uuid_from_handle(pinfo, handle, bluetooth_data);
switch (service_uuid.bt_uuid) {
case GATT_SERVICE_AUTOMATION_IO:
error_vals = error_code_aios_vals;
hfx_btatt_error_code = hf_btatt_error_code_aios;
break;
case GATT_SERVICE_ALERT_NOTIFICATION_SERVICE:
error_vals = error_code_ans_vals;
hfx_btatt_error_code = hf_btatt_error_code_ans;
break;
case GATT_SERVICE_BOND_MANAGEMENT:
error_vals = error_code_bms_vals;
hfx_btatt_error_code = hf_btatt_error_code_bms;
break;
case GATT_SERVICE_CONTINUOUS_GLUCOSE_MONITORING:
error_vals = error_code_cgms_vals;
hfx_btatt_error_code = hf_btatt_error_code_cgms;
break;
case GATT_SERVICE_CYCLING_POWER:
error_vals = error_code_cps_vals;
hfx_btatt_error_code = hf_btatt_error_code_cps;
break;
case GATT_SERVICE_CYCLING_SPEED_AND_CADENCE:
error_vals = error_code_cscs_vals;
hfx_btatt_error_code = hf_btatt_error_code_cscs;
break;
case GATT_SERVICE_CURRENT_TIME_SERVICE:
error_vals = error_code_cts_vals;
hfx_btatt_error_code = hf_btatt_error_code_cts;
break;
case GATT_SERVICE_ENVIRONMENTAL_SENSING:
error_vals = error_code_ess_vals;
hfx_btatt_error_code = hf_btatt_error_code_ess;
break;
case GATT_SERVICE_GLUCOSE:
error_vals = error_code_gls_vals;
hfx_btatt_error_code = hf_btatt_error_code_gls;
break;
case GATT_SERVICE_HTTP_PROXY:
error_vals = error_code_hps_vals;
hfx_btatt_error_code = hf_btatt_error_code_hps;
break;
case GATT_SERVICE_HEART_RATE:
error_vals = error_code_hrs_vals;
hfx_btatt_error_code = hf_btatt_error_code_hrs;
break;
case GATT_SERVICE_HEALTH_THERMOMETER:
error_vals = error_code_hts_vals;
hfx_btatt_error_code = hf_btatt_error_code_hts;
break;
case GATT_SERVICE_INDOOR_POSITIONING:
error_vals = error_code_ips_vals;
hfx_btatt_error_code = hf_btatt_error_code_ips;
break;
case GATT_SERVICE_OBJECT_TRANSFER:
error_vals = error_code_ots_vals;
hfx_btatt_error_code = hf_btatt_error_code_ots;
break;
case GATT_SERVICE_RUNNING_SPEED_AND_CADENCE:
error_vals = error_code_rscs_vals;
hfx_btatt_error_code = hf_btatt_error_code_rscs;
break;
case GATT_SERVICE_USER_DATA:
error_vals = error_code_uds_vals;
hfx_btatt_error_code = hf_btatt_error_code_uds;
break;
default:
error_vals = error_code_vals;
hfx_btatt_error_code = hf_btatt_error_code;
}
}
col_append_fstr(pinfo->cinfo, COL_INFO, "" - %s"",
val_to_str_const(error_code, error_vals, ""<unknown>""));
col_append_info_by_handle(pinfo, handle, bluetooth_data);
proto_tree_add_item(main_tree, hfx_btatt_error_code, tvb, offset, 1, ENC_LITTLE_ENDIAN);
offset++;
if (request_data && (request_opcode == 0x08 || request_opcode == 0x10)) {
sub_item = proto_tree_add_uint(main_tree, hf_btatt_uuid16, tvb, 0, 0, request_data->parameters.read_by_type.uuid.bt_uuid);
proto_item_set_generated(sub_item);
}
}
break;
case 0x02: 
col_append_fstr(pinfo->cinfo, COL_INFO, "", Client Rx MTU: %u"", tvb_get_letohs(tvb, offset));
proto_tree_add_item(main_tree, hf_btatt_client_rx_mtu, tvb, offset, 2, ENC_LITTLE_ENDIAN);
offset += 2;
if (!pinfo->fd->visited && bluetooth_data) {
union request_parameters_union  request_parameters;
request_parameters.mtu.mtu = tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN);
save_request(pinfo, opcode, request_parameters, bluetooth_data);
}
break;
case 0x03: 
col_append_fstr(pinfo->cinfo, COL_INFO, "", Server Rx MTU: %u"", tvb_get_letohs(tvb, offset));
proto_tree_add_item(main_tree, hf_btatt_server_rx_mtu, tvb, offset, 2, ENC_LITTLE_ENDIAN);
if (!pinfo->fd->visited && request_data && bluetooth_data) {
guint new_mtu;
new_mtu = tvb_get_guint16(tvb, offset, ENC_LITTLE_ENDIAN);
if (new_mtu > request_data->parameters.mtu.mtu)
new_mtu = request_data->parameters.mtu.mtu;
save_mtu(pinfo, bluetooth_data, new_mtu);
}
offset += 2;
break;
case 0x04: 
col_append_fstr(pinfo->cinfo, COL_INFO, "", Handles: 0x%04x..0x%04x"",
tvb_get_letohs(tvb, offset), tvb_get_letohs(tvb, offset+2));
proto_tree_add_item(main_tree, hf_btatt_starting_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
offset += 2;
proto_tree_add_item(main_tree, hf_btatt_ending_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
offset += 2;
if (!pinfo->fd->visited && bluetooth_data) {
union request_parameters_union  request_parameters;
request_parameters.find_information.starting_handle = tvb_get_guint16(tvb, offset - 4, ENC_LITTLE_ENDIAN);
request_parameters.find_information.ending_handle   = tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN);
save_request(pinfo, opcode, request_parameters, bluetooth_data);
}
break;
case 0x05: 
{
guint8  format;
sub_item = proto_tree_add_item(main_tree, hf_btatt_uuid_format, tvb, offset, 1, ENC_LITTLE_ENDIAN);
format = tvb_get_guint8(tvb, offset);
offset += 1;
if (format == 1) {
while( tvb_reported_length_remaining(tvb, offset) > 0) {
sub_item = proto_tree_add_item(main_tree, hf_btatt_information_data, tvb, offset, 4, ENC_NA);
sub_tree = proto_item_add_subtree(sub_item, ett_btatt_list);
offset = dissect_handle(sub_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, NULL, HANDLE_TVB);
handle = tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN);
proto_tree_add_item(sub_tree, hf_btatt_uuid16, tvb, offset, 2, ENC_LITTLE_ENDIAN);
uuid = get_uuid(tvb, offset, 2);
offset += 2;
proto_item_append_text(sub_item, "", Handle: 0x%04x, UUID: %s"",
handle, print_uuid(&uuid));
save_handle(pinfo, uuid, handle, ATTRIBUTE_TYPE_OTHER, bluetooth_data);
col_append_info_by_handle(pinfo, handle, bluetooth_data);
}
}
else if (format == 2) {
while( tvb_reported_length_remaining(tvb, offset) > 0) {
sub_item = proto_tree_add_item(main_tree, hf_btatt_information_data, tvb, offset, 4, ENC_NA);
sub_tree = proto_item_add_subtree(sub_item, ett_btatt_list);
offset = dissect_handle(sub_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, NULL, HANDLE_TVB);
handle = tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN);
proto_tree_add_item(sub_tree, hf_btatt_uuid128, tvb, offset, 16, ENC_NA);
uuid = get_uuid(tvb, offset, 16);
offset += 16;
proto_item_append_text(sub_item, "", Handle: 0x%04x, UUID: %s"",
handle, print_uuid(&uuid));
save_handle(pinfo, uuid, handle, ATTRIBUTE_TYPE_OTHER, bluetooth_data);
col_append_info_by_handle(pinfo, handle, bluetooth_data);
}
}
else {
expert_add_info(pinfo, sub_item, &ei_btatt_uuid_format_unknown);
}
}
break;
case 0x06: 
col_append_fstr(pinfo->cinfo, COL_INFO, "", %s, Handles: 0x%04x..0x%04x"",
val_to_str_ext_const(tvb_get_letohs(tvb, offset+4), &bluetooth_uuid_vals_ext, ""<unknown>""),
tvb_get_letohs(tvb, offset), tvb_get_letohs(tvb, offset+2));
proto_tree_add_item(main_tree, hf_btatt_starting_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
offset += 2;
proto_tree_add_item(main_tree, hf_btatt_ending_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
offset += 2;
proto_tree_add_item(main_tree, hf_btatt_uuid16, tvb, offset, 2, ENC_LITTLE_ENDIAN);
uuid = get_uuid(tvb, offset - 2, 2);
offset += 2;
dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, tvb_captured_length_remaining(tvb, offset), 0, uuid, &att_data);
if (!pinfo->fd->visited && bluetooth_data) {
union request_parameters_union  request_parameters;
request_parameters.read_by_type.starting_handle = tvb_get_guint16(tvb, offset - 6, ENC_LITTLE_ENDIAN);
request_parameters.read_by_type.ending_handle   = tvb_get_guint16(tvb, offset - 4, ENC_LITTLE_ENDIAN);
request_parameters.read_by_type.uuid = uuid;
save_request(pinfo, opcode, request_parameters, bluetooth_data);
}
offset = tvb_reported_length(tvb);
break;
case 0x07: 
while( tvb_reported_length_remaining(tvb, offset) > 0 ) {
sub_item = proto_tree_add_none_format(main_tree, hf_btatt_handles_info, tvb, offset, 4,
""Handles Info, Handle: 0x%04x, Group End Handle: 0x%04x"",
tvb_get_letohs(tvb, offset), tvb_get_letohs(tvb, offset+2));
sub_tree = proto_item_add_subtree(sub_item, ett_btatt_list);
offset = dissect_handle(sub_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, NULL, HANDLE_TVB);
proto_tree_add_item(sub_tree, hf_btatt_group_end_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
offset += 2;
if (request_data)
save_handle(pinfo, request_data->parameters.read_by_type.uuid,
tvb_get_guint16(tvb, offset - 4, ENC_LITTLE_ENDIAN),
ATTRIBUTE_TYPE_OTHER, bluetooth_data);
}
break;
case 0x08: 
case 0x10: 
col_append_fstr(pinfo->cinfo, COL_INFO, "", %s, Handles: 0x%04x..0x%04x"",
val_to_str_ext_const(tvb_get_letohs(tvb, offset+4), &bluetooth_uuid_vals_ext, ""<unknown>""),
tvb_get_letohs(tvb, offset), tvb_get_letohs(tvb, offset+2));
proto_tree_add_item(main_tree, hf_btatt_starting_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
offset += 2;
proto_tree_add_item(main_tree, hf_btatt_ending_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
offset += 2;
if (tvb_reported_length_remaining(tvb, offset) == 2) {
proto_tree_add_item(main_tree, hf_btatt_uuid16, tvb, offset, 2, ENC_LITTLE_ENDIAN);
offset += 2;
if (!pinfo->fd->visited && bluetooth_data) {
union request_parameters_union  request_parameters;
request_parameters.read_by_type.starting_handle = tvb_get_guint16(tvb, offset - 6, ENC_LITTLE_ENDIAN);
request_parameters.read_by_type.ending_handle   = tvb_get_guint16(tvb, offset - 4, ENC_LITTLE_ENDIAN);
request_parameters.read_by_type.uuid = get_uuid(tvb, offset - 2, 2);
save_request(pinfo, opcode, request_parameters, bluetooth_data);
}
} else if (tvb_reported_length_remaining(tvb, offset) == 16) {
sub_item = proto_tree_add_item(main_tree, hf_btatt_uuid128, tvb, offset, 16, ENC_NA);
proto_item_append_text(sub_item, "" (%s)"", val_to_str_ext_const(tvb_get_letohs(tvb, offset),
&bluetooth_uuid_vals_ext, ""<unknown>""));
offset += 16;
if (!pinfo->fd->visited && bluetooth_data) {
union request_parameters_union  request_parameters;
request_parameters.read_by_type.starting_handle = tvb_get_guint16(tvb, offset - 20, ENC_LITTLE_ENDIAN);
request_parameters.read_by_type.ending_handle   = tvb_get_guint16(tvb, offset - 18, ENC_LITTLE_ENDIAN);
request_parameters.read_by_type.uuid = get_uuid(tvb, offset - 16, 16);
save_request(pinfo, opcode, request_parameters, bluetooth_data);
}
} else {
sub_item = proto_tree_add_item(tree, hf_btatt_value, tvb, offset, -1, ENC_NA);
expert_add_info(pinfo, sub_item, &ei_btatt_bad_data);
offset = tvb_captured_length(tvb);
}
break;
case 0x09: 
{
guint8  length = tvb_get_guint8(tvb, offset);
proto_tree_add_item(main_tree, hf_btatt_length, tvb, offset, 1, ENC_LITTLE_ENDIAN);
offset++;
if(length > 0) {
col_append_fstr(pinfo->cinfo, COL_INFO, "", Attribute List Length: %u"",
tvb_reported_length_remaining(tvb, offset)/length);
while (tvb_reported_length_remaining(tvb, offset) >= length)
{
sub_item = proto_tree_add_none_format(main_tree, hf_btatt_attribute_data, tvb,
offset, length, ""Attribute Data, Handle: 0x%04x"",
tvb_get_letohs(tvb, offset));
sub_tree = proto_item_add_subtree(sub_item, ett_btatt_list);
if (request_data) {
save_handle(pinfo, request_data->parameters.read_by_type.uuid,
tvb_get_guint16(tvb, offset, ENC_LITTLE_ENDIAN),
ATTRIBUTE_TYPE_OTHER, bluetooth_data);
}
offset = dissect_handle(sub_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, NULL, HANDLE_TVB);
if (request_data) {
offset = dissect_attribute_value(sub_tree, sub_item, pinfo, tvb, offset, length - 2, tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN), request_data->parameters.read_by_type.uuid, &att_data);
} else {
proto_tree_add_item(sub_tree, hf_btatt_value, tvb, offset, length - 2, ENC_NA);
offset += length - 2;
}
}
}
if (request_data) {
sub_item = proto_tree_add_uint(main_tree, hf_btatt_uuid16, tvb, 0, 0, request_data->parameters.read_by_type.uuid.bt_uuid);
proto_item_set_generated(sub_item);
}
}
break;
case 0x0a: 
offset = dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, HANDLE_TVB);
handle = tvb_get_letohs(tvb, offset - 2);
col_append_info_by_handle(pinfo, handle, bluetooth_data);
if (!pinfo->fd->visited && bluetooth_data) {
union request_parameters_union  request_parameters;
request_parameters.read_write.handle = handle;
request_parameters.read_write.offset = 0;
save_request(pinfo, opcode, request_parameters, bluetooth_data);
}
offset = dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, tvb_captured_length_remaining(tvb, offset), handle, uuid, &att_data);
break;
case 0x0b: 
if (request_data) {
dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, request_data->parameters.read_write.handle);
col_append_info_by_handle(pinfo, request_data->parameters.read_write.handle, bluetooth_data);
}
if (is_long_attribute_value(uuid) && tvb_captured_length(tvb) >= mtu) {
sub_item = proto_tree_add_item(main_tree, hf_btatt_value, tvb, offset, -1, ENC_NA);
if (!pinfo->fd->visited && request_data && bluetooth_data)
save_value_fragment(pinfo, tvb, offset, request_data->parameters.read_write.handle, 0, bluetooth_data);
offset = tvb_captured_length(tvb);
expert_add_info(pinfo, sub_item, &ei_btatt_mtu_full);
} else {
if (request_data)
handle = request_data->parameters.read_write.handle;
else
handle = 0;
offset = dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, tvb_captured_length_remaining(tvb, offset), handle, uuid, &att_data);
}
break;
case 0x0c: 
offset = dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, HANDLE_TVB);
handle = tvb_get_letohs(tvb, offset - 2);
col_append_info_by_handle(pinfo, handle, bluetooth_data);
col_append_fstr(pinfo->cinfo, COL_INFO, "", Offset: %u"", tvb_get_letohs(tvb, offset));
proto_tree_add_item(main_tree, hf_btatt_offset, tvb, offset, 2, ENC_LITTLE_ENDIAN);
offset += 2;
dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, 0, handle, uuid, &att_data);
if (!pinfo->fd->visited && bluetooth_data) {
union request_parameters_union  request_parameters;
request_parameters.read_write.handle = handle;
request_parameters.read_write.offset = tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN);
save_request(pinfo, opcode, request_parameters, bluetooth_data);
}
break;
case 0x0d: 
if (request_data) {
dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, request_data->parameters.read_write.handle);
col_append_info_by_handle(pinfo, request_data->parameters.read_write.handle, bluetooth_data);
if (request_data->parameters.read_write.offset == 0 && !is_long_attribute_value(uuid)) {
offset = dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, tvb_captured_length_remaining(tvb, offset), request_data->parameters.read_write.handle, uuid, &att_data);
} else {
if (!pinfo->fd->visited && bluetooth_data)
save_value_fragment(pinfo, tvb, offset, request_data->parameters.read_write.handle, request_data->parameters.read_write.offset, bluetooth_data);
if (tvb_captured_length(tvb) < mtu) {
tvbuff_t  *next_tvb;
guint      reassembled_length;
guint8    *reassembled_data;
sub_item = proto_tree_add_item(main_tree, hf_btatt_value, tvb, offset, -1, ENC_NA);
offset = tvb_captured_length(tvb);
reassembled_data = get_value(pinfo, request_data->parameters.read_write.handle, bluetooth_data, &reassembled_length);
if (reassembled_data) {
sub_tree = proto_item_add_subtree(sub_item, ett_btatt_value);
next_tvb = tvb_new_child_real_data(tvb, reassembled_data, reassembled_length, reassembled_length);
add_new_data_source(pinfo, next_tvb, ""Reassembled ATT"");
dissect_attribute_value(sub_tree, NULL, pinfo, next_tvb, 0, tvb_captured_length(next_tvb), request_data->parameters.read_write.handle, uuid, &att_data);
}
} else {
sub_item = proto_tree_add_item(main_tree, hf_btatt_value, tvb, offset, -1, ENC_NA);
offset = tvb_captured_length(tvb);
expert_add_info(pinfo, sub_item, &ei_btatt_mtu_full);
}
}
} else {
proto_tree_add_item(main_tree, hf_btatt_value, tvb, offset, -1, ENC_NA);
offset = tvb_captured_length(tvb);
}
break;
case 0x0e: 
if(tvb_reported_length_remaining(tvb, offset) < 4) {
expert_add_info(pinfo, main_item, &ei_btatt_handle_too_few);
break;
}
col_append_str(pinfo->cinfo, COL_INFO, "", Handles: "");
while (tvb_reported_length_remaining(tvb, offset) >= 2) {
offset = dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, HANDLE_TVB);
handle = tvb_get_letohs(tvb, offset - 2);
col_append_fstr(pinfo->cinfo, COL_INFO, ""0x%04x "", handle);
dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, 0, handle, uuid, &att_data);
}
if (!pinfo->fd->visited && bluetooth_data) {
union request_parameters_union  request_parameters;
request_parameters.read_multiple.number_of_handles = (tvb_captured_length(tvb) - 1) / 2;
request_parameters.read_multiple.handle = (guint16 *) tvb_memdup(wmem_file_scope(),
tvb, 1, request_parameters.read_multiple.number_of_handles * 2);
save_request(pinfo, opcode, request_parameters, bluetooth_data);
}
break;
case 0x0f: 
if (request_data) {
guint  i_handle;
for (i_handle = 0; i_handle < request_data->parameters.read_multiple.number_of_handles; i_handle += 1) {
dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, request_data->parameters.read_multiple.handle[i_handle]);
offset = dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, tvb_captured_length_remaining(tvb, offset), request_data->parameters.read_multiple.handle[i_handle], uuid, &att_data);
}
} else {
proto_tree_add_item(main_tree, hf_btatt_value, tvb, offset, -1, ENC_NA);
offset = tvb_reported_length(tvb);
}
break;
case 0x11: 
{
guint8  length = tvb_get_guint8(tvb, offset);
proto_tree_add_item(main_tree, hf_btatt_length, tvb, offset, 1, ENC_LITTLE_ENDIAN);
offset++;
if (length > 0) {
col_append_fstr(pinfo->cinfo, COL_INFO, "", Attribute List Length: %u"", tvb_reported_length_remaining(tvb, offset)/length);
while (tvb_reported_length_remaining(tvb, offset) >= length) {
sub_item = proto_tree_add_none_format(main_tree, hf_btatt_attribute_data, tvb, offset, length,
""Attribute Data, Handle: 0x%04x, Group End Handle: 0x%04x"",
tvb_get_letohs(tvb, offset), tvb_get_letohs(tvb, offset+2));
sub_tree = proto_item_add_subtree(sub_item, ett_btatt_list);
offset = dissect_handle(sub_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, NULL, HANDLE_TVB);
handle = tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN);
proto_tree_add_item(sub_tree, hf_btatt_group_end_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
offset += 2;
if (request_data) {
offset = dissect_attribute_value(sub_tree, sub_item, pinfo, tvb, offset, length - 4, handle, request_data->parameters.read_by_type.uuid, &att_data);
} else {
proto_tree_add_item(sub_tree, hf_btatt_value, tvb, offset, length - 4, ENC_NA);
offset += length - 4;
}
}
}
if (request_data) {
sub_item = proto_tree_add_uint(main_tree, hf_btatt_uuid16, tvb, 0, 0, request_data->parameters.read_by_type.uuid.bt_uuid);
proto_item_set_generated(sub_item);
}
}
break;
case 0x12: 
case 0x1d: 
case 0x52: 
case 0x1b: 
offset = dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, HANDLE_TVB);
handle = tvb_get_letohs(tvb, offset - 2);
col_append_info_by_handle(pinfo, handle, bluetooth_data);
offset = dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, tvb_captured_length_remaining(tvb, offset), tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN), uuid, &att_data);
if (!pinfo->fd->visited && bluetooth_data && (opcode == 0x12 || opcode == 0x1d)) {
union request_parameters_union  request_parameters;
request_parameters.read_write.handle = handle;
request_parameters.read_write.offset = 0;
save_request(pinfo, opcode, request_parameters, bluetooth_data);
}
break;
case 0x13: 
if (request_data) {
dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, request_data->parameters.read_write.handle);
dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, 0, request_data->parameters.read_write.handle, uuid, &att_data);
col_append_info_by_handle(pinfo, request_data->parameters.read_write.handle, bluetooth_data);
}
break;
case 0x16: 
case 0x17: 
offset = dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, HANDLE_TVB);
handle = tvb_get_letohs(tvb, offset - 2);
col_append_info_by_handle(pinfo, handle, bluetooth_data);
col_append_fstr(pinfo->cinfo, COL_INFO, "", Offset: %u"", tvb_get_letohs(tvb, offset));
proto_tree_add_item(main_tree, hf_btatt_offset, tvb, offset, 2, ENC_LITTLE_ENDIAN);
offset += 2;
if (!pinfo->fd->visited && bluetooth_data && opcode == 0x16) {
union request_parameters_union  request_parameters;
request_parameters.data = NULL;
save_request(pinfo, opcode, request_parameters, bluetooth_data);
}
if (!pinfo->fd->visited && request_data && bluetooth_data && opcode == 0x16)
save_value_fragment(pinfo, tvb, offset,
tvb_get_guint16(tvb, offset - 4, ENC_LITTLE_ENDIAN),
tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN),
bluetooth_data);
if (request_data && tvb_captured_length(tvb) < mtu) {
tvbuff_t  *next_tvb;
guint      reassembled_length;
guint8    *reassembled_data;
sub_item = proto_tree_add_item(main_tree, hf_btatt_value, tvb, offset, -1, ENC_NA);
reassembled_data = get_value(pinfo, request_data->parameters.read_write.handle, bluetooth_data, &reassembled_length);
if (reassembled_data) {
sub_tree = proto_item_add_subtree(sub_item, ett_btatt_value);
next_tvb = tvb_new_child_real_data(tvb, reassembled_data, reassembled_length, reassembled_length);
add_new_data_source(pinfo, next_tvb, ""Reassembled ATT"");
dissect_attribute_value(sub_tree, NULL, pinfo, next_tvb, 0, tvb_captured_length(next_tvb), request_data->parameters.read_write.handle, uuid, &att_data);
}
} else {
proto_tree_add_item(main_tree, hf_btatt_value, tvb, offset, -1, ENC_NA);
}
offset = tvb_reported_length(tvb);
break;
case 0x18: 
col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"",
val_to_str_const(tvb_get_guint8(tvb, offset), flags_vals, ""<unknown>""));
proto_tree_add_item(main_tree, hf_btatt_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);
offset++;
if (!pinfo->fd->visited && bluetooth_data) {
union request_parameters_union  request_parameters;
request_parameters.data = NULL;
save_request(pinfo, opcode, request_parameters, bluetooth_data);
}
break;
case 0x19: 
break;
case 0x1E: 
if (request_data) {
dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, request_data->parameters.read_write.handle);
col_append_info_by_handle(pinfo, request_data->parameters.read_write.handle, bluetooth_data);
dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, 0, request_data->parameters.read_write.handle, uuid, &att_data);
}
break;
case 0xd2: 
{
guint8 length;
offset = dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, HANDLE_TVB);
handle = tvb_get_letohs(tvb, offset - 2);
col_append_info_by_handle(pinfo, handle, bluetooth_data);
","static int
dissect_btatt(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void *VAR_3)
{
proto_item        *VAR_4;
proto_tree        *VAR_5;
proto_item        *VAR_6;
proto_tree        *VAR_7;
int                VAR_8 = 0;
guint8             VAR_9;
guint8             VAR_10;
bluetooth_data_t  *VAR_11;
btatt_data_t       VAR_12;
request_data_t    *VAR_13;
guint16            VAR_14;
bluetooth_uuid_t   VAR_15;
guint              VAR_16;
memset(&VAR_15, 0, sizeof VAR_15);
VAR_11 = (bluetooth_data_t *) VAR_3;
if (tvb_reported_length_remaining(VAR_0, 0) < 1)
return 0;
VAR_12.bluetooth_data   = VAR_11;
VAR_4 = proto_tree_add_item(VAR_2, VAR_17, VAR_0, 0, -1, VAR_18);
VAR_5 = proto_item_add_subtree(VAR_4, VAR_19);
col_set_str(VAR_1->cinfo, VAR_20, ""ATT"");
switch (VAR_1->p2p_dir) {
case VAR_21:
col_set_str(VAR_1->cinfo, VAR_22, ""Sent "");
break;
case VAR_23:
col_set_str(VAR_1->cinfo, VAR_22, ""Rcvd "");
break;
default:
col_set_str(VAR_1->cinfo, VAR_22, ""UnknownDirection "");
break;
}
VAR_16 = get_mtu(VAR_1, VAR_11);
if (tvb_reported_length(VAR_0) > VAR_16)
expert_add_info(VAR_1, VAR_4, &VAR_24);
proto_tree_add_bitmask_with_flags(VAR_5, VAR_0, VAR_8, VAR_25, VAR_26,  VAR_27, VAR_18, VAR_28);
VAR_9 = tvb_get_guint8(VAR_0, 0);
VAR_12.opcode = VAR_9;
VAR_8++;
VAR_13 = get_request(VAR_0, VAR_8, VAR_1, VAR_9, VAR_11);
col_append_str(VAR_1->cinfo, VAR_22, val_to_str_const(VAR_9, VAR_29, ""<unknown>""));
switch (VAR_9) {
case 0x01: 
{
guint8               VAR_30;
bluetooth_uuid_t     VAR_31;
const value_string  *VAR_32 = VAR_33;
gint                 VAR_34 = VAR_35;
proto_tree_add_bitmask_with_flags(VAR_5, VAR_0, VAR_8, VAR_36, VAR_26,  VAR_27, VAR_18, VAR_28);
VAR_10 = tvb_get_guint8(VAR_0, VAR_8);
VAR_8 += 1;
VAR_8 = dissect_handle(VAR_5, VAR_1, VAR_37, VAR_0, VAR_8, VAR_11, NULL, VAR_38);
VAR_14 = tvb_get_letohs(VAR_0, VAR_8 - 2);
VAR_30 = tvb_get_guint8(VAR_0, VAR_8);
if (VAR_30 >= 0x80 && VAR_30 <= 0x9F) {
VAR_31 = get_service_uuid_from_handle(VAR_1, VAR_14, VAR_11);
switch (VAR_31.bt_uuid) {
case VAR_39:
VAR_32 = VAR_40;
VAR_34 = VAR_41;
break;
case VAR_42:
VAR_32 = VAR_43;
VAR_34 = VAR_44;
break;
case VAR_45:
VAR_32 = VAR_46;
VAR_34 = VAR_47;
break;
case VAR_48:
VAR_32 = VAR_49;
VAR_34 = VAR_50;
break;
case VAR_51:
VAR_32 = VAR_52;
VAR_34 = VAR_53;
break;
case VAR_54:
VAR_32 = VAR_55;
VAR_34 = VAR_56;
break;
case VAR_57:
VAR_32 = VAR_58;
VAR_34 = VAR_59;
break;
case VAR_60:
VAR_32 = VAR_61;
VAR_34 = VAR_62;
break;
case VAR_63:
VAR_32 = VAR_64;
VAR_34 = VAR_65;
break;
case VAR_66:
VAR_32 = VAR_67;
VAR_34 = VAR_68;
break;
case VAR_69:
VAR_32 = VAR_70;
VAR_34 = VAR_71;
break;
case VAR_72:
VAR_32 = VAR_73;
VAR_34 = VAR_74;
break;
case VAR_75:
VAR_32 = VAR_76;
VAR_34 = VAR_77;
break;
case VAR_78:
VAR_32 = VAR_79;
VAR_34 = VAR_80;
break;
case VAR_81:
VAR_32 = VAR_82;
VAR_34 = VAR_83;
break;
case VAR_84:
VAR_32 = VAR_85;
VAR_34 = VAR_86;
break;
default:
VAR_32 = VAR_33;
VAR_34 = VAR_35;
}
}
col_append_fstr(VAR_1->cinfo, VAR_22, "" - %s"",
val_to_str_const(VAR_30, VAR_32, ""<unknown>""));
col_append_info_by_handle(VAR_1, VAR_14, VAR_11);
proto_tree_add_item(VAR_5, VAR_34, VAR_0, VAR_8, 1, VAR_87);
VAR_8++;
if (VAR_13 && (VAR_10 == 0x08 || VAR_10 == 0x10)) {
VAR_6 = proto_tree_add_uint(VAR_5, VAR_88, VAR_0, 0, 0, VAR_13->parameters.read_by_type.uuid.bt_uuid);
proto_item_set_generated(VAR_6);
}
}
break;
case 0x02: 
col_append_fstr(VAR_1->cinfo, VAR_22, "", Client Rx MTU: %u"", tvb_get_letohs(VAR_0, VAR_8));
proto_tree_add_item(VAR_5, VAR_89, VAR_0, VAR_8, 2, VAR_87);
VAR_8 += 2;
if (!VAR_1->fd->visited && VAR_11) {
union request_parameters_union  VAR_90;
VAR_90.mtu.mtu = tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87);
save_request(VAR_1, VAR_9, VAR_90, VAR_11);
}
break;
case 0x03: 
col_append_fstr(VAR_1->cinfo, VAR_22, "", Server Rx MTU: %u"", tvb_get_letohs(VAR_0, VAR_8));
proto_tree_add_item(VAR_5, VAR_91, VAR_0, VAR_8, 2, VAR_87);
if (!VAR_1->fd->visited && VAR_13 && VAR_11) {
guint VAR_92;
VAR_92 = tvb_get_guint16(VAR_0, VAR_8, VAR_87);
if (VAR_92 > VAR_13->parameters.mtu.mtu)
VAR_92 = VAR_13->parameters.mtu.mtu;
save_mtu(VAR_1, VAR_11, VAR_92);
}
VAR_8 += 2;
break;
case 0x04: 
col_append_fstr(VAR_1->cinfo, VAR_22, "", Handles: 0x%04x..0x%04x"",
tvb_get_letohs(VAR_0, VAR_8), tvb_get_letohs(VAR_0, VAR_8+2));
proto_tree_add_item(VAR_5, VAR_93, VAR_0, VAR_8, 2, VAR_87);
VAR_8 += 2;
proto_tree_add_item(VAR_5, VAR_94, VAR_0, VAR_8, 2, VAR_87);
VAR_8 += 2;
if (!VAR_1->fd->visited && VAR_11) {
union request_parameters_union  VAR_90;
VAR_90.find_information.starting_handle = tvb_get_guint16(VAR_0, VAR_8 - 4, VAR_87);
VAR_90.find_information.ending_handle   = tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87);
save_request(VAR_1, VAR_9, VAR_90, VAR_11);
}
break;
case 0x05: 
{
guint8  VAR_95;
VAR_6 = proto_tree_add_item(VAR_5, VAR_96, VAR_0, VAR_8, 1, VAR_87);
VAR_95 = tvb_get_guint8(VAR_0, VAR_8);
VAR_8 += 1;
if (VAR_95 == 1) {
while( tvb_reported_length_remaining(VAR_0, VAR_8) > 0) {
VAR_6 = proto_tree_add_item(VAR_5, VAR_97, VAR_0, VAR_8, 4, VAR_18);
VAR_7 = proto_item_add_subtree(VAR_6, VAR_98);
VAR_8 = dissect_handle(VAR_7, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, NULL, VAR_38);
VAR_14 = tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87);
proto_tree_add_item(VAR_7, VAR_88, VAR_0, VAR_8, 2, VAR_87);
VAR_15 = get_uuid(VAR_0, VAR_8, 2);
VAR_8 += 2;
proto_item_append_text(VAR_6, "", Handle: 0x%04x, UUID: %s"",
VAR_14, print_uuid(&VAR_15));
save_handle(VAR_1, VAR_15, VAR_14, VAR_100, VAR_11);
col_append_info_by_handle(VAR_1, VAR_14, VAR_11);
}
}
else if (VAR_95 == 2) {
while( tvb_reported_length_remaining(VAR_0, VAR_8) > 0) {
VAR_6 = proto_tree_add_item(VAR_5, VAR_97, VAR_0, VAR_8, 4, VAR_18);
VAR_7 = proto_item_add_subtree(VAR_6, VAR_98);
VAR_8 = dissect_handle(VAR_7, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, NULL, VAR_38);
VAR_14 = tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87);
proto_tree_add_item(VAR_7, VAR_101, VAR_0, VAR_8, 16, VAR_18);
VAR_15 = get_uuid(VAR_0, VAR_8, 16);
VAR_8 += 16;
proto_item_append_text(VAR_6, "", Handle: 0x%04x, UUID: %s"",
VAR_14, print_uuid(&VAR_15));
save_handle(VAR_1, VAR_15, VAR_14, VAR_100, VAR_11);
col_append_info_by_handle(VAR_1, VAR_14, VAR_11);
}
}
else {
expert_add_info(VAR_1, VAR_6, &VAR_102);
}
}
break;
case 0x06: 
col_append_fstr(VAR_1->cinfo, VAR_22, "", %s, Handles: 0x%04x..0x%04x"",
val_to_str_ext_const(tvb_get_letohs(VAR_0, VAR_8+4), &VAR_103, ""<unknown>""),
tvb_get_letohs(VAR_0, VAR_8), tvb_get_letohs(VAR_0, VAR_8+2));
proto_tree_add_item(VAR_5, VAR_93, VAR_0, VAR_8, 2, VAR_87);
VAR_8 += 2;
proto_tree_add_item(VAR_5, VAR_94, VAR_0, VAR_8, 2, VAR_87);
VAR_8 += 2;
proto_tree_add_item(VAR_5, VAR_88, VAR_0, VAR_8, 2, VAR_87);
VAR_15 = get_uuid(VAR_0, VAR_8 - 2, 2);
VAR_8 += 2;
dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, tvb_captured_length_remaining(VAR_0, VAR_8), 0, VAR_15, &VAR_12);
if (!VAR_1->fd->visited && VAR_11) {
union request_parameters_union  VAR_90;
VAR_90.read_by_type.starting_handle = tvb_get_guint16(VAR_0, VAR_8 - 6, VAR_87);
VAR_90.read_by_type.ending_handle   = tvb_get_guint16(VAR_0, VAR_8 - 4, VAR_87);
VAR_90.read_by_type.uuid = VAR_15;
save_request(VAR_1, VAR_9, VAR_90, VAR_11);
}
VAR_8 = tvb_reported_length(VAR_0);
break;
case 0x07: 
while( tvb_reported_length_remaining(VAR_0, VAR_8) > 0 ) {
VAR_6 = proto_tree_add_none_format(VAR_5, VAR_104, VAR_0, VAR_8, 4,
""Handles Info, Handle: 0x%04x, Group End Handle: 0x%04x"",
tvb_get_letohs(VAR_0, VAR_8), tvb_get_letohs(VAR_0, VAR_8+2));
VAR_7 = proto_item_add_subtree(VAR_6, VAR_98);
VAR_8 = dissect_handle(VAR_7, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, NULL, VAR_38);
proto_tree_add_item(VAR_7, VAR_105, VAR_0, VAR_8, 2, VAR_87);
VAR_8 += 2;
if (VAR_13)
save_handle(VAR_1, VAR_13->parameters.read_by_type.uuid,
tvb_get_guint16(VAR_0, VAR_8 - 4, VAR_87),
VAR_100, VAR_11);
}
break;
case 0x08: 
case 0x10: 
col_append_fstr(VAR_1->cinfo, VAR_22, "", %s, Handles: 0x%04x..0x%04x"",
val_to_str_ext_const(tvb_get_letohs(VAR_0, VAR_8+4), &VAR_103, ""<unknown>""),
tvb_get_letohs(VAR_0, VAR_8), tvb_get_letohs(VAR_0, VAR_8+2));
proto_tree_add_item(VAR_5, VAR_93, VAR_0, VAR_8, 2, VAR_87);
VAR_8 += 2;
proto_tree_add_item(VAR_5, VAR_94, VAR_0, VAR_8, 2, VAR_87);
VAR_8 += 2;
if (tvb_reported_length_remaining(VAR_0, VAR_8) == 2) {
proto_tree_add_item(VAR_5, VAR_88, VAR_0, VAR_8, 2, VAR_87);
VAR_8 += 2;
if (!VAR_1->fd->visited && VAR_11) {
union request_parameters_union  VAR_90;
VAR_90.read_by_type.starting_handle = tvb_get_guint16(VAR_0, VAR_8 - 6, VAR_87);
VAR_90.read_by_type.ending_handle   = tvb_get_guint16(VAR_0, VAR_8 - 4, VAR_87);
VAR_90.read_by_type.uuid = get_uuid(VAR_0, VAR_8 - 2, 2);
save_request(VAR_1, VAR_9, VAR_90, VAR_11);
}
} else if (tvb_reported_length_remaining(VAR_0, VAR_8) == 16) {
VAR_6 = proto_tree_add_item(VAR_5, VAR_101, VAR_0, VAR_8, 16, VAR_18);
proto_item_append_text(VAR_6, "" (%s)"", val_to_str_ext_const(tvb_get_letohs(VAR_0, VAR_8),
&VAR_103, ""<unknown>""));
VAR_8 += 16;
if (!VAR_1->fd->visited && VAR_11) {
union request_parameters_union  VAR_90;
VAR_90.read_by_type.starting_handle = tvb_get_guint16(VAR_0, VAR_8 - 20, VAR_87);
VAR_90.read_by_type.ending_handle   = tvb_get_guint16(VAR_0, VAR_8 - 18, VAR_87);
VAR_90.read_by_type.uuid = get_uuid(VAR_0, VAR_8 - 16, 16);
save_request(VAR_1, VAR_9, VAR_90, VAR_11);
}
} else {
VAR_6 = proto_tree_add_item(VAR_2, VAR_106, VAR_0, VAR_8, -1, VAR_18);
expert_add_info(VAR_1, VAR_6, &VAR_107);
VAR_8 = tvb_captured_length(VAR_0);
}
break;
case 0x09: 
{
guint8  VAR_108 = tvb_get_guint8(VAR_0, VAR_8);
proto_tree_add_item(VAR_5, VAR_109, VAR_0, VAR_8, 1, VAR_87);
VAR_8++;
if(VAR_108 > 0) {
col_append_fstr(VAR_1->cinfo, VAR_22, "", Attribute List Length: %u"",
tvb_reported_length_remaining(VAR_0, VAR_8)/VAR_108);
while (tvb_reported_length_remaining(VAR_0, VAR_8) >= VAR_108)
{
VAR_6 = proto_tree_add_none_format(VAR_5, VAR_110, VAR_0,
VAR_8, VAR_108, ""Attribute Data, Handle: 0x%04x"",
tvb_get_letohs(VAR_0, VAR_8));
VAR_7 = proto_item_add_subtree(VAR_6, VAR_98);
if (VAR_13) {
save_handle(VAR_1, VAR_13->parameters.read_by_type.uuid,
tvb_get_guint16(VAR_0, VAR_8, VAR_87),
VAR_100, VAR_11);
}
VAR_8 = dissect_handle(VAR_7, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, NULL, VAR_38);
if (VAR_13) {
VAR_8 = dissect_attribute_value(VAR_7, VAR_6, VAR_1, VAR_0, VAR_8, VAR_108 - 2, tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87), VAR_13->parameters.read_by_type.uuid, &VAR_12);
} else {
proto_tree_add_item(VAR_7, VAR_106, VAR_0, VAR_8, VAR_108 - 2, VAR_18);
VAR_8 += VAR_108 - 2;
}
}
}
if (VAR_13) {
VAR_6 = proto_tree_add_uint(VAR_5, VAR_88, VAR_0, 0, 0, VAR_13->parameters.read_by_type.uuid.bt_uuid);
proto_item_set_generated(VAR_6);
}
}
break;
case 0x0a: 
VAR_8 = dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_38);
VAR_14 = tvb_get_letohs(VAR_0, VAR_8 - 2);
col_append_info_by_handle(VAR_1, VAR_14, VAR_11);
if (!VAR_1->fd->visited && VAR_11) {
union request_parameters_union  VAR_90;
VAR_90.read_write.handle = VAR_14;
VAR_90.read_write.offset = 0;
save_request(VAR_1, VAR_9, VAR_90, VAR_11);
}
VAR_8 = dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, tvb_captured_length_remaining(VAR_0, VAR_8), VAR_14, VAR_15, &VAR_12);
break;
case 0x0b: 
if (VAR_13) {
dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_13->parameters.read_write.handle);
col_append_info_by_handle(VAR_1, VAR_13->parameters.read_write.handle, VAR_11);
}
if (is_long_attribute_value(VAR_15) && tvb_captured_length(VAR_0) >= VAR_16) {
VAR_6 = proto_tree_add_item(VAR_5, VAR_106, VAR_0, VAR_8, -1, VAR_18);
if (!VAR_1->fd->visited && VAR_13 && VAR_11)
save_value_fragment(VAR_1, VAR_0, VAR_8, VAR_13->parameters.read_write.handle, 0, VAR_11);
VAR_8 = tvb_captured_length(VAR_0);
expert_add_info(VAR_1, VAR_6, &VAR_111);
} else {
if (VAR_13)
VAR_14 = VAR_13->parameters.read_write.handle;
else
VAR_14 = 0;
VAR_8 = dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, tvb_captured_length_remaining(VAR_0, VAR_8), VAR_14, VAR_15, &VAR_12);
}
break;
case 0x0c: 
VAR_8 = dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_38);
VAR_14 = tvb_get_letohs(VAR_0, VAR_8 - 2);
col_append_info_by_handle(VAR_1, VAR_14, VAR_11);
col_append_fstr(VAR_1->cinfo, VAR_22, "", Offset: %u"", tvb_get_letohs(VAR_0, VAR_8));
proto_tree_add_item(VAR_5, VAR_112, VAR_0, VAR_8, 2, VAR_87);
VAR_8 += 2;
dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, 0, VAR_14, VAR_15, &VAR_12);
if (!VAR_1->fd->visited && VAR_11) {
union request_parameters_union  VAR_90;
VAR_90.read_write.handle = VAR_14;
VAR_90.read_write.offset = tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87);
save_request(VAR_1, VAR_9, VAR_90, VAR_11);
}
break;
case 0x0d: 
if (VAR_13) {
dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_13->parameters.read_write.handle);
col_append_info_by_handle(VAR_1, VAR_13->parameters.read_write.handle, VAR_11);
if (VAR_13->parameters.read_write.offset == 0 && !is_long_attribute_value(VAR_15)) {
VAR_8 = dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, tvb_captured_length_remaining(VAR_0, VAR_8), VAR_13->parameters.read_write.handle, VAR_15, &VAR_12);
} else {
if (!VAR_1->fd->visited && VAR_11)
save_value_fragment(VAR_1, VAR_0, VAR_8, VAR_13->parameters.read_write.handle, VAR_13->parameters.read_write.offset, VAR_11);
if (tvb_captured_length(VAR_0) < VAR_16) {
tvbuff_t  *VAR_113;
guint      VAR_114;
guint8    *VAR_115;
VAR_6 = proto_tree_add_item(VAR_5, VAR_106, VAR_0, VAR_8, -1, VAR_18);
VAR_8 = tvb_captured_length(VAR_0);
VAR_115 = get_value(VAR_1, VAR_13->parameters.read_write.handle, VAR_11, &VAR_114);
if (VAR_115) {
VAR_7 = proto_item_add_subtree(VAR_6, VAR_116);
VAR_113 = tvb_new_child_real_data(VAR_0, VAR_115, VAR_114, VAR_114);
add_new_data_source(VAR_1, VAR_113, ""Reassembled ATT"");
dissect_attribute_value(VAR_7, NULL, VAR_1, VAR_113, 0, tvb_captured_length(VAR_113), VAR_13->parameters.read_write.handle, VAR_15, &VAR_12);
}
} else {
VAR_6 = proto_tree_add_item(VAR_5, VAR_106, VAR_0, VAR_8, -1, VAR_18);
VAR_8 = tvb_captured_length(VAR_0);
expert_add_info(VAR_1, VAR_6, &VAR_111);
}
}
} else {
proto_tree_add_item(VAR_5, VAR_106, VAR_0, VAR_8, -1, VAR_18);
VAR_8 = tvb_captured_length(VAR_0);
}
break;
case 0x0e: 
if(tvb_reported_length_remaining(VAR_0, VAR_8) < 4) {
expert_add_info(VAR_1, VAR_4, &VAR_117);
break;
}
col_append_str(VAR_1->cinfo, VAR_22, "", Handles: "");
while (tvb_reported_length_remaining(VAR_0, VAR_8) >= 2) {
VAR_8 = dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_38);
VAR_14 = tvb_get_letohs(VAR_0, VAR_8 - 2);
col_append_fstr(VAR_1->cinfo, VAR_22, ""0x%04x "", VAR_14);
dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, 0, VAR_14, VAR_15, &VAR_12);
}
if (!VAR_1->fd->visited && VAR_11) {
union request_parameters_union  VAR_90;
VAR_90.read_multiple.number_of_handles = (tvb_captured_length(VAR_0) - 1) / 2;
VAR_90.read_multiple.handle = (guint16 *) tvb_memdup(wmem_file_scope(),
VAR_0, 1, VAR_90.read_multiple.number_of_handles * 2);
save_request(VAR_1, VAR_9, VAR_90, VAR_11);
}
break;
case 0x0f: 
if (VAR_13) {
guint  VAR_118;
for (VAR_118 = 0; VAR_118 < VAR_13->parameters.read_multiple.number_of_handles; VAR_118 += 1) {
dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_13->parameters.read_multiple.handle[VAR_118]);
VAR_8 = dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, tvb_captured_length_remaining(VAR_0, VAR_8), VAR_13->parameters.read_multiple.handle[VAR_118], VAR_15, &VAR_12);
}
} else {
proto_tree_add_item(VAR_5, VAR_106, VAR_0, VAR_8, -1, VAR_18);
VAR_8 = tvb_reported_length(VAR_0);
}
break;
case 0x11: 
{
guint8  VAR_108 = tvb_get_guint8(VAR_0, VAR_8);
proto_tree_add_item(VAR_5, VAR_109, VAR_0, VAR_8, 1, VAR_87);
VAR_8++;
if (VAR_108 > 0) {
col_append_fstr(VAR_1->cinfo, VAR_22, "", Attribute List Length: %u"", tvb_reported_length_remaining(VAR_0, VAR_8)/VAR_108);
while (tvb_reported_length_remaining(VAR_0, VAR_8) >= VAR_108) {
VAR_6 = proto_tree_add_none_format(VAR_5, VAR_110, VAR_0, VAR_8, VAR_108,
""Attribute Data, Handle: 0x%04x, Group End Handle: 0x%04x"",
tvb_get_letohs(VAR_0, VAR_8), tvb_get_letohs(VAR_0, VAR_8+2));
VAR_7 = proto_item_add_subtree(VAR_6, VAR_98);
VAR_8 = dissect_handle(VAR_7, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, NULL, VAR_38);
VAR_14 = tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87);
proto_tree_add_item(VAR_7, VAR_105, VAR_0, VAR_8, 2, VAR_87);
VAR_8 += 2;
if (VAR_13) {
VAR_8 = dissect_attribute_value(VAR_7, VAR_6, VAR_1, VAR_0, VAR_8, VAR_108 - 4, VAR_14, VAR_13->parameters.read_by_type.uuid, &VAR_12);
} else {
proto_tree_add_item(VAR_7, VAR_106, VAR_0, VAR_8, VAR_108 - 4, VAR_18);
VAR_8 += VAR_108 - 4;
}
}
}
if (VAR_13) {
VAR_6 = proto_tree_add_uint(VAR_5, VAR_88, VAR_0, 0, 0, VAR_13->parameters.read_by_type.uuid.bt_uuid);
proto_item_set_generated(VAR_6);
}
}
break;
case 0x12: 
case 0x1d: 
case 0x52: 
case 0x1b: 
VAR_8 = dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_38);
VAR_14 = tvb_get_letohs(VAR_0, VAR_8 - 2);
col_append_info_by_handle(VAR_1, VAR_14, VAR_11);
VAR_8 = dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, tvb_captured_length_remaining(VAR_0, VAR_8), tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87), VAR_15, &VAR_12);
if (!VAR_1->fd->visited && VAR_11 && (VAR_9 == 0x12 || VAR_9 == 0x1d)) {
union request_parameters_union  VAR_90;
VAR_90.read_write.handle = VAR_14;
VAR_90.read_write.offset = 0;
save_request(VAR_1, VAR_9, VAR_90, VAR_11);
}
break;
case 0x13: 
if (VAR_13) {
dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_13->parameters.read_write.handle);
dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, 0, VAR_13->parameters.read_write.handle, VAR_15, &VAR_12);
col_append_info_by_handle(VAR_1, VAR_13->parameters.read_write.handle, VAR_11);
}
break;
case 0x16: 
case 0x17: 
VAR_8 = dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_38);
VAR_14 = tvb_get_letohs(VAR_0, VAR_8 - 2);
col_append_info_by_handle(VAR_1, VAR_14, VAR_11);
col_append_fstr(VAR_1->cinfo, VAR_22, "", Offset: %u"", tvb_get_letohs(VAR_0, VAR_8));
proto_tree_add_item(VAR_5, VAR_112, VAR_0, VAR_8, 2, VAR_87);
VAR_8 += 2;
if (!VAR_1->fd->visited && VAR_11 && VAR_9 == 0x16) {
union request_parameters_union  VAR_90;
VAR_90.data = NULL;
save_request(VAR_1, VAR_9, VAR_90, VAR_11);
}
if (!VAR_1->fd->visited && VAR_13 && VAR_11 && VAR_9 == 0x16)
save_value_fragment(VAR_1, VAR_0, VAR_8,
tvb_get_guint16(VAR_0, VAR_8 - 4, VAR_87),
tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87),
VAR_11);
if (VAR_13 && tvb_captured_length(VAR_0) < VAR_16) {
tvbuff_t  *VAR_113;
guint      VAR_114;
guint8    *VAR_115;
VAR_6 = proto_tree_add_item(VAR_5, VAR_106, VAR_0, VAR_8, -1, VAR_18);
VAR_115 = get_value(VAR_1, VAR_13->parameters.read_write.handle, VAR_11, &VAR_114);
if (VAR_115) {
VAR_7 = proto_item_add_subtree(VAR_6, VAR_116);
VAR_113 = tvb_new_child_real_data(VAR_0, VAR_115, VAR_114, VAR_114);
add_new_data_source(VAR_1, VAR_113, ""Reassembled ATT"");
dissect_attribute_value(VAR_7, NULL, VAR_1, VAR_113, 0, tvb_captured_length(VAR_113), VAR_13->parameters.read_write.handle, VAR_15, &VAR_12);
}
} else {
proto_tree_add_item(VAR_5, VAR_106, VAR_0, VAR_8, -1, VAR_18);
}
VAR_8 = tvb_reported_length(VAR_0);
break;
case 0x18: 
col_append_fstr(VAR_1->cinfo, VAR_22, "", %s"",
val_to_str_const(tvb_get_guint8(VAR_0, VAR_8), VAR_119, ""<unknown>""));
proto_tree_add_item(VAR_5, VAR_120, VAR_0, VAR_8, 1, VAR_87);
VAR_8++;
if (!VAR_1->fd->visited && VAR_11) {
union request_parameters_union  VAR_90;
VAR_90.data = NULL;
save_request(VAR_1, VAR_9, VAR_90, VAR_11);
}
break;
case 0x19: 
break;
case 0x1E: 
if (VAR_13) {
dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_13->parameters.read_write.handle);
col_append_info_by_handle(VAR_1, VAR_13->parameters.read_write.handle, VAR_11);
dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, 0, VAR_13->parameters.read_write.handle, VAR_15, &VAR_12);
}
break;
case 0xd2: 
{
guint8 VAR_108;
VAR_8 = dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_38);
VAR_14 = tvb_get_letohs(VAR_0, VAR_8 - 2);
col_append_info_by_handle(VAR_1, VAR_14, VAR_11);
VAR_108 = tvb_reported_length_remaining(VAR_0, VAR_8);
dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, (VAR_108 > 12) ? VAR_108 - 12 : 0, VAR_14, VAR_15, &VAR_12);
if (VAR_108 > 12) {
VAR_8 += VAR_108 - 12;
}
proto_tree_add_item(VAR_5, VAR_121, VAR_0, VAR_8, 4, VAR_87);
VAR_8+=4;
proto_tree_add_item(VAR_5, VAR_122, VAR_0, VAR_8, 8, VAR_18);
VAR_8+=8;
break;
}
default:
break;
}
if (VAR_13) {
if (VAR_13->request_in_frame > 0  && VAR_13->request_in_frame != VAR_1->num) {
VAR_6 = proto_tree_add_uint(VAR_5, VAR_123, VAR_0, 0, 0, VAR_13->request_in_frame);
proto_item_set_generated(VAR_6);
}
if (!VAR_1->fd->visited && VAR_13->response_in_frame == 0 &&
VAR_1->num > VAR_13->request_in_frame)
VAR_13->response_in_frame = VAR_1->num;
if (VAR_13->response_in_frame > 0 && VAR_13->response_in_frame != VAR_1->num) {
VAR_6 = proto_tree_add_uint(VAR_5, VAR_124, VAR_0, 0, 0, VAR_13->response_in_frame);
proto_item_set_generated(VAR_6);
}
}
return VAR_8;
}",wireshark/01f261de41f4dd3233ef578e5c0ffb9c25c7d14d/packet-btatt.c/vul/before/1.json,"static int
dissect_btatt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
    proto_item        *main_item;
    proto_tree        *main_tree;
    proto_item        *sub_item;
    proto_tree        *sub_tree;
    int                offset = 0;
    guint8             opcode;
    guint8             request_opcode;
    bluetooth_data_t  *bluetooth_data;
    btatt_data_t       att_data;
    request_data_t    *request_data;
    guint16            handle;
    bluetooth_uuid_t   uuid;
    guint              mtu;

    memset(&uuid, 0, sizeof uuid);

    bluetooth_data = (bluetooth_data_t *) data;

    if (tvb_reported_length_remaining(tvb, 0) < 1)
        return 0;

    att_data.bluetooth_data   = bluetooth_data;

    main_item = proto_tree_add_item(tree, proto_btatt, tvb, 0, -1, ENC_NA);
    main_tree = proto_item_add_subtree(main_item, ett_btatt);

    col_set_str(pinfo->cinfo, COL_PROTOCOL, ""ATT"");

    switch (pinfo->p2p_dir) {
        case P2P_DIR_SENT:
            col_set_str(pinfo->cinfo, COL_INFO, ""Sent "");
            break;
        case P2P_DIR_RECV:
            col_set_str(pinfo->cinfo, COL_INFO, ""Rcvd "");
            break;
        default:
            col_set_str(pinfo->cinfo, COL_INFO, ""UnknownDirection "");
            break;
    }

    mtu = get_mtu(pinfo, bluetooth_data);
    if (tvb_reported_length(tvb) > mtu)
        expert_add_info(pinfo, main_item, &ei_btatt_mtu_exceeded);

    proto_tree_add_bitmask_with_flags(main_tree, tvb, offset, hf_btatt_opcode, ett_btatt_opcode,  hfx_btatt_opcode, ENC_NA, BMT_NO_APPEND);
    opcode = tvb_get_guint8(tvb, 0);
    att_data.opcode = opcode;
    offset++;

    request_data = get_request(tvb, offset, pinfo, opcode, bluetooth_data);

    col_append_str(pinfo->cinfo, COL_INFO, val_to_str_const(opcode, opcode_vals, ""<unknown>""));

    switch (opcode) {
    case 0x01: /* Error Response */
        {
        guint8               error_code;
        bluetooth_uuid_t     service_uuid;
        const value_string  *error_vals = error_code_vals;
        gint                 hfx_btatt_error_code = hf_btatt_error_code;

        proto_tree_add_bitmask_with_flags(main_tree, tvb, offset, hf_btatt_req_opcode_in_error, ett_btatt_opcode,  hfx_btatt_opcode, ENC_NA, BMT_NO_APPEND);
        request_opcode = tvb_get_guint8(tvb, offset);
        offset += 1;

        offset = dissect_handle(main_tree, pinfo, hf_btatt_handle_in_error, tvb, offset, bluetooth_data, NULL, HANDLE_TVB);
        handle = tvb_get_letohs(tvb, offset - 2);

        error_code = tvb_get_guint8(tvb, offset);

        if (error_code >= 0x80 && error_code <= 0x9F) {
            service_uuid = get_service_uuid_from_handle(pinfo, handle, bluetooth_data);

            switch (service_uuid.bt_uuid) {
            case GATT_SERVICE_AUTOMATION_IO:
                error_vals = error_code_aios_vals;
                hfx_btatt_error_code = hf_btatt_error_code_aios;

                break;
            case GATT_SERVICE_ALERT_NOTIFICATION_SERVICE:
                error_vals = error_code_ans_vals;
                hfx_btatt_error_code = hf_btatt_error_code_ans;

                break;
            case GATT_SERVICE_BOND_MANAGEMENT:
                error_vals = error_code_bms_vals;
                hfx_btatt_error_code = hf_btatt_error_code_bms;

                break;
            case GATT_SERVICE_CONTINUOUS_GLUCOSE_MONITORING:
                error_vals = error_code_cgms_vals;
                hfx_btatt_error_code = hf_btatt_error_code_cgms;

                break;
            case GATT_SERVICE_CYCLING_POWER:
                error_vals = error_code_cps_vals;
                hfx_btatt_error_code = hf_btatt_error_code_cps;

                break;
            case GATT_SERVICE_CYCLING_SPEED_AND_CADENCE:
                error_vals = error_code_cscs_vals;
                hfx_btatt_error_code = hf_btatt_error_code_cscs;

                break;
            case GATT_SERVICE_CURRENT_TIME_SERVICE:
                error_vals = error_code_cts_vals;
                hfx_btatt_error_code = hf_btatt_error_code_cts;

                break;
            case GATT_SERVICE_ENVIRONMENTAL_SENSING:
                error_vals = error_code_ess_vals;
                hfx_btatt_error_code = hf_btatt_error_code_ess;

                break;
            case GATT_SERVICE_GLUCOSE:
                error_vals = error_code_gls_vals;
                hfx_btatt_error_code = hf_btatt_error_code_gls;

                break;
            case GATT_SERVICE_HTTP_PROXY:
                error_vals = error_code_hps_vals;
                hfx_btatt_error_code = hf_btatt_error_code_hps;

                break;
            case GATT_SERVICE_HEART_RATE:
                error_vals = error_code_hrs_vals;
                hfx_btatt_error_code = hf_btatt_error_code_hrs;

                break;
            case GATT_SERVICE_HEALTH_THERMOMETER:
                error_vals = error_code_hts_vals;
                hfx_btatt_error_code = hf_btatt_error_code_hts;

                break;
            case GATT_SERVICE_INDOOR_POSITIONING:
                error_vals = error_code_ips_vals;
                hfx_btatt_error_code = hf_btatt_error_code_ips;

                break;
            case GATT_SERVICE_OBJECT_TRANSFER:
                error_vals = error_code_ots_vals;
                hfx_btatt_error_code = hf_btatt_error_code_ots;

                break;
            case GATT_SERVICE_RUNNING_SPEED_AND_CADENCE:
                error_vals = error_code_rscs_vals;
                hfx_btatt_error_code = hf_btatt_error_code_rscs;

                break;
            case GATT_SERVICE_USER_DATA:
                error_vals = error_code_uds_vals;
                hfx_btatt_error_code = hf_btatt_error_code_uds;

                break;
            default:
                error_vals = error_code_vals;
                hfx_btatt_error_code = hf_btatt_error_code;
            }
        }
        col_append_fstr(pinfo->cinfo, COL_INFO, "" - %s"",
                        val_to_str_const(error_code, error_vals, ""<unknown>""));

        col_append_info_by_handle(pinfo, handle, bluetooth_data);

        proto_tree_add_item(main_tree, hfx_btatt_error_code, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        offset++;

        if (request_data && (request_opcode == 0x08 || request_opcode == 0x10)) {
            sub_item = proto_tree_add_uint(main_tree, hf_btatt_uuid16, tvb, 0, 0, request_data->parameters.read_by_type.uuid.bt_uuid);
            proto_item_set_generated(sub_item);
        }
        }
        break;

    case 0x02: /* Exchange MTU Request */
        col_append_fstr(pinfo->cinfo, COL_INFO, "", Client Rx MTU: %u"", tvb_get_letohs(tvb, offset));
        proto_tree_add_item(main_tree, hf_btatt_client_rx_mtu, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;

        if (!pinfo->fd->visited && bluetooth_data) {
            union request_parameters_union  request_parameters;

            request_parameters.mtu.mtu = tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN);

            save_request(pinfo, opcode, request_parameters, bluetooth_data);
        }

        break;

    case 0x03: /* Exchange MTU Response */
        col_append_fstr(pinfo->cinfo, COL_INFO, "", Server Rx MTU: %u"", tvb_get_letohs(tvb, offset));
        proto_tree_add_item(main_tree, hf_btatt_server_rx_mtu, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        if (!pinfo->fd->visited && request_data && bluetooth_data) {
            guint new_mtu;

            new_mtu = tvb_get_guint16(tvb, offset, ENC_LITTLE_ENDIAN);
            if (new_mtu > request_data->parameters.mtu.mtu)
                new_mtu = request_data->parameters.mtu.mtu;
            save_mtu(pinfo, bluetooth_data, new_mtu);
        }
        offset += 2;
        break;

    case 0x04: /* Find Information Request */
        col_append_fstr(pinfo->cinfo, COL_INFO, "", Handles: 0x%04x..0x%04x"",
                            tvb_get_letohs(tvb, offset), tvb_get_letohs(tvb, offset+2));
        proto_tree_add_item(main_tree, hf_btatt_starting_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;

        proto_tree_add_item(main_tree, hf_btatt_ending_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;

        if (!pinfo->fd->visited && bluetooth_data) {
            union request_parameters_union  request_parameters;

            request_parameters.find_information.starting_handle = tvb_get_guint16(tvb, offset - 4, ENC_LITTLE_ENDIAN);
            request_parameters.find_information.ending_handle   = tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN);

            save_request(pinfo, opcode, request_parameters, bluetooth_data);
        }

        break;

    case 0x05: /* Find Information Response */
        {
            guint8  format;

            sub_item = proto_tree_add_item(main_tree, hf_btatt_uuid_format, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            format = tvb_get_guint8(tvb, offset);
            offset += 1;

            if (format == 1) {
                while (tvb_reported_length_remaining(tvb, offset) > 0) {
                    sub_item = proto_tree_add_item(main_tree, hf_btatt_information_data, tvb, offset, 4, ENC_NA);
                    sub_tree = proto_item_add_subtree(sub_item, ett_btatt_list);

                    offset = dissect_handle(sub_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, NULL, HANDLE_TVB);
                    handle = tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN);

                    proto_tree_add_item(sub_tree, hf_btatt_uuid16, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                    uuid = get_uuid(tvb, offset, 2);
                    offset += 2;

                    proto_item_append_text(sub_item, "", Handle: 0x%04x, UUID: %s"",
                            handle, print_uuid(&uuid));

                    save_handle(pinfo, uuid, handle, ATTRIBUTE_TYPE_OTHER, bluetooth_data);

                    col_append_info_by_handle(pinfo, handle, bluetooth_data);
                }
            }
            else if (format == 2) {
                while (tvb_reported_length_remaining(tvb, offset) > 0) {
                    sub_item = proto_tree_add_item(main_tree, hf_btatt_information_data, tvb, offset, 4, ENC_NA);
                    sub_tree = proto_item_add_subtree(sub_item, ett_btatt_list);

                    offset = dissect_handle(sub_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, NULL, HANDLE_TVB);
                    handle = tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN);

                    proto_tree_add_item(sub_tree, hf_btatt_uuid128, tvb, offset, 16, ENC_NA);
                    uuid = get_uuid(tvb, offset, 16);
                    offset += 16;

                    proto_item_append_text(sub_item, "", Handle: 0x%04x, UUID: %s"",
                            handle, print_uuid(&uuid));

                    save_handle(pinfo, uuid, handle, ATTRIBUTE_TYPE_OTHER, bluetooth_data);

                    col_append_info_by_handle(pinfo, handle, bluetooth_data);
                }
            }
            else {
                expert_add_info(pinfo, sub_item, &ei_btatt_uuid_format_unknown);
            }
        }
        break;

    case 0x06: /* Find By Type Value Request */
        col_append_fstr(pinfo->cinfo, COL_INFO, "", %s, Handles: 0x%04x..0x%04x"",
                            val_to_str_ext_const(tvb_get_letohs(tvb, offset+4), &bluetooth_uuid_vals_ext, ""<unknown>""),
                            tvb_get_letohs(tvb, offset), tvb_get_letohs(tvb, offset+2));

        proto_tree_add_item(main_tree, hf_btatt_starting_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;

        proto_tree_add_item(main_tree, hf_btatt_ending_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;

        proto_tree_add_item(main_tree, hf_btatt_uuid16, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        uuid = get_uuid(tvb, offset - 2, 2);
        offset += 2;

        dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, tvb_captured_length_remaining(tvb, offset), 0, uuid, &att_data);

        if (!pinfo->fd->visited && bluetooth_data) {
            union request_parameters_union  request_parameters;

            request_parameters.read_by_type.starting_handle = tvb_get_guint16(tvb, offset - 6, ENC_LITTLE_ENDIAN);
            request_parameters.read_by_type.ending_handle   = tvb_get_guint16(tvb, offset - 4, ENC_LITTLE_ENDIAN);
            request_parameters.read_by_type.uuid = uuid;

            save_request(pinfo, opcode, request_parameters, bluetooth_data);
        }

        offset = tvb_reported_length(tvb);

        break;

    case 0x07: /* Find By Type Value Response */
        while (tvb_reported_length_remaining(tvb, offset) > 0) {
            sub_item = proto_tree_add_none_format(main_tree, hf_btatt_handles_info, tvb, offset, 4,
                                            ""Handles Info, Handle: 0x%04x, Group End Handle: 0x%04x"",
                                            tvb_get_letohs(tvb, offset), tvb_get_letohs(tvb, offset+2));

            sub_tree = proto_item_add_subtree(sub_item, ett_btatt_list);

            offset = dissect_handle(sub_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, NULL, HANDLE_TVB);

            proto_tree_add_item(sub_tree, hf_btatt_group_end_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            offset += 2;

            if (request_data)
                save_handle(pinfo, request_data->parameters.read_by_type.uuid,
                        tvb_get_guint16(tvb, offset - 4, ENC_LITTLE_ENDIAN),
                        ATTRIBUTE_TYPE_OTHER, bluetooth_data);

        }
        break;

    case 0x08: /* Read By Type Request */
    case 0x10: /* Read By Group Type Request */
        col_append_fstr(pinfo->cinfo, COL_INFO, "", %s, Handles: 0x%04x..0x%04x"",
                            val_to_str_ext_const(tvb_get_letohs(tvb, offset+4), &bluetooth_uuid_vals_ext, ""<unknown>""),
                            tvb_get_letohs(tvb, offset), tvb_get_letohs(tvb, offset+2));

        proto_tree_add_item(main_tree, hf_btatt_starting_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
        proto_tree_add_item(main_tree, hf_btatt_ending_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;

        if (tvb_reported_length_remaining(tvb, offset) == 2) {
            proto_tree_add_item(main_tree, hf_btatt_uuid16, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            offset += 2;

            if (!pinfo->fd->visited && bluetooth_data) {
                union request_parameters_union  request_parameters;

                request_parameters.read_by_type.starting_handle = tvb_get_guint16(tvb, offset - 6, ENC_LITTLE_ENDIAN);
                request_parameters.read_by_type.ending_handle   = tvb_get_guint16(tvb, offset - 4, ENC_LITTLE_ENDIAN);
                request_parameters.read_by_type.uuid = get_uuid(tvb, offset - 2, 2);

                save_request(pinfo, opcode, request_parameters, bluetooth_data);
            }
        } else if (tvb_reported_length_remaining(tvb, offset) == 16) {
            sub_item = proto_tree_add_item(main_tree, hf_btatt_uuid128, tvb, offset, 16, ENC_NA);
            proto_item_append_text(sub_item, "" (%s)"", val_to_str_ext_const(tvb_get_letohs(tvb, offset),
                                            &bluetooth_uuid_vals_ext, ""<unknown>""));
            offset += 16;

            if (!pinfo->fd->visited && bluetooth_data) {
                union request_parameters_union  request_parameters;

                request_parameters.read_by_type.starting_handle = tvb_get_guint16(tvb, offset - 20, ENC_LITTLE_ENDIAN);
                request_parameters.read_by_type.ending_handle   = tvb_get_guint16(tvb, offset - 18, ENC_LITTLE_ENDIAN);
                request_parameters.read_by_type.uuid = get_uuid(tvb, offset - 16, 16);

                save_request(pinfo, opcode, request_parameters, bluetooth_data);
            }
        } else {
            sub_item = proto_tree_add_item(tree, hf_btatt_value, tvb, offset, -1, ENC_NA);
            expert_add_info(pinfo, sub_item, &ei_btatt_bad_data);
            offset = tvb_captured_length(tvb);
        }

        break;

    case 0x09: /* Read By Type Response */
        {
            guint8  length = tvb_get_guint8(tvb, offset);

            proto_tree_add_item(main_tree, hf_btatt_length, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            offset++;

            if (length > 0) {
                col_append_fstr(pinfo->cinfo, COL_INFO, "", Attribute List Length: %u"",
                                        tvb_reported_length_remaining(tvb, offset)/length);

                while (tvb_reported_length_remaining(tvb, offset) >= length)
                {
                    sub_item = proto_tree_add_none_format(main_tree, hf_btatt_attribute_data, tvb,
                                                    offset, length, ""Attribute Data, Handle: 0x%04x"",
                                                    tvb_get_letohs(tvb, offset));

                    sub_tree = proto_item_add_subtree(sub_item, ett_btatt_list);

                    if (request_data) {
                        save_handle(pinfo, request_data->parameters.read_by_type.uuid,
                                tvb_get_guint16(tvb, offset, ENC_LITTLE_ENDIAN),
                                ATTRIBUTE_TYPE_OTHER, bluetooth_data);
                    }

                    offset = dissect_handle(sub_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, NULL, HANDLE_TVB);

                    if (request_data) {
                        offset = dissect_attribute_value(sub_tree, sub_item, pinfo, tvb, offset, length - 2, tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN), request_data->parameters.read_by_type.uuid, &att_data);
                    } else {
                        proto_tree_add_item(sub_tree, hf_btatt_value, tvb, offset, length - 2, ENC_NA);
                        offset += length - 2;
                    }
                }
            }

            if (request_data) {
                sub_item = proto_tree_add_uint(main_tree, hf_btatt_uuid16, tvb, 0, 0, request_data->parameters.read_by_type.uuid.bt_uuid);
                proto_item_set_generated(sub_item);
            }
        }
        break;

    case 0x0a: /* Read Request */
        offset = dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, HANDLE_TVB);
        handle = tvb_get_letohs(tvb, offset - 2);

        col_append_info_by_handle(pinfo, handle, bluetooth_data);

        if (!pinfo->fd->visited && bluetooth_data) {
            union request_parameters_union  request_parameters;

            request_parameters.read_write.handle = handle;
            request_parameters.read_write.offset = 0;

            save_request(pinfo, opcode, request_parameters, bluetooth_data);
        }

        offset = dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, tvb_captured_length_remaining(tvb, offset), handle, uuid, &att_data);

        break;

    case 0x0b: /* Read Response */
        if (request_data) {
            dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, request_data->parameters.read_write.handle);

            col_append_info_by_handle(pinfo, request_data->parameters.read_write.handle, bluetooth_data);
        }

        if (is_long_attribute_value(uuid) && tvb_captured_length(tvb) >= mtu) {
            sub_item = proto_tree_add_item(main_tree, hf_btatt_value, tvb, offset, -1, ENC_NA);
            if (!pinfo->fd->visited && request_data && bluetooth_data)
                save_value_fragment(pinfo, tvb, offset, request_data->parameters.read_write.handle, 0, bluetooth_data);
            offset = tvb_captured_length(tvb);

            expert_add_info(pinfo, sub_item, &ei_btatt_mtu_full);
        } else {
            if (request_data)
                handle = request_data->parameters.read_write.handle;
            else
                handle = 0;

            offset = dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, tvb_captured_length_remaining(tvb, offset), handle, uuid, &att_data);
        }
        break;

    case 0x0c: /* Read Blob Request */
        offset = dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, HANDLE_TVB);
        handle = tvb_get_letohs(tvb, offset - 2);

        col_append_info_by_handle(pinfo, handle, bluetooth_data);
        col_append_fstr(pinfo->cinfo, COL_INFO, "", Offset: %u"", tvb_get_letohs(tvb, offset));

        proto_tree_add_item(main_tree, hf_btatt_offset, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;

        dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, 0, handle, uuid, &att_data);


        if (!pinfo->fd->visited && bluetooth_data) {
            union request_parameters_union  request_parameters;

            request_parameters.read_write.handle = handle;
            request_parameters.read_write.offset = tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN);

            save_request(pinfo, opcode, request_parameters, bluetooth_data);
        }
        break;

    case 0x0d: /* Read Blob Response */
        if (request_data && request_data->opcode == (opcode - 1)) {
            dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, request_data->parameters.read_write.handle);

            col_append_info_by_handle(pinfo, request_data->parameters.read_write.handle, bluetooth_data);

            if (request_data->parameters.read_write.offset == 0 && !is_long_attribute_value(uuid)) {
                offset = dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, tvb_captured_length_remaining(tvb, offset), request_data->parameters.read_write.handle, uuid, &att_data);
            } else {
                if (!pinfo->fd->visited && bluetooth_data)
                    save_value_fragment(pinfo, tvb, offset, request_data->parameters.read_write.handle, request_data->parameters.read_write.offset, bluetooth_data);

                if (tvb_captured_length(tvb) < mtu) {
                    tvbuff_t  *next_tvb;
                    guint      reassembled_length;
                    guint8    *reassembled_data;

                    sub_item = proto_tree_add_item(main_tree, hf_btatt_value, tvb, offset, -1, ENC_NA);
                    offset = tvb_captured_length(tvb);

                    reassembled_data = get_value(pinfo, request_data->parameters.read_write.handle, bluetooth_data, &reassembled_length);
                    if (reassembled_data) {
                        sub_tree = proto_item_add_subtree(sub_item, ett_btatt_value);
                        next_tvb = tvb_new_child_real_data(tvb, reassembled_data, reassembled_length, reassembled_length);
                        add_new_data_source(pinfo, next_tvb, ""Reassembled ATT"");
                        dissect_attribute_value(sub_tree, NULL, pinfo, next_tvb, 0, tvb_captured_length(next_tvb), request_data->parameters.read_write.handle, uuid, &att_data);
                    }
                } else {
                    sub_item = proto_tree_add_item(main_tree, hf_btatt_value, tvb, offset, -1, ENC_NA);
                    offset = tvb_captured_length(tvb);

                    expert_add_info(pinfo, sub_item, &ei_btatt_mtu_full);
                }
            }
        } else {
            proto_tree_add_item(main_tree, hf_btatt_value, tvb, offset, -1, ENC_NA);
            offset = tvb_captured_length(tvb);
        }

        break;

    case 0x0e: /* Multiple Read Request */
        if(tvb_reported_length_remaining(tvb, offset) < 4) {
            expert_add_info(pinfo, main_item, &ei_btatt_handle_too_few);
            break;
        }

        col_append_str(pinfo->cinfo, COL_INFO, "", Handles: "");
        while (tvb_reported_length_remaining(tvb, offset) >= 2) {
            offset = dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, HANDLE_TVB);
            handle = tvb_get_letohs(tvb, offset - 2);
            col_append_fstr(pinfo->cinfo, COL_INFO, ""0x%04x "", handle);

            dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, 0, handle, uuid, &att_data);
        }

        if (!pinfo->fd->visited && bluetooth_data) {
            union request_parameters_union  request_parameters;

            request_parameters.read_multiple.number_of_handles = (tvb_captured_length(tvb) - 1) / 2;
            request_parameters.read_multiple.handle = (guint16 *) tvb_memdup(wmem_file_scope(),
                    tvb, 1, request_parameters.read_multiple.number_of_handles * 2);

            save_request(pinfo, opcode, request_parameters, bluetooth_data);
        }
        break;

    case 0x0f: /* Multiple Read Response */
        if (request_data && request_data->opcode == (opcode - 1)) {
            guint  i_handle;

            for (i_handle = 0; i_handle < request_data->parameters.read_multiple.number_of_handles; i_handle += 1) {
                dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, request_data->parameters.read_multiple.handle[i_handle]);
                offset = dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, tvb_captured_length_remaining(tvb, offset), request_data->parameters.read_multiple.handle[i_handle], uuid, &att_data);
            }
        } else {
            proto_tree_add_item(main_tree, hf_btatt_value, tvb, offset, -1, ENC_NA);
            offset = tvb_reported_length(tvb);
        }
        break;

    case 0x11: /* Read By Group Type Response */
        {
            guint8  length = tvb_get_guint8(tvb, offset);

            proto_tree_add_item(main_tree, hf_btatt_length, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            offset++;

            if (length > 0) {
                col_append_fstr(pinfo->cinfo, COL_INFO, "", Attribute List Length: %u"", tvb_reported_length_remaining(tvb, offset)/length);

                while (tvb_reported_length_remaining(tvb, offset) >= length) {
                    sub_item = proto_tree_add_none_format(main_tree, hf_btatt_attribute_data, tvb, offset, length,
                                                    ""Attribute Data, Handle: 0x%04x, Group End Handle: 0x%04x"",
                                                    tvb_get_letohs(tvb, offset), tvb_get_letohs(tvb, offset+2));

                    sub_tree = proto_item_add_subtree(sub_item, ett_btatt_list);

                    offset = dissect_handle(sub_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, NULL, HANDLE_TVB);
                    handle = tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN);

                    proto_tree_add_item(sub_tree, hf_btatt_group_end_handle, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                    offset += 2;

                    if (request_data) {
                        offset = dissect_attribute_value(sub_tree, sub_item, pinfo, tvb, offset, length - 4, handle, request_data->parameters.read_by_type.uuid, &att_data);
                    } else {
                        proto_tree_add_item(sub_tree, hf_btatt_value, tvb, offset, length - 4, ENC_NA);
                        offset += length - 4;
                    }
                }
            }

            if (request_data && request_data->opcode == (opcode - 1)) {
                sub_item = proto_tree_add_uint(main_tree, hf_btatt_uuid16, tvb, 0, 0, request_data->parameters.read_by_type.uuid.bt_uuid);
                proto_item_set_generated(sub_item);
            }
        }
        break;

    case 0x12: /* Write Request */
    case 0x1d: /* Handle Value Indication */
    case 0x52: /* Write Command */
    case 0x1b: /* Handle Value Notification */
        offset = dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, HANDLE_TVB);
        handle = tvb_get_letohs(tvb, offset - 2);

        col_append_info_by_handle(pinfo, handle, bluetooth_data);

        offset = dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, tvb_captured_length_remaining(tvb, offset), tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN), uuid, &att_data);

        if (!pinfo->fd->visited && bluetooth_data && (opcode == 0x12 || opcode == 0x1d)) {
            union request_parameters_union  request_parameters;

            request_parameters.read_write.handle = handle;
            request_parameters.read_write.offset = 0;

            save_request(pinfo, opcode, request_parameters, bluetooth_data);
        }
        break;

    case 0x13: /* Write Response */
        /* No parameters */

        if (request_data && request_data->opcode == (opcode - 1)) {
            dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, request_data->parameters.read_write.handle);

            dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, 0, request_data->parameters.read_write.handle, uuid, &att_data);

            col_append_info_by_handle(pinfo, request_data->parameters.read_write.handle, bluetooth_data);
        }

        break;

    case 0x16: /* Prepare Write Request */
    case 0x17: /* Prepare Write Response */
        offset = dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, HANDLE_TVB);
        handle = tvb_get_letohs(tvb, offset - 2);

        col_append_info_by_handle(pinfo, handle, bluetooth_data);
        col_append_fstr(pinfo->cinfo, COL_INFO, "", Offset: %u"", tvb_get_letohs(tvb, offset));

        proto_tree_add_item(main_tree, hf_btatt_offset, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;

        if (!pinfo->fd->visited && bluetooth_data && opcode == 0x16) {
            union request_parameters_union  request_parameters;

            request_parameters.data = NULL;

            save_request(pinfo, opcode, request_parameters, bluetooth_data);
        }
        if (!pinfo->fd->visited && request_data && bluetooth_data && opcode == 0x16)
            save_value_fragment(pinfo, tvb, offset,
                    tvb_get_guint16(tvb, offset - 4, ENC_LITTLE_ENDIAN),
                    tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN),
                    bluetooth_data);

        /* XXX: How to detect there is max data in frame and it is last fragment?
        (Execute Write Request/Response is good candidate, but there is no one handle) */
        if (request_data && request_data->opcode == (opcode - 1) && tvb_captured_length(tvb) < mtu) {
            tvbuff_t  *next_tvb;
            guint      reassembled_length;
            guint8    *reassembled_data;

            sub_item = proto_tree_add_item(main_tree, hf_btatt_value, tvb, offset, -1, ENC_NA);

            reassembled_data = get_value(pinfo, request_data->parameters.read_write.handle, bluetooth_data, &reassembled_length);
            if (reassembled_data) {
                sub_tree = proto_item_add_subtree(sub_item, ett_btatt_value);
                next_tvb = tvb_new_child_real_data(tvb, reassembled_data, reassembled_length, reassembled_length);
                add_new_data_source(pinfo, next_tvb, ""Reassembled ATT"");
                dissect_attribute_value(sub_tree, NULL, pinfo, next_tvb, 0, tvb_captured_length(next_tvb), request_data->parameters.read_write.handle, uuid, &att_data);
            }
        } else {
            proto_tree_add_item(main_tree, hf_btatt_value, tvb, offset, -1, ENC_NA);
        }

        offset = tvb_reported_length(tvb);

        break;

    case 0x18: /* Execute Write Request */
        col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"",
                        val_to_str_const(tvb_get_guint8(tvb, offset), flags_vals, ""<unknown>""));
        proto_tree_add_item(main_tree, hf_btatt_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        offset++;

        if (!pinfo->fd->visited && bluetooth_data) {
            union request_parameters_union  request_parameters;

            /* NOTE: Enable request-response tracking using empty data*/
            request_parameters.data = NULL;

            save_request(pinfo, opcode, request_parameters, bluetooth_data);
        }
        break;

    case 0x19: /* Execute Write Response */
        /* No parameters */
        break;

    case 0x1E: /* Handle Value Confirmation */
        if (request_data && request_data->opcode == (opcode - 1)) {
            dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, request_data->parameters.read_write.handle);

            col_append_info_by_handle(pinfo, request_data->parameters.read_write.handle, bluetooth_data);

            dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, 0, request_data->parameters.read_write.handle, uuid, &att_data);
        }
        break;

    case 0xd2: /* Signed Write Command */
        {
            guint8 length;

  ","static int
dissect_btatt(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void *VAR_3)
{
    proto_item        *VAR_4;
    proto_tree        *VAR_5;
    proto_item        *VAR_6;
    proto_tree        *VAR_7;
    int                VAR_8 = 0;
    guint8             VAR_9;
    guint8             VAR_10;
    bluetooth_data_t  *VAR_11;
    btatt_data_t       VAR_12;
    request_data_t    *VAR_13;
    guint16            VAR_14;
    bluetooth_uuid_t   VAR_15;
    guint              VAR_16;

    memset(&VAR_15, 0, sizeof VAR_15);

    VAR_11 = (bluetooth_data_t *) VAR_3;

    if (tvb_reported_length_remaining(VAR_0, 0) < 1)
        return 0;

    VAR_12.bluetooth_data   = VAR_11;

    VAR_4 = proto_tree_add_item(VAR_2, VAR_17, VAR_0, 0, -1, VAR_18);
    VAR_5 = proto_item_add_subtree(VAR_4, VAR_19);

    col_set_str(VAR_1->cinfo, VAR_20, ""ATT"");

    switch (VAR_1->p2p_dir) {
        case VAR_21:
            col_set_str(VAR_1->cinfo, VAR_22, ""Sent "");
            break;
        case VAR_23:
            col_set_str(VAR_1->cinfo, VAR_22, ""Rcvd "");
            break;
        default:
            col_set_str(VAR_1->cinfo, VAR_22, ""UnknownDirection "");
            break;
    }

    VAR_16 = get_mtu(VAR_1, VAR_11);
    if (tvb_reported_length(VAR_0) > VAR_16)
        expert_add_info(VAR_1, VAR_4, &VAR_24);

    proto_tree_add_bitmask_with_flags(VAR_5, VAR_0, VAR_8, VAR_25, VAR_26,  VAR_27, VAR_18, VAR_28);
    VAR_9 = tvb_get_guint8(VAR_0, 0);
    VAR_12.opcode = VAR_9;
    VAR_8++;

    VAR_13 = get_request(VAR_0, VAR_8, VAR_1, VAR_9, VAR_11);

    col_append_str(VAR_1->cinfo, VAR_22, val_to_str_const(VAR_9, VAR_29, ""<unknown>""));

    switch (VAR_9) {
    case 0x01: /* COMMENT_0 */
        {
        guint8               VAR_30;
        bluetooth_uuid_t     VAR_31;
        const value_string  *VAR_32 = VAR_33;
        gint                 VAR_34 = VAR_35;

        proto_tree_add_bitmask_with_flags(VAR_5, VAR_0, VAR_8, VAR_36, VAR_26,  VAR_27, VAR_18, VAR_28);
        VAR_10 = tvb_get_guint8(VAR_0, VAR_8);
        VAR_8 += 1;

        VAR_8 = dissect_handle(VAR_5, VAR_1, VAR_37, VAR_0, VAR_8, VAR_11, NULL, VAR_38);
        VAR_14 = tvb_get_letohs(VAR_0, VAR_8 - 2);

        VAR_30 = tvb_get_guint8(VAR_0, VAR_8);

        if (VAR_30 >= 0x80 && VAR_30 <= 0x9F) {
            VAR_31 = get_service_uuid_from_handle(VAR_1, VAR_14, VAR_11);

            switch (VAR_31.bt_uuid) {
            case VAR_39:
                VAR_32 = VAR_40;
                VAR_34 = VAR_41;

                break;
            case VAR_42:
                VAR_32 = VAR_43;
                VAR_34 = VAR_44;

                break;
            case VAR_45:
                VAR_32 = VAR_46;
                VAR_34 = VAR_47;

                break;
            case VAR_48:
                VAR_32 = VAR_49;
                VAR_34 = VAR_50;

                break;
            case VAR_51:
                VAR_32 = VAR_52;
                VAR_34 = VAR_53;

                break;
            case VAR_54:
                VAR_32 = VAR_55;
                VAR_34 = VAR_56;

                break;
            case VAR_57:
                VAR_32 = VAR_58;
                VAR_34 = VAR_59;

                break;
            case VAR_60:
                VAR_32 = VAR_61;
                VAR_34 = VAR_62;

                break;
            case VAR_63:
                VAR_32 = VAR_64;
                VAR_34 = VAR_65;

                break;
            case VAR_66:
                VAR_32 = VAR_67;
                VAR_34 = VAR_68;

                break;
            case VAR_69:
                VAR_32 = VAR_70;
                VAR_34 = VAR_71;

                break;
            case VAR_72:
                VAR_32 = VAR_73;
                VAR_34 = VAR_74;

                break;
            case VAR_75:
                VAR_32 = VAR_76;
                VAR_34 = VAR_77;

                break;
            case VAR_78:
                VAR_32 = VAR_79;
                VAR_34 = VAR_80;

                break;
            case VAR_81:
                VAR_32 = VAR_82;
                VAR_34 = VAR_83;

                break;
            case VAR_84:
                VAR_32 = VAR_85;
                VAR_34 = VAR_86;

                break;
            default:
                VAR_32 = VAR_33;
                VAR_34 = VAR_35;
            }
        }
        col_append_fstr(VAR_1->cinfo, VAR_22, "" - %s"",
                        val_to_str_const(VAR_30, VAR_32, ""<unknown>""));

        col_append_info_by_handle(VAR_1, VAR_14, VAR_11);

        proto_tree_add_item(VAR_5, VAR_34, VAR_0, VAR_8, 1, VAR_87);
        VAR_8++;

        if (VAR_13 && (VAR_10 == 0x08 || VAR_10 == 0x10)) {
            VAR_6 = proto_tree_add_uint(VAR_5, VAR_88, VAR_0, 0, 0, VAR_13->parameters.read_by_type.uuid.bt_uuid);
            proto_item_set_generated(VAR_6);
        }
        }
        break;

    case 0x02: /* COMMENT_1 */
        col_append_fstr(VAR_1->cinfo, VAR_22, "", Client Rx MTU: %u"", tvb_get_letohs(VAR_0, VAR_8));
        proto_tree_add_item(VAR_5, VAR_89, VAR_0, VAR_8, 2, VAR_87);
        VAR_8 += 2;

        if (!VAR_1->fd->visited && VAR_11) {
            union request_parameters_union  VAR_90;

            VAR_90.mtu.mtu = tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87);

            save_request(VAR_1, VAR_9, VAR_90, VAR_11);
        }

        break;

    case 0x03: /* COMMENT_2 */
        col_append_fstr(VAR_1->cinfo, VAR_22, "", Server Rx MTU: %u"", tvb_get_letohs(VAR_0, VAR_8));
        proto_tree_add_item(VAR_5, VAR_91, VAR_0, VAR_8, 2, VAR_87);
        if (!VAR_1->fd->visited && VAR_13 && VAR_11) {
            guint VAR_92;

            VAR_92 = tvb_get_guint16(VAR_0, VAR_8, VAR_87);
            if (VAR_92 > VAR_13->parameters.mtu.mtu)
                VAR_92 = VAR_13->parameters.mtu.mtu;
            save_mtu(VAR_1, VAR_11, VAR_92);
        }
        VAR_8 += 2;
        break;

    case 0x04: /* COMMENT_3 */
        col_append_fstr(VAR_1->cinfo, VAR_22, "", Handles: 0x%04x..0x%04x"",
                            tvb_get_letohs(VAR_0, VAR_8), tvb_get_letohs(VAR_0, VAR_8+2));
        proto_tree_add_item(VAR_5, VAR_93, VAR_0, VAR_8, 2, VAR_87);
        VAR_8 += 2;

        proto_tree_add_item(VAR_5, VAR_94, VAR_0, VAR_8, 2, VAR_87);
        VAR_8 += 2;

        if (!VAR_1->fd->visited && VAR_11) {
            union request_parameters_union  VAR_90;

            VAR_90.find_information.starting_handle = tvb_get_guint16(VAR_0, VAR_8 - 4, VAR_87);
            VAR_90.find_information.ending_handle   = tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87);

            save_request(VAR_1, VAR_9, VAR_90, VAR_11);
        }

        break;

    case 0x05: /* COMMENT_4 */
        {
            guint8  VAR_95;

            VAR_6 = proto_tree_add_item(VAR_5, VAR_96, VAR_0, VAR_8, 1, VAR_87);
            VAR_95 = tvb_get_guint8(VAR_0, VAR_8);
            VAR_8 += 1;

            if (VAR_95 == 1) {
                while (tvb_reported_length_remaining(VAR_0, VAR_8) > 0) {
                    VAR_6 = proto_tree_add_item(VAR_5, VAR_97, VAR_0, VAR_8, 4, VAR_18);
                    VAR_7 = proto_item_add_subtree(VAR_6, VAR_98);

                    VAR_8 = dissect_handle(VAR_7, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, NULL, VAR_38);
                    VAR_14 = tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87);

                    proto_tree_add_item(VAR_7, VAR_88, VAR_0, VAR_8, 2, VAR_87);
                    VAR_15 = get_uuid(VAR_0, VAR_8, 2);
                    VAR_8 += 2;

                    proto_item_append_text(VAR_6, "", Handle: 0x%04x, UUID: %s"",
                            VAR_14, print_uuid(&VAR_15));

                    save_handle(VAR_1, VAR_15, VAR_14, VAR_100, VAR_11);

                    col_append_info_by_handle(VAR_1, VAR_14, VAR_11);
                }
            }
            else if (VAR_95 == 2) {
                while (tvb_reported_length_remaining(VAR_0, VAR_8) > 0) {
                    VAR_6 = proto_tree_add_item(VAR_5, VAR_97, VAR_0, VAR_8, 4, VAR_18);
                    VAR_7 = proto_item_add_subtree(VAR_6, VAR_98);

                    VAR_8 = dissect_handle(VAR_7, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, NULL, VAR_38);
                    VAR_14 = tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87);

                    proto_tree_add_item(VAR_7, VAR_101, VAR_0, VAR_8, 16, VAR_18);
                    VAR_15 = get_uuid(VAR_0, VAR_8, 16);
                    VAR_8 += 16;

                    proto_item_append_text(VAR_6, "", Handle: 0x%04x, UUID: %s"",
                            VAR_14, print_uuid(&VAR_15));

                    save_handle(VAR_1, VAR_15, VAR_14, VAR_100, VAR_11);

                    col_append_info_by_handle(VAR_1, VAR_14, VAR_11);
                }
            }
            else {
                expert_add_info(VAR_1, VAR_6, &VAR_102);
            }
        }
        break;

    case 0x06: /* COMMENT_5 */
        col_append_fstr(VAR_1->cinfo, VAR_22, "", %s, Handles: 0x%04x..0x%04x"",
                            val_to_str_ext_const(tvb_get_letohs(VAR_0, VAR_8+4), &VAR_103, ""<unknown>""),
                            tvb_get_letohs(VAR_0, VAR_8), tvb_get_letohs(VAR_0, VAR_8+2));

        proto_tree_add_item(VAR_5, VAR_93, VAR_0, VAR_8, 2, VAR_87);
        VAR_8 += 2;

        proto_tree_add_item(VAR_5, VAR_94, VAR_0, VAR_8, 2, VAR_87);
        VAR_8 += 2;

        proto_tree_add_item(VAR_5, VAR_88, VAR_0, VAR_8, 2, VAR_87);
        VAR_15 = get_uuid(VAR_0, VAR_8 - 2, 2);
        VAR_8 += 2;

        dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, tvb_captured_length_remaining(VAR_0, VAR_8), 0, VAR_15, &VAR_12);

        if (!VAR_1->fd->visited && VAR_11) {
            union request_parameters_union  VAR_90;

            VAR_90.read_by_type.starting_handle = tvb_get_guint16(VAR_0, VAR_8 - 6, VAR_87);
            VAR_90.read_by_type.ending_handle   = tvb_get_guint16(VAR_0, VAR_8 - 4, VAR_87);
            VAR_90.read_by_type.uuid = VAR_15;

            save_request(VAR_1, VAR_9, VAR_90, VAR_11);
        }

        VAR_8 = tvb_reported_length(VAR_0);

        break;

    case 0x07: /* COMMENT_6 */
        while (tvb_reported_length_remaining(VAR_0, VAR_8) > 0) {
            VAR_6 = proto_tree_add_none_format(VAR_5, VAR_104, VAR_0, VAR_8, 4,
                                            ""Handles Info, Handle: 0x%04x, Group End Handle: 0x%04x"",
                                            tvb_get_letohs(VAR_0, VAR_8), tvb_get_letohs(VAR_0, VAR_8+2));

            VAR_7 = proto_item_add_subtree(VAR_6, VAR_98);

            VAR_8 = dissect_handle(VAR_7, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, NULL, VAR_38);

            proto_tree_add_item(VAR_7, VAR_105, VAR_0, VAR_8, 2, VAR_87);
            VAR_8 += 2;

            if (VAR_13)
                save_handle(VAR_1, VAR_13->parameters.read_by_type.uuid,
                        tvb_get_guint16(VAR_0, VAR_8 - 4, VAR_87),
                        VAR_100, VAR_11);

        }
        break;

    case 0x08: /* COMMENT_7 */
    case 0x10: /* COMMENT_8 */
        col_append_fstr(VAR_1->cinfo, VAR_22, "", %s, Handles: 0x%04x..0x%04x"",
                            val_to_str_ext_const(tvb_get_letohs(VAR_0, VAR_8+4), &VAR_103, ""<unknown>""),
                            tvb_get_letohs(VAR_0, VAR_8), tvb_get_letohs(VAR_0, VAR_8+2));

        proto_tree_add_item(VAR_5, VAR_93, VAR_0, VAR_8, 2, VAR_87);
        VAR_8 += 2;
        proto_tree_add_item(VAR_5, VAR_94, VAR_0, VAR_8, 2, VAR_87);
        VAR_8 += 2;

        if (tvb_reported_length_remaining(VAR_0, VAR_8) == 2) {
            proto_tree_add_item(VAR_5, VAR_88, VAR_0, VAR_8, 2, VAR_87);
            VAR_8 += 2;

            if (!VAR_1->fd->visited && VAR_11) {
                union request_parameters_union  VAR_90;

                VAR_90.read_by_type.starting_handle = tvb_get_guint16(VAR_0, VAR_8 - 6, VAR_87);
                VAR_90.read_by_type.ending_handle   = tvb_get_guint16(VAR_0, VAR_8 - 4, VAR_87);
                VAR_90.read_by_type.uuid = get_uuid(VAR_0, VAR_8 - 2, 2);

                save_request(VAR_1, VAR_9, VAR_90, VAR_11);
            }
        } else if (tvb_reported_length_remaining(VAR_0, VAR_8) == 16) {
            VAR_6 = proto_tree_add_item(VAR_5, VAR_101, VAR_0, VAR_8, 16, VAR_18);
            proto_item_append_text(VAR_6, "" (%s)"", val_to_str_ext_const(tvb_get_letohs(VAR_0, VAR_8),
                                            &VAR_103, ""<unknown>""));
            VAR_8 += 16;

            if (!VAR_1->fd->visited && VAR_11) {
                union request_parameters_union  VAR_90;

                VAR_90.read_by_type.starting_handle = tvb_get_guint16(VAR_0, VAR_8 - 20, VAR_87);
                VAR_90.read_by_type.ending_handle   = tvb_get_guint16(VAR_0, VAR_8 - 18, VAR_87);
                VAR_90.read_by_type.uuid = get_uuid(VAR_0, VAR_8 - 16, 16);

                save_request(VAR_1, VAR_9, VAR_90, VAR_11);
            }
        } else {
            VAR_6 = proto_tree_add_item(VAR_2, VAR_106, VAR_0, VAR_8, -1, VAR_18);
            expert_add_info(VAR_1, VAR_6, &VAR_107);
            VAR_8 = tvb_captured_length(VAR_0);
        }

        break;

    case 0x09: /* COMMENT_9 */
        {
            guint8  VAR_108 = tvb_get_guint8(VAR_0, VAR_8);

            proto_tree_add_item(VAR_5, VAR_109, VAR_0, VAR_8, 1, VAR_87);
            VAR_8++;

            if (VAR_108 > 0) {
                col_append_fstr(VAR_1->cinfo, VAR_22, "", Attribute List Length: %u"",
                                        tvb_reported_length_remaining(VAR_0, VAR_8)/VAR_108);

                while (tvb_reported_length_remaining(VAR_0, VAR_8) >= VAR_108)
                {
                    VAR_6 = proto_tree_add_none_format(VAR_5, VAR_110, VAR_0,
                                                    VAR_8, VAR_108, ""Attribute Data, Handle: 0x%04x"",
                                                    tvb_get_letohs(VAR_0, VAR_8));

                    VAR_7 = proto_item_add_subtree(VAR_6, VAR_98);

                    if (VAR_13) {
                        save_handle(VAR_1, VAR_13->parameters.read_by_type.uuid,
                                tvb_get_guint16(VAR_0, VAR_8, VAR_87),
                                VAR_100, VAR_11);
                    }

                    VAR_8 = dissect_handle(VAR_7, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, NULL, VAR_38);

                    if (VAR_13) {
                        VAR_8 = dissect_attribute_value(VAR_7, VAR_6, VAR_1, VAR_0, VAR_8, VAR_108 - 2, tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87), VAR_13->parameters.read_by_type.uuid, &VAR_12);
                    } else {
                        proto_tree_add_item(VAR_7, VAR_106, VAR_0, VAR_8, VAR_108 - 2, VAR_18);
                        VAR_8 += VAR_108 - 2;
                    }
                }
            }

            if (VAR_13) {
                VAR_6 = proto_tree_add_uint(VAR_5, VAR_88, VAR_0, 0, 0, VAR_13->parameters.read_by_type.uuid.bt_uuid);
                proto_item_set_generated(VAR_6);
            }
        }
        break;

    case 0x0a: /* COMMENT_10 */
        VAR_8 = dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_38);
        VAR_14 = tvb_get_letohs(VAR_0, VAR_8 - 2);

        col_append_info_by_handle(VAR_1, VAR_14, VAR_11);

        if (!VAR_1->fd->visited && VAR_11) {
            union request_parameters_union  VAR_90;

            VAR_90.read_write.handle = VAR_14;
            VAR_90.read_write.offset = 0;

            save_request(VAR_1, VAR_9, VAR_90, VAR_11);
        }

        VAR_8 = dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, tvb_captured_length_remaining(VAR_0, VAR_8), VAR_14, VAR_15, &VAR_12);

        break;

    case 0x0b: /* COMMENT_11 */
        if (VAR_13) {
            dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_13->parameters.read_write.handle);

            col_append_info_by_handle(VAR_1, VAR_13->parameters.read_write.handle, VAR_11);
        }

        if (is_long_attribute_value(VAR_15) && tvb_captured_length(VAR_0) >= VAR_16) {
            VAR_6 = proto_tree_add_item(VAR_5, VAR_106, VAR_0, VAR_8, -1, VAR_18);
            if (!VAR_1->fd->visited && VAR_13 && VAR_11)
                save_value_fragment(VAR_1, VAR_0, VAR_8, VAR_13->parameters.read_write.handle, 0, VAR_11);
            VAR_8 = tvb_captured_length(VAR_0);

            expert_add_info(VAR_1, VAR_6, &VAR_111);
        } else {
            if (VAR_13)
                VAR_14 = VAR_13->parameters.read_write.handle;
            else
                VAR_14 = 0;

            VAR_8 = dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, tvb_captured_length_remaining(VAR_0, VAR_8), VAR_14, VAR_15, &VAR_12);
        }
        break;

    case 0x0c: /* COMMENT_12 */
        VAR_8 = dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_38);
        VAR_14 = tvb_get_letohs(VAR_0, VAR_8 - 2);

        col_append_info_by_handle(VAR_1, VAR_14, VAR_11);
        col_append_fstr(VAR_1->cinfo, VAR_22, "", Offset: %u"", tvb_get_letohs(VAR_0, VAR_8));

        proto_tree_add_item(VAR_5, VAR_112, VAR_0, VAR_8, 2, VAR_87);
        VAR_8 += 2;

        dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, 0, VAR_14, VAR_15, &VAR_12);


        if (!VAR_1->fd->visited && VAR_11) {
            union request_parameters_union  VAR_90;

            VAR_90.read_write.handle = VAR_14;
            VAR_90.read_write.offset = tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87);

            save_request(VAR_1, VAR_9, VAR_90, VAR_11);
        }
        break;

    case 0x0d: /* COMMENT_13 */
        if (VAR_13 && VAR_13->opcode == (VAR_9 - 1)) {
            dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_13->parameters.read_write.handle);

            col_append_info_by_handle(VAR_1, VAR_13->parameters.read_write.handle, VAR_11);

            if (VAR_13->parameters.read_write.offset == 0 && !is_long_attribute_value(VAR_15)) {
                VAR_8 = dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, tvb_captured_length_remaining(VAR_0, VAR_8), VAR_13->parameters.read_write.handle, VAR_15, &VAR_12);
            } else {
                if (!VAR_1->fd->visited && VAR_11)
                    save_value_fragment(VAR_1, VAR_0, VAR_8, VAR_13->parameters.read_write.handle, VAR_13->parameters.read_write.offset, VAR_11);

                if (tvb_captured_length(VAR_0) < VAR_16) {
                    tvbuff_t  *VAR_113;
                    guint      VAR_114;
                    guint8    *VAR_115;

                    VAR_6 = proto_tree_add_item(VAR_5, VAR_106, VAR_0, VAR_8, -1, VAR_18);
                    VAR_8 = tvb_captured_length(VAR_0);

                    VAR_115 = get_value(VAR_1, VAR_13->parameters.read_write.handle, VAR_11, &VAR_114);
                    if (VAR_115) {
                        VAR_7 = proto_item_add_subtree(VAR_6, VAR_116);
                        VAR_113 = tvb_new_child_real_data(VAR_0, VAR_115, VAR_114, VAR_114);
                        add_new_data_source(VAR_1, VAR_113, ""Reassembled ATT"");
                        dissect_attribute_value(VAR_7, NULL, VAR_1, VAR_113, 0, tvb_captured_length(VAR_113), VAR_13->parameters.read_write.handle, VAR_15, &VAR_12);
                    }
                } else {
                    VAR_6 = proto_tree_add_item(VAR_5, VAR_106, VAR_0, VAR_8, -1, VAR_18);
                    VAR_8 = tvb_captured_length(VAR_0);

                    expert_add_info(VAR_1, VAR_6, &VAR_111);
                }
            }
        } else {
            proto_tree_add_item(VAR_5, VAR_106, VAR_0, VAR_8, -1, VAR_18);
            VAR_8 = tvb_captured_length(VAR_0);
        }

        break;

    case 0x0e: /* COMMENT_14 */
        if(tvb_reported_length_remaining(VAR_0, VAR_8) < 4) {
            expert_add_info(VAR_1, VAR_4, &VAR_117);
            break;
        }

        col_append_str(VAR_1->cinfo, VAR_22, "", Handles: "");
        while (tvb_reported_length_remaining(VAR_0, VAR_8) >= 2) {
            VAR_8 = dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_38);
            VAR_14 = tvb_get_letohs(VAR_0, VAR_8 - 2);
            col_append_fstr(VAR_1->cinfo, VAR_22, ""0x%04x "", VAR_14);

            dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, 0, VAR_14, VAR_15, &VAR_12);
        }

        if (!VAR_1->fd->visited && VAR_11) {
            union request_parameters_union  VAR_90;

            VAR_90.read_multiple.number_of_handles = (tvb_captured_length(VAR_0) - 1) / 2;
            VAR_90.read_multiple.handle = (guint16 *) tvb_memdup(wmem_file_scope(),
                    VAR_0, 1, VAR_90.read_multiple.number_of_handles * 2);

            save_request(VAR_1, VAR_9, VAR_90, VAR_11);
        }
        break;

    case 0x0f: /* COMMENT_15 */
        if (VAR_13 && VAR_13->opcode == (VAR_9 - 1)) {
            guint  VAR_118;

            for (VAR_118 = 0; VAR_118 < VAR_13->parameters.read_multiple.number_of_handles; VAR_118 += 1) {
                dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_13->parameters.read_multiple.handle[VAR_118]);
                VAR_8 = dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, tvb_captured_length_remaining(VAR_0, VAR_8), VAR_13->parameters.read_multiple.handle[VAR_118], VAR_15, &VAR_12);
            }
        } else {
            proto_tree_add_item(VAR_5, VAR_106, VAR_0, VAR_8, -1, VAR_18);
            VAR_8 = tvb_reported_length(VAR_0);
        }
        break;

    case 0x11: /* COMMENT_16 */
        {
            guint8  VAR_108 = tvb_get_guint8(VAR_0, VAR_8);

            proto_tree_add_item(VAR_5, VAR_109, VAR_0, VAR_8, 1, VAR_87);
            VAR_8++;

            if (VAR_108 > 0) {
                col_append_fstr(VAR_1->cinfo, VAR_22, "", Attribute List Length: %u"", tvb_reported_length_remaining(VAR_0, VAR_8)/VAR_108);

                while (tvb_reported_length_remaining(VAR_0, VAR_8) >= VAR_108) {
                    VAR_6 = proto_tree_add_none_format(VAR_5, VAR_110, VAR_0, VAR_8, VAR_108,
                                                    ""Attribute Data, Handle: 0x%04x, Group End Handle: 0x%04x"",
                                                    tvb_get_letohs(VAR_0, VAR_8), tvb_get_letohs(VAR_0, VAR_8+2));

                    VAR_7 = proto_item_add_subtree(VAR_6, VAR_98);

                    VAR_8 = dissect_handle(VAR_7, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, NULL, VAR_38);
                    VAR_14 = tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87);

                    proto_tree_add_item(VAR_7, VAR_105, VAR_0, VAR_8, 2, VAR_87);
                    VAR_8 += 2;

                    if (VAR_13) {
                        VAR_8 = dissect_attribute_value(VAR_7, VAR_6, VAR_1, VAR_0, VAR_8, VAR_108 - 4, VAR_14, VAR_13->parameters.read_by_type.uuid, &VAR_12);
                    } else {
                        proto_tree_add_item(VAR_7, VAR_106, VAR_0, VAR_8, VAR_108 - 4, VAR_18);
                        VAR_8 += VAR_108 - 4;
                    }
                }
            }

            if (VAR_13 && VAR_13->opcode == (VAR_9 - 1)) {
                VAR_6 = proto_tree_add_uint(VAR_5, VAR_88, VAR_0, 0, 0, VAR_13->parameters.read_by_type.uuid.bt_uuid);
                proto_item_set_generated(VAR_6);
            }
        }
        break;

    case 0x12: /* COMMENT_17 */
    case 0x1d: /* COMMENT_18 */
    case 0x52: /* COMMENT_19 */
    case 0x1b: /* COMMENT_20 */
        VAR_8 = dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_38);
        VAR_14 = tvb_get_letohs(VAR_0, VAR_8 - 2);

        col_append_info_by_handle(VAR_1, VAR_14, VAR_11);

        VAR_8 = dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, tvb_captured_length_remaining(VAR_0, VAR_8), tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87), VAR_15, &VAR_12);

        if (!VAR_1->fd->visited && VAR_11 && (VAR_9 == 0x12 || VAR_9 == 0x1d)) {
            union request_parameters_union  VAR_90;

            VAR_90.read_write.handle = VAR_14;
            VAR_90.read_write.offset = 0;

            save_request(VAR_1, VAR_9, VAR_90, VAR_11);
        }
        break;

    case 0x13: /* COMMENT_21 */
        /* COMMENT_22 */

        if (VAR_13 && VAR_13->opcode == (VAR_9 - 1)) {
            dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_13->parameters.read_write.handle);

            dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, 0, VAR_13->parameters.read_write.handle, VAR_15, &VAR_12);

            col_append_info_by_handle(VAR_1, VAR_13->parameters.read_write.handle, VAR_11);
        }

        break;

    case 0x16: /* COMMENT_23 */
    case 0x17: /* COMMENT_24 */
        VAR_8 = dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_38);
        VAR_14 = tvb_get_letohs(VAR_0, VAR_8 - 2);

        col_append_info_by_handle(VAR_1, VAR_14, VAR_11);
        col_append_fstr(VAR_1->cinfo, VAR_22, "", Offset: %u"", tvb_get_letohs(VAR_0, VAR_8));

        proto_tree_add_item(VAR_5, VAR_112, VAR_0, VAR_8, 2, VAR_87);
        VAR_8 += 2;

        if (!VAR_1->fd->visited && VAR_11 && VAR_9 == 0x16) {
            union request_parameters_union  VAR_90;

            VAR_90.data = NULL;

            save_request(VAR_1, VAR_9, VAR_90, VAR_11);
        }
        if (!VAR_1->fd->visited && VAR_13 && VAR_11 && VAR_9 == 0x16)
            save_value_fragment(VAR_1, VAR_0, VAR_8,
                    tvb_get_guint16(VAR_0, VAR_8 - 4, VAR_87),
                    tvb_get_guint16(VAR_0, VAR_8 - 2, VAR_87),
                    VAR_11);

        /* COMMENT_25 */
                                                                                         
        if (VAR_13 && VAR_13->opcode == (VAR_9 - 1) && tvb_captured_length(VAR_0) < VAR_16) {
            tvbuff_t  *VAR_113;
            guint      VAR_114;
            guint8    *VAR_115;

            VAR_6 = proto_tree_add_item(VAR_5, VAR_106, VAR_0, VAR_8, -1, VAR_18);

            VAR_115 = get_value(VAR_1, VAR_13->parameters.read_write.handle, VAR_11, &VAR_114);
            if (VAR_115) {
                VAR_7 = proto_item_add_subtree(VAR_6, VAR_116);
                VAR_113 = tvb_new_child_real_data(VAR_0, VAR_115, VAR_114, VAR_114);
                add_new_data_source(VAR_1, VAR_113, ""Reassembled ATT"");
                dissect_attribute_value(VAR_7, NULL, VAR_1, VAR_113, 0, tvb_captured_length(VAR_113), VAR_13->parameters.read_write.handle, VAR_15, &VAR_12);
            }
        } else {
            proto_tree_add_item(VAR_5, VAR_106, VAR_0, VAR_8, -1, VAR_18);
        }

        VAR_8 = tvb_reported_length(VAR_0);

        break;

    case 0x18: /* COMMENT_27 */
        col_append_fstr(VAR_1->cinfo, VAR_22, "", %s"",
                        val_to_str_const(tvb_get_guint8(VAR_0, VAR_8), VAR_119, ""<unknown>""));
        proto_tree_add_item(VAR_5, VAR_120, VAR_0, VAR_8, 1, VAR_87);
        VAR_8++;

        if (!VAR_1->fd->visited && VAR_11) {
            union request_parameters_union  VAR_90;

            /* COMMENT_28 */
            VAR_90.data = NULL;

            save_request(VAR_1, VAR_9, VAR_90, VAR_11);
        }
        break;

    case 0x19: /* COMMENT_29 */
        /* COMMENT_22 */
        break;

    case 0x1E: /* COMMENT_30 */
        if (VAR_13 && VAR_13->opcode == (VAR_9 - 1)) {
            dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_13->parameters.read_write.handle);

            col_append_info_by_handle(VAR_1, VAR_13->parameters.read_write.handle, VAR_11);

            dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, 0, VAR_13->parameters.read_write.handle, VAR_15, &VAR_12);
        }
        break;

    case 0xd2: /* COMMENT_31 */
        {
            guint8 VAR_108;

            VAR_8 = dissect_handle(VAR_5, VAR_1, VAR_99, VAR_0, VAR_8, VAR_11, &VAR_15, VAR_38);
            VAR_14 = tvb_get_letohs(VAR_0, VAR_8 - 2);

            col_append_info_by_handle(VAR_1, VAR_14, VAR_11);

            VAR_108 = tvb_reported_length_remaining(VAR_0, VAR_8);
            dissect_attribute_value(VAR_5, NULL, VAR_1, VAR_0, VAR_8, (VAR_108 > 12) ? VAR_108 - 12 : 0, VAR_14, VAR_15, &VAR_12);
            if (VAR_108 > 12) {
                VAR_8 += VAR_108 - 12;
            }

            proto_tree_add_item(VAR_5, VAR_121, VAR_0, VAR_8, 4, VAR_87);
            VAR_8+=4;
            proto_tree_add_item(VAR_5, VAR_122, VAR_0, VAR_8, 8, VAR_18);
            VAR_8+=8;
        break;
        }
    default:
        break;
    }

    if (VAR_13 && VAR_13->opcode == (VAR_9 - 1)) {
        if (VAR_13->request_in_frame > 0  && VAR_13->request_in_frame != VAR_1->num) {
            VAR_6 = proto_tree_add_uint(VAR_5, VAR_123, VAR_0, 0, 0, VAR_13->request_in_frame);
            proto_item_set_generated(VAR_6);
        }

        if (!VAR_1->fd->visited && VAR_13->response_in_frame == 0 &&
                VAR_1->num > VAR_13->request_in_frame)
            VAR_13->response_in_frame = VAR_1->num;

        if (VAR_13->response_in_frame > 0 && VAR_13->response_in_frame != VAR_1->num) {
            VAR_6 = proto_tree_add_uint(VAR_5, VAR_124, VAR_0, 0, 0, VAR_13->response_in_frame);
            proto_item_set_generated(VAR_6);
        }
    }

    return VAR_8;
}",wireshark/01f261de41f4dd3233ef578e5c0ffb9c25c7d14d/packet-btatt.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -233,7 +233,7 @@
             offset += 1;
 
             if (format == 1) {
-                while( tvb_reported_length_remaining(tvb, offset) > 0) {
+                while (tvb_reported_length_remaining(tvb, offset) > 0) {
                     sub_item = proto_tree_add_item(main_tree, hf_btatt_information_data, tvb, offset, 4, ENC_NA);
                     sub_tree = proto_item_add_subtree(sub_item, ett_btatt_list);
 
@@ -253,7 +253,7 @@
                 }
             }
             else if (format == 2) {
-                while( tvb_reported_length_remaining(tvb, offset) > 0) {
+                while (tvb_reported_length_remaining(tvb, offset) > 0) {
                     sub_item = proto_tree_add_item(main_tree, hf_btatt_information_data, tvb, offset, 4, ENC_NA);
                     sub_tree = proto_item_add_subtree(sub_item, ett_btatt_list);
 
@@ -310,7 +310,7 @@
         break;
 
     case 0x07: /* Find By Type Value Response */
-        while( tvb_reported_length_remaining(tvb, offset) > 0 ) {
+        while (tvb_reported_length_remaining(tvb, offset) > 0) {
             sub_item = proto_tree_add_none_format(main_tree, hf_btatt_handles_info, tvb, offset, 4,
                                             ""Handles Info, Handle: 0x%04x, Group End Handle: 0x%04x"",
                                             tvb_get_letohs(tvb, offset), tvb_get_letohs(tvb, offset+2));
@@ -384,7 +384,7 @@
             proto_tree_add_item(main_tree, hf_btatt_length, tvb, offset, 1, ENC_LITTLE_ENDIAN);
             offset++;
 
-            if(length > 0) {
+            if (length > 0) {
                 col_append_fstr(pinfo->cinfo, COL_INFO, "", Attribute List Length: %u"",
                                         tvb_reported_length_remaining(tvb, offset)/length);
 
@@ -487,7 +487,7 @@
         break;
 
     case 0x0d: /* Read Blob Response */
-        if (request_data) {
+        if (request_data && request_data->opcode == (opcode - 1)) {
             dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, request_data->parameters.read_write.handle);
 
             col_append_info_by_handle(pinfo, request_data->parameters.read_write.handle, bluetooth_data);
@@ -554,7 +554,7 @@
         break;
 
     case 0x0f: /* Multiple Read Response */
-        if (request_data) {
+        if (request_data && request_data->opcode == (opcode - 1)) {
             guint  i_handle;
 
             for (i_handle = 0; i_handle < request_data->parameters.read_multiple.number_of_handles; i_handle += 1) {
@@ -599,7 +599,7 @@
                 }
             }
 
-            if (request_data) {
+            if (request_data && request_data->opcode == (opcode - 1)) {
                 sub_item = proto_tree_add_uint(main_tree, hf_btatt_uuid16, tvb, 0, 0, request_data->parameters.read_by_type.uuid.bt_uuid);
                 proto_item_set_generated(sub_item);
             }
@@ -630,7 +630,7 @@
     case 0x13: /* Write Response */
         /* No parameters */
 
-        if (request_data) {
+        if (request_data && request_data->opcode == (opcode - 1)) {
             dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, request_data->parameters.read_write.handle);
 
             dissect_attribute_value(main_tree, NULL, pinfo, tvb, offset, 0, request_data->parameters.read_write.handle, uuid, &att_data);
@@ -664,9 +664,9 @@
                     tvb_get_guint16(tvb, offset - 2, ENC_LITTLE_ENDIAN),
                     bluetooth_data);
 
-/* XXX: How to detect there is max data in frame and it is last fragment?
+        /* XXX: How to detect there is max data in frame and it is last fragment?
         (Execute Write Request/Response is good candidate, but there is no one handle) */
-        if (request_data && tvb_captured_length(tvb) < mtu) {
+        if (request_data && request_data->opcode == (opcode - 1) && tvb_captured_length(tvb) < mtu) {
             tvbuff_t  *next_tvb;
             guint      reassembled_length;
             guint8    *reassembled_data;
@@ -709,7 +709,7 @@
         break;
 
     case 0x1E: /* Handle Value Confirmation */
-        if (request_data) {
+        if (request_data && request_data->opcode == (opcode - 1)) {
             dissect_handle(main_tree, pinfo, hf_btatt_handle, tvb, offset, bluetooth_data, &uuid, request_data->parameters.read_write.handle);
 
             col_append_info_by_handle(pinfo, request_data->parameters.read_write.handle, bluetooth_data);
@@ -743,7 +743,7 @@
         break;
     }
 
-    if (request_data) {
+    if (request_data && request_data->opcode == (opcode - 1)) {
         if (request_data->request_in_frame > 0  && request_data->request_in_frame != pinfo->num) {
             sub_item = proto_tree_add_uint(main_tree, hf_request_in_frame, tvb, 0, 0, request_data->request_in_frame);
             proto_item_set_generated(sub_item);","{'deleted_lines': ['                while( tvb_reported_length_remaining(tvb, offset) > 0) {', '                while( tvb_reported_length_remaining(tvb, offset) > 0) {', '        while( tvb_reported_length_remaining(tvb, offset) > 0 ) {', '            if(length > 0) {', '        if (request_data) {', '        if (request_data) {', '            if (request_data) {', '        if (request_data) {', '/* XXX: How to detect there is max data in frame and it is last fragment?', '        if (request_data && tvb_captured_length(tvb) < mtu) {', '        if (request_data) {', '    if (request_data) {'], 'added_lines': ['                while (tvb_reported_length_remaining(tvb, offset) > 0) {', '                while (tvb_reported_length_remaining(tvb, offset) > 0) {', '        while (tvb_reported_length_remaining(tvb, offset) > 0) {', '            if (length > 0) {', '        if (request_data && request_data->opcode == (opcode - 1)) {', '        if (request_data && request_data->opcode == (opcode - 1)) {', '            if (request_data && request_data->opcode == (opcode - 1)) {', '        if (request_data && request_data->opcode == (opcode - 1)) {', '        /* XXX: How to detect there is max data in frame and it is last fragment?', '        if (request_data && request_data->opcode == (opcode - 1) && tvb_captured_length(tvb) < mtu) {', '        if (request_data && request_data->opcode == (opcode - 1)) {', '    if (request_data && request_data->opcode == (opcode - 1)) {']}",True,"In Wireshark 3.0.x before 3.0.8, the BT ATT dissector could crash. This was addressed in epan/dissectors/packet-btatt.c by validating opcodes.",6.5,MEDIUM,1,test,2019-12-06T22:31:12Z,3
CVE-2020-7045,['CWE-476'],AV:A/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"btatt: check the opcode against the current data.

While here:
- some indentation fixes
- add defines for missing ATT_OPCODEs

Bug: 16258
Change-Id: I2cd8172bcff9c209bbddc4729573c008a8e81fec
Reviewed-on: https://code.wireshark.org/review/35339
Petri-Dish: Dario Lombardo <lomato@gmail.com>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 68a7add68a725203cccf98d7d6c752a6bad866c0)
Reviewed-on: https://code.wireshark.org/review/35387
Reviewed-by: Dario Lombardo <lomato@gmail.com>",01f261de41f4dd3233ef578e5c0ffb9c25c7d14d,https://github.com/wireshark/wireshark/commit/01f261de41f4dd3233ef578e5c0ffb9c25c7d14d,epan/dissectors/packet-btatt.c,save_request,"static void
save_request(packet_info *pinfo, guint8 opcode, union request_parameters_union parameters,
bluetooth_data_t *bluetooth_data)
{
wmem_tree_key_t  key[5];
guint32          frame_number, curr_layer_num;
request_data_t  *request_data;
frame_number = pinfo->num;
curr_layer_num = pinfo->curr_layer_num;
key[0].length = 1;
key[0].key    = &bluetooth_data->interface_id;
key[1].length = 1;
key[1].key    = &bluetooth_data->adapter_id;
key[2].length = 1;
key[2].key    = &curr_layer_num;
key[3].length = 1;
key[3].key    = &frame_number;
key[4].length = 0;
key[4].key    = NULL;
request_data = wmem_new(wmem_file_scope(), request_data_t);
request_data->opcode = opcode;
request_data->request_in_frame = frame_number;
request_data->response_in_frame = 0;
request_data->parameters = parameters;
wmem_tree_insert32_array(requests, key, request_data);
}","static void
save_request(packet_info *VAR_0, guint8 VAR_1, union request_parameters_union VAR_2,
bluetooth_data_t *VAR_3)
{
wmem_tree_key_t  VAR_4[5];
guint32          VAR_5, VAR_6;
request_data_t  *VAR_7;
VAR_5 = VAR_0->num;
VAR_6 = VAR_0->curr_layer_num;
VAR_4[0].length = 1;
VAR_4[0].key    = &VAR_3->interface_id;
VAR_4[1].length = 1;
VAR_4[1].key    = &VAR_3->adapter_id;
VAR_4[2].length = 1;
VAR_4[2].key    = &VAR_6;
VAR_4[3].length = 1;
VAR_4[3].key    = &VAR_5;
VAR_4[4].length = 0;
VAR_4[4].key    = NULL;
VAR_7 = wmem_new(wmem_file_scope(), request_data_t);
VAR_7->opcode = VAR_1;
VAR_7->request_in_frame = VAR_5;
VAR_7->response_in_frame = 0;
VAR_7->parameters = VAR_2;
wmem_tree_insert32_array(VAR_8, VAR_4, VAR_7);
}",wireshark/01f261de41f4dd3233ef578e5c0ffb9c25c7d14d/packet-btatt.c/vul/before/0.json,"static void
save_request(packet_info *pinfo, guint8 opcode, union request_parameters_union parameters,
        bluetooth_data_t *bluetooth_data)
{
    wmem_tree_key_t  key[5];
    guint32          frame_number, curr_layer_num;
    request_data_t  *request_data;

    frame_number = pinfo->num;
    curr_layer_num = pinfo->curr_layer_num;

    key[0].length = 1;
    key[0].key    = &bluetooth_data->interface_id;
    key[1].length = 1;
    key[1].key    = &bluetooth_data->adapter_id;
    key[2].length = 1;
    key[2].key    = &curr_layer_num;
    key[3].length = 1;
    key[3].key    = &frame_number;
    key[4].length = 0;
    key[4].key    = NULL;

    request_data = wmem_new0(wmem_file_scope(), request_data_t);
    request_data->opcode = opcode;
    request_data->request_in_frame = frame_number;
    request_data->response_in_frame = 0;

    request_data->parameters = parameters;

    wmem_tree_insert32_array(requests, key, request_data);
}","static void
save_request(packet_info *VAR_0, guint8 VAR_1, union request_parameters_union VAR_2,
        bluetooth_data_t *VAR_3)
{
    wmem_tree_key_t  VAR_4[5];
    guint32          VAR_5, VAR_6;
    request_data_t  *VAR_7;

    VAR_5 = VAR_0->num;
    VAR_6 = VAR_0->curr_layer_num;

    VAR_4[0].length = 1;
    VAR_4[0].key    = &VAR_3->interface_id;
    VAR_4[1].length = 1;
    VAR_4[1].key    = &VAR_3->adapter_id;
    VAR_4[2].length = 1;
    VAR_4[2].key    = &VAR_6;
    VAR_4[3].length = 1;
    VAR_4[3].key    = &VAR_5;
    VAR_4[4].length = 0;
    VAR_4[4].key    = NULL;

    VAR_7 = wmem_new0(wmem_file_scope(), request_data_t);
    VAR_7->opcode = VAR_1;
    VAR_7->request_in_frame = VAR_5;
    VAR_7->response_in_frame = 0;

    VAR_7->parameters = VAR_2;

    wmem_tree_insert32_array(VAR_8, VAR_4, VAR_7);
}",wireshark/01f261de41f4dd3233ef578e5c0ffb9c25c7d14d/packet-btatt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -20,7 +20,7 @@
     key[4].length = 0;
     key[4].key    = NULL;
 
-    request_data = wmem_new(wmem_file_scope(), request_data_t);
+    request_data = wmem_new0(wmem_file_scope(), request_data_t);
     request_data->opcode = opcode;
     request_data->request_in_frame = frame_number;
     request_data->response_in_frame = 0;","{'deleted_lines': ['    request_data = wmem_new(wmem_file_scope(), request_data_t);'], 'added_lines': ['    request_data = wmem_new0(wmem_file_scope(), request_data_t);']}",True,"In Wireshark 3.0.x before 3.0.8, the BT ATT dissector could crash. This was addressed in epan/dissectors/packet-btatt.c by validating opcodes.",6.5,MEDIUM,1,test,2019-12-06T22:31:12Z,3
CVE-2019-19880,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,sqlite,"When processing constant integer values in ORDER BY clauses of window
definitions (see check-in [7e4809eadfe99ebf]) be sure to fully disable
the constant value to avoid an invalid pointer dereference if the expression
is ever duplicated. This fixes a crash report from Yongheng and Rui.

FossilOrigin-Name: 1ca0bd982ab1183bbafce0d260e4dceda5eb766ed2e7793374a88d1ae0bdd2ca",75e95e1fcd52d3ec8282edb75ac8cd0814095d54,https://github.com/sqlite/sqlite/commit/75e95e1fcd52d3ec8282edb75ac8cd0814095d54,src/window.c,exprListAppendList,"static ExprList *exprListAppendList(
Parse *pParse,          
ExprList *pList,        
ExprList *pAppend,      
int bIntToNull
){
if( pAppend ){
int i;
int nInit = pList ? pList->nExpr : 0;
for(i=0; i<pAppend->nExpr; i++){
Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);
if( bIntToNull && pDup && pDup->op==TK_INTEGER ){
pDup->op = TK_NULL;
pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);
}
pList = sqlite3ExprListAppend(pParse, pList, pDup);
if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;
}
}
return pList;
}","static ExprList *exprListAppendList(
Parse *VAR_0,          
ExprList *VAR_1,        
ExprList *VAR_2,      
int VAR_3
){
if( VAR_2 ){
int VAR_4;
int VAR_5 = VAR_1 ? VAR_1->nExpr : 0;
for(VAR_4=0; VAR_4<VAR_2->nExpr; VAR_4++){
Expr *VAR_6 = sqlite3ExprDup(VAR_0->db, VAR_2->a[VAR_4].pExpr, 0);
if( VAR_3 && VAR_6 && VAR_6->op==VAR_7 ){
VAR_6->op = VAR_8;
VAR_6->flags &= ~(VAR_9|VAR_10|VAR_11);
}
VAR_1 = sqlite3ExprListAppend(VAR_0, VAR_1, VAR_6);
if( VAR_1 ) VAR_1->a[VAR_5+VAR_4].sortFlags = VAR_2->a[VAR_4].sortFlags;
}
}
return VAR_1;
}",sqlite/75e95e1fcd52d3ec8282edb75ac8cd0814095d54/window.c/vul/before/0.json,"static ExprList *exprListAppendList(
  Parse *pParse,          /* Parsing context */
  ExprList *pList,        /* List to which to append. Might be NULL */
  ExprList *pAppend,      /* List of values to append. Might be NULL */
  int bIntToNull
){
  if( pAppend ){
    int i;
    int nInit = pList ? pList->nExpr : 0;
    for(i=0; i<pAppend->nExpr; i++){
      Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);
      assert( pDup==0 || !ExprHasProperty(pDup, EP_MemToken) );
      if( bIntToNull && pDup && pDup->op==TK_INTEGER ){
        pDup->op = TK_NULL;
        pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);
        pDup->u.zToken = 0;
      }
      pList = sqlite3ExprListAppend(pParse, pList, pDup);
      if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;
    }
  }
  return pList;
}","static ExprList *exprListAppendList(
  Parse *VAR_0,          /* COMMENT_0 */
  ExprList *VAR_1,        /* COMMENT_1 */
  ExprList *VAR_2,      /* COMMENT_2 */
  int VAR_3
){
  if( VAR_2 ){
    int VAR_4;
    int VAR_5 = VAR_1 ? VAR_1->nExpr : 0;
    for(VAR_4=0; VAR_4<VAR_2->nExpr; VAR_4++){
      Expr *VAR_6 = sqlite3ExprDup(VAR_0->db, VAR_2->a[VAR_4].pExpr, 0);
      assert( VAR_6==0 || !ExprHasProperty(VAR_6, VAR_7) );
      if( VAR_3 && VAR_6 && VAR_6->op==VAR_8 ){
        VAR_6->op = VAR_9;
        VAR_6->flags &= ~(VAR_10|VAR_11|VAR_12);
        VAR_6->u.zToken = 0;
      }
      VAR_1 = sqlite3ExprListAppend(VAR_0, VAR_1, VAR_6);
      if( VAR_1 ) VAR_1->a[VAR_5+VAR_4].sortFlags = VAR_2->a[VAR_4].sortFlags;
    }
  }
  return VAR_1;
}",sqlite/75e95e1fcd52d3ec8282edb75ac8cd0814095d54/window.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,9 +9,11 @@
     int nInit = pList ? pList->nExpr : 0;
     for(i=0; i<pAppend->nExpr; i++){
       Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);
+      assert( pDup==0 || !ExprHasProperty(pDup, EP_MemToken) );
       if( bIntToNull && pDup && pDup->op==TK_INTEGER ){
         pDup->op = TK_NULL;
         pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);
+        pDup->u.zToken = 0;
       }
       pList = sqlite3ExprListAppend(pParse, pList, pDup);
       if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;","{'deleted_lines': [], 'added_lines': ['      assert( pDup==0 || !ExprHasProperty(pDup, EP_MemToken) );', '        pDup->u.zToken = 0;']}",True,exprListAppendList in window.c in SQLite 3.30.1 allows attackers to trigger an invalid pointer dereference because constant integer values in ORDER BY clauses of window definitions are mishandled.,7.5,HIGH,2,test,2019-12-18T00:05:50Z,3
CVE-2019-19924,['CWE-755'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,sqlite,"When an error occurs while rewriting the parser tree for window functions
in the sqlite3WindowRewrite() routine, make sure that pParse->nErr is set,
and make sure that this shuts down any subsequent code generation that might
depend on the transformations that were implemented.  This fixes a problem
discovered by the Yongheng and Rui fuzzer.

FossilOrigin-Name: e2bddcd4c55ba3cbe0130332679ff4b048630d0ced9a8899982edb5a3569ba7f",8654186b0236d556aa85528c2573ee0b6ab71be3,https://github.com/sqlite/sqlite/commit/8654186b0236d556aa85528c2573ee0b6ab71be3,src/expr.c,codeCompare,"static int codeCompare(
Parse *pParse,    
Expr *pLeft,      
Expr *pRight,     
int opcode,       
int in1, int in2, 
int dest,         
int jumpIfNull,   
int isCommuted    
){
int p5;
int addr;
CollSeq *p4;
if( isCommuted ){
p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);
}else{
p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);
}
p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);
addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,
(void*)p4, P4_COLLSEQ);
sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);
return addr;
}","static int codeCompare(
Parse *VAR_0,    
Expr *VAR_1,      
Expr *VAR_2,     
int VAR_3,       
int VAR_4, int VAR_5, 
int VAR_6,         
int VAR_7,   
int VAR_8    
){
int VAR_9;
int VAR_10;
CollSeq *VAR_11;
if( VAR_8 ){
VAR_11 = sqlite3BinaryCompareCollSeq(VAR_0, VAR_2, VAR_1);
}else{
VAR_11 = sqlite3BinaryCompareCollSeq(VAR_0, VAR_1, VAR_2);
}
VAR_9 = binaryCompareP5(VAR_1, VAR_2, VAR_7);
VAR_10 = sqlite3VdbeAddOp4(VAR_0->pVdbe, VAR_3, VAR_5, VAR_6, VAR_4,
(void*)VAR_11, VAR_12);
sqlite3VdbeChangeP5(VAR_0->pVdbe, (u8)VAR_9);
return VAR_10;
}",sqlite/8654186b0236d556aa85528c2573ee0b6ab71be3/expr.c/vul/before/0.json,"static int codeCompare(
  Parse *pParse,    /* The parsing (and code generating) context */
  Expr *pLeft,      /* The left operand */
  Expr *pRight,     /* The right operand */
  int opcode,       /* The comparison opcode */
  int in1, int in2, /* Register holding operands */
  int dest,         /* Jump here if true.  */
  int jumpIfNull,   /* If true, jump if either operand is NULL */
  int isCommuted    /* The comparison has been commuted */
){
  int p5;
  int addr;
  CollSeq *p4;

  if( pParse->nErr ) return 0;
  if( isCommuted ){
    p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);
  }else{
    p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);
  }
  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);
  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,
                           (void*)p4, P4_COLLSEQ);
  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);
  return addr;
}","static int codeCompare(
  Parse *VAR_0,    /* COMMENT_0 */
  Expr *VAR_1,      /* COMMENT_1 */
  Expr *VAR_2,     /* COMMENT_2 */
  int VAR_3,       /* COMMENT_3 */
  int VAR_4, int VAR_5, /* COMMENT_4 */
  int VAR_6,         /* COMMENT_5 */
  int VAR_7,   /* COMMENT_6 */
  int VAR_8    /* COMMENT_7 */
){
  int VAR_9;
  int VAR_10;
  CollSeq *VAR_11;

  if( VAR_0->nErr ) return 0;
  if( VAR_8 ){
    VAR_11 = sqlite3BinaryCompareCollSeq(VAR_0, VAR_2, VAR_1);
  }else{
    VAR_11 = sqlite3BinaryCompareCollSeq(VAR_0, VAR_1, VAR_2);
  }
  VAR_9 = binaryCompareP5(VAR_1, VAR_2, VAR_7);
  VAR_10 = sqlite3VdbeAddOp4(VAR_0->pVdbe, VAR_3, VAR_5, VAR_6, VAR_4,
                           (void*)VAR_11, VAR_12);
  sqlite3VdbeChangeP5(VAR_0->pVdbe, (u8)VAR_9);
  return VAR_10;
}",sqlite/8654186b0236d556aa85528c2573ee0b6ab71be3/expr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,7 @@
   int addr;
   CollSeq *p4;
 
+  if( pParse->nErr ) return 0;
   if( isCommuted ){
     p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);
   }else{","{'deleted_lines': [], 'added_lines': ['  if( pParse->nErr ) return 0;']}",True,"SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.",5.3,MEDIUM,1,test,2019-12-19T20:37:32Z,3
CVE-2019-19924,['CWE-755'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,sqlite,"When an error occurs while rewriting the parser tree for window functions
in the sqlite3WindowRewrite() routine, make sure that pParse->nErr is set,
and make sure that this shuts down any subsequent code generation that might
depend on the transformations that were implemented.  This fixes a problem
discovered by the Yongheng and Rui fuzzer.

FossilOrigin-Name: e2bddcd4c55ba3cbe0130332679ff4b048630d0ced9a8899982edb5a3569ba7f",8654186b0236d556aa85528c2573ee0b6ab71be3,https://github.com/sqlite/sqlite/commit/8654186b0236d556aa85528c2573ee0b6ab71be3,src/window.c,sqlite3WindowRewrite,"int sqlite3WindowRewrite(Parse *pParse, Select *p){
int rc = SQLITE_OK;
if( p->pWin && p->pPrior==0 && (p->selFlags & SF_WinRewrite)==0 ){
Vdbe *v = sqlite3GetVdbe(pParse);
sqlite3 *db = pParse->db;
Select *pSub = 0;             
SrcList *pSrc = p->pSrc;
Expr *pWhere = p->pWhere;
ExprList *pGroupBy = p->pGroupBy;
Expr *pHaving = p->pHaving;
ExprList *pSort = 0;
ExprList *pSublist = 0;       
Window *pMWin = p->pWin;      
Window *pWin;                 
Table *pTab;
pTab = sqlite3DbMallocZero(db, sizeof(Table));
if( pTab==0 ){
return SQLITE_NOMEM;
}
p->pSrc = 0;
p->pWhere = 0;
p->pGroupBy = 0;
p->pHaving = 0;
p->selFlags &= ~SF_Aggregate;
p->selFlags |= SF_WinRewrite;
pSort = sqlite3ExprListDup(db, pMWin->pPartition, 0);
pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1);
if( pSort && p->pOrderBy && p->pOrderBy->nExpr<=pSort->nExpr ){
int nSave = pSort->nExpr;
pSort->nExpr = p->pOrderBy->nExpr;
if( sqlite3ExprListCompare(pSort, p->pOrderBy, -1)==0 ){
sqlite3ExprListDelete(db, p->pOrderBy);
p->pOrderBy = 0;
}
pSort->nExpr = nSave;
}
pMWin->iEphCsr = pParse->nTab++;
pParse->nTab += 3;
selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, &pSublist);
selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, &pSublist);
pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);
pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0);
pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0);
for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
ExprList *pArgs = pWin->pOwner->x.pList;
if( pWin->pFunc->funcFlags & SQLITE_FUNC_SUBTYPE ){
selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist);
pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);
pWin->bExprArgs = 1;
}else{
pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);
pSublist = exprListAppendList(pParse, pSublist, pArgs, 0);
}
if( pWin->pFilter ){
Expr *pFilter = sqlite3ExprDup(db, pWin->pFilter, 0);
pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);
}
pWin->regAccum = ++pParse->nMem;
pWin->regResult = ++pParse->nMem;
sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);
}
if( pSublist==0 ){
pSublist = sqlite3ExprListAppend(pParse, 0, 
sqlite3Expr(db, TK_INTEGER, ""0"")
);
}
pSub = sqlite3SelectNew(
pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, 0, 0
);
p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);
if( p->pSrc ){
Table *pTab2;
p->pSrc->a[0].pSelect = pSub;
sqlite3SrcListAssignCursors(pParse, p->pSrc);
pSub->selFlags |= SF_Expanded;
pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, SQLITE_AFF_NONE);
if( pTab2==0 ){
rc = SQLITE_NOMEM;
}else{
memcpy(pTab, pTab2, sizeof(Table));
pTab->tabFlags |= TF_Ephemeral;
p->pSrc->a[0].pTab = pTab;
pTab = pTab2;
}
sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pMWin->iEphCsr, pSublist->nExpr);
sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+1, pMWin->iEphCsr);
sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+2, pMWin->iEphCsr);
sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+3, pMWin->iEphCsr);
}else{
sqlite3SelectDelete(db, pSub);
}
if( db->mallocFailed ) rc = SQLITE_NOMEM;
sqlite3DbFree(db, pTab);
}
return rc;
}","int sqlite3WindowRewrite(Parse *VAR_0, Select *VAR_1){
int VAR_2 = VAR_3;
if( VAR_1->pWin && VAR_1->pPrior==0 && (VAR_1->selFlags & VAR_4)==0 ){
Vdbe *VAR_5 = sqlite3GetVdbe(VAR_0);
sqlite3 *VAR_6 = VAR_0->db;
Select *VAR_7 = 0;             
SrcList *VAR_8 = VAR_1->pSrc;
Expr *VAR_9 = VAR_1->pWhere;
ExprList *VAR_10 = VAR_1->pGroupBy;
Expr *VAR_11 = VAR_1->pHaving;
ExprList *VAR_12 = 0;
ExprList *VAR_13 = 0;       
Window *VAR_14 = VAR_1->pWin;      
Window *VAR_15;                 
Table *VAR_16;
VAR_16 = sqlite3DbMallocZero(VAR_6, sizeof(Table));
if( VAR_16==0 ){
return VAR_17;
}
VAR_1->pSrc = 0;
VAR_1->pWhere = 0;
VAR_1->pGroupBy = 0;
VAR_1->pHaving = 0;
VAR_1->selFlags &= ~VAR_18;
VAR_1->selFlags |= VAR_4;
VAR_12 = sqlite3ExprListDup(VAR_6, VAR_14->pPartition, 0);
VAR_12 = exprListAppendList(VAR_0, VAR_12, VAR_14->pOrderBy, 1);
if( VAR_12 && VAR_1->pOrderBy && VAR_1->pOrderBy->nExpr<=VAR_12->nExpr ){
int VAR_19 = VAR_12->nExpr;
VAR_12->nExpr = VAR_1->pOrderBy->nExpr;
if( sqlite3ExprListCompare(VAR_12, VAR_1->pOrderBy, -1)==0 ){
sqlite3ExprListDelete(VAR_6, VAR_1->pOrderBy);
VAR_1->pOrderBy = 0;
}
VAR_12->nExpr = VAR_19;
}
VAR_14->iEphCsr = VAR_0->nTab++;
VAR_0->nTab += 3;
selectWindowRewriteEList(VAR_0, VAR_14, VAR_8, VAR_1->pEList, VAR_16, &VAR_13);
selectWindowRewriteEList(VAR_0, VAR_14, VAR_8, VAR_1->pOrderBy, VAR_16, &VAR_13);
VAR_14->nBufferCol = (VAR_13 ? VAR_13->nExpr : 0);
VAR_13 = exprListAppendList(VAR_0, VAR_13, VAR_14->pPartition, 0);
VAR_13 = exprListAppendList(VAR_0, VAR_13, VAR_14->pOrderBy, 0);
for(VAR_15=VAR_14; VAR_15; VAR_15=VAR_15->pNextWin){
ExprList *VAR_20 = VAR_15->pOwner->x.pList;
if( VAR_15->pFunc->funcFlags & VAR_21 ){
selectWindowRewriteEList(VAR_0, VAR_14, VAR_8, VAR_20, VAR_16, &VAR_13);
VAR_15->iArgCol = (VAR_13 ? VAR_13->nExpr : 0);
VAR_15->bExprArgs = 1;
}else{
VAR_15->iArgCol = (VAR_13 ? VAR_13->nExpr : 0);
VAR_13 = exprListAppendList(VAR_0, VAR_13, VAR_20, 0);
}
if( VAR_15->pFilter ){
Expr *VAR_22 = sqlite3ExprDup(VAR_6, VAR_15->pFilter, 0);
VAR_13 = sqlite3ExprListAppend(VAR_0, VAR_13, VAR_22);
}
VAR_15->regAccum = ++VAR_0->nMem;
VAR_15->regResult = ++VAR_0->nMem;
sqlite3VdbeAddOp2(VAR_5, VAR_23, 0, VAR_15->regAccum);
}
if( VAR_13==0 ){
VAR_13 = sqlite3ExprListAppend(VAR_0, 0, 
sqlite3Expr(VAR_6, VAR_24, ""0"")
);
}
VAR_7 = sqlite3SelectNew(
VAR_0, VAR_13, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12, 0, 0
);
VAR_1->pSrc = sqlite3SrcListAppend(VAR_0, 0, 0, 0);
if( VAR_1->pSrc ){
Table *VAR_25;
VAR_1->pSrc->a[0].pSelect = VAR_7;
sqlite3SrcListAssignCursors(VAR_0, VAR_1->pSrc);
VAR_7->selFlags |= VAR_26;
VAR_25 = sqlite3ResultSetOfSelect(VAR_0, VAR_7, VAR_27);
if( VAR_25==0 ){
VAR_2 = VAR_17;
}else{
memcpy(VAR_16, VAR_25, sizeof(Table));
VAR_16->tabFlags |= VAR_28;
VAR_1->pSrc->a[0].pTab = VAR_16;
VAR_16 = VAR_25;
}
sqlite3VdbeAddOp2(VAR_5, VAR_29, VAR_14->iEphCsr, VAR_13->nExpr);
sqlite3VdbeAddOp2(VAR_5, VAR_30, VAR_14->iEphCsr+1, VAR_14->iEphCsr);
sqlite3VdbeAddOp2(VAR_5, VAR_30, VAR_14->iEphCsr+2, VAR_14->iEphCsr);
sqlite3VdbeAddOp2(VAR_5, VAR_30, VAR_14->iEphCsr+3, VAR_14->iEphCsr);
}else{
sqlite3SelectDelete(VAR_6, VAR_7);
}
if( VAR_6->mallocFailed ) VAR_2 = VAR_17;
sqlite3DbFree(VAR_6, VAR_16);
}
return VAR_2;
}",sqlite/8654186b0236d556aa85528c2573ee0b6ab71be3/window.c/vul/before/0.json,"int sqlite3WindowRewrite(Parse *pParse, Select *p){
  int rc = SQLITE_OK;
  if( p->pWin && p->pPrior==0 && (p->selFlags & SF_WinRewrite)==0 ){
    Vdbe *v = sqlite3GetVdbe(pParse);
    sqlite3 *db = pParse->db;
    Select *pSub = 0;             /* The subquery */
    SrcList *pSrc = p->pSrc;
    Expr *pWhere = p->pWhere;
    ExprList *pGroupBy = p->pGroupBy;
    Expr *pHaving = p->pHaving;
    ExprList *pSort = 0;

    ExprList *pSublist = 0;       /* Expression list for sub-query */
    Window *pMWin = p->pWin;      /* Master window object */
    Window *pWin;                 /* Window object iterator */
    Table *pTab;

    pTab = sqlite3DbMallocZero(db, sizeof(Table));
    if( pTab==0 ){
      return sqlite3ErrorToParser(db, SQLITE_NOMEM);
    }

    p->pSrc = 0;
    p->pWhere = 0;
    p->pGroupBy = 0;
    p->pHaving = 0;
    p->selFlags &= ~SF_Aggregate;
    p->selFlags |= SF_WinRewrite;

    /* Create the ORDER BY clause for the sub-select. This is the concatenation
    ** of the window PARTITION and ORDER BY clauses. Then, if this makes it
    ** redundant, remove the ORDER BY from the parent SELECT.  */
    pSort = sqlite3ExprListDup(db, pMWin->pPartition, 0);
    pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1);
    if( pSort && p->pOrderBy && p->pOrderBy->nExpr<=pSort->nExpr ){
      int nSave = pSort->nExpr;
      pSort->nExpr = p->pOrderBy->nExpr;
      if( sqlite3ExprListCompare(pSort, p->pOrderBy, -1)==0 ){
        sqlite3ExprListDelete(db, p->pOrderBy);
        p->pOrderBy = 0;
      }
      pSort->nExpr = nSave;
    }

    /* Assign a cursor number for the ephemeral table used to buffer rows.
    ** The OpenEphemeral instruction is coded later, after it is known how
    ** many columns the table will have.  */
    pMWin->iEphCsr = pParse->nTab++;
    pParse->nTab += 3;

    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, &pSublist);
    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, &pSublist);
    pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);

    /* Append the PARTITION BY and ORDER BY expressions to the to the 
    ** sub-select expression list. They are required to figure out where 
    ** boundaries for partitions and sets of peer rows lie.  */
    pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0);
    pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0);

    /* Append the arguments passed to each window function to the
    ** sub-select expression list. Also allocate two registers for each
    ** window function - one for the accumulator, another for interim
    ** results.  */
    for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
      ExprList *pArgs = pWin->pOwner->x.pList;
      if( pWin->pFunc->funcFlags & SQLITE_FUNC_SUBTYPE ){
        selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist);
        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);
        pWin->bExprArgs = 1;
      }else{
        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);
        pSublist = exprListAppendList(pParse, pSublist, pArgs, 0);
      }
      if( pWin->pFilter ){
        Expr *pFilter = sqlite3ExprDup(db, pWin->pFilter, 0);
        pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);
      }
      pWin->regAccum = ++pParse->nMem;
      pWin->regResult = ++pParse->nMem;
      sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);
    }

    /* If there is no ORDER BY or PARTITION BY clause, and the window
    ** function accepts zero arguments, and there are no other columns
    ** selected (e.g. ""SELECT row_number() OVER () FROM t1""), it is possible
    ** that pSublist is still NULL here. Add a constant expression here to 
    ** keep everything legal in this case. 
    */
    if( pSublist==0 ){
      pSublist = sqlite3ExprListAppend(pParse, 0, 
        sqlite3Expr(db, TK_INTEGER, ""0"")
      );
    }

    pSub = sqlite3SelectNew(
        pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, 0, 0
    );
    p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);
    if( p->pSrc ){
      Table *pTab2;
      p->pSrc->a[0].pSelect = pSub;
      sqlite3SrcListAssignCursors(pParse, p->pSrc);
      pSub->selFlags |= SF_Expanded;
      pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, SQLITE_AFF_NONE);
      if( pTab2==0 ){
        rc = SQLITE_NOMEM;
      }else{
        memcpy(pTab, pTab2, sizeof(Table));
        pTab->tabFlags |= TF_Ephemeral;
        p->pSrc->a[0].pTab = pTab;
        pTab = pTab2;
      }
      sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pMWin->iEphCsr, pSublist->nExpr);
      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+1, pMWin->iEphCsr);
      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+2, pMWin->iEphCsr);
      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+3, pMWin->iEphCsr);
    }else{
      sqlite3SelectDelete(db, pSub);
    }
    if( db->mallocFailed ) rc = SQLITE_NOMEM;
    sqlite3DbFree(db, pTab);
  }

  if( rc && pParse->nErr==0 ){
    assert( pParse->db->mallocFailed );
    return sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);
  }
  return rc;
}","int sqlite3WindowRewrite(Parse *VAR_0, Select *VAR_1){
  int VAR_2 = VAR_3;
  if( VAR_1->pWin && VAR_1->pPrior==0 && (VAR_1->selFlags & VAR_4)==0 ){
    Vdbe *VAR_5 = sqlite3GetVdbe(VAR_0);
    sqlite3 *VAR_6 = VAR_0->db;
    Select *VAR_7 = 0;             /* COMMENT_0 */
    SrcList *VAR_8 = VAR_1->pSrc;
    Expr *VAR_9 = VAR_1->pWhere;
    ExprList *VAR_10 = VAR_1->pGroupBy;
    Expr *VAR_11 = VAR_1->pHaving;
    ExprList *VAR_12 = 0;

    ExprList *VAR_13 = 0;       /* COMMENT_1 */
    Window *VAR_14 = VAR_1->pWin;      /* COMMENT_2 */
    Window *VAR_15;                 /* COMMENT_3 */
    Table *VAR_16;

    VAR_16 = sqlite3DbMallocZero(VAR_6, sizeof(Table));
    if( VAR_16==0 ){
      return sqlite3ErrorToParser(VAR_6, VAR_17);
    }

    VAR_1->pSrc = 0;
    VAR_1->pWhere = 0;
    VAR_1->pGroupBy = 0;
    VAR_1->pHaving = 0;
    VAR_1->selFlags &= ~VAR_18;
    VAR_1->selFlags |= VAR_4;

    /* COMMENT_4 */
                                                                           
                                                                 
    VAR_12 = sqlite3ExprListDup(VAR_6, VAR_14->pPartition, 0);
    VAR_12 = exprListAppendList(VAR_0, VAR_12, VAR_14->pOrderBy, 1);
    if( VAR_12 && VAR_1->pOrderBy && VAR_1->pOrderBy->nExpr<=VAR_12->nExpr ){
      int VAR_19 = VAR_12->nExpr;
      VAR_12->nExpr = VAR_1->pOrderBy->nExpr;
      if( sqlite3ExprListCompare(VAR_12, VAR_1->pOrderBy, -1)==0 ){
        sqlite3ExprListDelete(VAR_6, VAR_1->pOrderBy);
        VAR_1->pOrderBy = 0;
      }
      VAR_12->nExpr = VAR_19;
    }

    /* COMMENT_7 */
                                                                          
                                            
    VAR_14->iEphCsr = VAR_0->nTab++;
    VAR_0->nTab += 3;

    selectWindowRewriteEList(VAR_0, VAR_14, VAR_8, VAR_1->pEList, VAR_16, &VAR_13);
    selectWindowRewriteEList(VAR_0, VAR_14, VAR_8, VAR_1->pOrderBy, VAR_16, &VAR_13);
    VAR_14->nBufferCol = (VAR_13 ? VAR_13->nExpr : 0);

    /* COMMENT_10 */
                                                                         
                                                               
    VAR_13 = exprListAppendList(VAR_0, VAR_13, VAR_14->pPartition, 0);
    VAR_13 = exprListAppendList(VAR_0, VAR_13, VAR_14->pOrderBy, 0);

    /* COMMENT_13 */
                                                                       
                                                                     
                   
    for(VAR_15=VAR_14; VAR_15; VAR_15=VAR_15->pNextWin){
      ExprList *VAR_20 = VAR_15->pOwner->x.pList;
      if( VAR_15->pFunc->funcFlags & VAR_21 ){
        selectWindowRewriteEList(VAR_0, VAR_14, VAR_8, VAR_20, VAR_16, &VAR_13);
        VAR_15->iArgCol = (VAR_13 ? VAR_13->nExpr : 0);
        VAR_15->bExprArgs = 1;
      }else{
        VAR_15->iArgCol = (VAR_13 ? VAR_13->nExpr : 0);
        VAR_13 = exprListAppendList(VAR_0, VAR_13, VAR_20, 0);
      }
      if( VAR_15->pFilter ){
        Expr *VAR_22 = sqlite3ExprDup(VAR_6, VAR_15->pFilter, 0);
        VAR_13 = sqlite3ExprListAppend(VAR_0, VAR_13, VAR_22);
      }
      VAR_15->regAccum = ++VAR_0->nMem;
      VAR_15->regResult = ++VAR_0->nMem;
      sqlite3VdbeAddOp2(VAR_5, VAR_23, 0, VAR_15->regAccum);
    }

    /* COMMENT_17 */
                                                                      
                                                                            
                                                                           
                                           
      
    if( VAR_13==0 ){
      VAR_13 = sqlite3ExprListAppend(VAR_0, 0, 
        sqlite3Expr(VAR_6, VAR_24, ""0"")
      );
    }

    VAR_7 = sqlite3SelectNew(
        VAR_0, VAR_13, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12, 0, 0
    );
    VAR_1->pSrc = sqlite3SrcListAppend(VAR_0, 0, 0, 0);
    if( VAR_1->pSrc ){
      Table *VAR_25;
      VAR_1->pSrc->a[0].pSelect = VAR_7;
      sqlite3SrcListAssignCursors(VAR_0, VAR_1->pSrc);
      VAR_7->selFlags |= VAR_26;
      VAR_25 = sqlite3ResultSetOfSelect(VAR_0, VAR_7, VAR_27);
      if( VAR_25==0 ){
        VAR_2 = VAR_17;
      }else{
        memcpy(VAR_16, VAR_25, sizeof(Table));
        VAR_16->tabFlags |= VAR_28;
        VAR_1->pSrc->a[0].pTab = VAR_16;
        VAR_16 = VAR_25;
      }
      sqlite3VdbeAddOp2(VAR_5, VAR_29, VAR_14->iEphCsr, VAR_13->nExpr);
      sqlite3VdbeAddOp2(VAR_5, VAR_30, VAR_14->iEphCsr+1, VAR_14->iEphCsr);
      sqlite3VdbeAddOp2(VAR_5, VAR_30, VAR_14->iEphCsr+2, VAR_14->iEphCsr);
      sqlite3VdbeAddOp2(VAR_5, VAR_30, VAR_14->iEphCsr+3, VAR_14->iEphCsr);
    }else{
      sqlite3SelectDelete(VAR_6, VAR_7);
    }
    if( VAR_6->mallocFailed ) VAR_2 = VAR_17;
    sqlite3DbFree(VAR_6, VAR_16);
  }

  if( VAR_2 && VAR_0->nErr==0 ){
    assert( VAR_0->db->mallocFailed );
    return sqlite3ErrorToParser(VAR_0->db, VAR_17);
  }
  return VAR_2;
}",sqlite/8654186b0236d556aa85528c2573ee0b6ab71be3/window.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,7 +17,7 @@
 
     pTab = sqlite3DbMallocZero(db, sizeof(Table));
     if( pTab==0 ){
-      return SQLITE_NOMEM;
+      return sqlite3ErrorToParser(db, SQLITE_NOMEM);
     }
 
     p->pSrc = 0;
@@ -122,5 +122,9 @@
     sqlite3DbFree(db, pTab);
   }
 
+  if( rc && pParse->nErr==0 ){
+    assert( pParse->db->mallocFailed );
+    return sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);
+  }
   return rc;
 }","{'deleted_lines': ['      return SQLITE_NOMEM;'], 'added_lines': ['      return sqlite3ErrorToParser(db, SQLITE_NOMEM);', '  if( rc && pParse->nErr==0 ){', '    assert( pParse->db->mallocFailed );', '    return sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);', '  }']}",True,"SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.",5.3,MEDIUM,1,test,2019-12-19T20:37:32Z,3
CVE-2019-19924,['CWE-755'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,sqlite,"When an error occurs while rewriting the parser tree for window functions
in the sqlite3WindowRewrite() routine, make sure that pParse->nErr is set,
and make sure that this shuts down any subsequent code generation that might
depend on the transformations that were implemented.  This fixes a problem
discovered by the Yongheng and Rui fuzzer.

FossilOrigin-Name: e2bddcd4c55ba3cbe0130332679ff4b048630d0ced9a8899982edb5a3569ba7f",8654186b0236d556aa85528c2573ee0b6ab71be3,https://github.com/sqlite/sqlite/commit/8654186b0236d556aa85528c2573ee0b6ab71be3,src/vdbeaux.c,vdbeVComment,"static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){
assert( p->nOp>0 || p->aOp==0 );
assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );
if( p->nOp ){
assert( p->aOp );
sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);
p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);
}
}","static void vdbeVComment(Vdbe *VAR_0, const char *VAR_1, va_list VAR_2){
assert( VAR_0->nOp>0 || VAR_0->aOp==0 );
assert( VAR_0->aOp==0 || VAR_0->aOp[VAR_0->nOp-1].zComment==0 || VAR_0->db->mallocFailed );
if( VAR_0->nOp ){
assert( VAR_0->aOp );
sqlite3DbFree(VAR_0->db, VAR_0->aOp[VAR_0->nOp-1].zComment);
VAR_0->aOp[VAR_0->nOp-1].zComment = sqlite3VMPrintf(VAR_0->db, VAR_1, VAR_2);
}
}",sqlite/8654186b0236d556aa85528c2573ee0b6ab71be3/vdbeaux.c/vul/before/0.json,"static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){
  assert( p->nOp>0 || p->aOp==0 );
  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed
          || p->pParse->nErr>0 );
  if( p->nOp ){
    assert( p->aOp );
    sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);
    p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);
  }
}","static void vdbeVComment(Vdbe *VAR_0, const char *VAR_1, va_list VAR_2){
  assert( VAR_0->nOp>0 || VAR_0->aOp==0 );
  assert( VAR_0->aOp==0 || VAR_0->aOp[VAR_0->nOp-1].zComment==0 || VAR_0->db->mallocFailed
          || VAR_0->pParse->nErr>0 );
  if( VAR_0->nOp ){
    assert( VAR_0->aOp );
    sqlite3DbFree(VAR_0->db, VAR_0->aOp[VAR_0->nOp-1].zComment);
    VAR_0->aOp[VAR_0->nOp-1].zComment = sqlite3VMPrintf(VAR_0->db, VAR_1, VAR_2);
  }
}",sqlite/8654186b0236d556aa85528c2573ee0b6ab71be3/vdbeaux.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,7 @@
 static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){
   assert( p->nOp>0 || p->aOp==0 );
-  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );
+  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed
+          || p->pParse->nErr>0 );
   if( p->nOp ){
     assert( p->aOp );
     sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);","{'deleted_lines': ['  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );'], 'added_lines': ['  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed', '          || p->pParse->nErr>0 );']}",True,"SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.",5.3,MEDIUM,1,test,2019-12-19T20:37:32Z,3
CVE-2020-12653,['CWE-787'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"mwifiex: Fix possible buffer overflows in mwifiex_cmd_append_vsie_tlv()

mwifiex_cmd_append_vsie_tlv() calls memcpy() without checking
the destination size may trigger a buffer overflower,
which a local user could use to cause denial of service
or the execution of arbitrary code.
Fix it by putting the length check before calling memcpy().

Signed-off-by: Qing Xu <m1s5p6688@gmail.com>
Signed-off-by: Kalle Valo <kvalo@codeaurora.org>",b70261a288ea4d2f4ac7cd04be08a9f0f2de4f4d,https://github.com/torvalds/linux/commit/b70261a288ea4d2f4ac7cd04be08a9f0f2de4f4d,drivers/net/wireless/marvell/mwifiex/scan.c,mwifiex_cmd_append_vsie_tlv,"int
mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,
u16 vsie_mask, u8 **buffer)
{
int id, ret_len = 0;
struct mwifiex_ie_types_vendor_param_set *vs_param_set;
if (!buffer)
return 0;
if (!(*buffer))
return 0;
for (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {
if (priv->vs_ie[id].mask & vsie_mask) {
vs_param_set =
(struct mwifiex_ie_types_vendor_param_set *)
*buffer;
vs_param_set->header.type =
cpu_to_le16(TLV_TYPE_PASSTHROUGH);
vs_param_set->header.len =
cpu_to_le16((((u16) priv->vs_ie[id].ie[1])
& 0x00FF) + 2);
memcpy(vs_param_set->ie, priv->vs_ie[id].ie,
le16_to_cpu(vs_param_set->header.len));
*buffer += le16_to_cpu(vs_param_set->header.len) +
sizeof(struct mwifiex_ie_types_header);
ret_len += le16_to_cpu(vs_param_set->header.len) +
sizeof(struct mwifiex_ie_types_header);
}
}
return ret_len;
}","int
mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *VAR_0,
u16 VAR_1, u8 **VAR_2)
{
int VAR_3, VAR_4 = 0;
struct mwifiex_ie_types_vendor_param_set *VAR_5;
if (!VAR_2)
return 0;
if (!(*VAR_2))
return 0;
for (VAR_3 = 0; VAR_3 < VAR_6; VAR_3++) {
if (VAR_0->vs_ie[VAR_3].mask & VAR_1) {
VAR_5 =
(struct mwifiex_ie_types_vendor_param_set *)
*VAR_2;
VAR_5->header.type =
cpu_to_le16(VAR_7);
VAR_5->header.len =
cpu_to_le16((((u16) VAR_0->vs_ie[VAR_3].ie[1])
& 0x00FF) + 2);
memcpy(VAR_5->ie, VAR_0->vs_ie[VAR_3].ie,
le16_to_cpu(VAR_5->header.len));
*VAR_2 += le16_to_cpu(VAR_5->header.len) +
sizeof(struct mwifiex_ie_types_header);
VAR_4 += le16_to_cpu(VAR_5->header.len) +
sizeof(struct mwifiex_ie_types_header);
}
}
return VAR_4;
}",torvalds/linux/b70261a288ea4d2f4ac7cd04be08a9f0f2de4f4d/scan.c/vul/before/0.json,"int
mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,
			    u16 vsie_mask, u8 **buffer)
{
	int id, ret_len = 0;
	struct mwifiex_ie_types_vendor_param_set *vs_param_set;

	if (!buffer)
		return 0;
	if (!(*buffer))
		return 0;

	/*
	 * Traverse through the saved vendor specific IE array and append
	 * the selected(scan/assoc/adhoc) IE as TLV to the command
	 */
	for (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {
		if (priv->vs_ie[id].mask & vsie_mask) {
			vs_param_set =
				(struct mwifiex_ie_types_vendor_param_set *)
				*buffer;
			vs_param_set->header.type =
				cpu_to_le16(TLV_TYPE_PASSTHROUGH);
			vs_param_set->header.len =
				cpu_to_le16((((u16) priv->vs_ie[id].ie[1])
				& 0x00FF) + 2);
			if (le16_to_cpu(vs_param_set->header.len) >
				MWIFIEX_MAX_VSIE_LEN) {
				mwifiex_dbg(priv->adapter, ERROR,
					    ""Invalid param length!\n"");
				break;
			}

			memcpy(vs_param_set->ie, priv->vs_ie[id].ie,
			       le16_to_cpu(vs_param_set->header.len));
			*buffer += le16_to_cpu(vs_param_set->header.len) +
				   sizeof(struct mwifiex_ie_types_header);
			ret_len += le16_to_cpu(vs_param_set->header.len) +
				   sizeof(struct mwifiex_ie_types_header);
		}
	}
	return ret_len;
}","int
mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *VAR_0,
			    u16 VAR_1, u8 **VAR_2)
{
	int VAR_3, VAR_4 = 0;
	struct mwifiex_ie_types_vendor_param_set *VAR_5;

	if (!VAR_2)
		return 0;
	if (!(*VAR_2))
		return 0;

	/* COMMENT_0 */
                                                                  
                                                           
    
	for (VAR_3 = 0; VAR_3 < VAR_6; VAR_3++) {
		if (VAR_0->vs_ie[VAR_3].mask & VAR_1) {
			VAR_5 =
				(struct mwifiex_ie_types_vendor_param_set *)
				*VAR_2;
			VAR_5->header.type =
				cpu_to_le16(VAR_7);
			VAR_5->header.len =
				cpu_to_le16((((u16) VAR_0->vs_ie[VAR_3].ie[1])
				& 0x00FF) + 2);
			if (le16_to_cpu(VAR_5->header.len) >
				VAR_8) {
				mwifiex_dbg(VAR_0->adapter, VAR_9,
					    ""Invalid param length!\n"");
				break;
			}

			memcpy(VAR_5->ie, VAR_0->vs_ie[VAR_3].ie,
			       le16_to_cpu(VAR_5->header.len));
			*VAR_2 += le16_to_cpu(VAR_5->header.len) +
				   sizeof(struct mwifiex_ie_types_header);
			VAR_4 += le16_to_cpu(VAR_5->header.len) +
				   sizeof(struct mwifiex_ie_types_header);
		}
	}
	return VAR_4;
}",torvalds/linux/b70261a288ea4d2f4ac7cd04be08a9f0f2de4f4d/scan.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -24,6 +24,13 @@
 			vs_param_set->header.len =
 				cpu_to_le16((((u16) priv->vs_ie[id].ie[1])
 				& 0x00FF) + 2);
+			if (le16_to_cpu(vs_param_set->header.len) >
+				MWIFIEX_MAX_VSIE_LEN) {
+				mwifiex_dbg(priv->adapter, ERROR,
+					    ""Invalid param length!\n"");
+				break;
+			}
+
 			memcpy(vs_param_set->ie, priv->vs_ie[id].ie,
 			       le16_to_cpu(vs_param_set->header.len));
 			*buffer += le16_to_cpu(vs_param_set->header.len) +","{'deleted_lines': [], 'added_lines': ['\t\t\tif (le16_to_cpu(vs_param_set->header.len) >', '\t\t\t\tMWIFIEX_MAX_VSIE_LEN) {', '\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,', '\t\t\t\t\t    ""Invalid param length!\\n"");', '\t\t\t\tbreak;', '\t\t\t}', '']}",True,"An issue was found in Linux kernel before 5.5.4. The mwifiex_cmd_append_vsie_tlv() function in drivers/net/wireless/marvell/mwifiex/scan.c allows local users to gain privileges or cause a denial of service because of an incorrect memcpy and buffer overflow, aka CID-b70261a288ea.",7.8,HIGH,2,test,2020-01-02T02:39:27Z,3
CVE-2020-11608,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"media: ov519: add missing endpoint sanity checks

Make sure to check that we have at least one endpoint before accessing
the endpoint array to avoid dereferencing a NULL-pointer on stream
start.

Note that these sanity checks are not redundant as the driver is mixing
looking up altsettings by index and by number, which need not coincide.

Fixes: 1876bb923c98 (""V4L/DVB (12079): gspca_ov519: add support for the ov511 bridge"")
Fixes: b282d87332f5 (""V4L/DVB (12080): gspca_ov519: Fix ov518+ with OV7620AE (Trust spacecam 320)"")
Cc: stable <stable@vger.kernel.org>     # 2.6.31
Cc: Hans de Goede <hdegoede@redhat.com>
Signed-off-by: Johan Hovold <johan@kernel.org>
Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>",998912346c0da53a6dbb71fab3a138586b596b30,https://github.com/torvalds/linux/commit/998912346c0da53a6dbb71fab3a138586b596b30,drivers/media/usb/gspca/ov519.c,ov518_mode_init_regs,"static void ov518_mode_init_regs(struct sd *sd)
{
struct gspca_dev *gspca_dev = (struct gspca_dev *)sd;
int hsegs, vsegs, packet_size;
struct usb_host_interface *alt;
struct usb_interface *intf;
intf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);
alt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);
if (!alt) {
gspca_err(gspca_dev, ""Couldn't get altsetting\n"");
sd->gspca_dev.usb_err = -EIO;
return;
}
packet_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);
ov518_reg_w32(sd, R51x_FIFO_PSIZE, packet_size & ~7, 2);
reg_w(sd, 0x2b, 0);
reg_w(sd, 0x2c, 0);
reg_w(sd, 0x2d, 0);
reg_w(sd, 0x2e, 0);
reg_w(sd, 0x3b, 0);
reg_w(sd, 0x3c, 0);
reg_w(sd, 0x3d, 0);
reg_w(sd, 0x3e, 0);
if (sd->bridge == BRIDGE_OV518) {
reg_w_mask(sd, 0x20, 0x08, 0x08);
reg_w_mask(sd, 0x28, 0x80, 0xf0);
reg_w_mask(sd, 0x38, 0x80, 0xf0);
} else {
reg_w(sd, 0x28, 0x80);
reg_w(sd, 0x38, 0x80);
}
hsegs = sd->gspca_dev.pixfmt.width / 16;
vsegs = sd->gspca_dev.pixfmt.height / 4;
reg_w(sd, 0x29, hsegs);
reg_w(sd, 0x2a, vsegs);
reg_w(sd, 0x39, hsegs);
reg_w(sd, 0x3a, vsegs);
reg_w(sd, 0x2f, 0x80);
if (sd->bridge == BRIDGE_OV518PLUS && sd->revision == 0 &&
sd->sensor == SEN_OV7620AE)
sd->clockdiv = 0;
else
sd->clockdiv = 1;
reg_w(sd, 0x51, 0x04);
reg_w(sd, 0x22, 0x18);
reg_w(sd, 0x23, 0xff);
if (sd->bridge == BRIDGE_OV518PLUS) {
switch (sd->sensor) {
case SEN_OV7620AE:
if (sd->revision > 0 &&
sd->gspca_dev.pixfmt.width == 640) {
reg_w(sd, 0x20, 0x60);
reg_w(sd, 0x21, 0x1f);
} else {
reg_w(sd, 0x20, 0x00);
reg_w(sd, 0x21, 0x19);
}
break;
case SEN_OV7620:
reg_w(sd, 0x20, 0x00);
reg_w(sd, 0x21, 0x19);
break;
default:
reg_w(sd, 0x21, 0x19);
}
} else
reg_w(sd, 0x71, 0x17);
i2c_w(sd, 0x54, 0x23);
reg_w(sd, 0x2f, 0x80);
if (sd->bridge == BRIDGE_OV518PLUS) {
reg_w(sd, 0x24, 0x94);
reg_w(sd, 0x25, 0x90);
ov518_reg_w32(sd, 0xc4,    400, 2);
ov518_reg_w32(sd, 0xc6,    540, 2);
ov518_reg_w32(sd, 0xc7,    540, 2);
ov518_reg_w32(sd, 0xc8,    108, 2);
ov518_reg_w32(sd, 0xca, 131098, 3);
ov518_reg_w32(sd, 0xcb,    532, 2);
ov518_reg_w32(sd, 0xcc,   2400, 2);
ov518_reg_w32(sd, 0xcd,     32, 2);
ov518_reg_w32(sd, 0xce,    608, 2);
} else {
reg_w(sd, 0x24, 0x9f);
reg_w(sd, 0x25, 0x90);
ov518_reg_w32(sd, 0xc4,    400, 2);
ov518_reg_w32(sd, 0xc6,    381, 2);
ov518_reg_w32(sd, 0xc7,    381, 2);
ov518_reg_w32(sd, 0xc8,    128, 2);
ov518_reg_w32(sd, 0xca, 183331, 3);
ov518_reg_w32(sd, 0xcb,    746, 2);
ov518_reg_w32(sd, 0xcc,   1750, 2);
ov518_reg_w32(sd, 0xcd,     45, 2);
ov518_reg_w32(sd, 0xce,    851, 2);
}
reg_w(sd, 0x2f, 0x80);
}","static void ov518_mode_init_regs(struct sd *sd)
{
struct gspca_dev *gspca_dev = (struct gspca_dev *)sd;
int VAR_0, VAR_1, VAR_2;
struct usb_host_interface *VAR_3;
struct usb_interface *VAR_4;
VAR_4 = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);
VAR_3 = usb_altnum_to_altsetting(VAR_4, sd->gspca_dev.alt);
if (!VAR_3) {
gspca_err(gspca_dev, ""Couldn't get altsetting\n"");
sd->gspca_dev.usb_err = -VAR_5;
return;
}
VAR_2 = le16_to_cpu(VAR_3->endpoint[0].desc.wMaxPacketSize);
ov518_reg_w32(sd, VAR_6, VAR_2 & ~7, 2);
reg_w(sd, 0x2b, 0);
reg_w(sd, 0x2c, 0);
reg_w(sd, 0x2d, 0);
reg_w(sd, 0x2e, 0);
reg_w(sd, 0x3b, 0);
reg_w(sd, 0x3c, 0);
reg_w(sd, 0x3d, 0);
reg_w(sd, 0x3e, 0);
if (sd->bridge == VAR_7) {
reg_w_mask(sd, 0x20, 0x08, 0x08);
reg_w_mask(sd, 0x28, 0x80, 0xf0);
reg_w_mask(sd, 0x38, 0x80, 0xf0);
} else {
reg_w(sd, 0x28, 0x80);
reg_w(sd, 0x38, 0x80);
}
VAR_0 = sd->gspca_dev.pixfmt.width / 16;
VAR_1 = sd->gspca_dev.pixfmt.height / 4;
reg_w(sd, 0x29, VAR_0);
reg_w(sd, 0x2a, VAR_1);
reg_w(sd, 0x39, VAR_0);
reg_w(sd, 0x3a, VAR_1);
reg_w(sd, 0x2f, 0x80);
if (sd->bridge == VAR_8 && sd->revision == 0 &&
sd->sensor == VAR_9)
sd->clockdiv = 0;
else
sd->clockdiv = 1;
reg_w(sd, 0x51, 0x04);
reg_w(sd, 0x22, 0x18);
reg_w(sd, 0x23, 0xff);
if (sd->bridge == VAR_8) {
switch (sd->sensor) {
case VAR_9:
if (sd->revision > 0 &&
sd->gspca_dev.pixfmt.width == 640) {
reg_w(sd, 0x20, 0x60);
reg_w(sd, 0x21, 0x1f);
} else {
reg_w(sd, 0x20, 0x00);
reg_w(sd, 0x21, 0x19);
}
break;
case VAR_10:
reg_w(sd, 0x20, 0x00);
reg_w(sd, 0x21, 0x19);
break;
default:
reg_w(sd, 0x21, 0x19);
}
} else
reg_w(sd, 0x71, 0x17);
i2c_w(sd, 0x54, 0x23);
reg_w(sd, 0x2f, 0x80);
if (sd->bridge == VAR_8) {
reg_w(sd, 0x24, 0x94);
reg_w(sd, 0x25, 0x90);
ov518_reg_w32(sd, 0xc4,    400, 2);
ov518_reg_w32(sd, 0xc6,    540, 2);
ov518_reg_w32(sd, 0xc7,    540, 2);
ov518_reg_w32(sd, 0xc8,    108, 2);
ov518_reg_w32(sd, 0xca, 131098, 3);
ov518_reg_w32(sd, 0xcb,    532, 2);
ov518_reg_w32(sd, 0xcc,   2400, 2);
ov518_reg_w32(sd, 0xcd,     32, 2);
ov518_reg_w32(sd, 0xce,    608, 2);
} else {
reg_w(sd, 0x24, 0x9f);
reg_w(sd, 0x25, 0x90);
ov518_reg_w32(sd, 0xc4,    400, 2);
ov518_reg_w32(sd, 0xc6,    381, 2);
ov518_reg_w32(sd, 0xc7,    381, 2);
ov518_reg_w32(sd, 0xc8,    128, 2);
ov518_reg_w32(sd, 0xca, 183331, 3);
ov518_reg_w32(sd, 0xcb,    746, 2);
ov518_reg_w32(sd, 0xcc,   1750, 2);
ov518_reg_w32(sd, 0xcd,     45, 2);
ov518_reg_w32(sd, 0xce,    851, 2);
}
reg_w(sd, 0x2f, 0x80);
}",torvalds/linux/998912346c0da53a6dbb71fab3a138586b596b30/ov519.c/vul/before/1.json,"static void ov518_mode_init_regs(struct sd *sd)
{
	struct gspca_dev *gspca_dev = (struct gspca_dev *)sd;
	int hsegs, vsegs, packet_size;
	struct usb_host_interface *alt;
	struct usb_interface *intf;

	intf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);
	alt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);
	if (!alt) {
		gspca_err(gspca_dev, ""Couldn't get altsetting\n"");
		sd->gspca_dev.usb_err = -EIO;
		return;
	}

	if (alt->desc.bNumEndpoints < 1) {
		sd->gspca_dev.usb_err = -ENODEV;
		return;
	}

	packet_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);
	ov518_reg_w32(sd, R51x_FIFO_PSIZE, packet_size & ~7, 2);

	/******** Set the mode ********/
	reg_w(sd, 0x2b, 0);
	reg_w(sd, 0x2c, 0);
	reg_w(sd, 0x2d, 0);
	reg_w(sd, 0x2e, 0);
	reg_w(sd, 0x3b, 0);
	reg_w(sd, 0x3c, 0);
	reg_w(sd, 0x3d, 0);
	reg_w(sd, 0x3e, 0);

	if (sd->bridge == BRIDGE_OV518) {
		/* Set 8-bit (YVYU) input format */
		reg_w_mask(sd, 0x20, 0x08, 0x08);

		/* Set 12-bit (4:2:0) output format */
		reg_w_mask(sd, 0x28, 0x80, 0xf0);
		reg_w_mask(sd, 0x38, 0x80, 0xf0);
	} else {
		reg_w(sd, 0x28, 0x80);
		reg_w(sd, 0x38, 0x80);
	}

	hsegs = sd->gspca_dev.pixfmt.width / 16;
	vsegs = sd->gspca_dev.pixfmt.height / 4;

	reg_w(sd, 0x29, hsegs);
	reg_w(sd, 0x2a, vsegs);

	reg_w(sd, 0x39, hsegs);
	reg_w(sd, 0x3a, vsegs);

	/* Windows driver does this here; who knows why */
	reg_w(sd, 0x2f, 0x80);

	/******** Set the framerate ********/
	if (sd->bridge == BRIDGE_OV518PLUS && sd->revision == 0 &&
					      sd->sensor == SEN_OV7620AE)
		sd->clockdiv = 0;
	else
		sd->clockdiv = 1;

	/* Mode independent, but framerate dependent, regs */
	/* 0x51: Clock divider; Only works on some cams which use 2 crystals */
	reg_w(sd, 0x51, 0x04);
	reg_w(sd, 0x22, 0x18);
	reg_w(sd, 0x23, 0xff);

	if (sd->bridge == BRIDGE_OV518PLUS) {
		switch (sd->sensor) {
		case SEN_OV7620AE:
			/*
			 * HdG: 640x480 needs special handling on device
			 * revision 2, we check for device revision > 0 to
			 * avoid regressions, as we don't know the correct
			 * thing todo for revision 1.
			 *
			 * Also this likely means we don't need to
			 * differentiate between the OV7620 and OV7620AE,
			 * earlier testing hitting this same problem likely
			 * happened to be with revision < 2 cams using an
			 * OV7620 and revision 2 cams using an OV7620AE.
			 */
			if (sd->revision > 0 &&
					sd->gspca_dev.pixfmt.width == 640) {
				reg_w(sd, 0x20, 0x60);
				reg_w(sd, 0x21, 0x1f);
			} else {
				reg_w(sd, 0x20, 0x00);
				reg_w(sd, 0x21, 0x19);
			}
			break;
		case SEN_OV7620:
			reg_w(sd, 0x20, 0x00);
			reg_w(sd, 0x21, 0x19);
			break;
		default:
			reg_w(sd, 0x21, 0x19);
		}
	} else
		reg_w(sd, 0x71, 0x17);	/* Compression-related? */

	/* FIXME: Sensor-specific */
	/* Bit 5 is what matters here. Of course, it is ""reserved"" */
	i2c_w(sd, 0x54, 0x23);

	reg_w(sd, 0x2f, 0x80);

	if (sd->bridge == BRIDGE_OV518PLUS) {
		reg_w(sd, 0x24, 0x94);
		reg_w(sd, 0x25, 0x90);
		ov518_reg_w32(sd, 0xc4,    400, 2);	/* 190h   */
		ov518_reg_w32(sd, 0xc6,    540, 2);	/* 21ch   */
		ov518_reg_w32(sd, 0xc7,    540, 2);	/* 21ch   */
		ov518_reg_w32(sd, 0xc8,    108, 2);	/* 6ch    */
		ov518_reg_w32(sd, 0xca, 131098, 3);	/* 2001ah */
		ov518_reg_w32(sd, 0xcb,    532, 2);	/* 214h   */
		ov518_reg_w32(sd, 0xcc,   2400, 2);	/* 960h   */
		ov518_reg_w32(sd, 0xcd,     32, 2);	/* 20h    */
		ov518_reg_w32(sd, 0xce,    608, 2);	/* 260h   */
	} else {
		reg_w(sd, 0x24, 0x9f);
		reg_w(sd, 0x25, 0x90);
		ov518_reg_w32(sd, 0xc4,    400, 2);	/* 190h   */
		ov518_reg_w32(sd, 0xc6,    381, 2);	/* 17dh   */
		ov518_reg_w32(sd, 0xc7,    381, 2);	/* 17dh   */
		ov518_reg_w32(sd, 0xc8,    128, 2);	/* 80h    */
		ov518_reg_w32(sd, 0xca, 183331, 3);	/* 2cc23h */
		ov518_reg_w32(sd, 0xcb,    746, 2);	/* 2eah   */
		ov518_reg_w32(sd, 0xcc,   1750, 2);	/* 6d6h   */
		ov518_reg_w32(sd, 0xcd,     45, 2);	/* 2dh    */
		ov518_reg_w32(sd, 0xce,    851, 2);	/* 353h   */
	}

	reg_w(sd, 0x2f, 0x80);
}","static void ov518_mode_init_regs(struct sd *sd)
{
	struct gspca_dev *gspca_dev = (struct gspca_dev *)sd;
	int VAR_0, VAR_1, VAR_2;
	struct usb_host_interface *VAR_3;
	struct usb_interface *VAR_4;

	VAR_4 = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);
	VAR_3 = usb_altnum_to_altsetting(VAR_4, sd->gspca_dev.alt);
	if (!VAR_3) {
		gspca_err(gspca_dev, ""Couldn't get altsetting\n"");
		sd->gspca_dev.usb_err = -VAR_5;
		return;
	}

	if (VAR_3->desc.bNumEndpoints < 1) {
		sd->gspca_dev.usb_err = -VAR_6;
		return;
	}

	VAR_2 = le16_to_cpu(VAR_3->endpoint[0].desc.wMaxPacketSize);
	ov518_reg_w32(sd, VAR_7, VAR_2 & ~7, 2);

	/* COMMENT_0 */
	reg_w(sd, 0x2b, 0);
	reg_w(sd, 0x2c, 0);
	reg_w(sd, 0x2d, 0);
	reg_w(sd, 0x2e, 0);
	reg_w(sd, 0x3b, 0);
	reg_w(sd, 0x3c, 0);
	reg_w(sd, 0x3d, 0);
	reg_w(sd, 0x3e, 0);

	if (sd->bridge == VAR_8) {
		/* COMMENT_1 */
		reg_w_mask(sd, 0x20, 0x08, 0x08);

		/* COMMENT_2 */
		reg_w_mask(sd, 0x28, 0x80, 0xf0);
		reg_w_mask(sd, 0x38, 0x80, 0xf0);
	} else {
		reg_w(sd, 0x28, 0x80);
		reg_w(sd, 0x38, 0x80);
	}

	VAR_0 = sd->gspca_dev.pixfmt.width / 16;
	VAR_1 = sd->gspca_dev.pixfmt.height / 4;

	reg_w(sd, 0x29, VAR_0);
	reg_w(sd, 0x2a, VAR_1);

	reg_w(sd, 0x39, VAR_0);
	reg_w(sd, 0x3a, VAR_1);

	/* COMMENT_3 */
	reg_w(sd, 0x2f, 0x80);

	/* COMMENT_4 */
	if (sd->bridge == VAR_9 && sd->revision == 0 &&
					      sd->sensor == VAR_10)
		sd->clockdiv = 0;
	else
		sd->clockdiv = 1;

	/* COMMENT_5 */
	/* COMMENT_6 */
	reg_w(sd, 0x51, 0x04);
	reg_w(sd, 0x22, 0x18);
	reg_w(sd, 0x23, 0xff);

	if (sd->bridge == VAR_9) {
		switch (sd->sensor) {
		case VAR_10:
			/* COMMENT_7 */
                                                   
                                                     
                                                     
                                
     
                                             
                                                    
                                                      
                                                    
                                                   
      
			if (sd->revision > 0 &&
					sd->gspca_dev.pixfmt.width == 640) {
				reg_w(sd, 0x20, 0x60);
				reg_w(sd, 0x21, 0x1f);
			} else {
				reg_w(sd, 0x20, 0x00);
				reg_w(sd, 0x21, 0x19);
			}
			break;
		case VAR_11:
			reg_w(sd, 0x20, 0x00);
			reg_w(sd, 0x21, 0x19);
			break;
		default:
			reg_w(sd, 0x21, 0x19);
		}
	} else
		reg_w(sd, 0x71, 0x17);	/* COMMENT_19 */

	/* COMMENT_20 */
	/* COMMENT_21 */
	i2c_w(sd, 0x54, 0x23);

	reg_w(sd, 0x2f, 0x80);

	if (sd->bridge == VAR_9) {
		reg_w(sd, 0x24, 0x94);
		reg_w(sd, 0x25, 0x90);
		ov518_reg_w32(sd, 0xc4,    400, 2);	/* COMMENT_22 */
		ov518_reg_w32(sd, 0xc6,    540, 2);	/* COMMENT_23 */
		ov518_reg_w32(sd, 0xc7,    540, 2);	/* COMMENT_23 */
		ov518_reg_w32(sd, 0xc8,    108, 2);	/* COMMENT_24 */
		ov518_reg_w32(sd, 0xca, 131098, 3);	/* COMMENT_25 */
		ov518_reg_w32(sd, 0xcb,    532, 2);	/* COMMENT_26 */
		ov518_reg_w32(sd, 0xcc,   2400, 2);	/* COMMENT_27 */
		ov518_reg_w32(sd, 0xcd,     32, 2);	/* COMMENT_28 */
		ov518_reg_w32(sd, 0xce,    608, 2);	/* COMMENT_29 */
	} else {
		reg_w(sd, 0x24, 0x9f);
		reg_w(sd, 0x25, 0x90);
		ov518_reg_w32(sd, 0xc4,    400, 2);	/* COMMENT_22 */
		ov518_reg_w32(sd, 0xc6,    381, 2);	/* COMMENT_30 */
		ov518_reg_w32(sd, 0xc7,    381, 2);	/* COMMENT_30 */
		ov518_reg_w32(sd, 0xc8,    128, 2);	/* COMMENT_31 */
		ov518_reg_w32(sd, 0xca, 183331, 3);	/* COMMENT_32 */
		ov518_reg_w32(sd, 0xcb,    746, 2);	/* COMMENT_33 */
		ov518_reg_w32(sd, 0xcc,   1750, 2);	/* COMMENT_34 */
		ov518_reg_w32(sd, 0xcd,     45, 2);	/* COMMENT_35 */
		ov518_reg_w32(sd, 0xce,    851, 2);	/* COMMENT_36 */
	}

	reg_w(sd, 0x2f, 0x80);
}",torvalds/linux/998912346c0da53a6dbb71fab3a138586b596b30/ov519.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -10,6 +10,11 @@
 	if (!alt) {
 		gspca_err(gspca_dev, ""Couldn't get altsetting\n"");
 		sd->gspca_dev.usb_err = -EIO;
+		return;
+	}
+
+	if (alt->desc.bNumEndpoints < 1) {
+		sd->gspca_dev.usb_err = -ENODEV;
 		return;
 	}
 ","{'deleted_lines': [], 'added_lines': ['\t\treturn;', '\t}', '', '\tif (alt->desc.bNumEndpoints < 1) {', '\t\tsd->gspca_dev.usb_err = -ENODEV;']}",True,"An issue was discovered in the Linux kernel before 5.6.1. drivers/media/usb/gspca/ov519.c allows NULL pointer dereferences in ov511_mode_init_regs and ov518_mode_init_regs when there are zero endpoints, aka CID-998912346c0d.",4.3,MEDIUM,1,test,2020-01-03T16:35:09Z,3
CVE-2020-11608,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"media: ov519: add missing endpoint sanity checks

Make sure to check that we have at least one endpoint before accessing
the endpoint array to avoid dereferencing a NULL-pointer on stream
start.

Note that these sanity checks are not redundant as the driver is mixing
looking up altsettings by index and by number, which need not coincide.

Fixes: 1876bb923c98 (""V4L/DVB (12079): gspca_ov519: add support for the ov511 bridge"")
Fixes: b282d87332f5 (""V4L/DVB (12080): gspca_ov519: Fix ov518+ with OV7620AE (Trust spacecam 320)"")
Cc: stable <stable@vger.kernel.org>     # 2.6.31
Cc: Hans de Goede <hdegoede@redhat.com>
Signed-off-by: Johan Hovold <johan@kernel.org>
Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>",998912346c0da53a6dbb71fab3a138586b596b30,https://github.com/torvalds/linux/commit/998912346c0da53a6dbb71fab3a138586b596b30,drivers/media/usb/gspca/ov519.c,ov511_mode_init_regs,"static void ov511_mode_init_regs(struct sd *sd)
{
struct gspca_dev *gspca_dev = (struct gspca_dev *)sd;
int hsegs, vsegs, packet_size, fps, needed;
int interlaced = 0;
struct usb_host_interface *alt;
struct usb_interface *intf;
intf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);
alt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);
if (!alt) {
gspca_err(gspca_dev, ""Couldn't get altsetting\n"");
sd->gspca_dev.usb_err = -EIO;
return;
}
packet_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);
reg_w(sd, R51x_FIFO_PSIZE, packet_size >> 5);
reg_w(sd, R511_CAM_UV_EN, 0x01);
reg_w(sd, R511_SNAP_UV_EN, 0x01);
reg_w(sd, R511_SNAP_OPTS, 0x03);
hsegs = (sd->gspca_dev.pixfmt.width >> 3) - 1;
vsegs = (sd->gspca_dev.pixfmt.height >> 3) - 1;
reg_w(sd, R511_CAM_PXCNT, hsegs);
reg_w(sd, R511_CAM_LNCNT, vsegs);
reg_w(sd, R511_CAM_PXDIV, 0x00);
reg_w(sd, R511_CAM_LNDIV, 0x00);
reg_w(sd, R511_CAM_OPTS, 0x03);
reg_w(sd, R511_SNAP_PXCNT, hsegs);
reg_w(sd, R511_SNAP_LNCNT, vsegs);
reg_w(sd, R511_SNAP_PXDIV, 0x00);
reg_w(sd, R511_SNAP_LNDIV, 0x00);
if (frame_rate > 0)
sd->frame_rate = frame_rate;
switch (sd->sensor) {
case SEN_OV6620:
sd->clockdiv = 3;
break;
case SEN_OV7620:
case SEN_OV7620AE:
case SEN_OV7640:
case SEN_OV7648:
case SEN_OV76BE:
if (sd->gspca_dev.pixfmt.width == 320)
interlaced = 1;
case SEN_OV6630:
case SEN_OV7610:
case SEN_OV7670:
switch (sd->frame_rate) {
case 30:
case 25:
if (sd->gspca_dev.pixfmt.width != 640) {
sd->clockdiv = 0;
break;
}
default:
sd->clockdiv = 1;
break;
case 10:
sd->clockdiv = 2;
break;
case 5:
sd->clockdiv = 5;
break;
}
if (interlaced) {
sd->clockdiv = (sd->clockdiv + 1) * 2 - 1;
if (sd->clockdiv > 10)
sd->clockdiv = 10;
}
break;
case SEN_OV8610:
sd->clockdiv = 0;
break;
}
fps = (interlaced ? 60 : 30) / (sd->clockdiv + 1) + 1;
needed = fps * sd->gspca_dev.pixfmt.width *
sd->gspca_dev.pixfmt.height * 3 / 2;
if (needed > 1000 * packet_size) {
reg_w(sd, R511_COMP_EN, 0x07);
reg_w(sd, R511_COMP_LUT_EN, 0x03);
} else {
reg_w(sd, R511_COMP_EN, 0x06);
reg_w(sd, R511_COMP_LUT_EN, 0x00);
}
reg_w(sd, R51x_SYS_RESET, OV511_RESET_OMNICE);
reg_w(sd, R51x_SYS_RESET, 0);
}","static void ov511_mode_init_regs(struct sd *sd)
{
struct gspca_dev *gspca_dev = (struct gspca_dev *)sd;
int VAR_0, VAR_1, VAR_2, VAR_3, VAR_4;
int VAR_5 = 0;
struct usb_host_interface *VAR_6;
struct usb_interface *VAR_7;
VAR_7 = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);
VAR_6 = usb_altnum_to_altsetting(VAR_7, sd->gspca_dev.alt);
if (!VAR_6) {
gspca_err(gspca_dev, ""Couldn't get altsetting\n"");
sd->gspca_dev.usb_err = -VAR_8;
return;
}
VAR_2 = le16_to_cpu(VAR_6->endpoint[0].desc.wMaxPacketSize);
reg_w(sd, VAR_9, VAR_2 >> 5);
reg_w(sd, VAR_10, 0x01);
reg_w(sd, VAR_11, 0x01);
reg_w(sd, VAR_12, 0x03);
VAR_0 = (sd->gspca_dev.pixfmt.width >> 3) - 1;
VAR_1 = (sd->gspca_dev.pixfmt.height >> 3) - 1;
reg_w(sd, VAR_13, VAR_0);
reg_w(sd, VAR_14, VAR_1);
reg_w(sd, VAR_15, 0x00);
reg_w(sd, VAR_16, 0x00);
reg_w(sd, VAR_17, 0x03);
reg_w(sd, VAR_18, VAR_0);
reg_w(sd, VAR_19, VAR_1);
reg_w(sd, VAR_20, 0x00);
reg_w(sd, VAR_21, 0x00);
if (VAR_22 > 0)
sd->frame_rate = VAR_22;
switch (sd->sensor) {
case VAR_23:
sd->clockdiv = 3;
break;
case VAR_24:
case VAR_25:
case VAR_26:
case VAR_27:
case VAR_28:
if (sd->gspca_dev.pixfmt.width == 320)
VAR_5 = 1;
case VAR_29:
case VAR_30:
case VAR_31:
switch (sd->frame_rate) {
case 30:
case 25:
if (sd->gspca_dev.pixfmt.width != 640) {
sd->clockdiv = 0;
break;
}
default:
sd->clockdiv = 1;
break;
case 10:
sd->clockdiv = 2;
break;
case 5:
sd->clockdiv = 5;
break;
}
if (VAR_5) {
sd->clockdiv = (sd->clockdiv + 1) * 2 - 1;
if (sd->clockdiv > 10)
sd->clockdiv = 10;
}
break;
case VAR_32:
sd->clockdiv = 0;
break;
}
VAR_3 = (VAR_5 ? 60 : 30) / (sd->clockdiv + 1) + 1;
VAR_4 = VAR_3 * sd->gspca_dev.pixfmt.width *
sd->gspca_dev.pixfmt.height * 3 / 2;
if (VAR_4 > 1000 * VAR_2) {
reg_w(sd, VAR_33, 0x07);
reg_w(sd, VAR_34, 0x03);
} else {
reg_w(sd, VAR_33, 0x06);
reg_w(sd, VAR_34, 0x00);
}
reg_w(sd, VAR_35, VAR_36);
reg_w(sd, VAR_35, 0);
}",torvalds/linux/998912346c0da53a6dbb71fab3a138586b596b30/ov519.c/vul/before/0.json,"static void ov511_mode_init_regs(struct sd *sd)
{
	struct gspca_dev *gspca_dev = (struct gspca_dev *)sd;
	int hsegs, vsegs, packet_size, fps, needed;
	int interlaced = 0;
	struct usb_host_interface *alt;
	struct usb_interface *intf;

	intf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);
	alt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);
	if (!alt) {
		gspca_err(gspca_dev, ""Couldn't get altsetting\n"");
		sd->gspca_dev.usb_err = -EIO;
		return;
	}

	if (alt->desc.bNumEndpoints < 1) {
		sd->gspca_dev.usb_err = -ENODEV;
		return;
	}

	packet_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);
	reg_w(sd, R51x_FIFO_PSIZE, packet_size >> 5);

	reg_w(sd, R511_CAM_UV_EN, 0x01);
	reg_w(sd, R511_SNAP_UV_EN, 0x01);
	reg_w(sd, R511_SNAP_OPTS, 0x03);

	/* Here I'm assuming that snapshot size == image size.
	 * I hope that's always true. --claudio
	 */
	hsegs = (sd->gspca_dev.pixfmt.width >> 3) - 1;
	vsegs = (sd->gspca_dev.pixfmt.height >> 3) - 1;

	reg_w(sd, R511_CAM_PXCNT, hsegs);
	reg_w(sd, R511_CAM_LNCNT, vsegs);
	reg_w(sd, R511_CAM_PXDIV, 0x00);
	reg_w(sd, R511_CAM_LNDIV, 0x00);

	/* YUV420, low pass filter on */
	reg_w(sd, R511_CAM_OPTS, 0x03);

	/* Snapshot additions */
	reg_w(sd, R511_SNAP_PXCNT, hsegs);
	reg_w(sd, R511_SNAP_LNCNT, vsegs);
	reg_w(sd, R511_SNAP_PXDIV, 0x00);
	reg_w(sd, R511_SNAP_LNDIV, 0x00);

	/******** Set the framerate ********/
	if (frame_rate > 0)
		sd->frame_rate = frame_rate;

	switch (sd->sensor) {
	case SEN_OV6620:
		/* No framerate control, doesn't like higher rates yet */
		sd->clockdiv = 3;
		break;

	/* Note once the FIXME's in mode_init_ov_sensor_regs() are fixed
	   for more sensors we need to do this for them too */
	case SEN_OV7620:
	case SEN_OV7620AE:
	case SEN_OV7640:
	case SEN_OV7648:
	case SEN_OV76BE:
		if (sd->gspca_dev.pixfmt.width == 320)
			interlaced = 1;
		/* Fall through */
	case SEN_OV6630:
	case SEN_OV7610:
	case SEN_OV7670:
		switch (sd->frame_rate) {
		case 30:
		case 25:
			/* Not enough bandwidth to do 640x480 @ 30 fps */
			if (sd->gspca_dev.pixfmt.width != 640) {
				sd->clockdiv = 0;
				break;
			}
			/* For 640x480 case */
			/* fall through */
		default:
/*		case 20: */
/*		case 15: */
			sd->clockdiv = 1;
			break;
		case 10:
			sd->clockdiv = 2;
			break;
		case 5:
			sd->clockdiv = 5;
			break;
		}
		if (interlaced) {
			sd->clockdiv = (sd->clockdiv + 1) * 2 - 1;
			/* Higher then 10 does not work */
			if (sd->clockdiv > 10)
				sd->clockdiv = 10;
		}
		break;

	case SEN_OV8610:
		/* No framerate control ?? */
		sd->clockdiv = 0;
		break;
	}

	/* Check if we have enough bandwidth to disable compression */
	fps = (interlaced ? 60 : 30) / (sd->clockdiv + 1) + 1;
	needed = fps * sd->gspca_dev.pixfmt.width *
			sd->gspca_dev.pixfmt.height * 3 / 2;
	/* 1000 isoc packets/sec */
	if (needed > 1000 * packet_size) {
		/* Enable Y and UV quantization and compression */
		reg_w(sd, R511_COMP_EN, 0x07);
		reg_w(sd, R511_COMP_LUT_EN, 0x03);
	} else {
		reg_w(sd, R511_COMP_EN, 0x06);
		reg_w(sd, R511_COMP_LUT_EN, 0x00);
	}

	reg_w(sd, R51x_SYS_RESET, OV511_RESET_OMNICE);
	reg_w(sd, R51x_SYS_RESET, 0);
}","static void ov511_mode_init_regs(struct sd *sd)
{
	struct gspca_dev *gspca_dev = (struct gspca_dev *)sd;
	int VAR_0, VAR_1, VAR_2, VAR_3, VAR_4;
	int VAR_5 = 0;
	struct usb_host_interface *VAR_6;
	struct usb_interface *VAR_7;

	VAR_7 = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);
	VAR_6 = usb_altnum_to_altsetting(VAR_7, sd->gspca_dev.alt);
	if (!VAR_6) {
		gspca_err(gspca_dev, ""Couldn't get altsetting\n"");
		sd->gspca_dev.usb_err = -VAR_8;
		return;
	}

	if (VAR_6->desc.bNumEndpoints < 1) {
		sd->gspca_dev.usb_err = -VAR_9;
		return;
	}

	VAR_2 = le16_to_cpu(VAR_6->endpoint[0].desc.wMaxPacketSize);
	reg_w(sd, VAR_10, VAR_2 >> 5);

	reg_w(sd, VAR_11, 0x01);
	reg_w(sd, VAR_12, 0x01);
	reg_w(sd, VAR_13, 0x03);

	/* COMMENT_0 */
                                        
    
	VAR_0 = (sd->gspca_dev.pixfmt.width >> 3) - 1;
	VAR_1 = (sd->gspca_dev.pixfmt.height >> 3) - 1;

	reg_w(sd, VAR_14, VAR_0);
	reg_w(sd, VAR_15, VAR_1);
	reg_w(sd, VAR_16, 0x00);
	reg_w(sd, VAR_17, 0x00);

	/* COMMENT_3 */
	reg_w(sd, VAR_18, 0x03);

	/* COMMENT_4 */
	reg_w(sd, VAR_19, VAR_0);
	reg_w(sd, VAR_20, VAR_1);
	reg_w(sd, VAR_21, 0x00);
	reg_w(sd, VAR_22, 0x00);

	/* COMMENT_5 */
	if (VAR_23 > 0)
		sd->frame_rate = VAR_23;

	switch (sd->sensor) {
	case VAR_24:
		/* COMMENT_6 */
		sd->clockdiv = 3;
		break;

	/* COMMENT_7 */
                                                       
	case VAR_25:
	case VAR_26:
	case VAR_27:
	case VAR_28:
	case VAR_29:
		if (sd->gspca_dev.pixfmt.width == 320)
			VAR_5 = 1;
		/* COMMENT_9 */
	case VAR_30:
	case VAR_31:
	case VAR_32:
		switch (sd->frame_rate) {
		case 30:
		case 25:
			/* COMMENT_10 */
			if (sd->gspca_dev.pixfmt.width != 640) {
				sd->clockdiv = 0;
				break;
			}
			/* COMMENT_11 */
			/* COMMENT_12 */
		default:
/* COMMENT_13 */
/* COMMENT_14 */
			sd->clockdiv = 1;
			break;
		case 10:
			sd->clockdiv = 2;
			break;
		case 5:
			sd->clockdiv = 5;
			break;
		}
		if (VAR_5) {
			sd->clockdiv = (sd->clockdiv + 1) * 2 - 1;
			/* COMMENT_15 */
			if (sd->clockdiv > 10)
				sd->clockdiv = 10;
		}
		break;

	case VAR_33:
		/* COMMENT_16 */
		sd->clockdiv = 0;
		break;
	}

	/* COMMENT_17 */
	VAR_3 = (VAR_5 ? 60 : 30) / (sd->clockdiv + 1) + 1;
	VAR_4 = VAR_3 * sd->gspca_dev.pixfmt.width *
			sd->gspca_dev.pixfmt.height * 3 / 2;
	/* COMMENT_18 */
	if (VAR_4 > 1000 * VAR_2) {
		/* COMMENT_19 */
		reg_w(sd, VAR_34, 0x07);
		reg_w(sd, VAR_35, 0x03);
	} else {
		reg_w(sd, VAR_34, 0x06);
		reg_w(sd, VAR_35, 0x00);
	}

	reg_w(sd, VAR_36, VAR_37);
	reg_w(sd, VAR_36, 0);
}",torvalds/linux/998912346c0da53a6dbb71fab3a138586b596b30/ov519.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,6 +11,11 @@
 	if (!alt) {
 		gspca_err(gspca_dev, ""Couldn't get altsetting\n"");
 		sd->gspca_dev.usb_err = -EIO;
+		return;
+	}
+
+	if (alt->desc.bNumEndpoints < 1) {
+		sd->gspca_dev.usb_err = -ENODEV;
 		return;
 	}
 ","{'deleted_lines': [], 'added_lines': ['\t\treturn;', '\t}', '', '\tif (alt->desc.bNumEndpoints < 1) {', '\t\tsd->gspca_dev.usb_err = -ENODEV;']}",True,"An issue was discovered in the Linux kernel before 5.6.1. drivers/media/usb/gspca/ov519.c allows NULL pointer dereferences in ov511_mode_init_regs and ov518_mode_init_regs when there are zero endpoints, aka CID-998912346c0d.",4.3,MEDIUM,1,test,2020-01-03T16:35:09Z,3
CVE-2019-20159,['CWE-401'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fix dinf memleak (#1321),e4c1f09ab9618b6af3bec6b94b8b349f2d01dbf8,https://github.com/gpac/gpac/commit/e4c1f09ab9618b6af3bec6b94b8b349f2d01dbf8,src/isomedia/box_code_base.c,minf_Read,"GF_Err minf_Read(GF_Box *s, GF_BitStream *bs)
{
GF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;
GF_Err e;
e = gf_isom_box_array_read(s, bs, minf_AddBox);
if (! ptr->dataInformation) {
GF_Box *dinf, *dref, *url;
Bool dump_mode = GF_FALSE;
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing DataInformationBox\n""));
dinf = gf_isom_box_new(GF_ISOM_BOX_TYPE_DINF);
if (!dinf) return GF_OUT_OF_MEM;
if (ptr->InfoHeader && gf_list_find(ptr->other_boxes, ptr->InfoHeader)>=0) dump_mode = GF_TRUE;
if (ptr->sampleTable && gf_list_find(ptr->other_boxes, ptr->sampleTable)>=0) dump_mode = GF_TRUE;
ptr->dataInformation = (GF_DataInformationBox *)dinf;
dref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
if (!dref) return GF_OUT_OF_MEM;
e = dinf_AddBox(dinf, dref);
url = gf_isom_box_new(GF_ISOM_BOX_TYPE_URL);
if (!url) return GF_OUT_OF_MEM;
((GF_FullBox*)url)->flags = 1;
e = gf_isom_box_add_default(dref, url);
if (dump_mode) {
gf_list_add(ptr->other_boxes, ptr->dataInformation);
if (!dinf->other_boxes) dinf->other_boxes = gf_list_new();
gf_list_add(dinf->other_boxes, dref);
}
}
return e;
}","GF_Err minf_Read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
GF_MediaInformationBox *VAR_2 = (GF_MediaInformationBox *)VAR_0;
GF_Err VAR_3;
VAR_3 = gf_isom_box_array_read(VAR_0, VAR_1, VAR_4);
if (! VAR_2->dataInformation) {
GF_Box *VAR_5, *VAR_6, *VAR_7;
Bool VAR_8 = VAR_9;
GF_LOG(VAR_10, VAR_11, (""[iso file] Missing DataInformationBox\n""));
VAR_5 = gf_isom_box_new(VAR_12);
if (!VAR_5) return VAR_13;
if (VAR_2->InfoHeader && gf_list_find(VAR_2->other_boxes, VAR_2->InfoHeader)>=0) VAR_8 = VAR_14;
if (VAR_2->sampleTable && gf_list_find(VAR_2->other_boxes, VAR_2->sampleTable)>=0) VAR_8 = VAR_14;
VAR_2->dataInformation = (GF_DataInformationBox *)VAR_5;
VAR_6 = gf_isom_box_new(VAR_15);
if (!VAR_6) return VAR_13;
VAR_3 = dinf_AddBox(VAR_5, VAR_6);
VAR_7 = gf_isom_box_new(VAR_16);
if (!VAR_7) return VAR_13;
((GF_FullBox*)VAR_7)->flags = 1;
VAR_3 = gf_isom_box_add_default(VAR_6, VAR_7);
if (VAR_8) {
gf_list_add(VAR_2->other_boxes, VAR_2->dataInformation);
if (!VAR_5->other_boxes) VAR_5->other_boxes = gf_list_new();
gf_list_add(VAR_5->other_boxes, VAR_6);
}
}
return VAR_3;
}",gpac/e4c1f09ab9618b6af3bec6b94b8b349f2d01dbf8/box_code_base.c/vul/before/0.json,"GF_Err minf_Read(GF_Box *s, GF_BitStream *bs)
{
	GF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;
	GF_Err e;
	e = gf_isom_box_array_read(s, bs, minf_AddBox);
	if (! ptr->dataInformation) {
		GF_Box *dinf, *dref, *url;
		extern Bool use_dump_mode;
		Bool dump_mode = use_dump_mode;
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing DataInformationBox\n""));
		//commented on purpose, we are still able to handle the file, we only throw an error but keep processing
//		e = GF_ISOM_INVALID_FILE;

		//add a dinf box to avoid any access to a null dinf
		dinf = gf_isom_box_new(GF_ISOM_BOX_TYPE_DINF);
		if (!dinf) return GF_OUT_OF_MEM;
		if (ptr->InfoHeader && gf_list_find(ptr->other_boxes, ptr->InfoHeader)>=0) dump_mode = GF_TRUE;
		if (ptr->sampleTable && gf_list_find(ptr->other_boxes, ptr->sampleTable)>=0) dump_mode = GF_TRUE;

		ptr->dataInformation = (GF_DataInformationBox *)dinf;

		dref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
		if (!dref) return GF_OUT_OF_MEM;
		e = dinf_AddBox(dinf, dref);

		url = gf_isom_box_new(GF_ISOM_BOX_TYPE_URL);
		if (!url) return GF_OUT_OF_MEM;
		((GF_FullBox*)url)->flags = 1;
		e = gf_isom_box_add_default(dref, url);

		if (dump_mode) {
			gf_list_add(ptr->other_boxes, ptr->dataInformation);
			if (!dinf->other_boxes) dinf->other_boxes = gf_list_new();
			gf_list_add(dinf->other_boxes, dref);
		}
	}
	return e;
}","GF_Err minf_Read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
	GF_MediaInformationBox *VAR_2 = (GF_MediaInformationBox *)VAR_0;
	GF_Err VAR_3;
	VAR_3 = gf_isom_box_array_read(VAR_0, VAR_1, VAR_4);
	if (! VAR_2->dataInformation) {
		GF_Box *VAR_5, *VAR_6, *VAR_7;
		extern Bool VAR_8;
		Bool VAR_9 = VAR_8;
		GF_LOG(VAR_10, VAR_11, (""[iso file] Missing DataInformationBox\n""));
		/* COMMENT_0 */
/* COMMENT_1 */

		/* COMMENT_2 */
		VAR_5 = gf_isom_box_new(VAR_12);
		if (!VAR_5) return VAR_13;
		if (VAR_2->InfoHeader && gf_list_find(VAR_2->other_boxes, VAR_2->InfoHeader)>=0) VAR_9 = VAR_14;
		if (VAR_2->sampleTable && gf_list_find(VAR_2->other_boxes, VAR_2->sampleTable)>=0) VAR_9 = VAR_14;

		VAR_2->dataInformation = (GF_DataInformationBox *)VAR_5;

		VAR_6 = gf_isom_box_new(VAR_15);
		if (!VAR_6) return VAR_13;
		VAR_3 = dinf_AddBox(VAR_5, VAR_6);

		VAR_7 = gf_isom_box_new(VAR_16);
		if (!VAR_7) return VAR_13;
		((GF_FullBox*)VAR_7)->flags = 1;
		VAR_3 = gf_isom_box_add_default(VAR_6, VAR_7);

		if (VAR_9) {
			gf_list_add(VAR_2->other_boxes, VAR_2->dataInformation);
			if (!VAR_5->other_boxes) VAR_5->other_boxes = gf_list_new();
			gf_list_add(VAR_5->other_boxes, VAR_6);
		}
	}
	return VAR_3;
}",gpac/e4c1f09ab9618b6af3bec6b94b8b349f2d01dbf8/box_code_base.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,8 @@
 	e = gf_isom_box_array_read(s, bs, minf_AddBox);
 	if (! ptr->dataInformation) {
 		GF_Box *dinf, *dref, *url;
-		Bool dump_mode = GF_FALSE;
+		extern Bool use_dump_mode;
+		Bool dump_mode = use_dump_mode;
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing DataInformationBox\n""));
 		//commented on purpose, we are still able to handle the file, we only throw an error but keep processing
 //		e = GF_ISOM_INVALID_FILE;","{'deleted_lines': ['\t\tBool dump_mode = GF_FALSE;'], 'added_lines': ['\t\textern Bool use_dump_mode;', '\t\tBool dump_mode = use_dump_mode;']}",True,An issue was discovered in GPAC version 0.8.0 and 0.9.0-development-20191109. There is a memory leak in dinf_New() in isomedia/box_code_base.c.,5.5,MEDIUM,1,test,2020-01-07T13:26:20Z,3
CVE-2019-20171,['CWE-401'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fix memleak in abst_Read (#1337),72cdc5048dead86bb1df7d21e0b9975e49cf2d97,https://github.com/gpac/gpac/commit/72cdc5048dead86bb1df7d21e0b9975e49cf2d97,src/isomedia/box_code_adobe.c,abst_Read,"GF_Err abst_Read(GF_Box *s, GF_BitStream *bs)
{
GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;
int i;
u32 tmp_strsize;
char *tmp_str;
GF_Err e;
ptr->bootstrapinfo_version = gf_bs_read_u32(bs);
ptr->profile = gf_bs_read_int(bs, 2);
ptr->live = gf_bs_read_int(bs, 1);
ptr->update = gf_bs_read_int(bs, 1);
ptr->reserved = gf_bs_read_int(bs, 4);
ptr->time_scale = gf_bs_read_u32(bs);
ptr->current_media_time = gf_bs_read_u64(bs);
ptr->smpte_time_code_offset = gf_bs_read_u64(bs);
i=0;
if (ptr->size<8) return GF_ISOM_INVALID_FILE;
tmp_strsize=(u32)ptr->size-8;
tmp_str = gf_malloc(sizeof(char)*tmp_strsize);
while (tmp_strsize) {
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i)
ptr->movie_identifier = gf_strdup(tmp_str);
ptr->server_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->server_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size-8;
while (tmp_strsize) {
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}
gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);
}
ptr->quality_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->quality_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size-8;
while (tmp_strsize) {
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}
gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);
}
i=0;
tmp_strsize=(u32)ptr->size-8;
while (tmp_strsize) {
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i)
ptr->drm_data = gf_strdup(tmp_str);
i=0;
tmp_strsize=(u32)ptr->size-8;
while (tmp_strsize) {
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i)
ptr->meta_data = gf_strdup(tmp_str);
ptr->segment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->segment_run_table_count; i++) {
GF_AdobeSegmentRunTableBox *asrt;
e = gf_isom_box_parse((GF_Box **)&asrt, bs);
if (e) return e;
gf_list_insert(ptr->segment_run_table_entries, asrt, i);
}
ptr->fragment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->fragment_run_table_count; i++) {
GF_AdobeFragmentRunTableBox *afrt;
e = gf_isom_box_parse((GF_Box **)&afrt, bs);
if (e) return e;
gf_list_insert(ptr->fragment_run_table_entries, afrt, i);
}
gf_free(tmp_str);
return GF_OK;
}","GF_Err abst_Read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
GF_AdobeBootstrapInfoBox *VAR_2 = (GF_AdobeBootstrapInfoBox *)VAR_0;
int VAR_3;
u32 VAR_4;
char *VAR_5;
GF_Err VAR_6;
VAR_2->bootstrapinfo_version = gf_bs_read_u32(VAR_1);
VAR_2->profile = gf_bs_read_int(VAR_1, 2);
VAR_2->live = gf_bs_read_int(VAR_1, 1);
VAR_2->update = gf_bs_read_int(VAR_1, 1);
VAR_2->reserved = gf_bs_read_int(VAR_1, 4);
VAR_2->time_scale = gf_bs_read_u32(VAR_1);
VAR_2->current_media_time = gf_bs_read_u64(VAR_1);
VAR_2->smpte_time_code_offset = gf_bs_read_u64(VAR_1);
VAR_3=0;
if (VAR_2->size<8) return VAR_7;
VAR_4=(u32)VAR_2->size-8;
VAR_5 = gf_malloc(sizeof(char)*VAR_4);
while (VAR_4) {
VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_3])
break;
VAR_3++;
}
if (VAR_3)
VAR_2->movie_identifier = gf_strdup(VAR_5);
VAR_2->server_entry_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->server_entry_count; VAR_3++) {
int VAR_8=0;
VAR_4=(u32)VAR_2->size-8;
while (VAR_4) {
VAR_5[VAR_8] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_8])
break;
VAR_8++;
}
gf_list_insert(VAR_2->server_entry_table, gf_strdup(VAR_5), VAR_3);
}
VAR_2->quality_entry_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->quality_entry_count; VAR_3++) {
int VAR_8=0;
VAR_4=(u32)VAR_2->size-8;
while (VAR_4) {
VAR_5[VAR_8] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_8])
break;
VAR_8++;
}
gf_list_insert(VAR_2->quality_entry_table, gf_strdup(VAR_5), VAR_3);
}
VAR_3=0;
VAR_4=(u32)VAR_2->size-8;
while (VAR_4) {
VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_3])
break;
VAR_3++;
}
if (VAR_3)
VAR_2->drm_data = gf_strdup(VAR_5);
VAR_3=0;
VAR_4=(u32)VAR_2->size-8;
while (VAR_4) {
VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_3])
break;
VAR_3++;
}
if (VAR_3)
VAR_2->meta_data = gf_strdup(VAR_5);
VAR_2->segment_run_table_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->segment_run_table_count; VAR_3++) {
GF_AdobeSegmentRunTableBox *VAR_9;
VAR_6 = gf_isom_box_parse((GF_Box **)&VAR_9, VAR_1);
if (VAR_6) return VAR_6;
gf_list_insert(VAR_2->segment_run_table_entries, VAR_9, VAR_3);
}
VAR_2->fragment_run_table_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->fragment_run_table_count; VAR_3++) {
GF_AdobeFragmentRunTableBox *VAR_10;
VAR_6 = gf_isom_box_parse((GF_Box **)&VAR_10, VAR_1);
if (VAR_6) return VAR_6;
gf_list_insert(VAR_2->fragment_run_table_entries, VAR_10, VAR_3);
}
gf_free(VAR_5);
return VAR_11;
}",gpac/72cdc5048dead86bb1df7d21e0b9975e49cf2d97/box_code_adobe.c/vul/before/0.json,"GF_Err abst_Read(GF_Box *s, GF_BitStream *bs)
{
	GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;
	int i;
	u32 tmp_strsize;
	char *tmp_str;
	GF_Err e;

	ptr->bootstrapinfo_version = gf_bs_read_u32(bs);
	ptr->profile = gf_bs_read_int(bs, 2);
	ptr->live = gf_bs_read_int(bs, 1);
	ptr->update = gf_bs_read_int(bs, 1);
	ptr->reserved = gf_bs_read_int(bs, 4);
	ptr->time_scale = gf_bs_read_u32(bs);
	ptr->current_media_time = gf_bs_read_u64(bs);
	ptr->smpte_time_code_offset = gf_bs_read_u64(bs);

	i=0;
	if (ptr->size<8) return GF_ISOM_INVALID_FILE;
	tmp_strsize=(u32)ptr->size-8;
	tmp_str = gf_malloc(sizeof(char)*tmp_strsize);

	while (tmp_strsize) {
		tmp_str[i] = gf_bs_read_u8(bs);
		tmp_strsize--;
		if (!tmp_str[i])
			break;
		i++;
	}
	if (i)
		ptr->movie_identifier = gf_strdup(tmp_str);

	ptr->server_entry_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->server_entry_count; i++) {
		int j=0;
		tmp_strsize=(u32)ptr->size-8;
		while (tmp_strsize) {
			tmp_str[j] = gf_bs_read_u8(bs);
			tmp_strsize--;
			if (!tmp_str[j])
				break;
			j++;
		}
		gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);
	}

	ptr->quality_entry_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->quality_entry_count; i++) {
		int j=0;
		tmp_strsize=(u32)ptr->size-8;
		while (tmp_strsize) {
			tmp_str[j] = gf_bs_read_u8(bs);
			tmp_strsize--;
			if (!tmp_str[j])
				break;
			j++;
		}
		gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);
	}

	i=0;
	tmp_strsize=(u32)ptr->size-8;
	while (tmp_strsize) {
		tmp_str[i] = gf_bs_read_u8(bs);
		tmp_strsize--;
		if (!tmp_str[i])
			break;
		i++;
	}
	if (i)
		ptr->drm_data = gf_strdup(tmp_str);

	i=0;
	tmp_strsize=(u32)ptr->size-8;
	while (tmp_strsize) {
		tmp_str[i] = gf_bs_read_u8(bs);
		tmp_strsize--;
		if (!tmp_str[i])
			break;
		i++;
	}
	if (i)
		ptr->meta_data = gf_strdup(tmp_str);

	ptr->segment_run_table_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->segment_run_table_count; i++) {
		GF_AdobeSegmentRunTableBox *asrt = NULL;
		e = gf_isom_box_parse((GF_Box **)&asrt, bs);
		if (e) {
			if (asrt) gf_isom_box_del((GF_Box*)asrt);
			gf_free(tmp_str);
			return e;
		}
		gf_list_insert(ptr->segment_run_table_entries, asrt, i);
	}

	ptr->fragment_run_table_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->fragment_run_table_count; i++) {
		GF_AdobeFragmentRunTableBox *afrt = NULL;
		e = gf_isom_box_parse((GF_Box **)&afrt, bs);
		if (e) {
			if (afrt) gf_isom_box_del((GF_Box*)afrt);
			gf_free(tmp_str);
			return e;
		}
		gf_list_insert(ptr->fragment_run_table_entries, afrt, i);
	}

	gf_free(tmp_str);

	return GF_OK;
}","GF_Err abst_Read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
	GF_AdobeBootstrapInfoBox *VAR_2 = (GF_AdobeBootstrapInfoBox *)VAR_0;
	int VAR_3;
	u32 VAR_4;
	char *VAR_5;
	GF_Err VAR_6;

	VAR_2->bootstrapinfo_version = gf_bs_read_u32(VAR_1);
	VAR_2->profile = gf_bs_read_int(VAR_1, 2);
	VAR_2->live = gf_bs_read_int(VAR_1, 1);
	VAR_2->update = gf_bs_read_int(VAR_1, 1);
	VAR_2->reserved = gf_bs_read_int(VAR_1, 4);
	VAR_2->time_scale = gf_bs_read_u32(VAR_1);
	VAR_2->current_media_time = gf_bs_read_u64(VAR_1);
	VAR_2->smpte_time_code_offset = gf_bs_read_u64(VAR_1);

	VAR_3=0;
	if (VAR_2->size<8) return VAR_7;
	VAR_4=(u32)VAR_2->size-8;
	VAR_5 = gf_malloc(sizeof(char)*VAR_4);

	while (VAR_4) {
		VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
		VAR_4--;
		if (!VAR_5[VAR_3])
			break;
		VAR_3++;
	}
	if (VAR_3)
		VAR_2->movie_identifier = gf_strdup(VAR_5);

	VAR_2->server_entry_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->server_entry_count; VAR_3++) {
		int VAR_8=0;
		VAR_4=(u32)VAR_2->size-8;
		while (VAR_4) {
			VAR_5[VAR_8] = gf_bs_read_u8(VAR_1);
			VAR_4--;
			if (!VAR_5[VAR_8])
				break;
			VAR_8++;
		}
		gf_list_insert(VAR_2->server_entry_table, gf_strdup(VAR_5), VAR_3);
	}

	VAR_2->quality_entry_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->quality_entry_count; VAR_3++) {
		int VAR_8=0;
		VAR_4=(u32)VAR_2->size-8;
		while (VAR_4) {
			VAR_5[VAR_8] = gf_bs_read_u8(VAR_1);
			VAR_4--;
			if (!VAR_5[VAR_8])
				break;
			VAR_8++;
		}
		gf_list_insert(VAR_2->quality_entry_table, gf_strdup(VAR_5), VAR_3);
	}

	VAR_3=0;
	VAR_4=(u32)VAR_2->size-8;
	while (VAR_4) {
		VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
		VAR_4--;
		if (!VAR_5[VAR_3])
			break;
		VAR_3++;
	}
	if (VAR_3)
		VAR_2->drm_data = gf_strdup(VAR_5);

	VAR_3=0;
	VAR_4=(u32)VAR_2->size-8;
	while (VAR_4) {
		VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
		VAR_4--;
		if (!VAR_5[VAR_3])
			break;
		VAR_3++;
	}
	if (VAR_3)
		VAR_2->meta_data = gf_strdup(VAR_5);

	VAR_2->segment_run_table_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->segment_run_table_count; VAR_3++) {
		GF_AdobeSegmentRunTableBox *VAR_9 = NULL;
		VAR_6 = gf_isom_box_parse((GF_Box **)&VAR_9, VAR_1);
		if (VAR_6) {
			if (VAR_9) gf_isom_box_del((GF_Box*)VAR_9);
			gf_free(VAR_5);
			return VAR_6;
		}
		gf_list_insert(VAR_2->segment_run_table_entries, VAR_9, VAR_3);
	}

	VAR_2->fragment_run_table_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->fragment_run_table_count; VAR_3++) {
		GF_AdobeFragmentRunTableBox *VAR_10 = NULL;
		VAR_6 = gf_isom_box_parse((GF_Box **)&VAR_10, VAR_1);
		if (VAR_6) {
			if (VAR_10) gf_isom_box_del((GF_Box*)VAR_10);
			gf_free(VAR_5);
			return VAR_6;
		}
		gf_list_insert(VAR_2->fragment_run_table_entries, VAR_10, VAR_3);
	}

	gf_free(VAR_5);

	return VAR_11;
}",gpac/72cdc5048dead86bb1df7d21e0b9975e49cf2d97/box_code_adobe.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -84,17 +84,25 @@
 
 	ptr->segment_run_table_count = gf_bs_read_u8(bs);
 	for (i=0; i<ptr->segment_run_table_count; i++) {
-		GF_AdobeSegmentRunTableBox *asrt;
+		GF_AdobeSegmentRunTableBox *asrt = NULL;
 		e = gf_isom_box_parse((GF_Box **)&asrt, bs);
-		if (e) return e;
+		if (e) {
+			if (asrt) gf_isom_box_del((GF_Box*)asrt);
+			gf_free(tmp_str);
+			return e;
+		}
 		gf_list_insert(ptr->segment_run_table_entries, asrt, i);
 	}
 
 	ptr->fragment_run_table_count = gf_bs_read_u8(bs);
 	for (i=0; i<ptr->fragment_run_table_count; i++) {
-		GF_AdobeFragmentRunTableBox *afrt;
+		GF_AdobeFragmentRunTableBox *afrt = NULL;
 		e = gf_isom_box_parse((GF_Box **)&afrt, bs);
-		if (e) return e;
+		if (e) {
+			if (afrt) gf_isom_box_del((GF_Box*)afrt);
+			gf_free(tmp_str);
+			return e;
+		}
 		gf_list_insert(ptr->fragment_run_table_entries, afrt, i);
 	}
 ","{'deleted_lines': ['\t\tGF_AdobeSegmentRunTableBox *asrt;', '\t\tif (e) return e;', '\t\tGF_AdobeFragmentRunTableBox *afrt;', '\t\tif (e) return e;'], 'added_lines': ['\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;', '\t\tif (e) {', '\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);', '\t\t\tgf_free(tmp_str);', '\t\t\treturn e;', '\t\t}', '\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;', '\t\tif (e) {', '\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);', '\t\t\tgf_free(tmp_str);', '\t\t\treturn e;', '\t\t}']}",True,An issue was discovered in GPAC version 0.8.0 and 0.9.0-development-20191109. There are memory leaks in metx_New in isomedia/box_code_base.c and abst_Read in isomedia/box_code_adobe.c.,5.5,MEDIUM,1,test,2020-01-08T12:08:21Z,3
CVE-2019-20171,['CWE-401'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,abst_Read: force last char of string to 0 for strdup (#1337),2bcca3f1d4605100bb27d3ed7be25b53cddbc75c,https://github.com/gpac/gpac/commit/2bcca3f1d4605100bb27d3ed7be25b53cddbc75c,src/isomedia/box_code_adobe.c,abst_Read,"GF_Err abst_Read(GF_Box *s, GF_BitStream *bs)
{
GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;
int i;
u32 tmp_strsize;
char *tmp_str;
GF_Err e;
ptr->bootstrapinfo_version = gf_bs_read_u32(bs);
ptr->profile = gf_bs_read_int(bs, 2);
ptr->live = gf_bs_read_int(bs, 1);
ptr->update = gf_bs_read_int(bs, 1);
ptr->reserved = gf_bs_read_int(bs, 4);
ptr->time_scale = gf_bs_read_u32(bs);
ptr->current_media_time = gf_bs_read_u64(bs);
ptr->smpte_time_code_offset = gf_bs_read_u64(bs);
i=0;
if (ptr->size<8) return GF_ISOM_INVALID_FILE;
tmp_strsize=(u32)ptr->size-8;
tmp_str = gf_malloc(sizeof(char)*tmp_strsize);
while (tmp_strsize) {
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i)
ptr->movie_identifier = gf_strdup(tmp_str);
ptr->server_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->server_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size-8;
while (tmp_strsize) {
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}
gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);
}
ptr->quality_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->quality_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size-8;
while (tmp_strsize) {
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}
gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);
}
i=0;
tmp_strsize=(u32)ptr->size-8;
while (tmp_strsize) {
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i)
ptr->drm_data = gf_strdup(tmp_str);
i=0;
tmp_strsize=(u32)ptr->size-8;
while (tmp_strsize) {
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i)
ptr->meta_data = gf_strdup(tmp_str);
ptr->segment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->segment_run_table_count; i++) {
GF_AdobeSegmentRunTableBox *asrt = NULL;
e = gf_isom_box_parse((GF_Box **)&asrt, bs);
if (e) {
if (asrt) gf_isom_box_del((GF_Box*)asrt);
gf_free(tmp_str);
return e;
}
gf_list_insert(ptr->segment_run_table_entries, asrt, i);
}
ptr->fragment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->fragment_run_table_count; i++) {
GF_AdobeFragmentRunTableBox *afrt = NULL;
e = gf_isom_box_parse((GF_Box **)&afrt, bs);
if (e) {
if (afrt) gf_isom_box_del((GF_Box*)afrt);
gf_free(tmp_str);
return e;
}
gf_list_insert(ptr->fragment_run_table_entries, afrt, i);
}
gf_free(tmp_str);
return GF_OK;
}","GF_Err abst_Read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
GF_AdobeBootstrapInfoBox *VAR_2 = (GF_AdobeBootstrapInfoBox *)VAR_0;
int VAR_3;
u32 VAR_4;
char *VAR_5;
GF_Err VAR_6;
VAR_2->bootstrapinfo_version = gf_bs_read_u32(VAR_1);
VAR_2->profile = gf_bs_read_int(VAR_1, 2);
VAR_2->live = gf_bs_read_int(VAR_1, 1);
VAR_2->update = gf_bs_read_int(VAR_1, 1);
VAR_2->reserved = gf_bs_read_int(VAR_1, 4);
VAR_2->time_scale = gf_bs_read_u32(VAR_1);
VAR_2->current_media_time = gf_bs_read_u64(VAR_1);
VAR_2->smpte_time_code_offset = gf_bs_read_u64(VAR_1);
VAR_3=0;
if (VAR_2->size<8) return VAR_7;
VAR_4=(u32)VAR_2->size-8;
VAR_5 = gf_malloc(sizeof(char)*VAR_4);
while (VAR_4) {
VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_3])
break;
VAR_3++;
}
if (VAR_3)
VAR_2->movie_identifier = gf_strdup(VAR_5);
VAR_2->server_entry_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->server_entry_count; VAR_3++) {
int VAR_8=0;
VAR_4=(u32)VAR_2->size-8;
while (VAR_4) {
VAR_5[VAR_8] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_8])
break;
VAR_8++;
}
gf_list_insert(VAR_2->server_entry_table, gf_strdup(VAR_5), VAR_3);
}
VAR_2->quality_entry_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->quality_entry_count; VAR_3++) {
int VAR_8=0;
VAR_4=(u32)VAR_2->size-8;
while (VAR_4) {
VAR_5[VAR_8] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_8])
break;
VAR_8++;
}
gf_list_insert(VAR_2->quality_entry_table, gf_strdup(VAR_5), VAR_3);
}
VAR_3=0;
VAR_4=(u32)VAR_2->size-8;
while (VAR_4) {
VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_3])
break;
VAR_3++;
}
if (VAR_3)
VAR_2->drm_data = gf_strdup(VAR_5);
VAR_3=0;
VAR_4=(u32)VAR_2->size-8;
while (VAR_4) {
VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_3])
break;
VAR_3++;
}
if (VAR_3)
VAR_2->meta_data = gf_strdup(VAR_5);
VAR_2->segment_run_table_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->segment_run_table_count; VAR_3++) {
GF_AdobeSegmentRunTableBox *VAR_9 = NULL;
VAR_6 = gf_isom_box_parse((GF_Box **)&VAR_9, VAR_1);
if (VAR_6) {
if (VAR_9) gf_isom_box_del((GF_Box*)VAR_9);
gf_free(VAR_5);
return VAR_6;
}
gf_list_insert(VAR_2->segment_run_table_entries, VAR_9, VAR_3);
}
VAR_2->fragment_run_table_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->fragment_run_table_count; VAR_3++) {
GF_AdobeFragmentRunTableBox *VAR_10 = NULL;
VAR_6 = gf_isom_box_parse((GF_Box **)&VAR_10, VAR_1);
if (VAR_6) {
if (VAR_10) gf_isom_box_del((GF_Box*)VAR_10);
gf_free(VAR_5);
return VAR_6;
}
gf_list_insert(VAR_2->fragment_run_table_entries, VAR_10, VAR_3);
}
gf_free(VAR_5);
return VAR_11;
}",gpac/2bcca3f1d4605100bb27d3ed7be25b53cddbc75c/box_code_adobe.c/vul/before/0.json,"GF_Err abst_Read(GF_Box *s, GF_BitStream *bs)
{
	GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;
	int i;
	u32 tmp_strsize, strsize;
	char *tmp_str;
	GF_Err e;

	ptr->bootstrapinfo_version = gf_bs_read_u32(bs);
	ptr->profile = gf_bs_read_int(bs, 2);
	ptr->live = gf_bs_read_int(bs, 1);
	ptr->update = gf_bs_read_int(bs, 1);
	ptr->reserved = gf_bs_read_int(bs, 4);
	ptr->time_scale = gf_bs_read_u32(bs);
	ptr->current_media_time = gf_bs_read_u64(bs);
	ptr->smpte_time_code_offset = gf_bs_read_u64(bs);

	i=0;
	if (ptr->size<8) return GF_ISOM_INVALID_FILE;
	strsize = tmp_strsize=(u32)ptr->size-8;
	tmp_str = gf_malloc(sizeof(char)*tmp_strsize);

	while (tmp_strsize) {
		tmp_str[i] = gf_bs_read_u8(bs);
		tmp_strsize--;
		if (!tmp_str[i])
			break;
		i++;
	}
	if (i) {
		tmp_str[strsize-1] = 0;
		ptr->movie_identifier = gf_strdup(tmp_str);
	}

	ptr->server_entry_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->server_entry_count; i++) {
		int j=0;
		tmp_strsize=(u32)ptr->size-8;
		while (tmp_strsize) {
			tmp_str[j] = gf_bs_read_u8(bs);
			tmp_strsize--;
			if (!tmp_str[j])
				break;
			j++;
		}
		tmp_str[strsize-1] = 0;
		gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);
	}

	ptr->quality_entry_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->quality_entry_count; i++) {
		int j=0;
		tmp_strsize=(u32)ptr->size-8;
		while (tmp_strsize) {
			tmp_str[j] = gf_bs_read_u8(bs);
			tmp_strsize--;
			if (!tmp_str[j])
				break;
			j++;
		}
		tmp_str[strsize-1] = 0;
		gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);
	}

	i=0;
	tmp_strsize=(u32)ptr->size-8;
	while (tmp_strsize) {
		tmp_str[i] = gf_bs_read_u8(bs);
		tmp_strsize--;
		if (!tmp_str[i])
			break;
		i++;
	}
	if (i) {
		tmp_str[strsize-1] = 0;
		ptr->drm_data = gf_strdup(tmp_str);
	}

	i=0;
	tmp_strsize=(u32)ptr->size-8;
	while (tmp_strsize) {
		tmp_str[i] = gf_bs_read_u8(bs);
		tmp_strsize--;
		if (!tmp_str[i])
			break;
		i++;
	}
	if (i) {
		tmp_str[strsize-1] = 0;
		ptr->meta_data = gf_strdup(tmp_str);
	}

	ptr->segment_run_table_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->segment_run_table_count; i++) {
		GF_AdobeSegmentRunTableBox *asrt = NULL;
		e = gf_isom_box_parse((GF_Box **)&asrt, bs);
		if (e) {
			if (asrt) gf_isom_box_del((GF_Box*)asrt);
			gf_free(tmp_str);
			return e;
		}
		gf_list_insert(ptr->segment_run_table_entries, asrt, i);
	}

	ptr->fragment_run_table_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->fragment_run_table_count; i++) {
		GF_AdobeFragmentRunTableBox *afrt = NULL;
		e = gf_isom_box_parse((GF_Box **)&afrt, bs);
		if (e) {
			if (afrt) gf_isom_box_del((GF_Box*)afrt);
			gf_free(tmp_str);
			return e;
		}
		gf_list_insert(ptr->fragment_run_table_entries, afrt, i);
	}

	gf_free(tmp_str);

	return GF_OK;
}","GF_Err abst_Read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
	GF_AdobeBootstrapInfoBox *VAR_2 = (GF_AdobeBootstrapInfoBox *)VAR_0;
	int VAR_3;
	u32 VAR_4, VAR_5;
	char *VAR_6;
	GF_Err VAR_7;

	VAR_2->bootstrapinfo_version = gf_bs_read_u32(VAR_1);
	VAR_2->profile = gf_bs_read_int(VAR_1, 2);
	VAR_2->live = gf_bs_read_int(VAR_1, 1);
	VAR_2->update = gf_bs_read_int(VAR_1, 1);
	VAR_2->reserved = gf_bs_read_int(VAR_1, 4);
	VAR_2->time_scale = gf_bs_read_u32(VAR_1);
	VAR_2->current_media_time = gf_bs_read_u64(VAR_1);
	VAR_2->smpte_time_code_offset = gf_bs_read_u64(VAR_1);

	VAR_3=0;
	if (VAR_2->size<8) return VAR_8;
	VAR_5 = VAR_4=(u32)VAR_2->size-8;
	VAR_6 = gf_malloc(sizeof(char)*VAR_4);

	while (VAR_4) {
		VAR_6[VAR_3] = gf_bs_read_u8(VAR_1);
		VAR_4--;
		if (!VAR_6[VAR_3])
			break;
		VAR_3++;
	}
	if (VAR_3) {
		VAR_6[VAR_5-1] = 0;
		VAR_2->movie_identifier = gf_strdup(VAR_6);
	}

	VAR_2->server_entry_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->server_entry_count; VAR_3++) {
		int VAR_9=0;
		VAR_4=(u32)VAR_2->size-8;
		while (VAR_4) {
			VAR_6[VAR_9] = gf_bs_read_u8(VAR_1);
			VAR_4--;
			if (!VAR_6[VAR_9])
				break;
			VAR_9++;
		}
		VAR_6[VAR_5-1] = 0;
		gf_list_insert(VAR_2->server_entry_table, gf_strdup(VAR_6), VAR_3);
	}

	VAR_2->quality_entry_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->quality_entry_count; VAR_3++) {
		int VAR_9=0;
		VAR_4=(u32)VAR_2->size-8;
		while (VAR_4) {
			VAR_6[VAR_9] = gf_bs_read_u8(VAR_1);
			VAR_4--;
			if (!VAR_6[VAR_9])
				break;
			VAR_9++;
		}
		VAR_6[VAR_5-1] = 0;
		gf_list_insert(VAR_2->quality_entry_table, gf_strdup(VAR_6), VAR_3);
	}

	VAR_3=0;
	VAR_4=(u32)VAR_2->size-8;
	while (VAR_4) {
		VAR_6[VAR_3] = gf_bs_read_u8(VAR_1);
		VAR_4--;
		if (!VAR_6[VAR_3])
			break;
		VAR_3++;
	}
	if (VAR_3) {
		VAR_6[VAR_5-1] = 0;
		VAR_2->drm_data = gf_strdup(VAR_6);
	}

	VAR_3=0;
	VAR_4=(u32)VAR_2->size-8;
	while (VAR_4) {
		VAR_6[VAR_3] = gf_bs_read_u8(VAR_1);
		VAR_4--;
		if (!VAR_6[VAR_3])
			break;
		VAR_3++;
	}
	if (VAR_3) {
		VAR_6[VAR_5-1] = 0;
		VAR_2->meta_data = gf_strdup(VAR_6);
	}

	VAR_2->segment_run_table_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->segment_run_table_count; VAR_3++) {
		GF_AdobeSegmentRunTableBox *VAR_10 = NULL;
		VAR_7 = gf_isom_box_parse((GF_Box **)&VAR_10, VAR_1);
		if (VAR_7) {
			if (VAR_10) gf_isom_box_del((GF_Box*)VAR_10);
			gf_free(VAR_6);
			return VAR_7;
		}
		gf_list_insert(VAR_2->segment_run_table_entries, VAR_10, VAR_3);
	}

	VAR_2->fragment_run_table_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->fragment_run_table_count; VAR_3++) {
		GF_AdobeFragmentRunTableBox *VAR_11 = NULL;
		VAR_7 = gf_isom_box_parse((GF_Box **)&VAR_11, VAR_1);
		if (VAR_7) {
			if (VAR_11) gf_isom_box_del((GF_Box*)VAR_11);
			gf_free(VAR_6);
			return VAR_7;
		}
		gf_list_insert(VAR_2->fragment_run_table_entries, VAR_11, VAR_3);
	}

	gf_free(VAR_6);

	return VAR_12;
}",gpac/2bcca3f1d4605100bb27d3ed7be25b53cddbc75c/box_code_adobe.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 {
 	GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;
 	int i;
-	u32 tmp_strsize;
+	u32 tmp_strsize, strsize;
 	char *tmp_str;
 	GF_Err e;
 
@@ -17,7 +17,7 @@
 
 	i=0;
 	if (ptr->size<8) return GF_ISOM_INVALID_FILE;
-	tmp_strsize=(u32)ptr->size-8;
+	strsize = tmp_strsize=(u32)ptr->size-8;
 	tmp_str = gf_malloc(sizeof(char)*tmp_strsize);
 
 	while (tmp_strsize) {
@@ -27,8 +27,10 @@
 			break;
 		i++;
 	}
-	if (i)
+	if (i) {
+		tmp_str[strsize-1] = 0;
 		ptr->movie_identifier = gf_strdup(tmp_str);
+	}
 
 	ptr->server_entry_count = gf_bs_read_u8(bs);
 	for (i=0; i<ptr->server_entry_count; i++) {
@@ -41,6 +43,7 @@
 				break;
 			j++;
 		}
+		tmp_str[strsize-1] = 0;
 		gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);
 	}
 
@@ -55,6 +58,7 @@
 				break;
 			j++;
 		}
+		tmp_str[strsize-1] = 0;
 		gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);
 	}
 
@@ -67,8 +71,10 @@
 			break;
 		i++;
 	}
-	if (i)
+	if (i) {
+		tmp_str[strsize-1] = 0;
 		ptr->drm_data = gf_strdup(tmp_str);
+	}
 
 	i=0;
 	tmp_strsize=(u32)ptr->size-8;
@@ -79,8 +85,10 @@
 			break;
 		i++;
 	}
-	if (i)
+	if (i) {
+		tmp_str[strsize-1] = 0;
 		ptr->meta_data = gf_strdup(tmp_str);
+	}
 
 	ptr->segment_run_table_count = gf_bs_read_u8(bs);
 	for (i=0; i<ptr->segment_run_table_count; i++) {","{'deleted_lines': ['\tu32 tmp_strsize;', '\ttmp_strsize=(u32)ptr->size-8;', '\tif (i)', '\tif (i)', '\tif (i)'], 'added_lines': ['\tu32 tmp_strsize, strsize;', '\tstrsize = tmp_strsize=(u32)ptr->size-8;', '\tif (i) {', '\t\ttmp_str[strsize-1] = 0;', '\t}', '\t\ttmp_str[strsize-1] = 0;', '\t\ttmp_str[strsize-1] = 0;', '\tif (i) {', '\t\ttmp_str[strsize-1] = 0;', '\t}', '\tif (i) {', '\t\ttmp_str[strsize-1] = 0;', '\t}']}",True,An issue was discovered in GPAC version 0.8.0 and 0.9.0-development-20191109. There are memory leaks in metx_New in isomedia/box_code_base.c and abst_Read in isomedia/box_code_adobe.c.,5.5,MEDIUM,1,test,2020-01-08T13:24:18Z,3
CVE-2020-22679,['CWE-401'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,add sgpd constant_iv_size check (#1345),6c1e7ddfae2ad4daeda7f7e544da34cb765d36c9,https://github.com/gpac/gpac/commit/6c1e7ddfae2ad4daeda7f7e544da34cb765d36c9,src/isomedia/box_code_base.c,sgpd_parse_entry,"static void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, u32 entry_size, u32 *total_bytes)
{
Bool null_size_ok = GF_FALSE;
GF_DefaultSampleGroupDescriptionEntry *ptr;
switch (grouping_type) {
case GF_ISOM_SAMPLE_GROUP_ROLL:
case GF_ISOM_SAMPLE_GROUP_PROL:
{
GF_RollRecoveryEntry *ptr;
GF_SAFEALLOC(ptr, GF_RollRecoveryEntry);
if (!ptr) return NULL;
ptr->roll_distance = gf_bs_read_int(bs, 16);
*total_bytes = 2;
return ptr;
}
case GF_ISOM_SAMPLE_GROUP_RAP:
{
GF_VisualRandomAccessEntry *ptr;
GF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry);
if (!ptr) return NULL;
ptr->num_leading_samples_known = gf_bs_read_int(bs, 1);
ptr->num_leading_samples = gf_bs_read_int(bs, 7);
*total_bytes = 1;
return ptr;
}
case GF_ISOM_SAMPLE_GROUP_SAP:
{
GF_SAPEntry *ptr;
GF_SAFEALLOC(ptr, GF_SAPEntry);
if (!ptr) return NULL;
ptr->dependent_flag = gf_bs_read_int(bs, 1);
gf_bs_read_int(bs, 3);
ptr->SAP_type = gf_bs_read_int(bs, 4);
*total_bytes = 1;
return ptr;
}
case GF_ISOM_SAMPLE_GROUP_SYNC:
{
GF_SYNCEntry *ptr;
GF_SAFEALLOC(ptr, GF_SYNCEntry);
if (!ptr) return NULL;
gf_bs_read_int(bs, 2);
ptr->NALU_type = gf_bs_read_int(bs, 6);
*total_bytes = 1;
return ptr;
}
case GF_ISOM_SAMPLE_GROUP_TELE:
{
GF_TemporalLevelEntry *ptr;
GF_SAFEALLOC(ptr, GF_TemporalLevelEntry);
if (!ptr) return NULL;
ptr->level_independently_decodable = gf_bs_read_int(bs, 1);
gf_bs_read_int(bs, 7);
*total_bytes = 1;
return ptr;
}
case GF_ISOM_SAMPLE_GROUP_SEIG:
{
GF_CENCSampleEncryptionGroupEntry *ptr;
GF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);
if (!ptr) return NULL;
gf_bs_read_u8(bs); ptr->crypt_byte_block = gf_bs_read_int(bs, 4);
ptr->skip_byte_block = gf_bs_read_int(bs, 4);
ptr->IsProtected = gf_bs_read_u8(bs);
ptr->Per_Sample_IV_size = gf_bs_read_u8(bs);
gf_bs_read_data(bs, (char *)ptr->KID, 16);
*total_bytes = 20;
if ((ptr->IsProtected == 1) && !ptr->Per_Sample_IV_size) {
ptr->constant_IV_size = gf_bs_read_u8(bs);
assert((ptr->constant_IV_size == 8) || (ptr->constant_IV_size == 16));
gf_bs_read_data(bs, (char *)ptr->constant_IV, ptr->constant_IV_size);
*total_bytes += 1 + ptr->constant_IV_size;
}
if (!entry_size) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] seig sample group does not indicate entry size, deprecated in spec\n""));
}
return ptr;
}
case GF_ISOM_SAMPLE_GROUP_OINF:
{
GF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();
u32 s = (u32) gf_bs_get_position(bs);
gf_isom_oinf_read_entry(ptr, bs);
*total_bytes = (u32) gf_bs_get_position(bs) - s;
if (!entry_size) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] oinf sample group does not indicate entry size, deprecated in spec\n""));
}
return ptr;
}
case GF_ISOM_SAMPLE_GROUP_LINF:
{
GF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();
u32 s = (u32) gf_bs_get_position(bs);
gf_isom_linf_read_entry(ptr, bs);
*total_bytes = (u32) gf_bs_get_position(bs) - s;
if (!entry_size) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] linf sample group does not indicate entry size, deprecated in spec\n""));
}
return ptr;
}
case GF_ISOM_SAMPLE_GROUP_TRIF:
if (! entry_size) {
u32 flags = gf_bs_peek_bits(bs, 24, 0);
if (flags & 0x10000) entry_size=3;
else {
if (flags & 0x80000) entry_size=7;
else entry_size=11;
if (flags & 0x200000) {
u32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size);
entry_size += 2 + 2*nb_entries;
}
}
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] trif sample group does not indicate entry size, deprecated in spec\n""));
}
break;
case GF_ISOM_SAMPLE_GROUP_NALM:
if (! entry_size) {
u64 start = gf_bs_get_position(bs);
Bool rle, large_size;
u32 entry_count;
gf_bs_read_int(bs, 6);
large_size = gf_bs_read_int(bs, 1);
rle = gf_bs_read_int(bs, 1);
entry_count = gf_bs_read_int(bs, large_size ? 16 : 8);
gf_bs_seek(bs, start);
entry_size = 1 + large_size ? 2 : 1;
entry_size += entry_count * 2;
if (rle) entry_size += entry_count * (large_size ? 2 : 1);
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] nalm sample group does not indicate entry size, deprecated in spec\n""));
}
break;
case GF_ISOM_SAMPLE_GROUP_TSAS:
case GF_ISOM_SAMPLE_GROUP_STSA:
null_size_ok = GF_TRUE;
break;
case GF_ISOM_SAMPLE_GROUP_TSCL:
entry_size = 20;
break;
case GF_ISOM_SAMPLE_GROUP_LBLI:
entry_size = 2;
break;
default:
break;
}
if (!entry_size && !null_size_ok) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\n"", gf_4cc_to_str( grouping_type) ));
return NULL;
}
GF_SAFEALLOC(ptr, GF_DefaultSampleGroupDescriptionEntry);
if (!ptr) return NULL;
if (entry_size) {
ptr->length = entry_size;
ptr->data = (u8 *) gf_malloc(sizeof(u8)*ptr->length);
gf_bs_read_data(bs, (char *) ptr->data, ptr->length);
*total_bytes = entry_size;
}
return ptr;
}","static void *sgpd_parse_entry(u32 VAR_0, GF_BitStream *VAR_1, u32 VAR_2, u32 *VAR_3)
{
Bool VAR_4 = VAR_5;
GF_DefaultSampleGroupDescriptionEntry *VAR_6;
switch (VAR_0) {
case VAR_7:
case VAR_8:
{
GF_RollRecoveryEntry *VAR_6;
GF_SAFEALLOC(VAR_6, GF_RollRecoveryEntry);
if (!VAR_6) return NULL;
VAR_6->roll_distance = gf_bs_read_int(VAR_1, 16);
*VAR_3 = 2;
return VAR_6;
}
case VAR_9:
{
GF_VisualRandomAccessEntry *VAR_6;
GF_SAFEALLOC(VAR_6, GF_VisualRandomAccessEntry);
if (!VAR_6) return NULL;
VAR_6->num_leading_samples_known = gf_bs_read_int(VAR_1, 1);
VAR_6->num_leading_samples = gf_bs_read_int(VAR_1, 7);
*VAR_3 = 1;
return VAR_6;
}
case VAR_10:
{
GF_SAPEntry *VAR_6;
GF_SAFEALLOC(VAR_6, GF_SAPEntry);
if (!VAR_6) return NULL;
VAR_6->dependent_flag = gf_bs_read_int(VAR_1, 1);
gf_bs_read_int(VAR_1, 3);
VAR_6->SAP_type = gf_bs_read_int(VAR_1, 4);
*VAR_3 = 1;
return VAR_6;
}
case VAR_11:
{
GF_SYNCEntry *VAR_6;
GF_SAFEALLOC(VAR_6, GF_SYNCEntry);
if (!VAR_6) return NULL;
gf_bs_read_int(VAR_1, 2);
VAR_6->NALU_type = gf_bs_read_int(VAR_1, 6);
*VAR_3 = 1;
return VAR_6;
}
case VAR_12:
{
GF_TemporalLevelEntry *VAR_6;
GF_SAFEALLOC(VAR_6, GF_TemporalLevelEntry);
if (!VAR_6) return NULL;
VAR_6->level_independently_decodable = gf_bs_read_int(VAR_1, 1);
gf_bs_read_int(VAR_1, 7);
*VAR_3 = 1;
return VAR_6;
}
case VAR_13:
{
GF_CENCSampleEncryptionGroupEntry *VAR_6;
GF_SAFEALLOC(VAR_6, GF_CENCSampleEncryptionGroupEntry);
if (!VAR_6) return NULL;
gf_bs_read_u8(VAR_1); 
VAR_6->crypt_byte_block = gf_bs_read_int(VAR_1, 4);
VAR_6->skip_byte_block = gf_bs_read_int(VAR_1, 4);
VAR_6->IsProtected = gf_bs_read_u8(VAR_1);
VAR_6->Per_Sample_IV_size = gf_bs_read_u8(VAR_1);
gf_bs_read_data(VAR_1, (char *)VAR_6->KID, 16);
*VAR_3 = 20;
if ((VAR_6->IsProtected == 1) && !VAR_6->Per_Sample_IV_size) {
VAR_6->constant_IV_size = gf_bs_read_u8(VAR_1);
assert((VAR_6->constant_IV_size == 8) || (VAR_6->constant_IV_size == 16));
gf_bs_read_data(VAR_1, (char *)VAR_6->constant_IV, VAR_6->constant_IV_size);
*VAR_3 += 1 + VAR_6->constant_IV_size;
}
if (!VAR_2) {
GF_LOG(VAR_14, VAR_15, (""[iso file] seig sample group does not indicate entry size, deprecated in spec\n""));
}
return VAR_6;
}
case VAR_16:
{
GF_OperatingPointsInformation *VAR_6 = gf_isom_oinf_new_entry();
u32 VAR_17 = (u32) gf_bs_get_position(VAR_1);
gf_isom_oinf_read_entry(VAR_6, VAR_1);
*VAR_3 = (u32) gf_bs_get_position(VAR_1) - VAR_17;
if (!VAR_2) {
GF_LOG(VAR_14, VAR_15, (""[iso file] oinf sample group does not indicate entry size, deprecated in spec\n""));
}
return VAR_6;
}
case VAR_18:
{
GF_LHVCLayerInformation *VAR_6 = gf_isom_linf_new_entry();
u32 VAR_17 = (u32) gf_bs_get_position(VAR_1);
gf_isom_linf_read_entry(VAR_6, VAR_1);
*VAR_3 = (u32) gf_bs_get_position(VAR_1) - VAR_17;
if (!VAR_2) {
GF_LOG(VAR_14, VAR_15, (""[iso file] linf sample group does not indicate entry size, deprecated in spec\n""));
}
return VAR_6;
}
case VAR_19:
if (! VAR_2) {
u32 VAR_20 = gf_bs_peek_bits(VAR_1, 24, 0);
if (VAR_20 & 0x10000) VAR_2=3;
else {
if (VAR_20 & 0x80000) VAR_2=7;
else VAR_2=11;
if (VAR_20 & 0x200000) {
u32 VAR_21 = gf_bs_peek_bits(VAR_1, 16, VAR_2);
VAR_2 += 2 + 2*VAR_21;
}
}
GF_LOG(VAR_14, VAR_15, (""[iso file] trif sample group does not indicate entry size, deprecated in spec\n""));
}
break;
case VAR_22:
if (! VAR_2) {
u64 VAR_23 = gf_bs_get_position(VAR_1);
Bool VAR_24, VAR_25;
u32 VAR_26;
gf_bs_read_int(VAR_1, 6);
VAR_25 = gf_bs_read_int(VAR_1, 1);
VAR_24 = gf_bs_read_int(VAR_1, 1);
VAR_26 = gf_bs_read_int(VAR_1, VAR_25 ? 16 : 8);
gf_bs_seek(VAR_1, VAR_23);
VAR_2 = 1 + VAR_25 ? 2 : 1;
VAR_2 += VAR_26 * 2;
if (VAR_24) VAR_2 += VAR_26 * (VAR_25 ? 2 : 1);
GF_LOG(VAR_14, VAR_15, (""[iso file] nalm sample group does not indicate entry size, deprecated in spec\n""));
}
break;
case VAR_27:
case VAR_28:
VAR_4 = VAR_29;
break;
case VAR_30:
VAR_2 = 20;
break;
case VAR_31:
VAR_2 = 2;
break;
default:
break;
}
if (!VAR_2 && !VAR_4) {
GF_LOG(VAR_14, VAR_15, (""[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\n"", gf_4cc_to_str( VAR_0) ));
return NULL;
}
GF_SAFEALLOC(VAR_6, GF_DefaultSampleGroupDescriptionEntry);
if (!VAR_6) return NULL;
if (VAR_2) {
VAR_6->length = VAR_2;
VAR_6->data = (u8 *) gf_malloc(sizeof(u8)*VAR_6->length);
gf_bs_read_data(VAR_1, (char *) VAR_6->data, VAR_6->length);
*VAR_3 = VAR_2;
}
return VAR_6;
}",gpac/6c1e7ddfae2ad4daeda7f7e544da34cb765d36c9/box_code_base.c/vul/before/0.json,"static void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, u32 entry_size, u32 *total_bytes)
{
	Bool null_size_ok = GF_FALSE;

	GF_DefaultSampleGroupDescriptionEntry *ptr;
	switch (grouping_type) {
	case GF_ISOM_SAMPLE_GROUP_ROLL:
	case GF_ISOM_SAMPLE_GROUP_PROL:
	{
		GF_RollRecoveryEntry *ptr;
		GF_SAFEALLOC(ptr, GF_RollRecoveryEntry);
		if (!ptr) return NULL;
		ptr->roll_distance = gf_bs_read_int(bs, 16);
		*total_bytes = 2;
		return ptr;
	}
	case GF_ISOM_SAMPLE_GROUP_RAP:
	{
		GF_VisualRandomAccessEntry *ptr;
		GF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry);
		if (!ptr) return NULL;
		ptr->num_leading_samples_known = gf_bs_read_int(bs, 1);
		ptr->num_leading_samples = gf_bs_read_int(bs, 7);
		*total_bytes = 1;
		return ptr;
	}
	case GF_ISOM_SAMPLE_GROUP_SAP:
	{
		GF_SAPEntry *ptr;
		GF_SAFEALLOC(ptr, GF_SAPEntry);
		if (!ptr) return NULL;
		ptr->dependent_flag = gf_bs_read_int(bs, 1);
		gf_bs_read_int(bs, 3);
		ptr->SAP_type = gf_bs_read_int(bs, 4);
		*total_bytes = 1;
		return ptr;
	}
	case GF_ISOM_SAMPLE_GROUP_SYNC:
	{
		GF_SYNCEntry *ptr;
		GF_SAFEALLOC(ptr, GF_SYNCEntry);
		if (!ptr) return NULL;
		gf_bs_read_int(bs, 2);
		ptr->NALU_type = gf_bs_read_int(bs, 6);
		*total_bytes = 1;
		return ptr;
	}
	case GF_ISOM_SAMPLE_GROUP_TELE:
	{
		GF_TemporalLevelEntry *ptr;
		GF_SAFEALLOC(ptr, GF_TemporalLevelEntry);
		if (!ptr) return NULL;
		ptr->level_independently_decodable = gf_bs_read_int(bs, 1);
		gf_bs_read_int(bs, 7);
		*total_bytes = 1;
		return ptr;
	}
	case GF_ISOM_SAMPLE_GROUP_SEIG:
	{
		GF_CENCSampleEncryptionGroupEntry *ptr;
		GF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);
		if (!ptr) return NULL;
		gf_bs_read_u8(bs); //reserved
		ptr->crypt_byte_block = gf_bs_read_int(bs, 4);
		ptr->skip_byte_block = gf_bs_read_int(bs, 4);
		ptr->IsProtected = gf_bs_read_u8(bs);
		ptr->Per_Sample_IV_size = gf_bs_read_u8(bs);
		gf_bs_read_data(bs, (char *)ptr->KID, 16);
		*total_bytes = 20;
		if ((ptr->IsProtected == 1) && !ptr->Per_Sample_IV_size) {
			ptr->constant_IV_size = gf_bs_read_u8(bs);
			if ((ptr->constant_IV_size != 8) && (ptr->constant_IV_size != 16)) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] seig sample group have invalid constant_IV size\n""));
				gf_free(ptr);
				return NULL;
			}
			gf_bs_read_data(bs, (char *)ptr->constant_IV, ptr->constant_IV_size);
			*total_bytes += 1 + ptr->constant_IV_size;
		}
		if (!entry_size) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] seig sample group does not indicate entry size, deprecated in spec\n""));
		}
		return ptr;
	}
	case GF_ISOM_SAMPLE_GROUP_OINF:
	{
		GF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();
		u32 s = (u32) gf_bs_get_position(bs);
		gf_isom_oinf_read_entry(ptr, bs);
		*total_bytes = (u32) gf_bs_get_position(bs) - s;
		if (!entry_size) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] oinf sample group does not indicate entry size, deprecated in spec\n""));
		}
		return ptr;
	}
	case GF_ISOM_SAMPLE_GROUP_LINF:
	{
		GF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();
		u32 s = (u32) gf_bs_get_position(bs);
		gf_isom_linf_read_entry(ptr, bs);
		*total_bytes = (u32) gf_bs_get_position(bs) - s;
		if (!entry_size) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] linf sample group does not indicate entry size, deprecated in spec\n""));
		}
		return ptr;
	}

	case GF_ISOM_SAMPLE_GROUP_TRIF:
		if (! entry_size) {
			u32 flags = gf_bs_peek_bits(bs, 24, 0);
			if (flags & 0x10000) entry_size=3;
			else {
				if (flags & 0x80000) entry_size=7;
				else entry_size=11;
				//have dependency list
				if (flags & 0x200000) {
					u32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size);
					entry_size += 2 + 2*nb_entries;
				}
			}
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] trif sample group does not indicate entry size, deprecated in spec\n""));
		}
		break;
	case GF_ISOM_SAMPLE_GROUP_NALM:
		if (! entry_size) {
			u64 start = gf_bs_get_position(bs);
			Bool rle, large_size;
			u32 entry_count;
			gf_bs_read_int(bs, 6);
			large_size = gf_bs_read_int(bs, 1);
			rle = gf_bs_read_int(bs, 1);
			entry_count = gf_bs_read_int(bs, large_size ? 16 : 8);
			gf_bs_seek(bs, start);
			entry_size = 1 + large_size ? 2 : 1;
			entry_size += entry_count * 2;
			if (rle) entry_size += entry_count * (large_size ? 2 : 1);
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] nalm sample group does not indicate entry size, deprecated in spec\n""));
		}
		break;

	case GF_ISOM_SAMPLE_GROUP_TSAS:
	case GF_ISOM_SAMPLE_GROUP_STSA:
		null_size_ok = GF_TRUE;
		break;
	//TODO, add support for these ones ?
	case GF_ISOM_SAMPLE_GROUP_TSCL:
		entry_size = 20;
		break;
	case GF_ISOM_SAMPLE_GROUP_LBLI:
		entry_size = 2;
		break;
	default:
		break;
	}

	if (!entry_size && !null_size_ok) {
		GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\n"", gf_4cc_to_str( grouping_type) ));
		return NULL;
	}
	GF_SAFEALLOC(ptr, GF_DefaultSampleGroupDescriptionEntry);
	if (!ptr) return NULL;
	if (entry_size) {
		ptr->length = entry_size;
		ptr->data = (u8 *) gf_malloc(sizeof(u8)*ptr->length);
		gf_bs_read_data(bs, (char *) ptr->data, ptr->length);
		*total_bytes = entry_size;
	}
	return ptr;
}","static void *sgpd_parse_entry(u32 VAR_0, GF_BitStream *VAR_1, u32 VAR_2, u32 *VAR_3)
{
	Bool VAR_4 = VAR_5;

	GF_DefaultSampleGroupDescriptionEntry *VAR_6;
	switch (VAR_0) {
	case VAR_7:
	case VAR_8:
	{
		GF_RollRecoveryEntry *VAR_6;
		GF_SAFEALLOC(VAR_6, GF_RollRecoveryEntry);
		if (!VAR_6) return NULL;
		VAR_6->roll_distance = gf_bs_read_int(VAR_1, 16);
		*VAR_3 = 2;
		return VAR_6;
	}
	case VAR_9:
	{
		GF_VisualRandomAccessEntry *VAR_6;
		GF_SAFEALLOC(VAR_6, GF_VisualRandomAccessEntry);
		if (!VAR_6) return NULL;
		VAR_6->num_leading_samples_known = gf_bs_read_int(VAR_1, 1);
		VAR_6->num_leading_samples = gf_bs_read_int(VAR_1, 7);
		*VAR_3 = 1;
		return VAR_6;
	}
	case VAR_10:
	{
		GF_SAPEntry *VAR_6;
		GF_SAFEALLOC(VAR_6, GF_SAPEntry);
		if (!VAR_6) return NULL;
		VAR_6->dependent_flag = gf_bs_read_int(VAR_1, 1);
		gf_bs_read_int(VAR_1, 3);
		VAR_6->SAP_type = gf_bs_read_int(VAR_1, 4);
		*VAR_3 = 1;
		return VAR_6;
	}
	case VAR_11:
	{
		GF_SYNCEntry *VAR_6;
		GF_SAFEALLOC(VAR_6, GF_SYNCEntry);
		if (!VAR_6) return NULL;
		gf_bs_read_int(VAR_1, 2);
		VAR_6->NALU_type = gf_bs_read_int(VAR_1, 6);
		*VAR_3 = 1;
		return VAR_6;
	}
	case VAR_12:
	{
		GF_TemporalLevelEntry *VAR_6;
		GF_SAFEALLOC(VAR_6, GF_TemporalLevelEntry);
		if (!VAR_6) return NULL;
		VAR_6->level_independently_decodable = gf_bs_read_int(VAR_1, 1);
		gf_bs_read_int(VAR_1, 7);
		*VAR_3 = 1;
		return VAR_6;
	}
	case VAR_13:
	{
		GF_CENCSampleEncryptionGroupEntry *VAR_6;
		GF_SAFEALLOC(VAR_6, GF_CENCSampleEncryptionGroupEntry);
		if (!VAR_6) return NULL;
		gf_bs_read_u8(VAR_1); /* COMMENT_0 */
		VAR_6->crypt_byte_block = gf_bs_read_int(VAR_1, 4);
		VAR_6->skip_byte_block = gf_bs_read_int(VAR_1, 4);
		VAR_6->IsProtected = gf_bs_read_u8(VAR_1);
		VAR_6->Per_Sample_IV_size = gf_bs_read_u8(VAR_1);
		gf_bs_read_data(VAR_1, (char *)VAR_6->KID, 16);
		*VAR_3 = 20;
		if ((VAR_6->IsProtected == 1) && !VAR_6->Per_Sample_IV_size) {
			VAR_6->constant_IV_size = gf_bs_read_u8(VAR_1);
			if ((VAR_6->constant_IV_size != 8) && (VAR_6->constant_IV_size != 16)) {
				GF_LOG(VAR_14, VAR_15, (""[iso file] seig sample group have invalid constant_IV size\n""));
				gf_free(VAR_6);
				return NULL;
			}
			gf_bs_read_data(VAR_1, (char *)VAR_6->constant_IV, VAR_6->constant_IV_size);
			*VAR_3 += 1 + VAR_6->constant_IV_size;
		}
		if (!VAR_2) {
			GF_LOG(VAR_14, VAR_15, (""[iso file] seig sample group does not indicate entry size, deprecated in spec\n""));
		}
		return VAR_6;
	}
	case VAR_16:
	{
		GF_OperatingPointsInformation *VAR_6 = gf_isom_oinf_new_entry();
		u32 VAR_17 = (u32) gf_bs_get_position(VAR_1);
		gf_isom_oinf_read_entry(VAR_6, VAR_1);
		*VAR_3 = (u32) gf_bs_get_position(VAR_1) - VAR_17;
		if (!VAR_2) {
			GF_LOG(VAR_14, VAR_15, (""[iso file] oinf sample group does not indicate entry size, deprecated in spec\n""));
		}
		return VAR_6;
	}
	case VAR_18:
	{
		GF_LHVCLayerInformation *VAR_6 = gf_isom_linf_new_entry();
		u32 VAR_17 = (u32) gf_bs_get_position(VAR_1);
		gf_isom_linf_read_entry(VAR_6, VAR_1);
		*VAR_3 = (u32) gf_bs_get_position(VAR_1) - VAR_17;
		if (!VAR_2) {
			GF_LOG(VAR_14, VAR_15, (""[iso file] linf sample group does not indicate entry size, deprecated in spec\n""));
		}
		return VAR_6;
	}

	case VAR_19:
		if (! VAR_2) {
			u32 VAR_20 = gf_bs_peek_bits(VAR_1, 24, 0);
			if (VAR_20 & 0x10000) VAR_2=3;
			else {
				if (VAR_20 & 0x80000) VAR_2=7;
				else VAR_2=11;
				/* COMMENT_1 */
				if (VAR_20 & 0x200000) {
					u32 VAR_21 = gf_bs_peek_bits(VAR_1, 16, VAR_2);
					VAR_2 += 2 + 2*VAR_21;
				}
			}
			GF_LOG(VAR_14, VAR_15, (""[iso file] trif sample group does not indicate entry size, deprecated in spec\n""));
		}
		break;
	case VAR_22:
		if (! VAR_2) {
			u64 VAR_23 = gf_bs_get_position(VAR_1);
			Bool VAR_24, VAR_25;
			u32 VAR_26;
			gf_bs_read_int(VAR_1, 6);
			VAR_25 = gf_bs_read_int(VAR_1, 1);
			VAR_24 = gf_bs_read_int(VAR_1, 1);
			VAR_26 = gf_bs_read_int(VAR_1, VAR_25 ? 16 : 8);
			gf_bs_seek(VAR_1, VAR_23);
			VAR_2 = 1 + VAR_25 ? 2 : 1;
			VAR_2 += VAR_26 * 2;
			if (VAR_24) VAR_2 += VAR_26 * (VAR_25 ? 2 : 1);
			GF_LOG(VAR_14, VAR_15, (""[iso file] nalm sample group does not indicate entry size, deprecated in spec\n""));
		}
		break;

	case VAR_27:
	case VAR_28:
		VAR_4 = VAR_29;
		break;
	/* COMMENT_2 */
	case VAR_30:
		VAR_2 = 20;
		break;
	case VAR_31:
		VAR_2 = 2;
		break;
	default:
		break;
	}

	if (!VAR_2 && !VAR_4) {
		GF_LOG(VAR_14, VAR_15, (""[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\n"", gf_4cc_to_str( VAR_0) ));
		return NULL;
	}
	GF_SAFEALLOC(VAR_6, GF_DefaultSampleGroupDescriptionEntry);
	if (!VAR_6) return NULL;
	if (VAR_2) {
		VAR_6->length = VAR_2;
		VAR_6->data = (u8 *) gf_malloc(sizeof(u8)*VAR_6->length);
		gf_bs_read_data(VAR_1, (char *) VAR_6->data, VAR_6->length);
		*VAR_3 = VAR_2;
	}
	return VAR_6;
}",gpac/6c1e7ddfae2ad4daeda7f7e544da34cb765d36c9/box_code_base.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -69,7 +69,11 @@
 		*total_bytes = 20;
 		if ((ptr->IsProtected == 1) && !ptr->Per_Sample_IV_size) {
 			ptr->constant_IV_size = gf_bs_read_u8(bs);
-			assert((ptr->constant_IV_size == 8) || (ptr->constant_IV_size == 16));
+			if ((ptr->constant_IV_size != 8) && (ptr->constant_IV_size != 16)) {
+				GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] seig sample group have invalid constant_IV size\n""));
+				gf_free(ptr);
+				return NULL;
+			}
 			gf_bs_read_data(bs, (char *)ptr->constant_IV, ptr->constant_IV_size);
 			*total_bytes += 1 + ptr->constant_IV_size;
 		}","{'deleted_lines': ['\t\t\tassert((ptr->constant_IV_size == 8) || (ptr->constant_IV_size == 16));'], 'added_lines': ['\t\t\tif ((ptr->constant_IV_size != 8) && (ptr->constant_IV_size != 16)) {', '\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] seig sample group have invalid constant_IV size\\n""));', '\t\t\t\tgf_free(ptr);', '\t\t\t\treturn NULL;', '\t\t\t}']}",True,Memory leak in the sgpd_parse_entry function in MP4Box in gpac 0.8.0 allows attackers to cause a denial of service (DoS) via a crafted input.,5.5,MEDIUM,1,test,2020-01-09T15:48:45Z,3
CVE-2020-6851,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,uclouvain/openjpeg,opj_j2k_update_image_dimensions(): reject images whose coordinates are beyond INT_MAX (fixes #1228),024b8407392cb0b82b04b58ed256094ed5799e04,https://github.com/uclouvain/openjpeg/commit/024b8407392cb0b82b04b58ed256094ed5799e04,src/lib/openjp2/j2k.c,opj_j2k_update_image_dimensions,"static OPJ_BOOL opj_j2k_update_image_dimensions(opj_image_t* p_image,
opj_event_mgr_t * p_manager)
{
OPJ_UINT32 it_comp;
OPJ_INT32 l_comp_x1, l_comp_y1;
opj_image_comp_t* l_img_comp = NULL;
l_img_comp = p_image->comps;
for (it_comp = 0; it_comp < p_image->numcomps; ++it_comp) {
OPJ_INT32 l_h, l_w;
l_img_comp->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->x0,
(OPJ_INT32)l_img_comp->dx);
l_img_comp->y0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->y0,
(OPJ_INT32)l_img_comp->dy);
l_comp_x1 = opj_int_ceildiv((OPJ_INT32)p_image->x1, (OPJ_INT32)l_img_comp->dx);
l_comp_y1 = opj_int_ceildiv((OPJ_INT32)p_image->y1, (OPJ_INT32)l_img_comp->dy);
l_w = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32)l_img_comp->factor)
- opj_int_ceildivpow2((OPJ_INT32)l_img_comp->x0, (OPJ_INT32)l_img_comp->factor);
if (l_w < 0) {
opj_event_msg(p_manager, EVT_ERROR,
""Size x of the decoded component image is incorrect (comp[%d].w=%d).\n"",
it_comp, l_w);
return OPJ_FALSE;
}
l_img_comp->w = (OPJ_UINT32)l_w;
l_h = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32)l_img_comp->factor)
- opj_int_ceildivpow2((OPJ_INT32)l_img_comp->y0, (OPJ_INT32)l_img_comp->factor);
if (l_h < 0) {
opj_event_msg(p_manager, EVT_ERROR,
""Size y of the decoded component image is incorrect (comp[%d].h=%d).\n"",
it_comp, l_h);
return OPJ_FALSE;
}
l_img_comp->h = (OPJ_UINT32)l_h;
l_img_comp++;
}
return OPJ_TRUE;
}","static OPJ_BOOL opj_j2k_update_image_dimensions(opj_image_t* VAR_0,
opj_event_mgr_t * VAR_1)
{
OPJ_UINT32 VAR_2;
OPJ_INT32 VAR_3, VAR_4;
opj_image_comp_t* VAR_5 = NULL;
VAR_5 = VAR_0->comps;
for (VAR_2 = 0; VAR_2 < VAR_0->numcomps; ++VAR_2) {
OPJ_INT32 VAR_6, VAR_7;
VAR_5->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)VAR_0->x0,
(OPJ_INT32)VAR_5->dx);
VAR_5->y0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)VAR_0->y0,
(OPJ_INT32)VAR_5->dy);
VAR_3 = opj_int_ceildiv((OPJ_INT32)VAR_0->x1, (OPJ_INT32)VAR_5->dx);
VAR_4 = opj_int_ceildiv((OPJ_INT32)VAR_0->y1, (OPJ_INT32)VAR_5->dy);
VAR_7 = opj_int_ceildivpow2(VAR_3, (OPJ_INT32)VAR_5->factor)
- opj_int_ceildivpow2((OPJ_INT32)VAR_5->x0, (OPJ_INT32)VAR_5->factor);
if (VAR_7 < 0) {
opj_event_msg(VAR_1, VAR_8,
""Size x of the decoded component image is incorrect (comp[%d].w=%d).\n"",
VAR_2, VAR_7);
return VAR_9;
}
VAR_5->w = (OPJ_UINT32)VAR_7;
VAR_6 = opj_int_ceildivpow2(VAR_4, (OPJ_INT32)VAR_5->factor)
- opj_int_ceildivpow2((OPJ_INT32)VAR_5->y0, (OPJ_INT32)VAR_5->factor);
if (VAR_6 < 0) {
opj_event_msg(VAR_1, VAR_8,
""Size y of the decoded component image is incorrect (comp[%d].h=%d).\n"",
VAR_2, VAR_6);
return VAR_9;
}
VAR_5->h = (OPJ_UINT32)VAR_6;
VAR_5++;
}
return VAR_10;
}",uclouvain/openjpeg/024b8407392cb0b82b04b58ed256094ed5799e04/j2k.c/vul/before/0.json,"static OPJ_BOOL opj_j2k_update_image_dimensions(opj_image_t* p_image,
        opj_event_mgr_t * p_manager)
{
    OPJ_UINT32 it_comp;
    OPJ_INT32 l_comp_x1, l_comp_y1;
    opj_image_comp_t* l_img_comp = NULL;

    l_img_comp = p_image->comps;
    for (it_comp = 0; it_comp < p_image->numcomps; ++it_comp) {
        OPJ_INT32 l_h, l_w;
        if (p_image->x0 > (OPJ_UINT32)INT_MAX ||
                p_image->y0 > (OPJ_UINT32)INT_MAX ||
                p_image->x1 > (OPJ_UINT32)INT_MAX ||
                p_image->y1 > (OPJ_UINT32)INT_MAX) {
            opj_event_msg(p_manager, EVT_ERROR,
                          ""Image coordinates above INT_MAX are not supported\n"");
            return OPJ_FALSE;
        }

        l_img_comp->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->x0,
                         (OPJ_INT32)l_img_comp->dx);
        l_img_comp->y0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->y0,
                         (OPJ_INT32)l_img_comp->dy);
        l_comp_x1 = opj_int_ceildiv((OPJ_INT32)p_image->x1, (OPJ_INT32)l_img_comp->dx);
        l_comp_y1 = opj_int_ceildiv((OPJ_INT32)p_image->y1, (OPJ_INT32)l_img_comp->dy);

        l_w = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32)l_img_comp->factor)
              - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->x0, (OPJ_INT32)l_img_comp->factor);
        if (l_w < 0) {
            opj_event_msg(p_manager, EVT_ERROR,
                          ""Size x of the decoded component image is incorrect (comp[%d].w=%d).\n"",
                          it_comp, l_w);
            return OPJ_FALSE;
        }
        l_img_comp->w = (OPJ_UINT32)l_w;

        l_h = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32)l_img_comp->factor)
              - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->y0, (OPJ_INT32)l_img_comp->factor);
        if (l_h < 0) {
            opj_event_msg(p_manager, EVT_ERROR,
                          ""Size y of the decoded component image is incorrect (comp[%d].h=%d).\n"",
                          it_comp, l_h);
            return OPJ_FALSE;
        }
        l_img_comp->h = (OPJ_UINT32)l_h;

        l_img_comp++;
    }

    return OPJ_TRUE;
}","static OPJ_BOOL opj_j2k_update_image_dimensions(opj_image_t* VAR_0,
        opj_event_mgr_t * VAR_1)
{
    OPJ_UINT32 VAR_2;
    OPJ_INT32 VAR_3, VAR_4;
    opj_image_comp_t* VAR_5 = NULL;

    VAR_5 = VAR_0->comps;
    for (VAR_2 = 0; VAR_2 < VAR_0->numcomps; ++VAR_2) {
        OPJ_INT32 VAR_6, VAR_7;
        if (VAR_0->x0 > (OPJ_UINT32)VAR_8 ||
                VAR_0->y0 > (OPJ_UINT32)VAR_8 ||
                VAR_0->x1 > (OPJ_UINT32)VAR_8 ||
                VAR_0->y1 > (OPJ_UINT32)VAR_8) {
            opj_event_msg(VAR_1, VAR_9,
                          ""Image coordinates above INT_MAX are not supported\n"");
            return VAR_10;
        }

        VAR_5->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)VAR_0->x0,
                         (OPJ_INT32)VAR_5->dx);
        VAR_5->y0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)VAR_0->y0,
                         (OPJ_INT32)VAR_5->dy);
        VAR_3 = opj_int_ceildiv((OPJ_INT32)VAR_0->x1, (OPJ_INT32)VAR_5->dx);
        VAR_4 = opj_int_ceildiv((OPJ_INT32)VAR_0->y1, (OPJ_INT32)VAR_5->dy);

        VAR_7 = opj_int_ceildivpow2(VAR_3, (OPJ_INT32)VAR_5->factor)
              - opj_int_ceildivpow2((OPJ_INT32)VAR_5->x0, (OPJ_INT32)VAR_5->factor);
        if (VAR_7 < 0) {
            opj_event_msg(VAR_1, VAR_9,
                          ""Size x of the decoded component image is incorrect (comp[%d].w=%d).\n"",
                          VAR_2, VAR_7);
            return VAR_10;
        }
        VAR_5->w = (OPJ_UINT32)VAR_7;

        VAR_6 = opj_int_ceildivpow2(VAR_4, (OPJ_INT32)VAR_5->factor)
              - opj_int_ceildivpow2((OPJ_INT32)VAR_5->y0, (OPJ_INT32)VAR_5->factor);
        if (VAR_6 < 0) {
            opj_event_msg(VAR_1, VAR_9,
                          ""Size y of the decoded component image is incorrect (comp[%d].h=%d).\n"",
                          VAR_2, VAR_6);
            return VAR_10;
        }
        VAR_5->h = (OPJ_UINT32)VAR_6;

        VAR_5++;
    }

    return VAR_11;
}",uclouvain/openjpeg/024b8407392cb0b82b04b58ed256094ed5799e04/j2k.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,6 +8,14 @@
     l_img_comp = p_image->comps;
     for (it_comp = 0; it_comp < p_image->numcomps; ++it_comp) {
         OPJ_INT32 l_h, l_w;
+        if (p_image->x0 > (OPJ_UINT32)INT_MAX ||
+                p_image->y0 > (OPJ_UINT32)INT_MAX ||
+                p_image->x1 > (OPJ_UINT32)INT_MAX ||
+                p_image->y1 > (OPJ_UINT32)INT_MAX) {
+            opj_event_msg(p_manager, EVT_ERROR,
+                          ""Image coordinates above INT_MAX are not supported\n"");
+            return OPJ_FALSE;
+        }
 
         l_img_comp->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->x0,
                          (OPJ_INT32)l_img_comp->dx);","{'deleted_lines': [], 'added_lines': ['        if (p_image->x0 > (OPJ_UINT32)INT_MAX ||', '                p_image->y0 > (OPJ_UINT32)INT_MAX ||', '                p_image->x1 > (OPJ_UINT32)INT_MAX ||', '                p_image->y1 > (OPJ_UINT32)INT_MAX) {', '            opj_event_msg(p_manager, EVT_ERROR,', '                          ""Image coordinates above INT_MAX are not supported\\n"");', '            return OPJ_FALSE;', '        }']}",True,OpenJPEG through 2.3.1 has a heap-based buffer overflow in opj_t1_clbl_decode_processor in openjp2/t1.c because of lack of opj_j2k_update_image_dimensions validation.,7.5,HIGH,2,test,2020-01-11T00:51:19Z,3
CVE-2020-21827,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,LibreDWG/libredwg,"read_2004_compressed_section: adjust for empty sections

Add a seperate writer index j for the info->size chunks being written.
Fix the uncompressed write overflow check.
Fixes GH #183 (fuzzed)",bcec483e73819af29787d5ed87fc515e1dfd0411,https://github.com/LibreDWG/libredwg/commit/bcec483e73819af29787d5ed87fc515e1dfd0411,src/decode.c,read_2004_compressed_section,"static int
read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
Bit_Chain *sec_dat, Dwg_Section_Type type)
{
uint32_t address, sec_mask, initial_address;
uint32_t max_decomp_size;
long bytes_left;
Dwg_Section_Info *info = NULL;
encrypted_section_header es;
BITCODE_RC *decomp;
BITCODE_BL i, j;
int error = 0;
for (i = 0; i < dwg->header.section_infohdr.num_desc && !info; ++i)
{
if (dwg->header.section_info[i].fixedtype == type)
{
info = &dwg->header.section_info[i];
break;
}
}
sec_dat->chain = NULL;   if (!info)
{
if (type < SECTION_REVHISTORY
&& type != SECTION_TEMPLATE
&& type != SECTION_OBJFREESPACE)
{
LOG_WARN (""Failed to find section_info[%u] with type %d"", i, type)
}
else
{
LOG_TRACE (""Found no section_info[%u] with type %d\n"", i, type)
}
return DWG_ERR_SECTIONNOTFOUND;
}
else
{
LOG_TRACE (""\nFound section_info["" FORMAT_BL
""] %s type %d with %d sections (%scompressed):\n"",
i, info->name, type, info->num_sections,
info->compressed == 2 ? """" : ""un"");
}
max_decomp_size = info->num_sections * info->max_decomp_size;
if (info->num_sections == 0)
return 0;
if (max_decomp_size == 0 || max_decomp_size > 0x2f000000)     {
LOG_ERROR (""Invalid section %s count or max decompression size. ""
""Sections: %u, Max size: %u"",
info->name, info->num_sections, info->max_decomp_size);
return DWG_ERR_INVALIDDWG;
}
decomp = (BITCODE_RC *)calloc (max_decomp_size, sizeof (BITCODE_RC));
if (!decomp)
{
LOG_ERROR (""Out of memory with %u sections"", info->num_sections);
return DWG_ERR_OUTOFMEM;
}
bytes_left = max_decomp_size;
initial_address = info->sections[0] ? info->sections[0]->address : 0;
sec_dat->bit = 0;
sec_dat->byte = 0;
sec_dat->version = dat->version;
sec_dat->from_version = dat->from_version;
sec_dat->chain = decomp;
for (i = 0; i < info->num_sections; ++i)
{
if (!info->sections[i])
{
LOG_WARN (""Skip empty section %u %s"", i, info->name);
continue;
}
address = info->sections[i]->address;
dat->byte = address;
bit_read_fixed (dat, es.char_data, 32);
sec_mask = 0x4164536b ^ address;
for (j = 0; j < 8; ++j)
es.long_data[j] ^= sec_mask;
LOG_INFO (""=== Section %s (%u) @%u ===\n"", info->name, i, address)
if (es.fields.tag != 0x4163043b)
{
LOG_WARN (""Section Tag:      0x%x  (should be 0x4163043b)"",
(unsigned)es.fields.tag);
}
else
{
LOG_INFO (""Section Tag:      0x%x\n"", (unsigned)es.fields.tag);
}
LOG_INFO (""Section Type:     %u\n"", (unsigned)es.fields.section_type)
LOG_INFO (""Data size:        0x%x/%u\n"", (unsigned)es.fields.data_size,
(unsigned)es.fields.data_size)
LOG_INFO (""Comp data size:   0x%x\n"", (unsigned)es.fields.section_size)
LOG_TRACE (""StartOffset:      0x%x\n"", (unsigned)es.fields.address)
LOG_HANDLE (""Unknown:          0x%x\n"", (unsigned)es.fields.unknown)
LOG_HANDLE (""Checksum1:        0x%x\n"", (unsigned)es.fields.checksum_1)
LOG_HANDLE (""Checksum2:        0x%x\n"", (unsigned)es.fields.checksum_2)
LOG_TRACE (""Section start:    %lu\n\n"", dat->byte);
LOG_INSANE (""info[%d]->max_decomp_size: %lu (0x%lx)\n"", i,
(unsigned long)info->max_decomp_size,
(unsigned long)info->max_decomp_size)
LOG_INSANE (""max_decomp_size:          %lu (0x%lx)\n"",
(unsigned long)max_decomp_size,
(unsigned long)max_decomp_size)
LOG_INSANE (""bytes_left:               %ld\n"", bytes_left);
if (info->compressed == 2
&& bytes_left > 0
&& (i * info->max_decomp_size) <= max_decomp_size)
{
error = decompress_R2004_section (
dat, &decomp[i * info->max_decomp_size],               info->max_decomp_size, es.fields.data_size);
if (error > DWG_ERR_CRITICAL)
{
sec_dat->chain = NULL;               free (decomp);
return error;
}
bytes_left -= info->max_decomp_size;
sec_dat->size = max_decomp_size;
}
else
{
if (info->compressed == 2
|| info->size > max_decomp_size
|| bytes_left < 0
)
{
LOG_ERROR (""Some section size out of bounds"")
sec_dat->chain = NULL;
free (decomp);
return type < SECTION_REVHISTORY ? DWG_ERR_INVALIDDWG
: DWG_ERR_VALUEOUTOFBOUNDS;
}
memcpy (&decomp[i * info->size],
&dat->chain[address + es.fields.address + 32],
MIN (bytes_left, info->size));
bytes_left -= info->size;
sec_dat->size = max_decomp_size;
}
}
return error;
}","static int
read_2004_compressed_section (Bit_Chain *VAR_0, Dwg_Data *restrict VAR_1,
Bit_Chain *VAR_2, Dwg_Section_Type VAR_3)
{
uint32_t VAR_4, VAR_5, VAR_6;
uint32_t VAR_7;
long VAR_8;
Dwg_Section_Info *VAR_9 = NULL;
encrypted_section_header VAR_10;
BITCODE_RC *VAR_11;
BITCODE_BL VAR_12, VAR_13;
int VAR_14 = 0;
for (VAR_12 = 0; VAR_12 < VAR_1->header.section_infohdr.num_desc && !VAR_9; ++VAR_12)
{
if (VAR_1->header.section_info[VAR_12].fixedtype == VAR_3)
{
VAR_9 = &VAR_1->header.section_info[VAR_12];
break;
}
}
VAR_2->chain = NULL; 
if (!VAR_9)
{
if (VAR_3 < VAR_15
&& VAR_3 != VAR_16
&& VAR_3 != VAR_17)
{
LOG_WARN (""Failed to find section_info[%u] with type %d"", VAR_12, VAR_3)
}
else
{
LOG_TRACE (""Found no section_info[%u] with type %d\n"", VAR_12, VAR_3)
}
return VAR_18;
}
else
{
LOG_TRACE (""\nFound section_info["" VAR_19
""] %s type %d with %d sections (%scompressed):\n"",
VAR_12, VAR_9->name, VAR_3, VAR_9->num_sections,
VAR_9->compressed == 2 ? """" : ""un"");
}
VAR_7 = VAR_9->num_sections * VAR_9->max_decomp_size;
if (VAR_9->num_sections == 0)
return 0;
if (VAR_7 == 0 || VAR_7 > 0x2f000000) 
{
LOG_ERROR (""Invalid section %s count or max decompression size. ""
""Sections: %u, Max size: %u"",
VAR_9->name, VAR_9->num_sections, VAR_9->max_decomp_size);
return VAR_20;
}
VAR_11 = (BITCODE_RC *)calloc (VAR_7, sizeof (BITCODE_RC));
if (!VAR_11)
{
LOG_ERROR (""Out of memory with %u sections"", VAR_9->num_sections);
return VAR_21;
}
VAR_8 = VAR_7;
VAR_6 = VAR_9->sections[0] ? VAR_9->sections[0]->address : 0;
VAR_2->bit = 0;
VAR_2->byte = 0;
VAR_2->version = VAR_0->version;
VAR_2->from_version = VAR_0->from_version;
VAR_2->chain = VAR_11;
for (VAR_12 = 0; VAR_12 < VAR_9->num_sections; ++VAR_12)
{
if (!VAR_9->sections[VAR_12])
{
LOG_WARN (""Skip empty section %u %s"", VAR_12, VAR_9->name);
continue;
}
VAR_4 = VAR_9->sections[VAR_12]->address;
VAR_0->byte = VAR_4;
bit_read_fixed (VAR_0, VAR_10.char_data, 32);
VAR_5 = 0x4164536b ^ VAR_4;
for (VAR_13 = 0; VAR_13 < 8; ++VAR_13)
VAR_10.long_data[VAR_13] ^= VAR_5;
LOG_INFO (""=== Section %s (%u) @%u ===\n"", VAR_9->name, VAR_12, VAR_4)
if (VAR_10.fields.tag != 0x4163043b)
{
LOG_WARN (""Section Tag:      0x%x  (should be 0x4163043b)"",
(unsigned)VAR_10.fields.tag);
}
else
{
LOG_INFO (""Section Tag:      0x%x\n"", (unsigned)VAR_10.fields.tag);
}
LOG_INFO (""Section Type:     %u\n"", (unsigned)VAR_10.fields.section_type)
VAR_22 (""Data size:        0x%x/%u\n"", (unsigned)VAR_10.fields.data_size,
(unsigned)VAR_10.fields.data_size)
VAR_22 (""Comp data size:   0x%x\n"", (unsigned)VAR_10.fields.section_size)
VAR_23 (""StartOffset:      0x%x\n"", (unsigned)VAR_10.fields.address)
VAR_24 (""Unknown:          0x%x\n"", (unsigned)VAR_10.fields.unknown)
VAR_24 (""Checksum1:        0x%x\n"", (unsigned)VAR_10.fields.checksum_1)
VAR_24 (""Checksum2:        0x%x\n"", (unsigned)VAR_10.fields.checksum_2)
VAR_23 (""Section start:    %lu\n\n"", VAR_0->byte);
LOG_INSANE (""info[%d]->max_decomp_size: %lu (0x%lx)\n"", VAR_12,
(unsigned long)VAR_9->max_decomp_size,
(unsigned long)VAR_9->max_decomp_size)
VAR_25 (""max_decomp_size:          %lu (0x%lx)\n"",
(unsigned long)VAR_7,
(unsigned long)VAR_7)
VAR_25 (""bytes_left:               %ld\n"", VAR_8);
if (VAR_9->compressed == 2
&& VAR_8 > 0
&& (VAR_12 * VAR_9->max_decomp_size) <= VAR_7)
{
VAR_14 = decompress_R2004_section (
VAR_0, &VAR_11[VAR_12 * VAR_9->max_decomp_size], 
VAR_9->max_decomp_size, VAR_10.fields.data_size);
if (VAR_14 > VAR_26)
{
VAR_2->chain = NULL; 
free (VAR_11);
return VAR_14;
}
VAR_8 -= VAR_9->max_decomp_size;
VAR_2->size = VAR_7;
}
else
{
if (VAR_9->compressed == 2
|| VAR_9->size > VAR_7
|| VAR_8 < 0
)
{
LOG_ERROR (""Some section size out of bounds"")
VAR_2->chain = NULL;
free (VAR_11);
return VAR_3 < VAR_15 ? VAR_20
: VAR_27;
}
memcpy (&VAR_11[VAR_12 * VAR_9->size],
&VAR_0->chain[VAR_4 + VAR_10.fields.address + 32],
MIN (VAR_8, VAR_9->size));
VAR_8 -= VAR_9->size;
VAR_2->size = VAR_7;
}
}
return VAR_14;
}",LibreDWG/libredwg/bcec483e73819af29787d5ed87fc515e1dfd0411/decode.c/vul/before/0.json,"static int
read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
                              Bit_Chain *sec_dat, Dwg_Section_Type type)
{
  uint32_t address, sec_mask, initial_address;
  uint32_t max_decomp_size;
  long bytes_left;
  Dwg_Section_Info *info = NULL;
  encrypted_section_header es;
  BITCODE_RC *decomp;
  BITCODE_BL i, j;
  int error = 0;

  for (i = 0; i < dwg->header.section_infohdr.num_desc && !info; ++i)
    {
      if (dwg->header.section_info[i].fixedtype == type)
        {
          info = &dwg->header.section_info[i];
          break;
        }
    }
  sec_dat->chain = NULL; // fixes double-free
  if (!info)
    {
      if (type < SECTION_REVHISTORY
          && type != SECTION_TEMPLATE
          && type != SECTION_OBJFREESPACE)
        {
          LOG_WARN (""Failed to find section_info[%u] with type %d"", i, type)
        }
      else
        {
          LOG_TRACE (""Found no section_info[%u] with type %d\n"", i, type)
        }
      return DWG_ERR_SECTIONNOTFOUND;
    }
  else
    {
      LOG_TRACE (""\nFound section_info["" FORMAT_BL
                 ""] %s type %d with %d sections (%scompressed):\n"",
                 i, info->name, type, info->num_sections,
                 info->compressed == 2 ? """" : ""un"");
    }

  max_decomp_size = info->num_sections * info->max_decomp_size;
  if (info->num_sections == 0)
    return 0;
  if (max_decomp_size == 0 || max_decomp_size > 0x2f000000) // 790Mb
    {
      LOG_ERROR (""Invalid section %s count or max decompression size. ""
                 ""Sections: %u, Max size: %u"",
                 info->name, info->num_sections, info->max_decomp_size);
      return DWG_ERR_INVALIDDWG;
    }
  decomp = (BITCODE_RC *)calloc (max_decomp_size, sizeof (BITCODE_RC));
  if (!decomp)
    {
      LOG_ERROR (""Out of memory with %u sections"", info->num_sections);
      return DWG_ERR_OUTOFMEM;
    }
  bytes_left = max_decomp_size;
  initial_address = info->sections[0] ? info->sections[0]->address : 0;
  sec_dat->bit = 0;
  sec_dat->byte = 0;
  sec_dat->version = dat->version;
  sec_dat->from_version = dat->from_version;
  sec_dat->chain = decomp;

  for (i = j = 0; i < info->num_sections; ++i, ++j)
    {
      if (!info->sections[i])
        {
          LOG_WARN (""Skip empty section %u %s"", i, info->name);
          j--; // index for writing info->size chunks
          continue;
        }
      address = info->sections[i]->address;
      dat->byte = address;
      bit_read_fixed (dat, es.char_data, 32);

      //? if encrypted properties: security_type & 2 ??
      sec_mask = 0x4164536b ^ address;
      {
        int k;
        for (k = 0; k < 8; ++k)
          es.long_data[k] ^= sec_mask;
      }

      LOG_INFO (""=== Section %s (%u) @%u ===\n"", info->name, i, address)
      if (es.fields.tag != 0x4163043b)
        {
          LOG_WARN (""Section Tag:      0x%x  (should be 0x4163043b)"",
                    (unsigned)es.fields.tag);
        }
      else
        {
          LOG_INFO (""Section Tag:      0x%x\n"", (unsigned)es.fields.tag);
        }
      LOG_INFO (""Section Type:     %u\n"", (unsigned)es.fields.section_type)
      // this is the number of bytes that is read in decompress_R2004_section
      // (+ 2bytes)
      LOG_INFO (""Data size:        0x%x/%u\n"", (unsigned)es.fields.data_size,
                (unsigned)es.fields.data_size)
      LOG_INFO (""Comp data size:   0x%x\n"", (unsigned)es.fields.section_size)
      LOG_TRACE (""StartOffset:      0x%x\n"", (unsigned)es.fields.address)
      LOG_HANDLE (""Unknown:          0x%x\n"", (unsigned)es.fields.unknown)
      LOG_HANDLE (""Checksum1:        0x%x\n"", (unsigned)es.fields.checksum_1)
      LOG_HANDLE (""Checksum2:        0x%x\n"", (unsigned)es.fields.checksum_2)
      LOG_TRACE (""Section start:    %lu\n\n"", dat->byte);

      // GH #126 part 4
      LOG_INSANE (""info[%d]->max_decomp_size: %lu (0x%lx)\n"", i,
                  (unsigned long)info->max_decomp_size,
                  (unsigned long)info->max_decomp_size)
      LOG_INSANE (""max_decomp_size:          %lu (0x%lx)\n"",
                  (unsigned long)max_decomp_size,
                  (unsigned long)max_decomp_size)
      LOG_INSANE (""bytes_left:               %ld\n"", bytes_left);

      // check if compressed at all
      if (info->compressed == 2
          && bytes_left > 0
          && (j * info->max_decomp_size) <= max_decomp_size)
        {
          error = decompress_R2004_section (
              dat, &decomp[j * info->max_decomp_size], // offset
              info->max_decomp_size, es.fields.data_size);
          if (error > DWG_ERR_CRITICAL)
            {
              sec_dat->chain = NULL; // fix double-free
              free (decomp);
              return error;
            }
          bytes_left -= info->max_decomp_size;
          sec_dat->size = max_decomp_size;
        }
      else
        {
          if (info->compressed == 2
              || bytes_left < 0
              || ((unsigned long)(address + es.fields.address + 32
                                   + info->size) > max_decomp_size)
              )
            {
              LOG_ERROR (""Some section size out of bounds"")
              sec_dat->chain = NULL;
              free (decomp);
              return type < SECTION_REVHISTORY ? DWG_ERR_INVALIDDWG
                                               : DWG_ERR_VALUEOUTOFBOUNDS;
            }
          memcpy (&decomp[j * info->size],
                  &dat->chain[address + es.fields.address + 32],
                  MIN (bytes_left, info->size));
          bytes_left -= info->size;
          sec_dat->size = max_decomp_size;
        }
    }

  return error;
}","static int
read_2004_compressed_section (Bit_Chain *VAR_0, Dwg_Data *restrict VAR_1,
                              Bit_Chain *VAR_2, Dwg_Section_Type VAR_3)
{
  uint32_t VAR_4, VAR_5, VAR_6;
  uint32_t VAR_7;
  long VAR_8;
  Dwg_Section_Info *VAR_9 = NULL;
  encrypted_section_header VAR_10;
  BITCODE_RC *VAR_11;
  BITCODE_BL VAR_12, VAR_13;
  int VAR_14 = 0;

  for (VAR_12 = 0; VAR_12 < VAR_1->header.section_infohdr.num_desc && !VAR_9; ++VAR_12)
    {
      if (VAR_1->header.section_info[VAR_12].fixedtype == VAR_3)
        {
          VAR_9 = &VAR_1->header.section_info[VAR_12];
          break;
        }
    }
  VAR_2->chain = NULL; /* COMMENT_0 */
  if (!VAR_9)
    {
      if (VAR_3 < VAR_15
          && VAR_3 != VAR_16
          && VAR_3 != VAR_17)
        {
          LOG_WARN (""Failed to find section_info[%u] with type %d"", VAR_12, VAR_3)
        }
      else
        {
          LOG_TRACE (""Found no section_info[%u] with type %d\n"", VAR_12, VAR_3)
        }
      return VAR_18;
    }
  else
    {
      LOG_TRACE (""\nFound section_info["" VAR_19
                 ""] %s type %d with %d sections (%scompressed):\n"",
                 VAR_12, VAR_9->name, VAR_3, VAR_9->num_sections,
                 VAR_9->compressed == 2 ? """" : ""un"");
    }

  VAR_7 = VAR_9->num_sections * VAR_9->max_decomp_size;
  if (VAR_9->num_sections == 0)
    return 0;
  if (VAR_7 == 0 || VAR_7 > 0x2f000000) /* COMMENT_1 */
    {
      LOG_ERROR (""Invalid section %s count or max decompression size. ""
                 ""Sections: %u, Max size: %u"",
                 VAR_9->name, VAR_9->num_sections, VAR_9->max_decomp_size);
      return VAR_20;
    }
  VAR_11 = (BITCODE_RC *)calloc (VAR_7, sizeof (BITCODE_RC));
  if (!VAR_11)
    {
      LOG_ERROR (""Out of memory with %u sections"", VAR_9->num_sections);
      return VAR_21;
    }
  VAR_8 = VAR_7;
  VAR_6 = VAR_9->sections[0] ? VAR_9->sections[0]->address : 0;
  VAR_2->bit = 0;
  VAR_2->byte = 0;
  VAR_2->version = VAR_0->version;
  VAR_2->from_version = VAR_0->from_version;
  VAR_2->chain = VAR_11;

  for (VAR_12 = VAR_13 = 0; VAR_12 < VAR_9->num_sections; ++VAR_12, ++VAR_13)
    {
      if (!VAR_9->sections[VAR_12])
        {
          LOG_WARN (""Skip empty section %u %s"", VAR_12, VAR_9->name);
          VAR_13--; /* COMMENT_2 */
          continue;
        }
      VAR_4 = VAR_9->sections[VAR_12]->address;
      VAR_0->byte = VAR_4;
      bit_read_fixed (VAR_0, VAR_10.char_data, 32);

      /* COMMENT_3 */
      VAR_5 = 0x4164536b ^ VAR_4;
      {
        int VAR_22;
        for (VAR_22 = 0; VAR_22 < 8; ++VAR_22)
          VAR_10.long_data[VAR_22] ^= VAR_5;
      }

      LOG_INFO (""=== Section %s (%u) @%u ===\n"", VAR_9->name, VAR_12, VAR_4)
      if (VAR_10.fields.tag != 0x4163043b)
        {
          LOG_WARN (""Section Tag:      0x%x  (should be 0x4163043b)"",
                    (unsigned)VAR_10.fields.tag);
        }
      else
        {
          LOG_INFO (""Section Tag:      0x%x\n"", (unsigned)VAR_10.fields.tag);
        }
      LOG_INFO (""Section Type:     %u\n"", (unsigned)VAR_10.fields.section_type)
      /* COMMENT_4 */
      /* COMMENT_5 */
      VAR_23 (""Data size:        0x%x/%u\n"", (unsigned)VAR_10.fields.data_size,
                (unsigned)VAR_10.fields.data_size)
      VAR_23 (""Comp data size:   0x%x\n"", (unsigned)VAR_10.fields.section_size)
      VAR_24 (""StartOffset:      0x%x\n"", (unsigned)VAR_10.fields.address)
      VAR_25 (""Unknown:          0x%x\n"", (unsigned)VAR_10.fields.unknown)
      VAR_25 (""Checksum1:        0x%x\n"", (unsigned)VAR_10.fields.checksum_1)
      VAR_25 (""Checksum2:        0x%x\n"", (unsigned)VAR_10.fields.checksum_2)
      VAR_24 (""Section start:    %lu\n\n"", VAR_0->byte);

      /* COMMENT_6 */
      LOG_INSANE (""info[%d]->max_decomp_size: %lu (0x%lx)\n"", VAR_12,
                  (unsigned long)VAR_9->max_decomp_size,
                  (unsigned long)VAR_9->max_decomp_size)
      VAR_26 (""max_decomp_size:          %lu (0x%lx)\n"",
                  (unsigned long)VAR_7,
                  (unsigned long)VAR_7)
      VAR_26 (""bytes_left:               %ld\n"", VAR_8);

      /* COMMENT_7 */
      if (VAR_9->compressed == 2
          && VAR_8 > 0
          && (VAR_13 * VAR_9->max_decomp_size) <= VAR_7)
        {
          VAR_14 = decompress_R2004_section (
              VAR_0, &VAR_11[VAR_13 * VAR_9->max_decomp_size], /* COMMENT_8 */
              VAR_9->max_decomp_size, VAR_10.fields.data_size);
          if (VAR_14 > VAR_27)
            {
              VAR_2->chain = NULL; /* COMMENT_9 */
              free (VAR_11);
              return VAR_14;
            }
          VAR_8 -= VAR_9->max_decomp_size;
          VAR_2->size = VAR_7;
        }
      else
        {
          if (VAR_9->compressed == 2
              || VAR_8 < 0
              || ((unsigned long)(VAR_4 + VAR_10.fields.address + 32
                                   + VAR_9->size) > VAR_7)
              )
            {
              LOG_ERROR (""Some section size out of bounds"")
              VAR_2->chain = NULL;
              free (VAR_11);
              return VAR_3 < VAR_15 ? VAR_20
                                               : VAR_28;
            }
          memcpy (&VAR_11[VAR_13 * VAR_9->size],
                  &VAR_0->chain[VAR_4 + VAR_10.fields.address + 32],
                  MIN (VAR_8, VAR_9->size));
          VAR_8 -= VAR_9->size;
          VAR_2->size = VAR_7;
        }
    }

  return VAR_14;
}",LibreDWG/libredwg/bcec483e73819af29787d5ed87fc515e1dfd0411/decode.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -66,11 +66,12 @@
   sec_dat->from_version = dat->from_version;
   sec_dat->chain = decomp;
 
-  for (i = 0; i < info->num_sections; ++i)
+  for (i = j = 0; i < info->num_sections; ++i, ++j)
     {
       if (!info->sections[i])
         {
           LOG_WARN (""Skip empty section %u %s"", i, info->name);
+          j--; // index for writing info->size chunks
           continue;
         }
       address = info->sections[i]->address;
@@ -79,8 +80,11 @@
 
       //? if encrypted properties: security_type & 2 ??
       sec_mask = 0x4164536b ^ address;
-      for (j = 0; j < 8; ++j)
-        es.long_data[j] ^= sec_mask;
+      {
+        int k;
+        for (k = 0; k < 8; ++k)
+          es.long_data[k] ^= sec_mask;
+      }
 
       LOG_INFO (""=== Section %s (%u) @%u ===\n"", info->name, i, address)
       if (es.fields.tag != 0x4163043b)
@@ -116,10 +120,10 @@
       // check if compressed at all
       if (info->compressed == 2
           && bytes_left > 0
-          && (i * info->max_decomp_size) <= max_decomp_size)
+          && (j * info->max_decomp_size) <= max_decomp_size)
         {
           error = decompress_R2004_section (
-              dat, &decomp[i * info->max_decomp_size], // offset
+              dat, &decomp[j * info->max_decomp_size], // offset
               info->max_decomp_size, es.fields.data_size);
           if (error > DWG_ERR_CRITICAL)
             {
@@ -133,11 +137,9 @@
       else
         {
           if (info->compressed == 2
-              || info->size > max_decomp_size
               || bytes_left < 0
-            /*|| ((unsigned long)(address + es.fields.address + 32
-                                   + info->size)
-                                   > dat->size) */
+              || ((unsigned long)(address + es.fields.address + 32
+                                   + info->size) > max_decomp_size)
               )
             {
               LOG_ERROR (""Some section size out of bounds"")
@@ -146,7 +148,7 @@
               return type < SECTION_REVHISTORY ? DWG_ERR_INVALIDDWG
                                                : DWG_ERR_VALUEOUTOFBOUNDS;
             }
-          memcpy (&decomp[i * info->size],
+          memcpy (&decomp[j * info->size],
                   &dat->chain[address + es.fields.address + 32],
                   MIN (bytes_left, info->size));
           bytes_left -= info->size;","{'deleted_lines': ['  for (i = 0; i < info->num_sections; ++i)', '      for (j = 0; j < 8; ++j)', '        es.long_data[j] ^= sec_mask;', '          && (i * info->max_decomp_size) <= max_decomp_size)', '              dat, &decomp[i * info->max_decomp_size], // offset', '              || info->size > max_decomp_size', '            /*|| ((unsigned long)(address + es.fields.address + 32', '                                   + info->size)', '                                   > dat->size) */', '          memcpy (&decomp[i * info->size],'], 'added_lines': ['  for (i = j = 0; i < info->num_sections; ++i, ++j)', '          j--; // index for writing info->size chunks', '      {', '        int k;', '        for (k = 0; k < 8; ++k)', '          es.long_data[k] ^= sec_mask;', '      }', '          && (j * info->max_decomp_size) <= max_decomp_size)', '              dat, &decomp[j * info->max_decomp_size], // offset', '              || ((unsigned long)(address + es.fields.address + 32', '                                   + info->size) > max_decomp_size)', '          memcpy (&decomp[j * info->size],']}",True,A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10 via read_2004_compressed_section ../../src/decode.c:2379.,7.8,HIGH,2,test,2020-01-13T10:06:26Z,3
CVE-2020-12268,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ArtifexSoftware/jbig2dec,"Fix OSS-Fuzz issue 20332: buffer overflow in jbig2_image_compose.

With extreme values of x/y/w/h we can get overflow. Test for this
and exit safely.

Thanks for OSS-Fuzz for reporting.",0726320a4b55078e9d8deb590e477d598b3da66e,https://github.com/ArtifexSoftware/jbig2dec/commit/0726320a4b55078e9d8deb590e477d598b3da66e,jbig2_image.c,jbig2_image_compose,"int
jbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)
{
uint32_t w, h;
uint32_t shift;
uint32_t leftbyte;
uint8_t *ss;
uint8_t *dd;
uint8_t leftmask, rightmask;
int early = x >= 0;
int late;
uint32_t bytewidth;
uint32_t syoffset = 0;
if (src == NULL)
return 0;
w = src->width;
h = src->height;
shift = (x & 7);
ss = src->data - early;
if (x < 0) {
if (w < (uint32_t) -x)
w = 0;
else
w += x;
ss += (-x-1)>>3;
x = 0;
}
if (y < 0) {
if (h < (uint32_t) -y)
h = 0;
else
h += y;
syoffset = -y * src->stride;
y = 0;
}
if ((uint32_t)x + w > dst->width)
{
if (dst->width < (uint32_t)x)
w = 0;
else
w = dst->width - x;
}
if ((uint32_t)y + h > dst->height)
{
if (dst->height < (uint32_t)y)
h = 0;
else
h = dst->height - y;
}
#ifdef JBIG2_DEBUG
jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""compositing %dx%d at (%d, %d) after clipping"", w, h, x, y);
#endif
if ((w <= 0) || (h <= 0)) {
#ifdef JBIG2_DEBUG
jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""zero clipping region"");
#endif
return 0;
}
leftbyte = (uint32_t) x >> 3;
dd = dst->data + y * dst->stride + leftbyte;
bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;
leftmask = 255>>(x&7);
rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));
if (bytewidth == 1)
leftmask &= rightmask;
late = (ss + bytewidth >= src->data + ((src->width+7)>>3));
ss += syoffset;
switch(op)
{
case JBIG2_COMPOSE_OR:
jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
break;
case JBIG2_COMPOSE_AND:
jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
break;
case JBIG2_COMPOSE_XOR:
jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
break;
case JBIG2_COMPOSE_XNOR:
jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
break;
case JBIG2_COMPOSE_REPLACE:
jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
break;
}
return 0;
}","int
jbig2_image_compose(Jbig2Ctx *VAR_0, Jbig2Image *VAR_1, Jbig2Image *VAR_2, int VAR_3, int VAR_4, Jbig2ComposeOp VAR_5)
{
uint32_t VAR_6, VAR_7;
uint32_t VAR_8;
uint32_t VAR_9;
uint8_t *VAR_10;
uint8_t *VAR_11;
uint8_t VAR_12, VAR_13;
int VAR_14 = VAR_3 >= 0;
int VAR_15;
uint32_t VAR_16;
uint32_t VAR_17 = 0;
if (VAR_2 == NULL)
return 0;
VAR_6 = VAR_2->width;
VAR_7 = VAR_2->height;
VAR_8 = (VAR_3 & 7);
VAR_10 = VAR_2->data - VAR_14;
if (VAR_3 < 0) {
if (VAR_6 < (uint32_t) -VAR_3)
VAR_6 = 0;
else
VAR_6 += VAR_3;
VAR_10 += (-VAR_3-1)>>3;
VAR_3 = 0;
}
if (VAR_4 < 0) {
if (VAR_7 < (uint32_t) -VAR_4)
VAR_7 = 0;
else
VAR_7 += VAR_4;
VAR_17 = -VAR_4 * VAR_2->stride;
VAR_4 = 0;
}
if ((uint32_t)VAR_3 + VAR_6 > VAR_1->width)
{
if (VAR_1->width < (uint32_t)VAR_3)
VAR_6 = 0;
else
VAR_6 = VAR_1->width - VAR_3;
}
if ((uint32_t)VAR_4 + VAR_7 > VAR_1->height)
{
if (VAR_1->height < (uint32_t)VAR_4)
VAR_7 = 0;
else
VAR_7 = VAR_1->height - VAR_4;
}
#ifdef VAR_18
jbig2_error(VAR_0, VAR_19, -1, ""compositing %dx%d at (%d, %d) after clipping"", VAR_6, VAR_7, VAR_3, VAR_4);
#endif
if ((VAR_6 <= 0) || (VAR_7 <= 0)) {
#ifdef VAR_18
jbig2_error(VAR_0, VAR_19, -1, ""zero clipping region"");
#endif
return 0;
}
VAR_9 = (uint32_t) VAR_3 >> 3;
VAR_11 = VAR_1->data + VAR_4 * VAR_1->stride + VAR_9;
VAR_16 = (((uint32_t) VAR_3 + VAR_6 - 1) >> 3) - VAR_9 + 1;
VAR_12 = 255>>(VAR_3&7);
VAR_13 = (((VAR_3+VAR_6)&7) == 0) ? 255 : ~(255>>((VAR_3+VAR_6)&7));
if (VAR_16 == 1)
VAR_12 &= VAR_13;
VAR_15 = (VAR_10 + VAR_16 >= VAR_2->data + ((VAR_2->width+7)>>3));
VAR_10 += VAR_17;
switch(VAR_5)
{
case VAR_20:
jbig2_image_compose_opt_OR(VAR_10, VAR_11, VAR_14, VAR_15, VAR_12, VAR_13, VAR_16, VAR_7, VAR_8, VAR_1->stride, VAR_2->stride);
break;
case VAR_21:
jbig2_image_compose_opt_AND(VAR_10, VAR_11, VAR_14, VAR_15, VAR_12, VAR_13, VAR_16, VAR_7, VAR_8, VAR_1->stride, VAR_2->stride);
break;
case VAR_22:
jbig2_image_compose_opt_XOR(VAR_10, VAR_11, VAR_14, VAR_15, VAR_12, VAR_13, VAR_16, VAR_7, VAR_8, VAR_1->stride, VAR_2->stride);
break;
case VAR_23:
jbig2_image_compose_opt_XNOR(VAR_10, VAR_11, VAR_14, VAR_15, VAR_12, VAR_13, VAR_16, VAR_7, VAR_8, VAR_1->stride, VAR_2->stride);
break;
case VAR_24:
jbig2_image_compose_opt_REPLACE(VAR_10, VAR_11, VAR_14, VAR_15, VAR_12, VAR_13, VAR_16, VAR_7, VAR_8, VAR_1->stride, VAR_2->stride);
break;
}
return 0;
}",ArtifexSoftware/jbig2dec/0726320a4b55078e9d8deb590e477d598b3da66e/jbig2_image.c/vul/before/0.json,"int
jbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)
{
    uint32_t w, h;
    uint32_t shift;
    uint32_t leftbyte;
    uint8_t *ss;
    uint8_t *dd;
    uint8_t leftmask, rightmask;
    int early = x >= 0;
    int late;
    uint32_t bytewidth;
    uint32_t syoffset = 0;

    if (src == NULL)
        return 0;

    if ((UINT32_MAX - src->width  < (x > 0 ? x : -x)) ||
        (UINT32_MAX - src->height < (y > 0 ? y : -y)))
    {
#ifdef JBIG2_DEBUG
        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""overflow in compose_image"");
#endif
        return 0;
    }

    /* This code takes a src image and combines it onto dst at offset (x,y), with operation op. */

    /* Data is packed msb first within a byte, so with bits numbered: 01234567.
     * Second byte is: 89abcdef. So to combine into a run, we use:
     *       (s[0]<<8) | s[1] == 0123456789abcdef.
     * To read from src into dst at offset 3, we need to read:
     *    read:      0123456789abcdef...
     *    write:  0123456798abcdef...
     * In general, to read from src and write into dst at offset x, we need to shift
     * down by (x&7) bits to allow for bit alignment. So shift = x&7.
     * So the 'central' part of our runs will see us doing:
     *   *d++ op= ((s[0]<<8)|s[1])>>shift;
     * with special cases on the left and right edges of the run to mask.
     * With the left hand edge, we have to be careful not to 'underread' the start of
     * the src image; this is what the early flag is about. Similarly we have to be
     * careful not to read off the right hand edge; this is what the late flag is for.
     */

    /* clip */
    w = src->width;
    h = src->height;
    shift = (x & 7);
    ss = src->data - early;

    if (x < 0) {
        if (w < (uint32_t) -x)
            w = 0;
        else
            w += x;
        ss += (-x-1)>>3;
        x = 0;
    }
    if (y < 0) {
        if (h < (uint32_t) -y)
            h = 0;
        else
            h += y;
        syoffset = -y * src->stride;
        y = 0;
    }
    if ((uint32_t)x + w > dst->width)
    {
        if (dst->width < (uint32_t)x)
            w = 0;
        else
            w = dst->width - x;
    }
    if ((uint32_t)y + h > dst->height)
    {
        if (dst->height < (uint32_t)y)
            h = 0;
        else
            h = dst->height - y;
    }
#ifdef JBIG2_DEBUG
    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""compositing %dx%d at (%d, %d) after clipping"", w, h, x, y);
#endif

    /* check for zero clipping region */
    if ((w <= 0) || (h <= 0)) {
#ifdef JBIG2_DEBUG
        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""zero clipping region"");
#endif
        return 0;
    }

    leftbyte = (uint32_t) x >> 3;
    dd = dst->data + y * dst->stride + leftbyte;
    bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;
    leftmask = 255>>(x&7);
    rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));
    if (bytewidth == 1)
        leftmask &= rightmask;
    late = (ss + bytewidth >= src->data + ((src->width+7)>>3));
    ss += syoffset;

    switch(op)
    {
    case JBIG2_COMPOSE_OR:
        jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
        break;
    case JBIG2_COMPOSE_AND:
        jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
        break;
    case JBIG2_COMPOSE_XOR:
        jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
        break;
    case JBIG2_COMPOSE_XNOR:
        jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
        break;
    case JBIG2_COMPOSE_REPLACE:
        jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
        break;
    }

    return 0;
}","int
jbig2_image_compose(Jbig2Ctx *VAR_0, Jbig2Image *VAR_1, Jbig2Image *VAR_2, int VAR_3, int VAR_4, Jbig2ComposeOp VAR_5)
{
    uint32_t VAR_6, VAR_7;
    uint32_t VAR_8;
    uint32_t VAR_9;
    uint8_t *VAR_10;
    uint8_t *VAR_11;
    uint8_t VAR_12, VAR_13;
    int VAR_14 = VAR_3 >= 0;
    int VAR_15;
    uint32_t VAR_16;
    uint32_t VAR_17 = 0;

    if (VAR_2 == NULL)
        return 0;

    if ((VAR_18 - VAR_2->width  < (VAR_3 > 0 ? VAR_3 : -VAR_3)) ||
        (VAR_18 - VAR_2->height < (VAR_4 > 0 ? VAR_4 : -VAR_4)))
    {
#ifdef VAR_19
        jbig2_error(VAR_0, VAR_20, -1, ""overflow in compose_image"");
#endif
        return 0;
    }

    /* COMMENT_0 */

    /* COMMENT_1 */
                                                                  
                                                  
                                                              
                                        
                                     
                                                                                    
                                                                     
                                                           
                                          
                                                                         
                                                                                     
                                                                                   
                                                                                      
       

    /* COMMENT_16 */
    VAR_6 = VAR_2->width;
    VAR_7 = VAR_2->height;
    VAR_8 = (VAR_3 & 7);
    VAR_10 = VAR_2->data - VAR_14;

    if (VAR_3 < 0) {
        if (VAR_6 < (uint32_t) -VAR_3)
            VAR_6 = 0;
        else
            VAR_6 += VAR_3;
        VAR_10 += (-VAR_3-1)>>3;
        VAR_3 = 0;
    }
    if (VAR_4 < 0) {
        if (VAR_7 < (uint32_t) -VAR_4)
            VAR_7 = 0;
        else
            VAR_7 += VAR_4;
        VAR_17 = -VAR_4 * VAR_2->stride;
        VAR_4 = 0;
    }
    if ((uint32_t)VAR_3 + VAR_6 > VAR_1->width)
    {
        if (VAR_1->width < (uint32_t)VAR_3)
            VAR_6 = 0;
        else
            VAR_6 = VAR_1->width - VAR_3;
    }
    if ((uint32_t)VAR_4 + VAR_7 > VAR_1->height)
    {
        if (VAR_1->height < (uint32_t)VAR_4)
            VAR_7 = 0;
        else
            VAR_7 = VAR_1->height - VAR_4;
    }
#ifdef VAR_19
    jbig2_error(VAR_0, VAR_20, -1, ""compositing %dx%d at (%d, %d) after clipping"", VAR_6, VAR_7, VAR_3, VAR_4);
#endif

    /* COMMENT_17 */
    if ((VAR_6 <= 0) || (VAR_7 <= 0)) {
#ifdef VAR_19
        jbig2_error(VAR_0, VAR_20, -1, ""zero clipping region"");
#endif
        return 0;
    }

    VAR_9 = (uint32_t) VAR_3 >> 3;
    VAR_11 = VAR_1->data + VAR_4 * VAR_1->stride + VAR_9;
    VAR_16 = (((uint32_t) VAR_3 + VAR_6 - 1) >> 3) - VAR_9 + 1;
    VAR_12 = 255>>(VAR_3&7);
    VAR_13 = (((VAR_3+VAR_6)&7) == 0) ? 255 : ~(255>>((VAR_3+VAR_6)&7));
    if (VAR_16 == 1)
        VAR_12 &= VAR_13;
    VAR_15 = (VAR_10 + VAR_16 >= VAR_2->data + ((VAR_2->width+7)>>3));
    VAR_10 += VAR_17;

    switch(VAR_5)
    {
    case VAR_21:
        jbig2_image_compose_opt_OR(VAR_10, VAR_11, VAR_14, VAR_15, VAR_12, VAR_13, VAR_16, VAR_7, VAR_8, VAR_1->stride, VAR_2->stride);
        break;
    case VAR_22:
        jbig2_image_compose_opt_AND(VAR_10, VAR_11, VAR_14, VAR_15, VAR_12, VAR_13, VAR_16, VAR_7, VAR_8, VAR_1->stride, VAR_2->stride);
        break;
    case VAR_23:
        jbig2_image_compose_opt_XOR(VAR_10, VAR_11, VAR_14, VAR_15, VAR_12, VAR_13, VAR_16, VAR_7, VAR_8, VAR_1->stride, VAR_2->stride);
        break;
    case VAR_24:
        jbig2_image_compose_opt_XNOR(VAR_10, VAR_11, VAR_14, VAR_15, VAR_12, VAR_13, VAR_16, VAR_7, VAR_8, VAR_1->stride, VAR_2->stride);
        break;
    case VAR_25:
        jbig2_image_compose_opt_REPLACE(VAR_10, VAR_11, VAR_14, VAR_15, VAR_12, VAR_13, VAR_16, VAR_7, VAR_8, VAR_1->stride, VAR_2->stride);
        break;
    }

    return 0;
}",ArtifexSoftware/jbig2dec/0726320a4b55078e9d8deb590e477d598b3da66e/jbig2_image.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,6 +14,15 @@
 
     if (src == NULL)
         return 0;
+
+    if ((UINT32_MAX - src->width  < (x > 0 ? x : -x)) ||
+        (UINT32_MAX - src->height < (y > 0 ? y : -y)))
+    {
+#ifdef JBIG2_DEBUG
+        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""overflow in compose_image"");
+#endif
+        return 0;
+    }
 
     /* This code takes a src image and combines it onto dst at offset (x,y), with operation op. */
 ","{'deleted_lines': [], 'added_lines': ['', '    if ((UINT32_MAX - src->width  < (x > 0 ? x : -x)) ||', '        (UINT32_MAX - src->height < (y > 0 ? y : -y)))', '    {', '#ifdef JBIG2_DEBUG', '        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""overflow in compose_image"");', '#endif', '        return 0;', '    }']}",True,jbig2_image_compose in jbig2_image.c in Artifex jbig2dec before 0.18 has a heap-based buffer overflow.,9.8,CRITICAL,3,test,2020-01-27T18:12:24Z,3
CVE-2020-7042,"['CWE-908', 'CWE-295']",AV:N/AC:L/Au:N/C:N/I:P/A:N,0,adrienverge/openfortivpn,"supply proper input buffer to X509_check_host

CVE-2020-7042 use of uninitialized memory in X509_check_host is fixed with
this commit

the uninitialized buffer common_name was passed as argument to X509_check_host
which prevented proper host name validation when openssl >= 1.0.2 was in use.
This came in with #282 which went into openfortivpn 1.7.1.
Unfortunately, this problem has stayed unnoticed because the return value
was not properly checked either (which is a separate issue, with CVE-2020-7041,
and which has been fixed by the previous commit)",9eee997d599a89492281fc7ffdd79d88cd61afc3,https://github.com/adrienverge/openfortivpn/commit/9eee997d599a89492281fc7ffdd79d88cd61afc3,src/tunnel.c,ssl_verify_cert,"static int ssl_verify_cert(struct tunnel *tunnel)
{
int ret = -1;
int cert_valid = 0;
unsigned char digest[SHA256LEN];
unsigned int len;
struct x509_digest *elem;
char digest_str[SHA256STRLEN], *subject, *issuer;
char *line;
int i;
X509_NAME *subj;
char common_name[FIELD_SIZE + 1];
SSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL);
X509 *cert = SSL_get_peer_certificate(tunnel->ssl_handle);
if (cert == NULL) {
log_error(""Unable to get gateway certificate.\n"");
return 1;
}
subj = X509_get_subject_name(cert);
#ifdef HAVE_X509_CHECK_HOST
if (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL) == 1)
cert_valid = 1;
#else
if (subj
&& X509_NAME_get_text_by_NID(subj, NID_commonName, common_name,
FIELD_SIZE) > 0
&& strncasecmp(common_name, tunnel->config->gateway_host,
FIELD_SIZE) == 0)
cert_valid = 1;
#endif
if (cert_valid
&& SSL_get_verify_result(tunnel->ssl_handle) == X509_V_OK) {
log_debug(""Gateway certificate validation succeeded.\n"");
ret = 0;
goto free_cert;
}
log_debug(""Gateway certificate validation failed.\n"");
if (X509_digest(cert, EVP_sha256(), digest, &len) <= 0
|| len != SHA256LEN) {
log_error(""Could not compute certificate sha256 digest.\n"");
goto free_cert;
}
for (i = 0; i < SHA256LEN; i++)
sprintf(&digest_str[2 * i], ""%02x"", digest[i]);
digest_str[SHA256STRLEN - 1] = '\0';
for (elem = tunnel->config->cert_whitelist; elem != NULL;
elem = elem->next)
if (memcmp(digest_str, elem->data, SHA256STRLEN - 1) == 0)
break;
if (elem != NULL) { log_debug(""Gateway certificate digest found in white list.\n"");
ret = 0;
goto free_cert;
}
subject = X509_NAME_oneline(subj, NULL, 0);
issuer = X509_NAME_oneline(X509_get_issuer_name(cert), NULL, 0);
log_error(""Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\n"");
log_error(""    --trusted-cert %s\n"", digest_str);
log_error(""or add this line to your config file:\n"");
log_error(""    trusted-cert = %s\n"", digest_str);
log_error(""Gateway certificate:\n"");
log_error(""    subject:\n"");
for (line = strtok(subject, ""/""); line != NULL;
line = strtok(NULL, ""/""))
log_error(""        %s\n"", line);
log_error(""    issuer:\n"");
for (line = strtok(issuer, ""/""); line != NULL;
line = strtok(NULL, ""/""))
log_error(""        %s\n"", line);
log_error(""    sha256 digest:\n"");
log_error(""        %s\n"", digest_str);
free_cert:
X509_free(cert);
return ret;
}","static int ssl_verify_cert(struct tunnel *tunnel)
{
int VAR_0 = -1;
int VAR_1 = 0;
unsigned char VAR_2[VAR_3];
unsigned int VAR_4;
struct x509_digest *VAR_5;
char VAR_6[VAR_7], *VAR_8, *VAR_9;
char *VAR_10;
int VAR_11;
X509_NAME *VAR_12;
char VAR_13[VAR_14 + 1];
SSL_set_verify(tunnel->ssl_handle, VAR_15, NULL);
X509 *VAR_16 = SSL_get_peer_certificate(tunnel->ssl_handle);
if (VAR_16 == NULL) {
log_error(""Unable to get gateway certificate.\n"");
return 1;
}
VAR_12 = X509_get_subject_name(VAR_16);
#ifdef VAR_17
if (X509_check_host(VAR_16, VAR_13, VAR_14, 0, NULL) == 1)
VAR_1 = 1;
#else
if (VAR_12
&& X509_NAME_get_text_by_NID(VAR_12, VAR_18, VAR_13,
VAR_14) > 0
&& strncasecmp(VAR_13, tunnel->config->gateway_host,
VAR_14) == 0)
VAR_1 = 1;
#endif
if (VAR_1
&& SSL_get_verify_result(tunnel->ssl_handle) == VAR_19) {
log_debug(""Gateway certificate validation succeeded.\n"");
VAR_0 = 0;
goto free_cert;
}
log_debug(""Gateway certificate validation failed.\n"");
if (X509_digest(VAR_16, EVP_sha256(), VAR_2, &VAR_4) <= 0
|| VAR_4 != VAR_3) {
log_error(""Could not compute certificate sha256 digest.\n"");
goto free_cert;
}
for (VAR_11 = 0; VAR_11 < VAR_3; VAR_11++)
sprintf(&VAR_6[2 * VAR_11], ""%02x"", VAR_2[VAR_11]);
VAR_6[VAR_7 - 1] = '\0';
for (VAR_5 = tunnel->config->cert_whitelist; VAR_5 != NULL;
VAR_5 = VAR_5->next)
if (memcmp(VAR_6, VAR_5->data, VAR_7 - 1) == 0)
break;
if (VAR_5 != NULL) { 
log_debug(""Gateway certificate digest found in white list.\n"");
VAR_0 = 0;
goto free_cert;
}
VAR_8 = X509_NAME_oneline(VAR_12, NULL, 0);
VAR_9 = X509_NAME_oneline(X509_get_issuer_name(VAR_16), NULL, 0);
log_error(""Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\n"");
log_error(""    --trusted-cert %s\n"", VAR_6);
log_error(""or add this line to your config file:\n"");
log_error(""    trusted-cert = %s\n"", VAR_6);
log_error(""Gateway certificate:\n"");
log_error(""    subject:\n"");
for (VAR_10 = strtok(VAR_8, ""/""); VAR_10 != NULL;
VAR_10 = strtok(NULL, ""/""))
log_error(""        %s\n"", VAR_10);
log_error(""    issuer:\n"");
for (VAR_10 = strtok(VAR_9, ""/""); VAR_10 != NULL;
VAR_10 = strtok(NULL, ""/""))
log_error(""        %s\n"", VAR_10);
log_error(""    sha256 digest:\n"");
log_error(""        %s\n"", VAR_6);
free_cert:
X509_free(VAR_16);
return VAR_0;
}",adrienverge/openfortivpn/9eee997d599a89492281fc7ffdd79d88cd61afc3/tunnel.c/vul/before/0.json,"static int ssl_verify_cert(struct tunnel *tunnel)
{
	int ret = -1;
	int cert_valid = 0;
	unsigned char digest[SHA256LEN];
	unsigned int len;
	struct x509_digest *elem;
	char digest_str[SHA256STRLEN], *subject, *issuer;
	char *line;
	int i;
	X509_NAME *subj;

	SSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL);

	X509 *cert = SSL_get_peer_certificate(tunnel->ssl_handle);
	if (cert == NULL) {
		log_error(""Unable to get gateway certificate.\n"");
		return 1;
	}

	subj = X509_get_subject_name(cert);

#ifdef HAVE_X509_CHECK_HOST
	// Use OpenSSL native host validation if v >= 1.0.2.
	// compare against gateway_host and correctly check return value
	// to fix piror Incorrect use of X509_check_host
	if (X509_check_host(cert, tunnel->config->gateway_host,
	                    0, 0, NULL) == 1)
		cert_valid = 1;
#else
	char common_name[FIELD_SIZE + 1];
	// Use explicit Common Name check if native validation not available.
	// Note: this will ignore Subject Alternative Name fields.
	if (subj
	    && X509_NAME_get_text_by_NID(subj, NID_commonName, common_name,
	                                 FIELD_SIZE) > 0
	    && strncasecmp(common_name, tunnel->config->gateway_host,
	                   FIELD_SIZE) == 0)
		cert_valid = 1;
#endif

	// Try to validate certificate using local PKI
	if (cert_valid
	    && SSL_get_verify_result(tunnel->ssl_handle) == X509_V_OK) {
		log_debug(""Gateway certificate validation succeeded.\n"");
		ret = 0;
		goto free_cert;
	}
	log_debug(""Gateway certificate validation failed.\n"");

	// If validation failed, check if cert is in the white list
	if (X509_digest(cert, EVP_sha256(), digest, &len) <= 0
	    || len != SHA256LEN) {
		log_error(""Could not compute certificate sha256 digest.\n"");
		goto free_cert;
	}
	// Encode digest in base16
	for (i = 0; i < SHA256LEN; i++)
		sprintf(&digest_str[2 * i], ""%02x"", digest[i]);
	digest_str[SHA256STRLEN - 1] = '\0';
	// Is it in whitelist?
	for (elem = tunnel->config->cert_whitelist; elem != NULL;
	     elem = elem->next)
		if (memcmp(digest_str, elem->data, SHA256STRLEN - 1) == 0)
			break;
	if (elem != NULL) { // break before end of loop
		log_debug(""Gateway certificate digest found in white list.\n"");
		ret = 0;
		goto free_cert;
	}

	subject = X509_NAME_oneline(subj, NULL, 0);
	issuer = X509_NAME_oneline(X509_get_issuer_name(cert), NULL, 0);

	log_error(""Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\n"");
	log_error(""    --trusted-cert %s\n"", digest_str);
	log_error(""or add this line to your config file:\n"");
	log_error(""    trusted-cert = %s\n"", digest_str);
	log_error(""Gateway certificate:\n"");
	log_error(""    subject:\n"");
	for (line = strtok(subject, ""/""); line != NULL;
	     line = strtok(NULL, ""/""))
		log_error(""        %s\n"", line);
	log_error(""    issuer:\n"");
	for (line = strtok(issuer, ""/""); line != NULL;
	     line = strtok(NULL, ""/""))
		log_error(""        %s\n"", line);
	log_error(""    sha256 digest:\n"");
	log_error(""        %s\n"", digest_str);

free_cert:
	X509_free(cert);
	return ret;
}","static int ssl_verify_cert(struct tunnel *tunnel)
{
	int VAR_0 = -1;
	int VAR_1 = 0;
	unsigned char VAR_2[VAR_3];
	unsigned int VAR_4;
	struct x509_digest *VAR_5;
	char VAR_6[VAR_7], *VAR_8, *VAR_9;
	char *VAR_10;
	int VAR_11;
	X509_NAME *VAR_12;

	SSL_set_verify(tunnel->ssl_handle, VAR_13, NULL);

	X509 *VAR_14 = SSL_get_peer_certificate(tunnel->ssl_handle);
	if (VAR_14 == NULL) {
		log_error(""Unable to get gateway certificate.\n"");
		return 1;
	}

	VAR_12 = X509_get_subject_name(VAR_14);

#ifdef VAR_15
	/* COMMENT_0 */
	/* COMMENT_1 */
	/* COMMENT_2 */
	if (X509_check_host(VAR_14, tunnel->config->gateway_host,
	                    0, 0, NULL) == 1)
		VAR_1 = 1;
#else
	char VAR_16[VAR_17 + 1];
	/* COMMENT_3 */
	/* COMMENT_4 */
	if (VAR_12
	    && X509_NAME_get_text_by_NID(VAR_12, VAR_18, VAR_16,
	                                 VAR_17) > 0
	    && strncasecmp(VAR_16, tunnel->config->gateway_host,
	                   VAR_17) == 0)
		VAR_1 = 1;
#endif

	/* COMMENT_5 */
	if (VAR_1
	    && SSL_get_verify_result(tunnel->ssl_handle) == VAR_19) {
		log_debug(""Gateway certificate validation succeeded.\n"");
		VAR_0 = 0;
		goto free_cert;
	}
	log_debug(""Gateway certificate validation failed.\n"");

	/* COMMENT_6 */
	if (X509_digest(VAR_14, EVP_sha256(), VAR_2, &VAR_4) <= 0
	    || VAR_4 != VAR_3) {
		log_error(""Could not compute certificate sha256 digest.\n"");
		goto free_cert;
	}
	/* COMMENT_7 */
	for (VAR_11 = 0; VAR_11 < VAR_3; VAR_11++)
		sprintf(&VAR_6[2 * VAR_11], ""%02x"", VAR_2[VAR_11]);
	VAR_6[VAR_7 - 1] = '\0';
	/* COMMENT_8 */
	for (VAR_5 = tunnel->config->cert_whitelist; VAR_5 != NULL;
	     VAR_5 = VAR_5->next)
		if (memcmp(VAR_6, VAR_5->data, VAR_7 - 1) == 0)
			break;
	if (VAR_5 != NULL) { /* COMMENT_9 */
		log_debug(""Gateway certificate digest found in white list.\n"");
		VAR_0 = 0;
		goto free_cert;
	}

	VAR_8 = X509_NAME_oneline(VAR_12, NULL, 0);
	VAR_9 = X509_NAME_oneline(X509_get_issuer_name(VAR_14), NULL, 0);

	log_error(""Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\n"");
	log_error(""    --trusted-cert %s\n"", VAR_6);
	log_error(""or add this line to your config file:\n"");
	log_error(""    trusted-cert = %s\n"", VAR_6);
	log_error(""Gateway certificate:\n"");
	log_error(""    subject:\n"");
	for (VAR_10 = strtok(VAR_8, ""/""); VAR_10 != NULL;
	     VAR_10 = strtok(NULL, ""/""))
		log_error(""        %s\n"", VAR_10);
	log_error(""    issuer:\n"");
	for (VAR_10 = strtok(VAR_9, ""/""); VAR_10 != NULL;
	     VAR_10 = strtok(NULL, ""/""))
		log_error(""        %s\n"", VAR_10);
	log_error(""    sha256 digest:\n"");
	log_error(""        %s\n"", VAR_6);

free_cert:
	X509_free(VAR_14);
	return VAR_0;
}",adrienverge/openfortivpn/9eee997d599a89492281fc7ffdd79d88cd61afc3/tunnel.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,7 +9,6 @@
 	char *line;
 	int i;
 	X509_NAME *subj;
-	char common_name[FIELD_SIZE + 1];
 
 	SSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL);
 
@@ -23,10 +22,13 @@
 
 #ifdef HAVE_X509_CHECK_HOST
 	// Use OpenSSL native host validation if v >= 1.0.2.
-	// correctly check return value of X509_check_host
-	if (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL) == 1)
+	// compare against gateway_host and correctly check return value
+	// to fix piror Incorrect use of X509_check_host
+	if (X509_check_host(cert, tunnel->config->gateway_host,
+	                    0, 0, NULL) == 1)
 		cert_valid = 1;
 #else
+	char common_name[FIELD_SIZE + 1];
 	// Use explicit Common Name check if native validation not available.
 	// Note: this will ignore Subject Alternative Name fields.
 	if (subj","{'deleted_lines': ['\tchar common_name[FIELD_SIZE + 1];', '\t// correctly check return value of X509_check_host', '\tif (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL) == 1)'], 'added_lines': ['\t// compare against gateway_host and correctly check return value', '\t// to fix piror Incorrect use of X509_check_host', '\tif (X509_check_host(cert, tunnel->config->gateway_host,', '\t                    0, 0, NULL) == 1)', '\tchar common_name[FIELD_SIZE + 1];']}",True,An issue was discovered in openfortivpn 1.11.0 when used with OpenSSL 1.0.2 or later. tunnel.c mishandles certificate validation because the hostname check operates on uninitialized memory. The outcome is that a valid certificate is never accepted (only a malformed certificate may be accepted).,5.3,MEDIUM,1,test,2020-02-21T19:58:11Z,3
CVE-2020-10019,['CWE-120'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,zephyrproject-rtos/zephyr,"usb: dfu: check requested length (wLength) during DFU_UPLOAD

During DFU_UPLOAD, the host could requests more data
as stated in wTransferSize. Limit upload length to the
size of the request buffer (USB_REQUEST_BUFFER_SIZE).

Signed-off-by: Johann Fischer <j.fischer@phytec.de>",8183a87931538650f09c00d8d51fbc2236600646,https://github.com/zephyrproject-rtos/zephyr/commit/8183a87931538650f09c00d8d51fbc2236600646,subsys/usb/class/usb_dfu.c,dfu_class_handle_req,"static int dfu_class_handle_req(struct usb_setup_packet *pSetup,
s32_t *data_len, u8_t **data)
{
int ret;
u32_t len, bytes_left;
switch (pSetup->bRequest) {
case DFU_GETSTATUS:
LOG_DBG(""DFU_GETSTATUS: status %d, state %d"",
dfu_data.status, dfu_data.state);
if (dfu_data.state == dfuMANIFEST_SYNC) {
dfu_data.state = dfuIDLE;
}
(*data)[0] = dfu_data.status;
sys_put_le16(dfu_data.bwPollTimeout, &(*data)[1]);
(*data)[3] = 0U;
(*data)[4] = dfu_data.state;
(*data)[5] = 0U;
*data_len = 6;
break;
case DFU_GETSTATE:
LOG_DBG(""DFU_GETSTATE"");
(*data)[0] = dfu_data.state;
*data_len = 1;
break;
case DFU_ABORT:
LOG_DBG(""DFU_ABORT"");
if (dfu_check_app_state()) {
return -EINVAL;
}
dfu_reset_counters();
dfu_data.state = dfuIDLE;
dfu_data.status = statusOK;
break;
case DFU_CLRSTATUS:
LOG_DBG(""DFU_CLRSTATUS"");
if (dfu_check_app_state()) {
return -EINVAL;
}
dfu_data.state = dfuIDLE;
dfu_data.status = statusOK;
break;
case DFU_DNLOAD:
LOG_DBG(""DFU_DNLOAD block %d, len %d, state %d"",
pSetup->wValue, pSetup->wLength, dfu_data.state);
if (dfu_check_app_state()) {
return -EINVAL;
}
switch (dfu_data.state) {
case dfuIDLE:
LOG_DBG(""DFU_DNLOAD start"");
dfu_reset_counters();
k_poll_signal_reset(&dfu_signal);
if (dfu_data.flash_area_id !=
DT_FLASH_AREA_IMAGE_1_ID) {
dfu_data.status = errWRITE;
dfu_data.state = dfuERROR;
LOG_ERR(""This area can not be overwritten"");
break;
}
dfu_data.state = dfuDNBUSY;
dfu_data_worker.worker_state = dfuIDLE;
dfu_data_worker.worker_len  = pSetup->wLength;
memcpy(dfu_data_worker.buf, *data, pSetup->wLength);
k_work_submit(&dfu_work);
break;
case dfuDNLOAD_IDLE:
dfu_data.state = dfuDNBUSY;
dfu_data_worker.worker_state = dfuDNLOAD_IDLE;
dfu_data_worker.worker_len  = pSetup->wLength;
if (dfu_data_worker.worker_len == 0U) {
dfu_data.state = dfuMANIFEST_SYNC;
k_poll_signal_raise(&dfu_signal, 0);
}
memcpy(dfu_data_worker.buf, *data, pSetup->wLength);
k_work_submit(&dfu_work);
break;
default:
LOG_ERR(""DFU_DNLOAD wrong state %d"", dfu_data.state);
dfu_data.state = dfuERROR;
dfu_data.status = errUNKNOWN;
dfu_reset_counters();
return -EINVAL;
}
break;
case DFU_UPLOAD:
LOG_DBG(""DFU_UPLOAD block %d, len %d, state %d"",
pSetup->wValue, pSetup->wLength, dfu_data.state);
if (dfu_check_app_state()) {
return -EINVAL;
}
switch (dfu_data.state) {
case dfuIDLE:
dfu_reset_counters();
LOG_DBG(""DFU_UPLOAD start"");
case dfuUPLOAD_IDLE:
if (!pSetup->wLength ||
dfu_data.block_nr != pSetup->wValue) {
LOG_DBG(""DFU_UPLOAD block %d, expected %d, ""
""len %d"", pSetup->wValue,
dfu_data.block_nr, pSetup->wLength);
dfu_data.state = dfuERROR;
dfu_data.status = errUNKNOWN;
break;
}
bytes_left = dfu_data.flash_upload_size -
dfu_data.bytes_sent;
if (bytes_left < pSetup->wLength) {
len = bytes_left;
} else {
len = pSetup->wLength;
}
if (len) {
const struct flash_area *fa;
ret = flash_area_open(dfu_data.flash_area_id,
&fa);
if (ret) {
dfu_data.state = dfuERROR;
dfu_data.status = errFILE;
break;
}
ret = flash_area_read(fa, dfu_data.bytes_sent,
*data, len);
flash_area_close(fa);
if (ret) {
dfu_data.state = dfuERROR;
dfu_data.status = errFILE;
break;
}
}
*data_len = len;
dfu_data.bytes_sent += len;
dfu_data.block_nr++;
if (dfu_data.bytes_sent == dfu_data.flash_upload_size &&
len < pSetup->wLength) {
*data_len = 0;
dfu_data.state = dfuIDLE;
} else
dfu_data.state = dfuUPLOAD_IDLE;
break;
default:
LOG_ERR(""DFU_UPLOAD wrong state %d"", dfu_data.state);
dfu_data.state = dfuERROR;
dfu_data.status = errUNKNOWN;
dfu_reset_counters();
return -EINVAL;
}
break;
case DFU_DETACH:
LOG_DBG(""DFU_DETACH timeout %d, state %d"",
pSetup->wValue, dfu_data.state);
if (dfu_data.state != appIDLE) {
dfu_data.state = appIDLE;
return -EINVAL;
}
dfu_data.state = appDETACH;
dfu_config.usb_device_description = (u8_t *) &dfu_mode_desc;
if (usb_set_config(dfu_config.usb_device_description) != 0) {
LOG_ERR(""usb_set_config failed in DFU_DETACH"");
return -EIO;
}
break;
default:
LOG_WRN(""DFU UNKNOWN STATE: %d"", pSetup->bRequest);
return -EINVAL;
}
return 0;
}","static int dfu_class_handle_req(struct usb_setup_packet *VAR_0,
s32_t *VAR_1, u8_t **VAR_2)
{
int VAR_3;
u32_t VAR_4, VAR_5;
switch (VAR_0->bRequest) {
case VAR_6:
LOG_DBG(""DFU_GETSTATUS: status %d, state %d"",
VAR_7.status, VAR_7.state);
if (VAR_7.state == VAR_8) {
VAR_7.state = VAR_9;
}
(*VAR_2)[0] = VAR_7.status;
sys_put_le16(VAR_7.bwPollTimeout, &(*VAR_2)[1]);
(*VAR_2)[3] = 0U;
(*VAR_2)[4] = VAR_7.state;
(*VAR_2)[5] = 0U;
*VAR_1 = 6;
break;
case VAR_10:
LOG_DBG(""DFU_GETSTATE"");
(*VAR_2)[0] = VAR_7.state;
*VAR_1 = 1;
break;
case VAR_11:
LOG_DBG(""DFU_ABORT"");
if (dfu_check_app_state()) {
return -VAR_12;
}
dfu_reset_counters();
VAR_7.state = VAR_9;
VAR_7.status = VAR_13;
break;
case VAR_14:
LOG_DBG(""DFU_CLRSTATUS"");
if (dfu_check_app_state()) {
return -VAR_12;
}
VAR_7.state = VAR_9;
VAR_7.status = VAR_13;
break;
case VAR_15:
LOG_DBG(""DFU_DNLOAD block %d, len %d, state %d"",
VAR_0->wValue, VAR_0->wLength, VAR_7.state);
if (dfu_check_app_state()) {
return -VAR_12;
}
switch (VAR_7.state) {
case VAR_9:
LOG_DBG(""DFU_DNLOAD start"");
dfu_reset_counters();
k_poll_signal_reset(&VAR_16);
if (VAR_7.flash_area_id !=
VAR_17) {
VAR_7.status = VAR_18;
VAR_7.state = VAR_19;
LOG_ERR(""This area can not be overwritten"");
break;
}
VAR_7.state = VAR_20;
VAR_21.worker_state = VAR_9;
VAR_21.worker_len  = VAR_0->wLength;
memcpy(VAR_21.buf, *VAR_2, VAR_0->wLength);
k_work_submit(&VAR_22);
break;
case VAR_23:
VAR_7.state = VAR_20;
VAR_21.worker_state = VAR_23;
VAR_21.worker_len  = VAR_0->wLength;
if (VAR_21.worker_len == 0U) {
VAR_7.state = VAR_8;
k_poll_signal_raise(&VAR_16, 0);
}
memcpy(VAR_21.buf, *VAR_2, VAR_0->wLength);
k_work_submit(&VAR_22);
break;
default:
LOG_ERR(""DFU_DNLOAD wrong state %d"", VAR_7.state);
VAR_7.state = VAR_19;
VAR_7.status = VAR_24;
dfu_reset_counters();
return -VAR_12;
}
break;
case VAR_25:
LOG_DBG(""DFU_UPLOAD block %d, len %d, state %d"",
VAR_0->wValue, VAR_0->wLength, VAR_7.state);
if (dfu_check_app_state()) {
return -VAR_12;
}
switch (VAR_7.state) {
case VAR_9:
dfu_reset_counters();
LOG_DBG(""DFU_UPLOAD start"");
case VAR_26:
if (!VAR_0->wLength ||
VAR_7.block_nr != VAR_0->wValue) {
LOG_DBG(""DFU_UPLOAD block %d, expected %d, ""
""len %d"", VAR_0->wValue,
VAR_7.block_nr, VAR_0->wLength);
VAR_7.state = VAR_19;
VAR_7.status = VAR_24;
break;
}
VAR_5 = VAR_7.flash_upload_size -
VAR_7.bytes_sent;
if (VAR_5 < VAR_0->wLength) {
VAR_4 = VAR_5;
} else {
VAR_4 = VAR_0->wLength;
}
if (VAR_4) {
const struct flash_area *VAR_27;
VAR_3 = flash_area_open(VAR_7.flash_area_id,
&VAR_27);
if (VAR_3) {
VAR_7.state = VAR_19;
VAR_7.status = VAR_28;
break;
}
VAR_3 = flash_area_read(VAR_27, VAR_7.bytes_sent,
*VAR_2, VAR_4);
flash_area_close(VAR_27);
if (VAR_3) {
VAR_7.state = VAR_19;
VAR_7.status = VAR_28;
break;
}
}
*VAR_1 = VAR_4;
VAR_7.bytes_sent += VAR_4;
VAR_7.block_nr++;
if (VAR_7.bytes_sent == VAR_7.flash_upload_size &&
VAR_4 < VAR_0->wLength) {
*VAR_1 = 0;
VAR_7.state = VAR_9;
} else
VAR_7.state = VAR_26;
break;
default:
LOG_ERR(""DFU_UPLOAD wrong state %d"", VAR_7.state);
VAR_7.state = VAR_19;
VAR_7.status = VAR_24;
dfu_reset_counters();
return -VAR_12;
}
break;
case VAR_29:
LOG_DBG(""DFU_DETACH timeout %d, state %d"",
VAR_0->wValue, VAR_7.state);
if (VAR_7.state != VAR_30) {
VAR_7.state = VAR_30;
return -VAR_12;
}
VAR_7.state = VAR_31;
VAR_32.usb_device_description = (u8_t *) &VAR_33;
if (usb_set_config(VAR_32.usb_device_description) != 0) {
LOG_ERR(""usb_set_config failed in DFU_DETACH"");
return -VAR_34;
}
break;
default:
LOG_WRN(""DFU UNKNOWN STATE: %d"", VAR_0->bRequest);
return -VAR_12;
}
return 0;
}",zephyrproject-rtos/zephyr/8183a87931538650f09c00d8d51fbc2236600646/usb_dfu.c/vul/before/0.json,"static int dfu_class_handle_req(struct usb_setup_packet *pSetup,
		s32_t *data_len, u8_t **data)
{
	int ret;
	u32_t len, bytes_left;

	switch (pSetup->bRequest) {
	case DFU_GETSTATUS:
		LOG_DBG(""DFU_GETSTATUS: status %d, state %d"",
			dfu_data.status, dfu_data.state);

		if (dfu_data.state == dfuMANIFEST_SYNC) {
			dfu_data.state = dfuIDLE;
		}

		/* bStatus */
		(*data)[0] = dfu_data.status;
		/* bwPollTimeout */
		sys_put_le16(dfu_data.bwPollTimeout, &(*data)[1]);
		(*data)[3] = 0U;
		/* bState */
		(*data)[4] = dfu_data.state;
		/* iString */
		(*data)[5] = 0U;
		*data_len = 6;
		break;

	case DFU_GETSTATE:
		LOG_DBG(""DFU_GETSTATE"");
		(*data)[0] = dfu_data.state;
		*data_len = 1;
		break;

	case DFU_ABORT:
		LOG_DBG(""DFU_ABORT"");

		if (dfu_check_app_state()) {
			return -EINVAL;
		}

		dfu_reset_counters();
		dfu_data.state = dfuIDLE;
		dfu_data.status = statusOK;
		break;

	case DFU_CLRSTATUS:
		LOG_DBG(""DFU_CLRSTATUS"");

		if (dfu_check_app_state()) {
			return -EINVAL;
		}

		dfu_data.state = dfuIDLE;
		dfu_data.status = statusOK;
		break;

	case DFU_DNLOAD:
		LOG_DBG(""DFU_DNLOAD block %d, len %d, state %d"",
			pSetup->wValue, pSetup->wLength, dfu_data.state);

		if (dfu_check_app_state()) {
			return -EINVAL;
		}

		switch (dfu_data.state) {
		case dfuIDLE:
			LOG_DBG(""DFU_DNLOAD start"");
			dfu_reset_counters();
			k_poll_signal_reset(&dfu_signal);

			if (dfu_data.flash_area_id !=
			    DT_FLASH_AREA_IMAGE_1_ID) {
				dfu_data.status = errWRITE;
				dfu_data.state = dfuERROR;
				LOG_ERR(""This area can not be overwritten"");
				break;
			}

			dfu_data.state = dfuDNBUSY;
			dfu_data_worker.worker_state = dfuIDLE;
			dfu_data_worker.worker_len  = pSetup->wLength;
			memcpy(dfu_data_worker.buf, *data, pSetup->wLength);
			k_work_submit(&dfu_work);
			break;
		case dfuDNLOAD_IDLE:
			dfu_data.state = dfuDNBUSY;
			dfu_data_worker.worker_state = dfuDNLOAD_IDLE;
			dfu_data_worker.worker_len  = pSetup->wLength;
			if (dfu_data_worker.worker_len == 0U) {
				dfu_data.state = dfuMANIFEST_SYNC;
				k_poll_signal_raise(&dfu_signal, 0);
			}

			memcpy(dfu_data_worker.buf, *data, pSetup->wLength);
			k_work_submit(&dfu_work);
			break;
		default:
			LOG_ERR(""DFU_DNLOAD wrong state %d"", dfu_data.state);
			dfu_data.state = dfuERROR;
			dfu_data.status = errUNKNOWN;
			dfu_reset_counters();
			return -EINVAL;
		}
		break;
	case DFU_UPLOAD:
		LOG_DBG(""DFU_UPLOAD block %d, len %d, state %d"",
			pSetup->wValue, pSetup->wLength, dfu_data.state);

		if (dfu_check_app_state()) {
			return -EINVAL;
		}

		switch (dfu_data.state) {
		case dfuIDLE:
			dfu_reset_counters();
			LOG_DBG(""DFU_UPLOAD start"");
		case dfuUPLOAD_IDLE:
			if (!pSetup->wLength ||
			    dfu_data.block_nr != pSetup->wValue) {
				LOG_DBG(""DFU_UPLOAD block %d, expected %d, ""
					""len %d"", pSetup->wValue,
					dfu_data.block_nr, pSetup->wLength);
				dfu_data.state = dfuERROR;
				dfu_data.status = errUNKNOWN;
				break;
			}

			/* Upload in progress */
			bytes_left = dfu_data.flash_upload_size -
				     dfu_data.bytes_sent;
			if (bytes_left < pSetup->wLength) {
				len = bytes_left;
			} else {
				len = pSetup->wLength;
			}

			if (len > USB_DFU_MAX_XFER_SIZE) {
				/*
				 * The host could requests more data as stated
				 * in wTransferSize. Limit upload length to the
				 * size of the request-buffer.
				 */
				len = USB_DFU_MAX_XFER_SIZE;
			}

			if (len) {
				const struct flash_area *fa;

				ret = flash_area_open(dfu_data.flash_area_id,
						      &fa);
				if (ret) {
					dfu_data.state = dfuERROR;
					dfu_data.status = errFILE;
					break;
				}
				ret = flash_area_read(fa, dfu_data.bytes_sent,
						      *data, len);
				flash_area_close(fa);
				if (ret) {
					dfu_data.state = dfuERROR;
					dfu_data.status = errFILE;
					break;
				}
			}
			*data_len = len;

			dfu_data.bytes_sent += len;
			dfu_data.block_nr++;

			if (dfu_data.bytes_sent == dfu_data.flash_upload_size &&
			    len < pSetup->wLength) {
				/* Upload completed when a
				 * short packet is received
				 */
				*data_len = 0;
				dfu_data.state = dfuIDLE;
			} else
				dfu_data.state = dfuUPLOAD_IDLE;

			break;
		default:
			LOG_ERR(""DFU_UPLOAD wrong state %d"", dfu_data.state);
			dfu_data.state = dfuERROR;
			dfu_data.status = errUNKNOWN;
			dfu_reset_counters();
			return -EINVAL;
		}
		break;
	case DFU_DETACH:
		LOG_DBG(""DFU_DETACH timeout %d, state %d"",
			pSetup->wValue, dfu_data.state);

		if (dfu_data.state != appIDLE) {
			dfu_data.state = appIDLE;
			return -EINVAL;
		}
		/* Move to appDETACH state */
		dfu_data.state = appDETACH;

		/* We should start a timer here but in order to
		 * keep things simple and do not increase the size
		 * we rely on the host to get us out of the appATTACHED
		 * state if needed.
		 */

		/* Set the DFU mode descriptors to be used after reset */
		dfu_config.usb_device_description = (u8_t *) &dfu_mode_desc;
		if (usb_set_config(dfu_config.usb_device_description) != 0) {
			LOG_ERR(""usb_set_config failed in DFU_DETACH"");
			return -EIO;
		}
		break;
	default:
		LOG_WRN(""DFU UNKNOWN STATE: %d"", pSetup->bRequest);
		return -EINVAL;
	}

	return 0;
}","static int dfu_class_handle_req(struct usb_setup_packet *VAR_0,
		s32_t *VAR_1, u8_t **VAR_2)
{
	int VAR_3;
	u32_t VAR_4, VAR_5;

	switch (VAR_0->bRequest) {
	case VAR_6:
		LOG_DBG(""DFU_GETSTATUS: status %d, state %d"",
			VAR_7.status, VAR_7.state);

		if (VAR_7.state == VAR_8) {
			VAR_7.state = VAR_9;
		}

		/* COMMENT_0 */
		(*VAR_2)[0] = VAR_7.status;
		/* COMMENT_1 */
		sys_put_le16(VAR_7.bwPollTimeout, &(*VAR_2)[1]);
		(*VAR_2)[3] = 0U;
		/* COMMENT_2 */
		(*VAR_2)[4] = VAR_7.state;
		/* COMMENT_3 */
		(*VAR_2)[5] = 0U;
		*VAR_1 = 6;
		break;

	case VAR_10:
		LOG_DBG(""DFU_GETSTATE"");
		(*VAR_2)[0] = VAR_7.state;
		*VAR_1 = 1;
		break;

	case VAR_11:
		LOG_DBG(""DFU_ABORT"");

		if (dfu_check_app_state()) {
			return -VAR_12;
		}

		dfu_reset_counters();
		VAR_7.state = VAR_9;
		VAR_7.status = VAR_13;
		break;

	case VAR_14:
		LOG_DBG(""DFU_CLRSTATUS"");

		if (dfu_check_app_state()) {
			return -VAR_12;
		}

		VAR_7.state = VAR_9;
		VAR_7.status = VAR_13;
		break;

	case VAR_15:
		LOG_DBG(""DFU_DNLOAD block %d, len %d, state %d"",
			VAR_0->wValue, VAR_0->wLength, VAR_7.state);

		if (dfu_check_app_state()) {
			return -VAR_12;
		}

		switch (VAR_7.state) {
		case VAR_9:
			LOG_DBG(""DFU_DNLOAD start"");
			dfu_reset_counters();
			k_poll_signal_reset(&VAR_16);

			if (VAR_7.flash_area_id !=
			    VAR_17) {
				VAR_7.status = VAR_18;
				VAR_7.state = VAR_19;
				LOG_ERR(""This area can not be overwritten"");
				break;
			}

			VAR_7.state = VAR_20;
			VAR_21.worker_state = VAR_9;
			VAR_21.worker_len  = VAR_0->wLength;
			memcpy(VAR_21.buf, *VAR_2, VAR_0->wLength);
			k_work_submit(&VAR_22);
			break;
		case VAR_23:
			VAR_7.state = VAR_20;
			VAR_21.worker_state = VAR_23;
			VAR_21.worker_len  = VAR_0->wLength;
			if (VAR_21.worker_len == 0U) {
				VAR_7.state = VAR_8;
				k_poll_signal_raise(&VAR_16, 0);
			}

			memcpy(VAR_21.buf, *VAR_2, VAR_0->wLength);
			k_work_submit(&VAR_22);
			break;
		default:
			LOG_ERR(""DFU_DNLOAD wrong state %d"", VAR_7.state);
			VAR_7.state = VAR_19;
			VAR_7.status = VAR_24;
			dfu_reset_counters();
			return -VAR_12;
		}
		break;
	case VAR_25:
		LOG_DBG(""DFU_UPLOAD block %d, len %d, state %d"",
			VAR_0->wValue, VAR_0->wLength, VAR_7.state);

		if (dfu_check_app_state()) {
			return -VAR_12;
		}

		switch (VAR_7.state) {
		case VAR_9:
			dfu_reset_counters();
			LOG_DBG(""DFU_UPLOAD start"");
		case VAR_26:
			if (!VAR_0->wLength ||
			    VAR_7.block_nr != VAR_0->wValue) {
				LOG_DBG(""DFU_UPLOAD block %d, expected %d, ""
					""len %d"", VAR_0->wValue,
					VAR_7.block_nr, VAR_0->wLength);
				VAR_7.state = VAR_19;
				VAR_7.status = VAR_24;
				break;
			}

			/* COMMENT_4 */
			VAR_5 = VAR_7.flash_upload_size -
				     VAR_7.bytes_sent;
			if (VAR_5 < VAR_0->wLength) {
				VAR_4 = VAR_5;
			} else {
				VAR_4 = VAR_0->wLength;
			}

			if (VAR_4 > VAR_27) {
				/* COMMENT_5 */
                                                  
                                                   
                                  
       
				VAR_4 = VAR_27;
			}

			if (VAR_4) {
				const struct flash_area *VAR_28;

				VAR_3 = flash_area_open(VAR_7.flash_area_id,
						      &VAR_28);
				if (VAR_3) {
					VAR_7.state = VAR_19;
					VAR_7.status = VAR_29;
					break;
				}
				VAR_3 = flash_area_read(VAR_28, VAR_7.bytes_sent,
						      *VAR_2, VAR_4);
				flash_area_close(VAR_28);
				if (VAR_3) {
					VAR_7.state = VAR_19;
					VAR_7.status = VAR_29;
					break;
				}
			}
			*VAR_1 = VAR_4;

			VAR_7.bytes_sent += VAR_4;
			VAR_7.block_nr++;

			if (VAR_7.bytes_sent == VAR_7.flash_upload_size &&
			    VAR_4 < VAR_0->wLength) {
				/* COMMENT_10 */
                               
       
				*VAR_1 = 0;
				VAR_7.state = VAR_9;
			} else
				VAR_7.state = VAR_26;

			break;
		default:
			LOG_ERR(""DFU_UPLOAD wrong state %d"", VAR_7.state);
			VAR_7.state = VAR_19;
			VAR_7.status = VAR_24;
			dfu_reset_counters();
			return -VAR_12;
		}
		break;
	case VAR_30:
		LOG_DBG(""DFU_DETACH timeout %d, state %d"",
			VAR_0->wValue, VAR_7.state);

		if (VAR_7.state != VAR_31) {
			VAR_7.state = VAR_31;
			return -VAR_12;
		}
		/* COMMENT_13 */
		VAR_7.state = VAR_32;

		/* COMMENT_14 */
                                                    
                                                         
                     
     

		/* COMMENT_19 */
		VAR_33.usb_device_description = (u8_t *) &VAR_34;
		if (usb_set_config(VAR_33.usb_device_description) != 0) {
			LOG_ERR(""usb_set_config failed in DFU_DETACH"");
			return -VAR_35;
		}
		break;
	default:
		LOG_WRN(""DFU UNKNOWN STATE: %d"", VAR_0->bRequest);
		return -VAR_12;
	}

	return 0;
}",zephyrproject-rtos/zephyr/8183a87931538650f09c00d8d51fbc2236600646/usb_dfu.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -132,6 +132,15 @@
 				len = bytes_left;
 			} else {
 				len = pSetup->wLength;
+			}
+
+			if (len > USB_DFU_MAX_XFER_SIZE) {
+				/*
+				 * The host could requests more data as stated
+				 * in wTransferSize. Limit upload length to the
+				 * size of the request-buffer.
+				 */
+				len = USB_DFU_MAX_XFER_SIZE;
 			}
 
 			if (len) {","{'deleted_lines': [], 'added_lines': ['\t\t\t}', '', '\t\t\tif (len > USB_DFU_MAX_XFER_SIZE) {', '\t\t\t\t/*', '\t\t\t\t * The host could requests more data as stated', '\t\t\t\t * in wTransferSize. Limit upload length to the', '\t\t\t\t * size of the request-buffer.', '\t\t\t\t */', '\t\t\t\tlen = USB_DFU_MAX_XFER_SIZE;']}",True,USB DFU has a potential buffer overflow where the requested length (wLength) is not checked against the buffer size. This could be used by a malicious USB host to exploit the buffer overflow. See NCC-ZEP-002 This issue affects: zephyrproject-rtos zephyr version 1.14.1 and later versions. version 2.1.0 and later versions.,8.1,HIGH,2,test,2020-03-02T11:14:50Z,3
CVE-2020-12284,['CWE-787'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,ffmpeg,"avcodec/cbs_jpeg: Check length for SOS

Fixes: out of array access
Fixes: 19734/clusterfuzz-testcase-minimized-ffmpeg_BSF_TRACE_HEADERS_fuzzer-5673507031875584
Fixes: 19353/clusterfuzz-testcase-minimized-ffmpeg_BSF_TRACE_HEADERS_fuzzer-5703944462663680

Found-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/projects/ffmpeg
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",1812352d767ccf5431aa440123e2e260a4db2726,https://github.com/FFmpeg/FFmpeg/commit/1812352d767ccf5431aa440123e2e260a4db2726,libavcodec/cbs_jpeg.c,cbs_jpeg_split_fragment,"static int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx,
CodedBitstreamFragment *frag,
int header)
{
AVBufferRef *data_ref;
uint8_t *data;
size_t data_size;
int unit, start, end, marker, next_start, next_marker;
int err, i, j, length;
if (frag->data_size < 4) {
return AVERROR_INVALIDDATA;
}
for (i = 0; i + 1 < frag->data_size && frag->data[i] != 0xff; i++);
if (i > 0) {
av_log(ctx->log_ctx, AV_LOG_WARNING, ""Discarding %d bytes at ""
""beginning of image.\n"", i);
}
for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);
if (i + 1 >= frag->data_size && frag->data[i]) {
av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: ""
""no SOI marker found.\n"");
return AVERROR_INVALIDDATA;
}
marker = frag->data[i];
if (marker != JPEG_MARKER_SOI) {
av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: first ""
""marker is %02x, should be SOI.\n"", marker);
return AVERROR_INVALIDDATA;
}
for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);
if (i + 1 >= frag->data_size) {
av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: ""
""no image content found.\n"");
return AVERROR_INVALIDDATA;
}
marker = frag->data[i];
start  = i + 1;
for (unit = 0;; unit++) {
if (marker == JPEG_MARKER_EOI) {
break;
} else if (marker == JPEG_MARKER_SOS) {
for (i = start; i + 1 < frag->data_size; i++) {
if (frag->data[i] != 0xff)
continue;
end = i;
for (++i; i + 1 < frag->data_size &&
frag->data[i] == 0xff; i++);
if (i + 1 >= frag->data_size) {
next_marker = -1;
} else {
if (frag->data[i] == 0x00)
continue;
next_marker = frag->data[i];
next_start  = i + 1;
}
break;
}
} else {
i = start;
if (i + 2 > frag->data_size) {
av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: ""
""truncated at %02x marker.\n"", marker);
return AVERROR_INVALIDDATA;
}
length = AV_RB16(frag->data + i);
if (i + length > frag->data_size) {
av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: ""
""truncated at %02x marker segment.\n"", marker);
return AVERROR_INVALIDDATA;
}
end = start + length;
i = end;
if (frag->data[i] != 0xff) {
next_marker = -1;
} else {
for (++i; i + 1 < frag->data_size &&
frag->data[i] == 0xff; i++);
if (i + 1 >= frag->data_size) {
next_marker = -1;
} else {
next_marker = frag->data[i];
next_start  = i + 1;
}
}
}
if (marker == JPEG_MARKER_SOS) {
length = AV_RB16(frag->data + start);
data_ref = NULL;
data     = av_malloc(end - start +
AV_INPUT_BUFFER_PADDING_SIZE);
if (!data)
return AVERROR(ENOMEM);
memcpy(data, frag->data + start, length);
for (i = start + length, j = length; i < end; i++, j++) {
if (frag->data[i] == 0xff) {
while (frag->data[i] == 0xff)
++i;
data[j] = 0xff;
} else {
data[j] = frag->data[i];
}
}
data_size = j;
memset(data + data_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
} else {
data      = frag->data + start;
data_size = end - start;
data_ref  = frag->data_ref;
}
err = ff_cbs_insert_unit_data(ctx, frag, unit, marker,
data, data_size, data_ref);
if (err < 0)
return err;
if (next_marker == -1)
break;
marker = next_marker;
start  = next_start;
}
return 0;
}","static int cbs_jpeg_split_fragment(CodedBitstreamContext *VAR_0,
CodedBitstreamFragment *VAR_1,
int VAR_2)
{
AVBufferRef *VAR_3;
uint8_t *VAR_4;
size_t VAR_5;
int VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11;
int VAR_12, VAR_13, VAR_14, VAR_15;
if (VAR_1->data_size < 4) {
return VAR_16;
}
for (VAR_13 = 0; VAR_13 + 1 < VAR_1->data_size && VAR_1->data[VAR_13] != 0xff; VAR_13++);
if (VAR_13 > 0) {
av_log(VAR_0->log_ctx, VAR_17, ""Discarding %d bytes at ""
""beginning of image.\n"", VAR_13);
}
for (++VAR_13; VAR_13 + 1 < VAR_1->data_size && VAR_1->data[VAR_13] == 0xff; VAR_13++);
if (VAR_13 + 1 >= VAR_1->data_size && VAR_1->data[VAR_13]) {
av_log(VAR_0->log_ctx, VAR_18, ""Invalid JPEG image: ""
""no SOI marker found.\n"");
return VAR_16;
}
VAR_9 = VAR_1->data[VAR_13];
if (VAR_9 != VAR_19) {
av_log(VAR_0->log_ctx, VAR_18, ""Invalid JPEG image: first ""
""marker is %02x, should be SOI.\n"", VAR_9);
return VAR_16;
}
for (++VAR_13; VAR_13 + 1 < VAR_1->data_size && VAR_1->data[VAR_13] == 0xff; VAR_13++);
if (VAR_13 + 1 >= VAR_1->data_size) {
av_log(VAR_0->log_ctx, VAR_18, ""Invalid JPEG image: ""
""no image content found.\n"");
return VAR_16;
}
VAR_9 = VAR_1->data[VAR_13];
VAR_7  = VAR_13 + 1;
for (VAR_6 = 0;; VAR_6++) {
if (VAR_9 == VAR_20) {
break;
} else if (VAR_9 == VAR_21) {
for (VAR_13 = VAR_7; VAR_13 + 1 < VAR_1->data_size; VAR_13++) {
if (VAR_1->data[VAR_13] != 0xff)
continue;
VAR_8 = VAR_13;
for (++VAR_13; VAR_13 + 1 < VAR_1->data_size &&
VAR_1->data[VAR_13] == 0xff; VAR_13++);
if (VAR_13 + 1 >= VAR_1->data_size) {
VAR_11 = -1;
} else {
if (VAR_1->data[VAR_13] == 0x00)
continue;
VAR_11 = VAR_1->data[VAR_13];
VAR_10  = VAR_13 + 1;
}
break;
}
} else {
VAR_13 = VAR_7;
if (VAR_13 + 2 > VAR_1->data_size) {
av_log(VAR_0->log_ctx, VAR_18, ""Invalid JPEG image: ""
""truncated at %02x marker.\n"", VAR_9);
return VAR_16;
}
VAR_15 = AV_RB16(VAR_1->data + VAR_13);
if (VAR_13 + VAR_15 > VAR_1->data_size) {
av_log(VAR_0->log_ctx, VAR_18, ""Invalid JPEG image: ""
""truncated at %02x marker segment.\n"", VAR_9);
return VAR_16;
}
VAR_8 = VAR_7 + VAR_15;
VAR_13 = VAR_8;
if (VAR_1->data[VAR_13] != 0xff) {
VAR_11 = -1;
} else {
for (++VAR_13; VAR_13 + 1 < VAR_1->data_size &&
VAR_1->data[VAR_13] == 0xff; VAR_13++);
if (VAR_13 + 1 >= VAR_1->data_size) {
VAR_11 = -1;
} else {
VAR_11 = VAR_1->data[VAR_13];
VAR_10  = VAR_13 + 1;
}
}
}
if (VAR_9 == VAR_21) {
VAR_15 = AV_RB16(VAR_1->data + VAR_7);
VAR_3 = NULL;
VAR_4     = av_malloc(VAR_8 - VAR_7 +
VAR_22);
if (!VAR_4)
return AVERROR(VAR_23);
memcpy(VAR_4, VAR_1->data + VAR_7, VAR_15);
for (VAR_13 = VAR_7 + VAR_15, VAR_14 = VAR_15; VAR_13 < VAR_8; VAR_13++, VAR_14++) {
if (VAR_1->data[VAR_13] == 0xff) {
while (VAR_1->data[VAR_13] == 0xff)
++VAR_13;
VAR_4[VAR_14] = 0xff;
} else {
VAR_4[VAR_14] = VAR_1->data[VAR_13];
}
}
VAR_5 = VAR_14;
memset(VAR_4 + VAR_5, 0, VAR_22);
} else {
VAR_4      = VAR_1->data + VAR_7;
VAR_5 = VAR_8 - VAR_7;
VAR_3  = VAR_1->data_ref;
}
VAR_12 = ff_cbs_insert_unit_data(VAR_0, VAR_1, VAR_6, VAR_9,
VAR_4, VAR_5, VAR_3);
if (VAR_12 < 0)
return VAR_12;
if (VAR_11 == -1)
break;
VAR_9 = VAR_11;
VAR_7  = VAR_10;
}
return 0;
}",ffmpeg/1812352d767ccf5431aa440123e2e260a4db2726/cbs_jpeg.c/vul/before/0.json,"static int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx,
                                   CodedBitstreamFragment *frag,
                                   int header)
{
    AVBufferRef *data_ref;
    uint8_t *data;
    size_t data_size;
    int unit, start, end, marker, next_start, next_marker;
    int err, i, j, length;

    if (frag->data_size < 4) {
        // Definitely too short to be meaningful.
        return AVERROR_INVALIDDATA;
    }

    for (i = 0; i + 1 < frag->data_size && frag->data[i] != 0xff; i++);
    if (i > 0) {
        av_log(ctx->log_ctx, AV_LOG_WARNING, ""Discarding %d bytes at ""
               ""beginning of image.\n"", i);
    }
    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);
    if (i + 1 >= frag->data_size && frag->data[i]) {
        av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: ""
               ""no SOI marker found.\n"");
        return AVERROR_INVALIDDATA;
    }
    marker = frag->data[i];
    if (marker != JPEG_MARKER_SOI) {
        av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: first ""
               ""marker is %02x, should be SOI.\n"", marker);
        return AVERROR_INVALIDDATA;
    }
    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);
    if (i + 1 >= frag->data_size) {
        av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: ""
               ""no image content found.\n"");
        return AVERROR_INVALIDDATA;
    }
    marker = frag->data[i];
    start  = i + 1;

    for (unit = 0;; unit++) {
        if (marker == JPEG_MARKER_EOI) {
            break;
        } else if (marker == JPEG_MARKER_SOS) {
            for (i = start; i + 1 < frag->data_size; i++) {
                if (frag->data[i] != 0xff)
                    continue;
                end = i;
                for (++i; i + 1 < frag->data_size &&
                          frag->data[i] == 0xff; i++);
                if (i + 1 >= frag->data_size) {
                    next_marker = -1;
                } else {
                    if (frag->data[i] == 0x00)
                        continue;
                    next_marker = frag->data[i];
                    next_start  = i + 1;
                }
                break;
            }
        } else {
            i = start;
            if (i + 2 > frag->data_size) {
                av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: ""
                       ""truncated at %02x marker.\n"", marker);
                return AVERROR_INVALIDDATA;
            }
            length = AV_RB16(frag->data + i);
            if (i + length > frag->data_size) {
                av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: ""
                       ""truncated at %02x marker segment.\n"", marker);
                return AVERROR_INVALIDDATA;
            }
            end = start + length;

            i = end;
            if (frag->data[i] != 0xff) {
                next_marker = -1;
            } else {
                for (++i; i + 1 < frag->data_size &&
                          frag->data[i] == 0xff; i++);
                if (i + 1 >= frag->data_size) {
                    next_marker = -1;
                } else {
                    next_marker = frag->data[i];
                    next_start  = i + 1;
                }
            }
        }

        if (marker == JPEG_MARKER_SOS) {
            length = AV_RB16(frag->data + start);

            if (length > end - start)
                return AVERROR_INVALIDDATA;

            data_ref = NULL;
            data     = av_malloc(end - start +
                                 AV_INPUT_BUFFER_PADDING_SIZE);
            if (!data)
                return AVERROR(ENOMEM);

            memcpy(data, frag->data + start, length);
            for (i = start + length, j = length; i < end; i++, j++) {
                if (frag->data[i] == 0xff) {
                    while (frag->data[i] == 0xff)
                        ++i;
                    data[j] = 0xff;
                } else {
                    data[j] = frag->data[i];
                }
            }
            data_size = j;

            memset(data + data_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);

        } else {
            data      = frag->data + start;
            data_size = end - start;
            data_ref  = frag->data_ref;
        }

        err = ff_cbs_insert_unit_data(ctx, frag, unit, marker,
                                      data, data_size, data_ref);
        if (err < 0)
            return err;

        if (next_marker == -1)
            break;
        marker = next_marker;
        start  = next_start;
    }

    return 0;
}","static int cbs_jpeg_split_fragment(CodedBitstreamContext *VAR_0,
                                   CodedBitstreamFragment *VAR_1,
                                   int VAR_2)
{
    AVBufferRef *VAR_3;
    uint8_t *VAR_4;
    size_t VAR_5;
    int VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11;
    int VAR_12, VAR_13, VAR_14, VAR_15;

    if (VAR_1->data_size < 4) {
        /* COMMENT_0 */
        return VAR_16;
    }

    for (VAR_13 = 0; VAR_13 + 1 < VAR_1->data_size && VAR_1->data[VAR_13] != 0xff; VAR_13++);
    if (VAR_13 > 0) {
        av_log(VAR_0->log_ctx, VAR_17, ""Discarding %d bytes at ""
               ""beginning of image.\n"", VAR_13);
    }
    for (++VAR_13; VAR_13 + 1 < VAR_1->data_size && VAR_1->data[VAR_13] == 0xff; VAR_13++);
    if (VAR_13 + 1 >= VAR_1->data_size && VAR_1->data[VAR_13]) {
        av_log(VAR_0->log_ctx, VAR_18, ""Invalid JPEG image: ""
               ""no SOI marker found.\n"");
        return VAR_16;
    }
    VAR_9 = VAR_1->data[VAR_13];
    if (VAR_9 != VAR_19) {
        av_log(VAR_0->log_ctx, VAR_18, ""Invalid JPEG image: first ""
               ""marker is %02x, should be SOI.\n"", VAR_9);
        return VAR_16;
    }
    for (++VAR_13; VAR_13 + 1 < VAR_1->data_size && VAR_1->data[VAR_13] == 0xff; VAR_13++);
    if (VAR_13 + 1 >= VAR_1->data_size) {
        av_log(VAR_0->log_ctx, VAR_18, ""Invalid JPEG image: ""
               ""no image content found.\n"");
        return VAR_16;
    }
    VAR_9 = VAR_1->data[VAR_13];
    VAR_7  = VAR_13 + 1;

    for (VAR_6 = 0;; VAR_6++) {
        if (VAR_9 == VAR_20) {
            break;
        } else if (VAR_9 == VAR_21) {
            for (VAR_13 = VAR_7; VAR_13 + 1 < VAR_1->data_size; VAR_13++) {
                if (VAR_1->data[VAR_13] != 0xff)
                    continue;
                VAR_8 = VAR_13;
                for (++VAR_13; VAR_13 + 1 < VAR_1->data_size &&
                          VAR_1->data[VAR_13] == 0xff; VAR_13++);
                if (VAR_13 + 1 >= VAR_1->data_size) {
                    VAR_11 = -1;
                } else {
                    if (VAR_1->data[VAR_13] == 0x00)
                        continue;
                    VAR_11 = VAR_1->data[VAR_13];
                    VAR_10  = VAR_13 + 1;
                }
                break;
            }
        } else {
            VAR_13 = VAR_7;
            if (VAR_13 + 2 > VAR_1->data_size) {
                av_log(VAR_0->log_ctx, VAR_18, ""Invalid JPEG image: ""
                       ""truncated at %02x marker.\n"", VAR_9);
                return VAR_16;
            }
            VAR_15 = AV_RB16(VAR_1->data + VAR_13);
            if (VAR_13 + VAR_15 > VAR_1->data_size) {
                av_log(VAR_0->log_ctx, VAR_18, ""Invalid JPEG image: ""
                       ""truncated at %02x marker segment.\n"", VAR_9);
                return VAR_16;
            }
            VAR_8 = VAR_7 + VAR_15;

            VAR_13 = VAR_8;
            if (VAR_1->data[VAR_13] != 0xff) {
                VAR_11 = -1;
            } else {
                for (++VAR_13; VAR_13 + 1 < VAR_1->data_size &&
                          VAR_1->data[VAR_13] == 0xff; VAR_13++);
                if (VAR_13 + 1 >= VAR_1->data_size) {
                    VAR_11 = -1;
                } else {
                    VAR_11 = VAR_1->data[VAR_13];
                    VAR_10  = VAR_13 + 1;
                }
            }
        }

        if (VAR_9 == VAR_21) {
            VAR_15 = AV_RB16(VAR_1->data + VAR_7);

            if (VAR_15 > VAR_8 - VAR_7)
                return VAR_16;

            VAR_3 = NULL;
            VAR_4     = av_malloc(VAR_8 - VAR_7 +
                                 VAR_22);
            if (!VAR_4)
                return AVERROR(VAR_23);

            memcpy(VAR_4, VAR_1->data + VAR_7, VAR_15);
            for (VAR_13 = VAR_7 + VAR_15, VAR_14 = VAR_15; VAR_13 < VAR_8; VAR_13++, VAR_14++) {
                if (VAR_1->data[VAR_13] == 0xff) {
                    while (VAR_1->data[VAR_13] == 0xff)
                        ++VAR_13;
                    VAR_4[VAR_14] = 0xff;
                } else {
                    VAR_4[VAR_14] = VAR_1->data[VAR_13];
                }
            }
            VAR_5 = VAR_14;

            memset(VAR_4 + VAR_5, 0, VAR_22);

        } else {
            VAR_4      = VAR_1->data + VAR_7;
            VAR_5 = VAR_8 - VAR_7;
            VAR_3  = VAR_1->data_ref;
        }

        VAR_12 = ff_cbs_insert_unit_data(VAR_0, VAR_1, VAR_6, VAR_9,
                                      VAR_4, VAR_5, VAR_3);
        if (VAR_12 < 0)
            return VAR_12;

        if (VAR_11 == -1)
            break;
        VAR_9 = VAR_11;
        VAR_7  = VAR_10;
    }

    return 0;
}",ffmpeg/1812352d767ccf5431aa440123e2e260a4db2726/cbs_jpeg.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -92,6 +92,9 @@
         if (marker == JPEG_MARKER_SOS) {
             length = AV_RB16(frag->data + start);
 
+            if (length > end - start)
+                return AVERROR_INVALIDDATA;
+
             data_ref = NULL;
             data     = av_malloc(end - start +
                                  AV_INPUT_BUFFER_PADDING_SIZE);","{'deleted_lines': [], 'added_lines': ['            if (length > end - start)', '                return AVERROR_INVALIDDATA;', '']}",True,cbs_jpeg_split_fragment in libavcodec/cbs_jpeg.c in FFmpeg 4.1 and 4.2.2 has a heap-based buffer overflow during JPEG_MARKER_SOS handling because of a missing length check.,9.8,CRITICAL,3,test,2020-03-07T14:42:58Z,3
CVE-2020-11683,['CWE-203'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,linux4sam/at91bootstrap,"driver: secure: use consttime_memequal for memory comparison

Do  not  use memcmp() to compare security critical data, such as
cryptographic secrets, because the required CPU time depends on the
number of equal bytes.
Instead, a function that performs comparisons in constant time is required.
Warning: consttime_memequal returns 0 if data are NOT equal, and 1 if they are
equal.

Signed-off-by: Eugen Hristev <eugen.hristev@microchip.com>
Reviewed-by: Nicolas Ferre <nicolas.ferre@microchip.com>",7753914c9a622c245f3a3cf2af5e24b6a9904213,https://github.com/linux4sam/at91bootstrap/commit/7753914c9a622c245f3a3cf2af5e24b6a9904213,driver/secure.c,secure_decrypt,"int secure_decrypt(void *data, unsigned int data_length, int is_signed)
{
at91_aes_key_size_t key_size;
unsigned int cmac_key[8], cipher_key[8];
unsigned int iv[AT91_AES_IV_SIZE_WORD];
unsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];
unsigned int fixed_length;
const unsigned int *cmac;
int rc = -1;
init_keys(&key_size, cipher_key, cmac_key, iv);
at91_aes_init();
if (is_signed) {
if (at91_aes_cmac(data_length, data, computed_cmac,
key_size, cmac_key))
goto exit;
fixed_length = at91_aes_roundup(data_length);
cmac = (const unsigned int *)((char *)data + fixed_length);
if (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))
goto exit;
}
if (at91_aes_cbc(data_length, data, data, 0,
key_size, cipher_key, iv))
goto exit;
rc = 0;
exit:
at91_aes_cleanup();
memset(cmac_key, 0, sizeof(cmac_key));
memset(cipher_key, 0, sizeof(cipher_key));
memset(iv, 0, sizeof(iv));
return rc;
}","int secure_decrypt(void *VAR_0, unsigned int VAR_1, int VAR_2)
{
at91_aes_key_size_t VAR_3;
unsigned int VAR_4[8], VAR_5[8];
unsigned int VAR_6[VAR_7];
unsigned int VAR_8[VAR_9];
unsigned int VAR_10;
const unsigned int *VAR_11;
int VAR_12 = -1;
init_keys(&VAR_3, VAR_5, VAR_4, VAR_6);
at91_aes_init();
if (VAR_2) {
if (at91_aes_cmac(VAR_1, VAR_0, VAR_8,
VAR_3, VAR_4))
goto exit;
VAR_10 = at91_aes_roundup(VAR_1);
VAR_11 = (const unsigned int *)((char *)VAR_0 + VAR_10);
if (memcmp(VAR_11, VAR_8, VAR_13))
goto exit;
}
if (at91_aes_cbc(VAR_1, VAR_0, VAR_0, 0,
VAR_3, VAR_5, VAR_6))
goto exit;
VAR_12 = 0;
exit:
at91_aes_cleanup();
memset(VAR_4, 0, sizeof(VAR_4));
memset(VAR_5, 0, sizeof(VAR_5));
memset(VAR_6, 0, sizeof(VAR_6));
return VAR_12;
}",linux4sam/at91bootstrap/7753914c9a622c245f3a3cf2af5e24b6a9904213/secure.c/vul/before/0.json,"int secure_decrypt(void *data, unsigned int data_length, int is_signed)
{
	at91_aes_key_size_t key_size;
	unsigned int cmac_key[8], cipher_key[8];
	unsigned int iv[AT91_AES_IV_SIZE_WORD];
	unsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];
	unsigned int fixed_length;
	const unsigned int *cmac;
	int rc = -1;

	/* Init keys */
	init_keys(&key_size, cipher_key, cmac_key, iv);

	/* Init periph */
	at91_aes_init();

	/* Check signature if required */
	if (is_signed) {
		/* Compute the CMAC */
		if (at91_aes_cmac(data_length, data, computed_cmac,
				  key_size, cmac_key))
			goto exit;

		/* Check the CMAC */
		fixed_length = at91_aes_roundup(data_length);
		cmac = (const unsigned int *)((char *)data + fixed_length);
		if (!consttime_memequal(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))
			goto exit;
	}

	/* Decrypt the whole file */
	if (at91_aes_cbc(data_length, data, data, 0,
			 key_size, cipher_key, iv))
		goto exit;

	rc = 0;
exit:
	/* Reset periph */
	at91_aes_cleanup();

	/* Reset keys */
	memset(cmac_key, 0, sizeof(cmac_key));
	memset(cipher_key, 0, sizeof(cipher_key));
	memset(iv, 0, sizeof(iv));

	return rc;
}","int secure_decrypt(void *VAR_0, unsigned int VAR_1, int VAR_2)
{
	at91_aes_key_size_t VAR_3;
	unsigned int VAR_4[8], VAR_5[8];
	unsigned int VAR_6[VAR_7];
	unsigned int VAR_8[VAR_9];
	unsigned int VAR_10;
	const unsigned int *VAR_11;
	int VAR_12 = -1;

	/* COMMENT_0 */
	init_keys(&VAR_3, VAR_5, VAR_4, VAR_6);

	/* COMMENT_1 */
	at91_aes_init();

	/* COMMENT_2 */
	if (VAR_2) {
		/* COMMENT_3 */
		if (at91_aes_cmac(VAR_1, VAR_0, VAR_8,
				  VAR_3, VAR_4))
			goto exit;

		/* COMMENT_4 */
		VAR_10 = at91_aes_roundup(VAR_1);
		VAR_11 = (const unsigned int *)((char *)VAR_0 + VAR_10);
		if (!consttime_memequal(VAR_11, VAR_8, VAR_13))
			goto exit;
	}

	/* COMMENT_5 */
	if (at91_aes_cbc(VAR_1, VAR_0, VAR_0, 0,
			 VAR_3, VAR_5, VAR_6))
		goto exit;

	VAR_12 = 0;
exit:
	/* COMMENT_6 */
	at91_aes_cleanup();

	/* COMMENT_7 */
	memset(VAR_4, 0, sizeof(VAR_4));
	memset(VAR_5, 0, sizeof(VAR_5));
	memset(VAR_6, 0, sizeof(VAR_6));

	return VAR_12;
}",linux4sam/at91bootstrap/7753914c9a622c245f3a3cf2af5e24b6a9904213/secure.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -24,7 +24,7 @@
 		/* Check the CMAC */
 		fixed_length = at91_aes_roundup(data_length);
 		cmac = (const unsigned int *)((char *)data + fixed_length);
-		if (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))
+		if (!consttime_memequal(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))
 			goto exit;
 	}
 ","{'deleted_lines': ['\t\tif (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))'], 'added_lines': ['\t\tif (!consttime_memequal(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))']}",True,A timing side channel was discovered in AT91bootstrap before 3.9.2. It can be exploited by attackers with physical access to forge CMAC values and subsequently boot arbitrary code on an affected system.,6.8,MEDIUM,1,test,2020-03-10T07:40:02Z,3
CVE-2019-15151,['CWE-415'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,adplug,"Fix double free in Cu6mPlayer::~Cu6mPlayer() (issue #91)

Leave deallocation of song_data to destructor when
decompression fails, just like on success.

This fixes CVE-2019-15151.

Even though load() is apparently not supposed to be called
twice (and bad things happen in many players if you do),
let's also avoid leaking song_data's memory in that case.

Fixes: https://github.com/adplug/adplug/issues/91",e8814f46ec2285a32eed47cbaea691030da67637,https://github.com/adplug/adplug/commit/e8814f46ec2285a32eed47cbaea691030da67637,src/u6m.cpp,Cu6mPlayer::load,"bool Cu6mPlayer::load(const std::string &filename, const CFileProvider &fp)
{
unsigned long filesize, decompressed_filesize;
binistream *f;
f = fp.open(filename); if(!f) return false;
filesize = fp.filesize(f);
if (filesize >= 6)
{
unsigned char pseudo_header[6];
f->readString((char *)pseudo_header, 6);
decompressed_filesize = pseudo_header[0] + (pseudo_header[1] << 8);
if (!( (pseudo_header[2]==0) && (pseudo_header[3]==0) &&
(pseudo_header[4] + ((pseudo_header[5] & 0x1)<<8) == 0x100) &&
(decompressed_filesize > (filesize-4)) ))
{
fp.close(f);
return(false);
}
}
else
{
fp.close(f);
return(false);
}
song_data = new unsigned char[decompressed_filesize];
unsigned char* compressed_song_data = new unsigned char[filesize-3];
f->seek(4);
f->readString((char *)compressed_song_data, filesize - 4);
fp.close(f);
data_block source, destination;
source.size = filesize-4;
source.data = compressed_song_data;
destination.size = decompressed_filesize;
destination.data = song_data;
if (!lzw_decompress(source,destination))
{
delete[] compressed_song_data;
delete[] song_data;
return(false);
}
delete[] compressed_song_data;
rewind(0);
return (true);
}","bool Cu6mPlayer::load(const std::string &VAR_0, const CFileProvider &VAR_1)
{
unsigned long VAR_2, VAR_3;
binistream *VAR_4;
VAR_4 = VAR_1.open(VAR_0); if(!VAR_4) return false;
VAR_2 = VAR_1.filesize(VAR_4);
if (VAR_2 >= 6)
{
unsigned char VAR_5[6];
VAR_4->readString((char *)VAR_5, 6);
VAR_3 = VAR_5[0] + (VAR_5[1] << 8);
if (!( (VAR_5[2]==0) && (VAR_5[3]==0) &&
(VAR_5[4] + ((VAR_5[5] & 0x1)<<8) == 0x100) &&
(VAR_3 > (VAR_2-4)) ))
{
VAR_1.close(VAR_4);
return(false);
}
}
else
{
VAR_1.close(VAR_4);
return(false);
}
VAR_6 = new unsigned char[VAR_3];
unsigned char* VAR_7 = new unsigned char[VAR_2-3];
VAR_4->seek(4);
VAR_4->readString((char *)VAR_7, VAR_2 - 4);
VAR_1.close(VAR_4);
data_block VAR_8, VAR_9;
VAR_8.size = VAR_2-4;
VAR_8.data = VAR_7;
VAR_9.size = VAR_3;
VAR_9.data = VAR_6;
if (!lzw_decompress(VAR_8,VAR_9))
{
delete[] VAR_7;
delete[] VAR_6;
return(false);
}
delete[] VAR_7;
rewind(0);
return (true);
}",adplug/e8814f46ec2285a32eed47cbaea691030da67637/u6m.cpp/vul/before/0.json,"bool Cu6mPlayer::load(const std::string &filename, const CFileProvider &fp)
{
  // file validation section
  // this section only checks a few *necessary* conditions
  unsigned long filesize, decompressed_filesize;
  binistream *f;

  f = fp.open(filename); if(!f) return false;
  filesize = fp.filesize(f);

  if (filesize >= 6)
    {
      // check if the file has a valid pseudo-header
      unsigned char pseudo_header[6];
      f->readString((char *)pseudo_header, 6);
      decompressed_filesize = pseudo_header[0] + (pseudo_header[1] << 8);

      if (!( (pseudo_header[2]==0) && (pseudo_header[3]==0) &&
	     (pseudo_header[4] + ((pseudo_header[5] & 0x1)<<8) == 0x100) &&
	     (decompressed_filesize > (filesize-4)) ))
        {
	  fp.close(f);
	  return(false);
        }
    }
  else
    {
      fp.close(f);
      return(false);
    }

  // load section
  delete[] song_data;
  song_data = new unsigned char[decompressed_filesize];
  unsigned char* compressed_song_data = new unsigned char[filesize-3];

  f->seek(4);
  f->readString((char *)compressed_song_data, filesize - 4);
  fp.close(f);

  // attempt to decompress the song data
  data_block source, destination;
  source.size = filesize-4;
  source.data = compressed_song_data;
  destination.size = decompressed_filesize;
  destination.data = song_data;
	
  if (!lzw_decompress(source,destination))
    {
      delete[] compressed_song_data;
      return(false);
    }

  // deallocation section
  delete[] compressed_song_data;

  rewind(0);
  return (true);
}","bool Cu6mPlayer::load(const std::string &VAR_0, const CFileProvider &VAR_1)
{
  /* COMMENT_0 */
  /* COMMENT_1 */
  unsigned long VAR_2, VAR_3;
  binistream *VAR_4;

  VAR_4 = VAR_1.open(VAR_0); if(!VAR_4) return false;
  VAR_2 = VAR_1.filesize(VAR_4);

  if (VAR_2 >= 6)
    {
      /* COMMENT_2 */
      unsigned char VAR_5[6];
      VAR_4->readString((char *)VAR_5, 6);
      VAR_3 = VAR_5[0] + (VAR_5[1] << 8);

      if (!( (VAR_5[2]==0) && (VAR_5[3]==0) &&
	     (VAR_5[4] + ((VAR_5[5] & 0x1)<<8) == 0x100) &&
	     (VAR_3 > (VAR_2-4)) ))
        {
	  VAR_1.close(VAR_4);
	  return(false);
        }
    }
  else
    {
      VAR_1.close(VAR_4);
      return(false);
    }

  /* COMMENT_3 */
  delete[] VAR_6;
  VAR_6 = new unsigned char[VAR_3];
  unsigned char* VAR_7 = new unsigned char[VAR_2-3];

  VAR_4->seek(4);
  VAR_4->readString((char *)VAR_7, VAR_2 - 4);
  VAR_1.close(VAR_4);

  /* COMMENT_4 */
  data_block VAR_8, VAR_9;
  VAR_8.size = VAR_2-4;
  VAR_8.data = VAR_7;
  VAR_9.size = VAR_3;
  VAR_9.data = VAR_6;
	
  if (!lzw_decompress(VAR_8,VAR_9))
    {
      delete[] VAR_7;
      return(false);
    }

  /* COMMENT_5 */
  delete[] VAR_7;

  rewind(0);
  return (true);
}",adplug/e8814f46ec2285a32eed47cbaea691030da67637/u6m.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -30,6 +30,7 @@
     }
 
   // load section
+  delete[] song_data;
   song_data = new unsigned char[decompressed_filesize];
   unsigned char* compressed_song_data = new unsigned char[filesize-3];
 
@@ -38,7 +39,6 @@
   fp.close(f);
 
   // attempt to decompress the song data
-  // if unsuccessful, deallocate song_data[] on the spot, and return(false)
   data_block source, destination;
   source.size = filesize-4;
   source.data = compressed_song_data;
@@ -48,7 +48,6 @@
   if (!lzw_decompress(source,destination))
     {
       delete[] compressed_song_data;
-      delete[] song_data;
       return(false);
     }
 ","{'deleted_lines': ['  // if unsuccessful, deallocate song_data[] on the spot, and return(false)', '      delete[] song_data;'], 'added_lines': ['  delete[] song_data;']}",True,AdPlug 2.3.1 has a double free in the Cu6mPlayer class in u6m.h.,9.8,CRITICAL,3,test,2020-03-24T14:43:22Z,3
CVE-2020-26880,['CWE-269'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,sympa-community/sympa,Sympa SA 2020-002 (candidate): Setuid wrappers should clear environment variables to avoid exploits.,3f8449c647e5ab32cf6f8837cb600c1756b6189c,https://github.com/sympa-community/sympa/commit/3f8449c647e5ab32cf6f8837cb600c1756b6189c,src/cgi/sympa_soap_server-wrapper.fcgi.c,main,"int main(int argn, char **argv, char **envp) {
setreuid(geteuid(),geteuid());
setregid(getegid(),getegid());
argv[0] = SYMPASOAP;
return execve(SYMPASOAP,argv,envp);
}","int main(int VAR_0, char **VAR_1, char **VAR_2) {
setreuid(geteuid(),geteuid());
setregid(getegid(),getegid());
VAR_1[0] = VAR_3;
return execve(VAR_3,VAR_1,VAR_2);
}",sympa-community/sympa/3f8449c647e5ab32cf6f8837cb600c1756b6189c/sympa_soap_server-wrapper.fcgi.c/vul/before/0.json,"int main(int argn, char **argv, char **envp) {
    char *myenvp[] = { ""IFS= \t\n"", ""PATH=/bin:/usr/bin"", NULL };

    setreuid(geteuid(),geteuid());
    setregid(getegid(),getegid());
    argv[0] = SYMPASOAP;
    return execve(SYMPASOAP, argv, myenvp);
}","int main(int VAR_0, char **VAR_1, char **VAR_2) {
    char *VAR_3[] = { ""IFS= \t\n"", ""PATH=/bin:/usr/bin"", NULL };

    setreuid(geteuid(),geteuid());
    setregid(getegid(),getegid());
    VAR_1[0] = VAR_4;
    return execve(VAR_4, VAR_1, VAR_3);
}",sympa-community/sympa/3f8449c647e5ab32cf6f8837cb600c1756b6189c/sympa_soap_server-wrapper.fcgi.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,8 @@
 int main(int argn, char **argv, char **envp) {
+    char *myenvp[] = { ""IFS= \t\n"", ""PATH=/bin:/usr/bin"", NULL };
+
     setreuid(geteuid(),geteuid());
     setregid(getegid(),getegid());
     argv[0] = SYMPASOAP;
-    return execve(SYMPASOAP,argv,envp);
+    return execve(SYMPASOAP, argv, myenvp);
 }","{'deleted_lines': ['    return execve(SYMPASOAP,argv,envp);'], 'added_lines': ['    char *myenvp[] = { ""IFS= \\t\\n"", ""PATH=/bin:/usr/bin"", NULL };', '', '    return execve(SYMPASOAP, argv, myenvp);']}",True,Sympa through 6.2.57b.2 allows a local privilege escalation from the sympa user account to full root access by modifying the sympa.conf configuration file (which is owned by sympa) and parsing it through the setuid sympa_newaliases-wrapper executable.,7.8,HIGH,2,test,2020-03-27T12:28:18Z,3
CVE-2020-26880,['CWE-269'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,sympa-community/sympa,Sympa SA 2020-002 (candidate): Setuid wrappers should clear environment variables to avoid exploits.,3f8449c647e5ab32cf6f8837cb600c1756b6189c,https://github.com/sympa-community/sympa/commit/3f8449c647e5ab32cf6f8837cb600c1756b6189c,src/libexec/sympa_newaliases-wrapper.c,main,"int main(int argn, char **argv, char **envp) {
setreuid(geteuid(),geteuid());
setregid(getegid(),getegid());
argv[0] = SYMPA_NEWALIASES;
return execve(SYMPA_NEWALIASES, argv, envp);
}","int main(int VAR_0, char **VAR_1, char **VAR_2) {
setreuid(geteuid(),geteuid());
setregid(getegid(),getegid());
VAR_1[0] = VAR_3;
return execve(VAR_3, VAR_1, VAR_2);
}",sympa-community/sympa/3f8449c647e5ab32cf6f8837cb600c1756b6189c/sympa_newaliases-wrapper.c/vul/before/0.json,"int main(int argn, char **argv, char **envp) {
    char *myenvp[] = { ""IFS= \t\n"", ""PATH=/bin:/usr/bin"", NULL };

    setreuid(geteuid(),geteuid());
    setregid(getegid(),getegid());
    argv[0] = SYMPA_NEWALIASES;
    return execve(SYMPA_NEWALIASES, argv, myenvp);
}","int main(int VAR_0, char **VAR_1, char **VAR_2) {
    char *VAR_3[] = { ""IFS= \t\n"", ""PATH=/bin:/usr/bin"", NULL };

    setreuid(geteuid(),geteuid());
    setregid(getegid(),getegid());
    VAR_1[0] = VAR_4;
    return execve(VAR_4, VAR_1, VAR_3);
}",sympa-community/sympa/3f8449c647e5ab32cf6f8837cb600c1756b6189c/sympa_newaliases-wrapper.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,8 @@
 int main(int argn, char **argv, char **envp) {
+    char *myenvp[] = { ""IFS= \t\n"", ""PATH=/bin:/usr/bin"", NULL };
+
     setreuid(geteuid(),geteuid());
     setregid(getegid(),getegid());
     argv[0] = SYMPA_NEWALIASES;
-    return execve(SYMPA_NEWALIASES, argv, envp);
+    return execve(SYMPA_NEWALIASES, argv, myenvp);
 }","{'deleted_lines': ['    return execve(SYMPA_NEWALIASES, argv, envp);'], 'added_lines': ['    char *myenvp[] = { ""IFS= \\t\\n"", ""PATH=/bin:/usr/bin"", NULL };', '', '    return execve(SYMPA_NEWALIASES, argv, myenvp);']}",True,Sympa through 6.2.57b.2 allows a local privilege escalation from the sympa user account to full root access by modifying the sympa.conf configuration file (which is owned by sympa) and parsing it through the setuid sympa_newaliases-wrapper executable.,7.8,HIGH,2,test,2020-03-27T12:28:18Z,3
CVE-2020-26880,['CWE-269'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,sympa-community/sympa,Sympa SA 2020-002 (candidate): Setuid wrappers should clear environment variables to avoid exploits.,3f8449c647e5ab32cf6f8837cb600c1756b6189c,https://github.com/sympa-community/sympa/commit/3f8449c647e5ab32cf6f8837cb600c1756b6189c,src/cgi/wwsympa-wrapper.fcgi.c,main,"int main(int argn, char **argv, char **envp) {
setreuid(geteuid(),geteuid());     setregid(getegid(),getegid());     argv[0] = WWSYMPA;
return execve(WWSYMPA,argv,envp);
}","int main(int VAR_0, char **VAR_1, char **VAR_2) {
setreuid(geteuid(),geteuid()); 
setregid(getegid(),getegid()); 
VAR_1[0] = VAR_3;
return execve(VAR_3,VAR_1,VAR_2);
}",sympa-community/sympa/3f8449c647e5ab32cf6f8837cb600c1756b6189c/wwsympa-wrapper.fcgi.c/vul/before/0.json,"int main(int argn, char **argv, char **envp) {
    char *myenvp[] = { ""IFS= \t\n"", ""PATH=/bin:/usr/bin"", NULL };

    setreuid(geteuid(),geteuid()); // Added to fix the segfault
    setregid(getegid(),getegid()); // Added to fix the segfault
    argv[0] = WWSYMPA;
    return execve(WWSYMPA, argv, myenvp);
}","int main(int VAR_0, char **VAR_1, char **VAR_2) {
    char *VAR_3[] = { ""IFS= \t\n"", ""PATH=/bin:/usr/bin"", NULL };

    setreuid(geteuid(),geteuid()); /* COMMENT_0 */
    setregid(getegid(),getegid()); /* COMMENT_0 */
    VAR_1[0] = VAR_4;
    return execve(VAR_4, VAR_1, VAR_3);
}",sympa-community/sympa/3f8449c647e5ab32cf6f8837cb600c1756b6189c/wwsympa-wrapper.fcgi.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,8 @@
 int main(int argn, char **argv, char **envp) {
+    char *myenvp[] = { ""IFS= \t\n"", ""PATH=/bin:/usr/bin"", NULL };
+
     setreuid(geteuid(),geteuid()); // Added to fix the segfault
     setregid(getegid(),getegid()); // Added to fix the segfault
     argv[0] = WWSYMPA;
-    return execve(WWSYMPA,argv,envp);
+    return execve(WWSYMPA, argv, myenvp);
 }","{'deleted_lines': ['    return execve(WWSYMPA,argv,envp);'], 'added_lines': ['    char *myenvp[] = { ""IFS= \\t\\n"", ""PATH=/bin:/usr/bin"", NULL };', '', '    return execve(WWSYMPA, argv, myenvp);']}",True,Sympa through 6.2.57b.2 allows a local privilege escalation from the sympa user account to full root access by modifying the sympa.conf configuration file (which is owned by sympa) and parsing it through the setuid sympa_newaliases-wrapper executable.,7.8,HIGH,2,test,2020-03-27T12:28:18Z,3
CVE-2020-13775,['CWE-476'],AV:N/AC:M/Au:S/C:N/I:N/A:P,0,znc,"Fix echo-message for *status

Close #1705",d229761821da38d984a9e4098ad96842490dc001,https://github.com/znc/znc/commit/d229761821da38d984a9e4098ad96842490dc001,src/Client.cpp,CClient::OnTextMessage,"bool CClient::OnTextMessage(CTextMessage& Message) {
CString sTargets = Message.GetTarget();
VCString vTargets;
sTargets.Split("","", vTargets, false);
for (CString& sTarget : vTargets) {
Message.SetTarget(sTarget);
if (m_pNetwork) {
Message.SetChan(m_pNetwork->FindChan(sTarget));
}
if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {
if (sTarget.Equals(""status"")) {
CString sMsg = Message.GetText();
UserCommand(sMsg);
} else {
CALLMOD(sTarget, this, m_pUser, m_pNetwork,
OnModCommand(Message.GetText()));
}
continue;
}
bool bContinue = false;
NETWORKMODULECALL(OnUserTextMessage(Message), m_pUser, m_pNetwork, this,
&bContinue);
if (bContinue) continue;
if (!GetIRCSock()) {
if (!sTarget.Equals(m_sNick))
PutStatus(
t_f(""Your message to {1} got lost, you are not connected ""
""to IRC!"")(Message.GetTarget()));
continue;
}
if (m_pNetwork) {
AddBuffer(Message);
EchoMessage(Message);
PutIRC(Message.ToString(CMessage::ExcludePrefix |
CMessage::ExcludeTags));
}
}
return true;
}","bool CClient::OnTextMessage(CTextMessage& VAR_0) {
CString VAR_1 = VAR_0.GetTarget();
VCString VAR_2;
VAR_1.Split("","", VAR_2, false);
for (CString& VAR_3 : VAR_2) {
VAR_0.SetTarget(VAR_3);
if (VAR_4) {
VAR_0.SetChan(VAR_4->FindChan(VAR_3));
}
if (VAR_3.TrimPrefix(VAR_5->GetStatusPrefix())) {
if (VAR_3.Equals(""status"")) {
CString VAR_6 = VAR_0.GetText();
UserCommand(VAR_6);
} else {
CALLMOD(VAR_3, this, VAR_5, VAR_4,
OnModCommand(VAR_0.GetText()));
}
continue;
}
bool VAR_7 = false;
NETWORKMODULECALL(OnUserTextMessage(VAR_0), VAR_5, VAR_4, this,
&VAR_7);
if (VAR_7) continue;
if (!GetIRCSock()) {
if (!VAR_3.Equals(VAR_8))
PutStatus(
t_f(""Your message to {1} got lost, you are not connected ""
""to IRC!"")(VAR_0.GetTarget()));
continue;
}
if (VAR_4) {
AddBuffer(VAR_0);
EchoMessage(VAR_0);
PutIRC(VAR_0.ToString(CMessage::ExcludePrefix |
CMessage::ExcludeTags));
}
}
return true;
}",znc/d229761821da38d984a9e4098ad96842490dc001/Client.cpp/vul/before/0.json,"bool CClient::OnTextMessage(CTextMessage& Message) {
    CString sTargets = Message.GetTarget();

    VCString vTargets;
    sTargets.Split("","", vTargets, false);

    for (CString& sTarget : vTargets) {
        Message.SetTarget(sTarget);
        if (m_pNetwork) {
            // May be nullptr.
            Message.SetChan(m_pNetwork->FindChan(sTarget));
        }

        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {
            EchoMessage(Message);

            if (sTarget.Equals(""status"")) {
                CString sMsg = Message.GetText();
                UserCommand(sMsg);
            } else {
                CALLMOD(sTarget, this, m_pUser, m_pNetwork,
                        OnModCommand(Message.GetText()));
            }
            continue;
        }

        bool bContinue = false;
        NETWORKMODULECALL(OnUserTextMessage(Message), m_pUser, m_pNetwork, this,
                          &bContinue);
        if (bContinue) continue;

        if (!GetIRCSock()) {
            // Some lagmeters do a PRIVMSG to their own nick, ignore those.
            if (!sTarget.Equals(m_sNick))
                PutStatus(
                    t_f(""Your message to {1} got lost, you are not connected ""
                        ""to IRC!"")(Message.GetTarget()));
            continue;
        }

        if (m_pNetwork) {
            AddBuffer(Message);
            EchoMessage(Message);
            PutIRC(Message.ToString(CMessage::ExcludePrefix |
                                    CMessage::ExcludeTags));
        }
    }

    return true;
}","bool CClient::OnTextMessage(CTextMessage& VAR_0) {
    CString VAR_1 = VAR_0.GetTarget();

    VCString VAR_2;
    VAR_1.Split("","", VAR_2, false);

    for (CString& VAR_3 : VAR_2) {
        VAR_0.SetTarget(VAR_3);
        if (VAR_4) {
            /* COMMENT_0 */
            VAR_0.SetChan(VAR_4->FindChan(VAR_3));
        }

        if (VAR_3.TrimPrefix(VAR_5->GetStatusPrefix())) {
            EchoMessage(VAR_0);

            if (VAR_3.Equals(""status"")) {
                CString VAR_6 = VAR_0.GetText();
                UserCommand(VAR_6);
            } else {
                CALLMOD(VAR_3, this, VAR_5, VAR_4,
                        OnModCommand(VAR_0.GetText()));
            }
            continue;
        }

        bool VAR_7 = false;
        NETWORKMODULECALL(OnUserTextMessage(VAR_0), VAR_5, VAR_4, this,
                          &VAR_7);
        if (VAR_7) continue;

        if (!GetIRCSock()) {
            /* COMMENT_1 */
            if (!VAR_3.Equals(VAR_8))
                PutStatus(
                    t_f(""Your message to {1} got lost, you are not connected ""
                        ""to IRC!"")(VAR_0.GetTarget()));
            continue;
        }

        if (VAR_4) {
            AddBuffer(VAR_0);
            EchoMessage(VAR_0);
            PutIRC(VAR_0.ToString(CMessage::ExcludePrefix |
                                    CMessage::ExcludeTags));
        }
    }

    return true;
}",znc/d229761821da38d984a9e4098ad96842490dc001/Client.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,8 @@
         }
 
         if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {
+            EchoMessage(Message);
+
             if (sTarget.Equals(""status"")) {
                 CString sMsg = Message.GetText();
                 UserCommand(sMsg);","{'deleted_lines': [], 'added_lines': ['            EchoMessage(Message);', '']}",True,ZNC 1.8.0 up to 1.8.1-rc1 allows authenticated users to trigger an application crash (with a NULL pointer dereference) if echo-message is not enabled and there is no network.,6.5,MEDIUM,1,test,2020-03-29T07:45:10Z,3
CVE-2020-13962,['CWE-Other'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,mumble-voip/mumble,"src/murmur/Server.cpp: implement workaround for critical QSslSocket issue

A severe bug was introduced in qt/qtbase@93a803a6de27d9eb57931c431b5f3d074914f693: q_SSL_shutdown() causes Qt to emit ""error()"" from unrelated QSslSocket(s), in addition to the correct one.

The issue causes Server::connectionClosed() to disconnect random authenticated clients.

The workaround consists in ignoring a specific OpenSSL error:
""Error while reading: error:140E0197:SSL routines:SSL_shutdown:shutdown while in init [20]""

Definitely not ideal, but it fixes a critical vulnerability. Details on how to trigger it are deliberately omitted.",a48aea18b6c7ee534cd21f7febfe253e31b33eda,https://github.com/mumble-voip/mumble/commit/a48aea18b6c7ee534cd21f7febfe253e31b33eda,src/murmur/Server.cpp,Server::connectionClosed,"void Server::connectionClosed(QAbstractSocket::SocketError err, const QString &reason) {
Connection *c = qobject_cast<Connection *>(sender());
if (! c)
return;
if (c->bDisconnectedEmitted)
return;
c->bDisconnectedEmitted = true;
ServerUser *u = static_cast<ServerUser *>(c);
log(u, QString(""Connection closed: %1 [%2]"").arg(reason).arg(err));
if (u->sState == ServerUser::Authenticated) {
MumbleProto::UserRemove mpur;
mpur.set_session(u->uiSession);
sendExcept(u, mpur);
emit userDisconnected(u);
}
Channel *old = u->cChannel;
{
QWriteLocker wl(&qrwlVoiceThread);
qhUsers.remove(u->uiSession);
qhHostUsers[u->haAddress].remove(u);
quint16 port = (u->saiUdpAddress.ss_family == AF_INET6) ? (reinterpret_cast<sockaddr_in6 *>(&u->saiUdpAddress)->sin6_port) : (reinterpret_cast<sockaddr_in *>(&u->saiUdpAddress)->sin_port);
const QPair<HostAddress, quint16> &key = QPair<HostAddress, quint16>(u->haAddress, port);
qhPeerUsers.remove(key);
if (old)
old->removeUser(u);
}
if (old && old->bTemporary && old->qlUsers.isEmpty())
QCoreApplication::instance()->postEvent(this, new ExecEvent(boost::bind(&Server::removeChannel, this, old->iId)));
if (static_cast<int>(u->uiSession) < iMaxUsers * 2)
qqIds.enqueue(u->uiSession); 
if (u->sState == ServerUser::Authenticated) {
clearTempGroups(u); recheckCodecVersions(); }
u->deleteLater();
if (qhUsers.isEmpty())
stopThread();
}","void Server::connectionClosed(QAbstractSocket::SocketError VAR_0, const QString &VAR_1) {
Connection *VAR_2 = VAR_3<Connection *>(sender());
if (! VAR_2)
return;
if (VAR_2->bDisconnectedEmitted)
return;
VAR_2->bDisconnectedEmitted = true;
ServerUser *VAR_4 = VAR_5<ServerUser *>(VAR_2);
log(VAR_4, QString(""Connection closed: %1 [%2]"").arg(VAR_1).arg(VAR_0));
if (VAR_4->sState == ServerUser::Authenticated) {
MumbleProto::UserRemove VAR_6;
VAR_6.set_session(VAR_4->uiSession);
sendExcept(VAR_4, VAR_6);
emit userDisconnected(u);
}
Channel *VAR_7 = u->cChannel;
{
QWriteLocker VAR_8(&VAR_9);
VAR_10.remove(u->uiSession);
VAR_11[u->haAddress].remove(u);
quint16 VAR_12 = (u->saiUdpAddress.ss_family == VAR_13) ? (VAR_14<sockaddr_in6 *>(&u->saiUdpAddress)->sin6_port) : (VAR_14<sockaddr_in *>(&u->saiUdpAddress)->sin_port);
const QPair<HostAddress, quint16> &VAR_15 = QPair<HostAddress, quint16>(u->haAddress, VAR_12);
VAR_16.remove(VAR_15);
if (VAR_7)
VAR_7->removeUser(u);
}
if (VAR_7 && VAR_7->bTemporary && VAR_7->qlUsers.isEmpty())
QCoreApplication::instance()->postEvent(this, new ExecEvent(boost::bind(&Server::removeChannel, this, VAR_7->iId)));
if (VAR_5<int>(u->uiSession) < VAR_17 * 2)
VAR_18.enqueue(u->uiSession); 
if (u->sState == ServerUser::Authenticated) {
clearTempGroups(u); 
recheckCodecVersions(); 
}
u->deleteLater();
if (VAR_10.isEmpty())
stopThread();
}",mumble-voip/mumble/a48aea18b6c7ee534cd21f7febfe253e31b33eda/Server.cpp/vul/before/0.json,"void Server::connectionClosed(QAbstractSocket::SocketError err, const QString &reason) {
	if (reason.contains(QLatin1String(""140E0197""))) {
		// A severe bug was introduced in qt/qtbase@93a803a6de27d9eb57931c431b5f3d074914f693.
		// q_SSL_shutdown() causes Qt to emit ""error()"" from unrelated QSslSocket(s), in addition to the correct one.
		// The issue causes this function to disconnect random authenticated clients.
		//
		// The workaround consists in ignoring a specific OpenSSL error:
		// ""Error while reading: error:140E0197:SSL routines:SSL_shutdown:shutdown while in init [20]""
		//
		// Definitely not ideal, but it fixes a critical vulnerability.
		qWarning(""Ignored OpenSSL error 140E0197 for %p"", sender());
		return;
	}

	Connection *c = qobject_cast<Connection *>(sender());
	if (! c)
		return;
	if (c->bDisconnectedEmitted)
		return;
	c->bDisconnectedEmitted = true;

	ServerUser *u = static_cast<ServerUser *>(c);

	log(u, QString(""Connection closed: %1 [%2]"").arg(reason).arg(err));

	if (u->sState == ServerUser::Authenticated) {
		MumbleProto::UserRemove mpur;
		mpur.set_session(u->uiSession);
		sendExcept(u, mpur);

		emit userDisconnected(u);
	}

	Channel *old = u->cChannel;

	{
		QWriteLocker wl(&qrwlVoiceThread);

		qhUsers.remove(u->uiSession);
		qhHostUsers[u->haAddress].remove(u);

		quint16 port = (u->saiUdpAddress.ss_family == AF_INET6) ? (reinterpret_cast<sockaddr_in6 *>(&u->saiUdpAddress)->sin6_port) : (reinterpret_cast<sockaddr_in *>(&u->saiUdpAddress)->sin_port);
		const QPair<HostAddress, quint16> &key = QPair<HostAddress, quint16>(u->haAddress, port);
		qhPeerUsers.remove(key);

		if (old)
			old->removeUser(u);
	}

	if (old && old->bTemporary && old->qlUsers.isEmpty())
		QCoreApplication::instance()->postEvent(this, new ExecEvent(boost::bind(&Server::removeChannel, this, old->iId)));

	if (static_cast<int>(u->uiSession) < iMaxUsers * 2)
		qqIds.enqueue(u->uiSession); // Reinsert session id into pool

	if (u->sState == ServerUser::Authenticated) {
		clearTempGroups(u); // Also clears ACL cache
		recheckCodecVersions(); // Maybe can choose a better codec now
	}

	u->deleteLater();

	if (qhUsers.isEmpty())
		stopThread();
}","void Server::connectionClosed(QAbstractSocket::SocketError VAR_0, const QString &VAR_1) {
	if (VAR_1.contains(QLatin1String(""140E0197""))) {
		/* COMMENT_0 */
		/* COMMENT_1 */
		/* COMMENT_2 */
		/* COMMENT_3 */
		/* COMMENT_4 */
		/* COMMENT_5 */
		/* COMMENT_3 */
		/* COMMENT_6 */
		qWarning(""Ignored OpenSSL error 140E0197 for %p"", sender());
		return;
	}

	Connection *VAR_2 = VAR_3<Connection *>(sender());
	if (! VAR_2)
		return;
	if (VAR_2->bDisconnectedEmitted)
		return;
	VAR_2->bDisconnectedEmitted = true;

	ServerUser *VAR_4 = VAR_5<ServerUser *>(VAR_2);

	log(VAR_4, QString(""Connection closed: %1 [%2]"").arg(VAR_1).arg(VAR_0));

	if (VAR_4->sState == ServerUser::Authenticated) {
		MumbleProto::UserRemove VAR_6;
		VAR_6.set_session(VAR_4->uiSession);
		sendExcept(VAR_4, VAR_6);

		emit userDisconnected(u);
	}

	Channel *VAR_7 = u->cChannel;

	{
		QWriteLocker VAR_8(&VAR_9);

		VAR_10.remove(u->uiSession);
		VAR_11[u->haAddress].remove(u);

		quint16 VAR_12 = (u->saiUdpAddress.ss_family == VAR_13) ? (VAR_14<sockaddr_in6 *>(&u->saiUdpAddress)->sin6_port) : (VAR_14<sockaddr_in *>(&u->saiUdpAddress)->sin_port);
		const QPair<HostAddress, quint16> &VAR_15 = QPair<HostAddress, quint16>(u->haAddress, VAR_12);
		VAR_16.remove(VAR_15);

		if (VAR_7)
			VAR_7->removeUser(u);
	}

	if (VAR_7 && VAR_7->bTemporary && VAR_7->qlUsers.isEmpty())
		QCoreApplication::instance()->postEvent(this, new ExecEvent(boost::bind(&Server::removeChannel, this, VAR_7->iId)));

	if (VAR_5<int>(u->uiSession) < VAR_17 * 2)
		VAR_18.enqueue(u->uiSession); /* COMMENT_7 */

	if (u->sState == ServerUser::Authenticated) {
		clearTempGroups(u); /* COMMENT_8 */
		recheckCodecVersions(); /* COMMENT_9 */
	}

	u->deleteLater();

	if (VAR_10.isEmpty())
		stopThread();
}",mumble-voip/mumble/a48aea18b6c7ee534cd21f7febfe253e31b33eda/Server.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,17 @@
 void Server::connectionClosed(QAbstractSocket::SocketError err, const QString &reason) {
+	if (reason.contains(QLatin1String(""140E0197""))) {
+		// A severe bug was introduced in qt/qtbase@93a803a6de27d9eb57931c431b5f3d074914f693.
+		// q_SSL_shutdown() causes Qt to emit ""error()"" from unrelated QSslSocket(s), in addition to the correct one.
+		// The issue causes this function to disconnect random authenticated clients.
+		//
+		// The workaround consists in ignoring a specific OpenSSL error:
+		// ""Error while reading: error:140E0197:SSL routines:SSL_shutdown:shutdown while in init [20]""
+		//
+		// Definitely not ideal, but it fixes a critical vulnerability.
+		qWarning(""Ignored OpenSSL error 140E0197 for %p"", sender());
+		return;
+	}
+
 	Connection *c = qobject_cast<Connection *>(sender());
 	if (! c)
 		return;","{'deleted_lines': [], 'added_lines': ['\tif (reason.contains(QLatin1String(""140E0197""))) {', '\t\t// A severe bug was introduced in qt/qtbase@93a803a6de27d9eb57931c431b5f3d074914f693.', '\t\t// q_SSL_shutdown() causes Qt to emit ""error()"" from unrelated QSslSocket(s), in addition to the correct one.', '\t\t// The issue causes this function to disconnect random authenticated clients.', '\t\t//', '\t\t// The workaround consists in ignoring a specific OpenSSL error:', '\t\t// ""Error while reading: error:140E0197:SSL routines:SSL_shutdown:shutdown while in init [20]""', '\t\t//', '\t\t// Definitely not ideal, but it fixes a critical vulnerability.', '\t\tqWarning(""Ignored OpenSSL error 140E0197 for %p"", sender());', '\t\treturn;', '\t}', '']}",True,"Qt 5.12.2 through 5.14.2, as used in unofficial builds of Mumble 1.3.0 and other products, mishandles OpenSSL's error queue, which can cause a denial of service to QSslSocket users. Because errors leak in unrelated TLS sessions, an unrelated session may be disconnected when any handshake fails. (Mumble 1.3.1 is not affected, regardless of the Qt version.)",7.5,HIGH,2,test,2020-04-04T05:48:46Z,3
CVE-2020-8037,['CWE-770'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,the-tcpdump-group/tcpdump,"PPP: When un-escaping, don't allocate a too-large buffer.

The buffer should be big enough to hold the captured data, but it
doesn't need to be big enough to hold the entire on-the-network packet,
if we haven't captured all of it.

(backported from commit e4add0b010ed6f2180dcb05a13026242ed935334)",32027e199368dad9508965aae8cd8de5b6ab5231,https://github.com/the-tcpdump-group/tcpdump/commit/32027e199368dad9508965aae8cd8de5b6ab5231,print-ppp.c,ppp_hdlc,"static void
ppp_hdlc(netdissect_options *ndo,
const u_char *p, int length)
{
u_char *b, *t, c;
const u_char *s;
int i, proto;
const void *se;
if (length <= 0)
return;
b = (u_char *)malloc(length);
if (b == NULL)
return;
for (s = p, t = b, i = length; i > 0 && ND_TTEST(*s); i--) {
c = *s++;
if (c == 0x7d) {
if (i <= 1 || !ND_TTEST(*s))
break;
i--;
c = *s++ ^ 0x20;
}
*t++ = c;
}
se = ndo->ndo_snapend;
ndo->ndo_snapend = t;
length = t - b;
if (length < 1)
goto trunc;
proto = *b; 
switch (proto) {
case PPP_IP:
ip_print(ndo, b + 1, length - 1);
goto cleanup;
case PPP_IPV6:
ip6_print(ndo, b + 1, length - 1);
goto cleanup;
default: 
break;
}
if (length < 2)
goto trunc;
proto = EXTRACT_16BITS(b); 
switch (proto) {
case (PPP_ADDRESS << 8 | PPP_CONTROL): 
if (length < 4)
goto trunc;
proto = EXTRACT_16BITS(b+2); 
handle_ppp(ndo, proto, b + 4, length - 4);
break;
default: 
handle_ppp(ndo, proto, b + 2, length - 2);
break;
}
cleanup:
ndo->ndo_snapend = se;
free(b);
return;
trunc:
ndo->ndo_snapend = se;
free(b);
ND_PRINT((ndo, ""[|ppp]""));
}","static void
ppp_hdlc(netdissect_options *VAR_0,
const u_char *VAR_1, int VAR_2)
{
u_char *VAR_3, *VAR_4, VAR_5;
const u_char *VAR_6;
int VAR_7, VAR_8;
const void *VAR_9;
if (VAR_2 <= 0)
return;
VAR_3 = (u_char *)malloc(VAR_2);
if (VAR_3 == NULL)
return;
for (VAR_6 = VAR_1, VAR_4 = VAR_3, VAR_7 = VAR_2; VAR_7 > 0 && ND_TTEST(*VAR_6); VAR_7--) {
VAR_5 = *VAR_6++;
if (VAR_5 == 0x7d) {
if (VAR_7 <= 1 || !ND_TTEST(*VAR_6))
break;
VAR_7--;
VAR_5 = *VAR_6++ ^ 0x20;
}
*VAR_4++ = VAR_5;
}
VAR_9 = VAR_0->ndo_snapend;
VAR_0->ndo_snapend = VAR_4;
VAR_2 = VAR_4 - VAR_3;
if (VAR_2 < 1)
goto trunc;
VAR_8 = *VAR_3; 
switch (VAR_8) {
case VAR_10:
ip_print(VAR_0, VAR_3 + 1, VAR_2 - 1);
goto cleanup;
case VAR_11:
ip6_print(VAR_0, VAR_3 + 1, VAR_2 - 1);
goto cleanup;
default: 
break;
}
if (VAR_2 < 2)
goto trunc;
VAR_8 = EXTRACT_16BITS(VAR_3); 
switch (VAR_8) {
case (VAR_12 << 8 | VAR_13): 
if (VAR_2 < 4)
goto trunc;
VAR_8 = EXTRACT_16BITS(VAR_3+2); 
handle_ppp(VAR_0, VAR_8, VAR_3 + 4, VAR_2 - 4);
break;
default: 
handle_ppp(VAR_0, VAR_8, VAR_3 + 2, VAR_2 - 2);
break;
}
cleanup:
VAR_0->ndo_snapend = VAR_9;
free(VAR_3);
return;
trunc:
VAR_0->ndo_snapend = VAR_9;
free(VAR_3);
ND_PRINT((VAR_0, ""[|ppp]""));
}",the-tcpdump-group/tcpdump/32027e199368dad9508965aae8cd8de5b6ab5231/print-ppp.c/vul/before/0.json,"static void
ppp_hdlc(netdissect_options *ndo,
         const u_char *p, int length)
{
	u_int caplen = ndo->ndo_snapend - p;
	u_char *b, *t, c;
	const u_char *s;
	u_int i;
	int proto;
	const void *se;

	if (caplen == 0)
		return;

        if (length <= 0)
                return;

	b = (u_char *)malloc(caplen);
	if (b == NULL)
		return;

	/*
	 * Unescape all the data into a temporary, private, buffer.
	 * Do this so that we dont overwrite the original packet
	 * contents.
	 */
	for (s = p, t = b, i = caplen; i != 0; i--) {
		c = *s++;
		if (c == 0x7d) {
			if (i <= 1)
				break;
			i--;
			c = *s++ ^ 0x20;
		}
		*t++ = c;
	}

	se = ndo->ndo_snapend;
	ndo->ndo_snapend = t;
	length = t - b;

        /* now lets guess about the payload codepoint format */
        if (length < 1)
                goto trunc;
        proto = *b; /* start with a one-octet codepoint guess */

        switch (proto) {
        case PPP_IP:
		ip_print(ndo, b + 1, length - 1);
		goto cleanup;
        case PPP_IPV6:
		ip6_print(ndo, b + 1, length - 1);
		goto cleanup;
        default: /* no luck - try next guess */
		break;
        }

        if (length < 2)
                goto trunc;
        proto = EXTRACT_16BITS(b); /* next guess - load two octets */

        switch (proto) {
        case (PPP_ADDRESS << 8 | PPP_CONTROL): /* looks like a PPP frame */
            if (length < 4)
                goto trunc;
            proto = EXTRACT_16BITS(b+2); /* load the PPP proto-id */
            handle_ppp(ndo, proto, b + 4, length - 4);
            break;
        default: /* last guess - proto must be a PPP proto-id */
            handle_ppp(ndo, proto, b + 2, length - 2);
            break;
        }

cleanup:
	ndo->ndo_snapend = se;
	free(b);
        return;

trunc:
	ndo->ndo_snapend = se;
	free(b);
	ND_PRINT((ndo, ""[|ppp]""));
}","static void
ppp_hdlc(netdissect_options *VAR_0,
         const u_char *VAR_1, int VAR_2)
{
	u_int VAR_3 = VAR_0->ndo_snapend - VAR_1;
	u_char *VAR_4, *VAR_5, VAR_6;
	const u_char *VAR_7;
	u_int VAR_8;
	int VAR_9;
	const void *VAR_10;

	if (VAR_3 == 0)
		return;

        if (VAR_2 <= 0)
                return;

	VAR_4 = (u_char *)malloc(VAR_3);
	if (VAR_4 == NULL)
		return;

	/* COMMENT_0 */
                                                            
                                                         
             
    
	for (VAR_7 = VAR_1, VAR_5 = VAR_4, VAR_8 = VAR_3; VAR_8 != 0; VAR_8--) {
		VAR_6 = *VAR_7++;
		if (VAR_6 == 0x7d) {
			if (VAR_8 <= 1)
				break;
			VAR_8--;
			VAR_6 = *VAR_7++ ^ 0x20;
		}
		*VAR_5++ = VAR_6;
	}

	VAR_10 = VAR_0->ndo_snapend;
	VAR_0->ndo_snapend = VAR_5;
	VAR_2 = VAR_5 - VAR_4;

        /* COMMENT_5 */
        if (VAR_2 < 1)
                goto trunc;
        VAR_9 = *VAR_4; /* COMMENT_6 */

        switch (VAR_9) {
        case VAR_11:
		ip_print(VAR_0, VAR_4 + 1, VAR_2 - 1);
		goto cleanup;
        case VAR_12:
		ip6_print(VAR_0, VAR_4 + 1, VAR_2 - 1);
		goto cleanup;
        default: /* COMMENT_7 */
		break;
        }

        if (VAR_2 < 2)
                goto trunc;
        VAR_9 = EXTRACT_16BITS(VAR_4); /* COMMENT_8 */

        switch (VAR_9) {
        case (VAR_13 << 8 | VAR_14): /* COMMENT_9 */
            if (VAR_2 < 4)
                goto trunc;
            VAR_9 = EXTRACT_16BITS(VAR_4+2); /* COMMENT_10 */
            handle_ppp(VAR_0, VAR_9, VAR_4 + 4, VAR_2 - 4);
            break;
        default: /* COMMENT_11 */
            handle_ppp(VAR_0, VAR_9, VAR_4 + 2, VAR_2 - 2);
            break;
        }

cleanup:
	VAR_0->ndo_snapend = VAR_10;
	free(VAR_4);
        return;

trunc:
	VAR_0->ndo_snapend = VAR_10;
	free(VAR_4);
	ND_PRINT((VAR_0, ""[|ppp]""));
}",the-tcpdump-group/tcpdump/32027e199368dad9508965aae8cd8de5b6ab5231/print-ppp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,15 +2,20 @@
 ppp_hdlc(netdissect_options *ndo,
          const u_char *p, int length)
 {
+	u_int caplen = ndo->ndo_snapend - p;
 	u_char *b, *t, c;
 	const u_char *s;
-	int i, proto;
+	u_int i;
+	int proto;
 	const void *se;
+
+	if (caplen == 0)
+		return;
 
         if (length <= 0)
                 return;
 
-	b = (u_char *)malloc(length);
+	b = (u_char *)malloc(caplen);
 	if (b == NULL)
 		return;
 
@@ -19,10 +24,10 @@
 	 * Do this so that we dont overwrite the original packet
 	 * contents.
 	 */
-	for (s = p, t = b, i = length; i > 0 && ND_TTEST(*s); i--) {
+	for (s = p, t = b, i = caplen; i != 0; i--) {
 		c = *s++;
 		if (c == 0x7d) {
-			if (i <= 1 || !ND_TTEST(*s))
+			if (i <= 1)
 				break;
 			i--;
 			c = *s++ ^ 0x20;","{'deleted_lines': ['\tint i, proto;', '\tb = (u_char *)malloc(length);', '\tfor (s = p, t = b, i = length; i > 0 && ND_TTEST(*s); i--) {', '\t\t\tif (i <= 1 || !ND_TTEST(*s))'], 'added_lines': ['\tu_int caplen = ndo->ndo_snapend - p;', '\tu_int i;', '\tint proto;', '', '\tif (caplen == 0)', '\t\treturn;', '\tb = (u_char *)malloc(caplen);', '\tfor (s = p, t = b, i = caplen; i != 0; i--) {', '\t\t\tif (i <= 1)']}",True,The ppp decapsulator in tcpdump 4.9.3 can be convinced to allocate a large amount of memory.,7.5,HIGH,2,test,2020-04-18T21:04:59Z,3
CVE-2020-12649,['CWE-22'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0,sirdude/gurbalib,"update help.c to fix security bug

path traversal in help.c allows administrative paths to be read",2c0e744927d4aaa5c5f1b5d4b5405104350f5f83,https://github.com/sirdude/gurbalib/commit/2c0e744927d4aaa5c5f1b5d4b5405104350f5f83,lib/cmds/player/help.c,main,"static void main(string arg) {
string file;
if (!alsos) {
setup_alsos();
}
if (empty_str(arg) || (arg == ""help"")) {
this_player()->more(usage());
return;
}
if (sscanf(arg, ""-%s"", arg)) {
this_player()->more(usage());
return;
}
file = normalize_path(arg, ""/doc/help/"");
if (show_help(file)) {
return;
}
if (query_wizard(this_player())) {
file = normalize_path(arg, ""/doc/help/wiz/"");
if (show_help(file)) {
return;
}
}
if (show_help_for_command(arg)) {
return;
}
write(capitalize(arg) + "": Unknown help topic."");
if (query_wizard(this_player())) {
write(""Try one of the following for more info:\n"");
write(""\tman "" + arg + ""\n"");
write(""\t"" + arg + "" -h\n"");
} else {
write(""If "" + arg + "" is a command, for more info try: "" + 
arg + "" -h\n"");
}
LOG_D->write_log(""help"", this_player()->query_Name() +
"" on "" + ctime(time()) + "": "" + arg + ""\n"");
return;
}","static void main(string VAR_0) {
string VAR_1;
if (!VAR_2) {
setup_alsos();
}
if (empty_str(VAR_0) || (VAR_0 == ""help"")) {
this_player()->more(usage());
return;
}
if (sscanf(VAR_0, ""-%s"", VAR_0)) {
this_player()->more(usage());
return;
}
VAR_1 = normalize_path(VAR_0, ""/doc/help/"");
if (show_help(VAR_1)) {
return;
}
if (query_wizard(this_player())) {
VAR_1 = normalize_path(VAR_0, ""/doc/help/wiz/"");
if (show_help(VAR_1)) {
return;
}
}
if (show_help_for_command(VAR_0)) {
return;
}
write(capitalize(VAR_0) + "": Unknown help topic."");
if (query_wizard(this_player())) {
write(""Try one of the following for more info:\n"");
write(""\tman "" + VAR_0 + ""\n"");
write(""\t"" + VAR_0 + "" -h\n"");
} else {
write(""If "" + VAR_0 + "" is a command, for more info try: "" + 
VAR_0 + "" -h\n"");
}
VAR_3->write_log(""help"", this_player()->query_Name() +
"" on "" + ctime(time()) + "": "" + VAR_0 + ""\n"");
return;
}",sirdude/gurbalib/2c0e744927d4aaa5c5f1b5d4b5405104350f5f83/help.c/vul/before/0.json,"static void main(string arg) {
   string file, *exparg;
   int szof;
   
   /* remove capability of path traversal */
   /* discoverd by David Byrne of X-Force Red */
   if (szof > 1) {
      return 1;
   }

   if (!alsos) {
      setup_alsos();
   }

   if (empty_str(arg) || (arg == ""help"")) {
      this_player()->more(usage());
      return;
   }

   if (sscanf(arg, ""-%s"", arg)) {
      this_player()->more(usage());
      return;
   }

   file = normalize_path(arg, ""/doc/help/"");
   if (show_help(file)) {
      return;
   }

   if (query_wizard(this_player())) {
      file = normalize_path(arg, ""/doc/help/wiz/"");
      if (show_help(file)) {
         return;
      }
   }

   if (show_help_for_command(arg)) {
      return;
   }

   write(capitalize(arg) + "": Unknown help topic."");
   if (query_wizard(this_player())) {
      write(""Try one of the following for more info:\n"");
      write(""\tman "" + arg + ""\n"");
      write(""\t"" + arg + "" -h\n"");
   } else {
      write(""If "" + arg + "" is a command, for more info try: "" + 
         arg + "" -h\n"");
   }
   LOG_D->write_log(""help"", this_player()->query_Name() +
      "" on "" + ctime(time()) + "": "" + arg + ""\n"");
   return;
}","static void main(string VAR_0) {
   string VAR_1, *VAR_2;
   int VAR_3;
   
   /* COMMENT_0 */
   /* COMMENT_1 */
   if (VAR_3 > 1) {
      return 1;
   }

   if (!VAR_4) {
      setup_alsos();
   }

   if (empty_str(VAR_0) || (VAR_0 == ""help"")) {
      this_player()->more(usage());
      return;
   }

   if (sscanf(VAR_0, ""-%s"", VAR_0)) {
      this_player()->more(usage());
      return;
   }

   VAR_1 = normalize_path(VAR_0, ""/doc/help/"");
   if (show_help(VAR_1)) {
      return;
   }

   if (query_wizard(this_player())) {
      VAR_1 = normalize_path(VAR_0, ""/doc/help/wiz/"");
      if (show_help(VAR_1)) {
         return;
      }
   }

   if (show_help_for_command(VAR_0)) {
      return;
   }

   write(capitalize(VAR_0) + "": Unknown help topic."");
   if (query_wizard(this_player())) {
      write(""Try one of the following for more info:\n"");
      write(""\tman "" + VAR_0 + ""\n"");
      write(""\t"" + VAR_0 + "" -h\n"");
   } else {
      write(""If "" + VAR_0 + "" is a command, for more info try: "" + 
         VAR_0 + "" -h\n"");
   }
   VAR_5->write_log(""help"", this_player()->query_Name() +
      "" on "" + ctime(time()) + "": "" + VAR_0 + ""\n"");
   return;
}",sirdude/gurbalib/2c0e744927d4aaa5c5f1b5d4b5405104350f5f83/help.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,12 @@
 static void main(string arg) {
-   string file;
+   string file, *exparg;
+   int szof;
+   
+   /* remove capability of path traversal */
+   /* discoverd by David Byrne of X-Force Red */
+   if (szof > 1) {
+      return 1;
+   }
 
    if (!alsos) {
       setup_alsos();","{'deleted_lines': ['   string file;'], 'added_lines': ['   string file, *exparg;', '   int szof;', '   ', '   /* remove capability of path traversal */', '   /* discoverd by David Byrne of X-Force Red */', '   if (szof > 1) {', '      return 1;', '   }']}",True,Gurbalib through 2020-04-30 allows lib/cmds/player/help.c directory traversal for reading administrative paths.,7.5,HIGH,2,test,2020-05-03T00:19:44Z,3
CVE-2020-36277,['CWE-670'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,DanBloomberg/leptonica,"Fix heap buffer overflow in selReadStream

selio_reg triggers a heap buffer overflow when sscanf tries to write 201 bytes into a 24 byte string.
It can be detected when the code is compiled with the address sanitizer:

    ==19856==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000001288 at pc 0x00000044462b bp 0x7fffffffddf0 sp 0x7fffffffd5a0
    WRITE of size 201 at 0x603000001288 thread T0
    0x603000001288 is located 0 bytes to the right of 24-byte region [0x603000001270,0x603000001288)

Signed-off-by: Stefan Weil <sw@weilnetz.de>",3ddd9a35cebc28f2b1a5693c27dcfff58218674a,https://github.com/DanBloomberg/leptonica/commit/3ddd9a35cebc28f2b1a5693c27dcfff58218674a,src/sel1.c,selReadStream,"SEL  *
selReadStream(FILE  *fp)
{
char    *selname;
char     linebuf[256];
l_int32  sy, sx, cy, cx, i, j, version, ignore;
SEL     *sel;
PROCNAME(""selReadStream"");
if (!fp)
return (SEL *)ERROR_PTR(""stream not defined"", procName, NULL);
if (fscanf(fp, ""  Sel Version %d\n"", &version) != 1)
return (SEL *)ERROR_PTR(""not a sel file"", procName, NULL);
if (version != SEL_VERSION_NUMBER)
return (SEL *)ERROR_PTR(""invalid sel version"", procName, NULL);
if (fgets(linebuf, sizeof(linebuf), fp) == NULL)
return (SEL *)ERROR_PTR(""error reading into linebuf"", procName, NULL);
selname = stringNew(linebuf);
sscanf(linebuf, ""  ------  %200s  ------"", selname);
if (fscanf(fp, ""  sy = %d, sx = %d, cy = %d, cx = %d\n"",
&sy, &sx, &cy, &cx) != 4) {
LEPT_FREE(selname);
return (SEL *)ERROR_PTR(""dimensions not read"", procName, NULL);
}
if ((sel = selCreate(sy, sx, selname)) == NULL) {
LEPT_FREE(selname);
return (SEL *)ERROR_PTR(""sel not made"", procName, NULL);
}
selSetOrigin(sel, cy, cx);
for (i = 0; i < sy; i++) {
ignore = fscanf(fp, ""    "");
for (j = 0; j < sx; j++)
ignore = fscanf(fp, ""%1d"", &sel->data[i][j]);
ignore = fscanf(fp, ""\n"");
}
ignore = fscanf(fp, ""\n"");
LEPT_FREE(selname);
return sel;
}","SEL  *
selReadStream(FILE  *VAR_0)
{
char    *VAR_1;
char     VAR_2[256];
l_int32  VAR_3, VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10;
SEL     *VAR_11;
PROCNAME(""selReadStream"");
if (!VAR_0)
return (SEL *)ERROR_PTR(""stream not defined"", VAR_12, NULL);
if (fscanf(VAR_0, ""  Sel Version %d\n"", &VAR_9) != 1)
return (SEL *)ERROR_PTR(""not a sel file"", VAR_12, NULL);
if (VAR_9 != VAR_13)
return (SEL *)ERROR_PTR(""invalid sel version"", VAR_12, NULL);
if (fgets(VAR_2, sizeof(VAR_2), VAR_0) == NULL)
return (SEL *)ERROR_PTR(""error reading into linebuf"", VAR_12, NULL);
VAR_1 = stringNew(VAR_2);
sscanf(VAR_2, ""  ------  %200s  ------"", VAR_1);
if (fscanf(VAR_0, ""  sy = %d, sx = %d, cy = %d, cx = %d\n"",
&VAR_3, &VAR_4, &VAR_5, &VAR_6) != 4) {
LEPT_FREE(VAR_1);
return (SEL *)ERROR_PTR(""dimensions not read"", VAR_12, NULL);
}
if ((VAR_11 = selCreate(VAR_3, VAR_4, VAR_1)) == NULL) {
LEPT_FREE(VAR_1);
return (SEL *)ERROR_PTR(""sel not made"", VAR_12, NULL);
}
selSetOrigin(VAR_11, VAR_5, VAR_6);
for (VAR_7 = 0; VAR_7 < VAR_3; VAR_7++) {
VAR_10 = fscanf(VAR_0, ""    "");
for (VAR_8 = 0; VAR_8 < VAR_4; VAR_8++)
VAR_10 = fscanf(VAR_0, ""%1d"", &VAR_11->data[VAR_7][VAR_8]);
VAR_10 = fscanf(VAR_0, ""\n"");
}
VAR_10 = fscanf(VAR_0, ""\n"");
LEPT_FREE(VAR_1);
return VAR_11;
}",DanBloomberg/leptonica/3ddd9a35cebc28f2b1a5693c27dcfff58218674a/sel1.c/vul/before/0.json,"SEL  *
selReadStream(FILE  *fp)
{
char     selname[256];
char     linebuf[256];
l_int32  sy, sx, cy, cx, i, j, version, ignore;
SEL     *sel;

    PROCNAME(""selReadStream"");

    if (!fp)
        return (SEL *)ERROR_PTR(""stream not defined"", procName, NULL);

    if (fscanf(fp, ""  Sel Version %d\n"", &version) != 1)
        return (SEL *)ERROR_PTR(""not a sel file"", procName, NULL);
    if (version != SEL_VERSION_NUMBER)
        return (SEL *)ERROR_PTR(""invalid sel version"", procName, NULL);

    if (fgets(linebuf, sizeof(linebuf), fp) == NULL)
        return (SEL *)ERROR_PTR(""error reading into linebuf"", procName, NULL);
    sscanf(linebuf, ""  ------  %200s  ------"", selname);

    if (fscanf(fp, ""  sy = %d, sx = %d, cy = %d, cx = %d\n"",
            &sy, &sx, &cy, &cx) != 4) {
        return (SEL *)ERROR_PTR(""dimensions not read"", procName, NULL);
    }

    if ((sel = selCreate(sy, sx, selname)) == NULL) {
        return (SEL *)ERROR_PTR(""sel not made"", procName, NULL);
    }
    selSetOrigin(sel, cy, cx);

    for (i = 0; i < sy; i++) {
        ignore = fscanf(fp, ""    "");
        for (j = 0; j < sx; j++)
            ignore = fscanf(fp, ""%1d"", &sel->data[i][j]);
        ignore = fscanf(fp, ""\n"");
    }
    ignore = fscanf(fp, ""\n"");

    return sel;
}","SEL  *
selReadStream(FILE  *VAR_0)
{
char     VAR_1[256];
char     VAR_2[256];
l_int32  VAR_3, VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10;
SEL     *VAR_11;

    PROCNAME(""selReadStream"");

    if (!VAR_0)
        return (SEL *)ERROR_PTR(""stream not defined"", VAR_12, NULL);

    if (fscanf(VAR_0, ""  Sel Version %d\n"", &VAR_9) != 1)
        return (SEL *)ERROR_PTR(""not a sel file"", VAR_12, NULL);
    if (VAR_9 != VAR_13)
        return (SEL *)ERROR_PTR(""invalid sel version"", VAR_12, NULL);

    if (fgets(VAR_2, sizeof(VAR_2), VAR_0) == NULL)
        return (SEL *)ERROR_PTR(""error reading into linebuf"", VAR_12, NULL);
    sscanf(VAR_2, ""  ------  %200s  ------"", VAR_1);

    if (fscanf(VAR_0, ""  sy = %d, sx = %d, cy = %d, cx = %d\n"",
            &VAR_3, &VAR_4, &VAR_5, &VAR_6) != 4) {
        return (SEL *)ERROR_PTR(""dimensions not read"", VAR_12, NULL);
    }

    if ((VAR_11 = selCreate(VAR_3, VAR_4, VAR_1)) == NULL) {
        return (SEL *)ERROR_PTR(""sel not made"", VAR_12, NULL);
    }
    selSetOrigin(VAR_11, VAR_5, VAR_6);

    for (VAR_7 = 0; VAR_7 < VAR_3; VAR_7++) {
        VAR_10 = fscanf(VAR_0, ""    "");
        for (VAR_8 = 0; VAR_8 < VAR_4; VAR_8++)
            VAR_10 = fscanf(VAR_0, ""%1d"", &VAR_11->data[VAR_7][VAR_8]);
        VAR_10 = fscanf(VAR_0, ""\n"");
    }
    VAR_10 = fscanf(VAR_0, ""\n"");

    return VAR_11;
}",DanBloomberg/leptonica/3ddd9a35cebc28f2b1a5693c27dcfff58218674a/sel1.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 SEL  *
 selReadStream(FILE  *fp)
 {
-char    *selname;
+char     selname[256];
 char     linebuf[256];
 l_int32  sy, sx, cy, cx, i, j, version, ignore;
 SEL     *sel;
@@ -18,17 +18,14 @@
 
     if (fgets(linebuf, sizeof(linebuf), fp) == NULL)
         return (SEL *)ERROR_PTR(""error reading into linebuf"", procName, NULL);
-    selname = stringNew(linebuf);
     sscanf(linebuf, ""  ------  %200s  ------"", selname);
 
     if (fscanf(fp, ""  sy = %d, sx = %d, cy = %d, cx = %d\n"",
             &sy, &sx, &cy, &cx) != 4) {
-        LEPT_FREE(selname);
         return (SEL *)ERROR_PTR(""dimensions not read"", procName, NULL);
     }
 
     if ((sel = selCreate(sy, sx, selname)) == NULL) {
-        LEPT_FREE(selname);
         return (SEL *)ERROR_PTR(""sel not made"", procName, NULL);
     }
     selSetOrigin(sel, cy, cx);
@@ -41,6 +38,5 @@
     }
     ignore = fscanf(fp, ""\n"");
 
-    LEPT_FREE(selname);
     return sel;
 }","{'deleted_lines': ['char    *selname;', '    selname = stringNew(linebuf);', '        LEPT_FREE(selname);', '        LEPT_FREE(selname);', '    LEPT_FREE(selname);'], 'added_lines': ['char     selname[256];']}",True,Leptonica before 1.80.0 allows a denial of service (application crash) via an incorrect left shift in pixConvert2To8 in pixconv.c.,7.5,HIGH,2,test,2020-05-03T14:14:20Z,3
CVE-2020-12649,['CWE-22'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0,sirdude/gurbalib,"Update help.c

added missing parts of the pr, sorry about that",220ec8cceaff2e3bda20f09164a6a96654957840,https://github.com/sirdude/gurbalib/commit/220ec8cceaff2e3bda20f09164a6a96654957840,lib/cmds/player/help.c,main,"static void main(string arg) {
string file, *exparg;
int szof;
if (szof > 1) {
return 1;
}
if (!alsos) {
setup_alsos();
}
if (empty_str(arg) || (arg == ""help"")) {
this_player()->more(usage());
return;
}
if (sscanf(arg, ""-%s"", arg)) {
this_player()->more(usage());
return;
}
file = normalize_path(arg, ""/doc/help/"");
if (show_help(file)) {
return;
}
if (query_wizard(this_player())) {
file = normalize_path(arg, ""/doc/help/wiz/"");
if (show_help(file)) {
return;
}
}
if (show_help_for_command(arg)) {
return;
}
write(capitalize(arg) + "": Unknown help topic."");
if (query_wizard(this_player())) {
write(""Try one of the following for more info:\n"");
write(""\tman "" + arg + ""\n"");
write(""\t"" + arg + "" -h\n"");
} else {
write(""If "" + arg + "" is a command, for more info try: "" + 
arg + "" -h\n"");
}
LOG_D->write_log(""help"", this_player()->query_Name() +
"" on "" + ctime(time()) + "": "" + arg + ""\n"");
return;
}","static void main(string VAR_0) {
string VAR_1, *VAR_2;
int VAR_3;
if (VAR_3 > 1) {
return 1;
}
if (!VAR_4) {
setup_alsos();
}
if (empty_str(VAR_0) || (VAR_0 == ""help"")) {
this_player()->more(usage());
return;
}
if (sscanf(VAR_0, ""-%s"", VAR_0)) {
this_player()->more(usage());
return;
}
VAR_1 = normalize_path(VAR_0, ""/doc/help/"");
if (show_help(VAR_1)) {
return;
}
if (query_wizard(this_player())) {
VAR_1 = normalize_path(VAR_0, ""/doc/help/wiz/"");
if (show_help(VAR_1)) {
return;
}
}
if (show_help_for_command(VAR_0)) {
return;
}
write(capitalize(VAR_0) + "": Unknown help topic."");
if (query_wizard(this_player())) {
write(""Try one of the following for more info:\n"");
write(""\tman "" + VAR_0 + ""\n"");
write(""\t"" + VAR_0 + "" -h\n"");
} else {
write(""If "" + VAR_0 + "" is a command, for more info try: "" + 
VAR_0 + "" -h\n"");
}
VAR_5->write_log(""help"", this_player()->query_Name() +
"" on "" + ctime(time()) + "": "" + VAR_0 + ""\n"");
return;
}",sirdude/gurbalib/220ec8cceaff2e3bda20f09164a6a96654957840/help.c/vul/before/0.json,"static void main(string arg) {
   string file, *exparg;
   int szof;
   
   /* remove capability of path traversal */
   /* discoverd by David Byrne of X-Force Red */
   exparg = explode(arg, ""/"");
   szof = sizeof(exparg);
   if (szof > 1) {
      return 1;
   }

   if (!alsos) {
      setup_alsos();
   }

   if (empty_str(arg) || (arg == ""help"")) {
      this_player()->more(usage());
      return;
   }

   if (sscanf(arg, ""-%s"", arg)) {
      this_player()->more(usage());
      return;
   }

   file = normalize_path(arg, ""/doc/help/"");
   if (show_help(file)) {
      return;
   }

   if (query_wizard(this_player())) {
      file = normalize_path(arg, ""/doc/help/wiz/"");
      if (show_help(file)) {
         return;
      }
   }

   if (show_help_for_command(arg)) {
      return;
   }

   write(capitalize(arg) + "": Unknown help topic."");
   if (query_wizard(this_player())) {
      write(""Try one of the following for more info:\n"");
      write(""\tman "" + arg + ""\n"");
      write(""\t"" + arg + "" -h\n"");
   } else {
      write(""If "" + arg + "" is a command, for more info try: "" + 
         arg + "" -h\n"");
   }
   LOG_D->write_log(""help"", this_player()->query_Name() +
      "" on "" + ctime(time()) + "": "" + arg + ""\n"");
   return;
}","static void main(string VAR_0) {
   string VAR_1, *VAR_2;
   int VAR_3;
   
   /* COMMENT_0 */
   /* COMMENT_1 */
   VAR_2 = explode(VAR_0, ""/"");
   VAR_3 = sizeof(VAR_2);
   if (VAR_3 > 1) {
      return 1;
   }

   if (!VAR_4) {
      setup_alsos();
   }

   if (empty_str(VAR_0) || (VAR_0 == ""help"")) {
      this_player()->more(usage());
      return;
   }

   if (sscanf(VAR_0, ""-%s"", VAR_0)) {
      this_player()->more(usage());
      return;
   }

   VAR_1 = normalize_path(VAR_0, ""/doc/help/"");
   if (show_help(VAR_1)) {
      return;
   }

   if (query_wizard(this_player())) {
      VAR_1 = normalize_path(VAR_0, ""/doc/help/wiz/"");
      if (show_help(VAR_1)) {
         return;
      }
   }

   if (show_help_for_command(VAR_0)) {
      return;
   }

   write(capitalize(VAR_0) + "": Unknown help topic."");
   if (query_wizard(this_player())) {
      write(""Try one of the following for more info:\n"");
      write(""\tman "" + VAR_0 + ""\n"");
      write(""\t"" + VAR_0 + "" -h\n"");
   } else {
      write(""If "" + VAR_0 + "" is a command, for more info try: "" + 
         VAR_0 + "" -h\n"");
   }
   VAR_5->write_log(""help"", this_player()->query_Name() +
      "" on "" + ctime(time()) + "": "" + VAR_0 + ""\n"");
   return;
}",sirdude/gurbalib/220ec8cceaff2e3bda20f09164a6a96654957840/help.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,8 @@
    
    /* remove capability of path traversal */
    /* discoverd by David Byrne of X-Force Red */
+   exparg = explode(arg, ""/"");
+   szof = sizeof(exparg);
    if (szof > 1) {
       return 1;
    }","{'deleted_lines': [], 'added_lines': ['   exparg = explode(arg, ""/"");', '   szof = sizeof(exparg);']}",True,Gurbalib through 2020-04-30 allows lib/cmds/player/help.c directory traversal for reading administrative paths.,7.5,HIGH,2,test,2020-05-03T17:12:10Z,3
CVE-2020-12649,['CWE-22'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0,sirdude/gurbalib,Update help.c,7fb572c700229ec29a83ebf7b5f67c62eece6082,https://github.com/sirdude/gurbalib/commit/7fb572c700229ec29a83ebf7b5f67c62eece6082,lib/cmds/player/help.c,main,"static void main(string arg) {
string file, *exparg;
int szof;
exparg = explode(arg, ""/"");
szof = sizeof(exparg);
if (szof > 1) {
return 1;
}
if (!alsos) {
setup_alsos();
}
if (empty_str(arg) || (arg == ""help"")) {
this_player()->more(usage());
return;
}
if (sscanf(arg, ""-%s"", arg)) {
this_player()->more(usage());
return;
}
file = normalize_path(arg, ""/doc/help/"");
if (show_help(file)) {
return;
}
if (query_wizard(this_player())) {
file = normalize_path(arg, ""/doc/help/wiz/"");
if (show_help(file)) {
return;
}
}
if (show_help_for_command(arg)) {
return;
}
write(capitalize(arg) + "": Unknown help topic."");
if (query_wizard(this_player())) {
write(""Try one of the following for more info:\n"");
write(""\tman "" + arg + ""\n"");
write(""\t"" + arg + "" -h\n"");
} else {
write(""If "" + arg + "" is a command, for more info try: "" + 
arg + "" -h\n"");
}
LOG_D->write_log(""help"", this_player()->query_Name() +
"" on "" + ctime(time()) + "": "" + arg + ""\n"");
return;
}","static void main(string VAR_0) {
string VAR_1, *VAR_2;
int VAR_3;
VAR_2 = explode(VAR_0, ""/"");
VAR_3 = sizeof(VAR_2);
if (VAR_3 > 1) {
return 1;
}
if (!VAR_4) {
setup_alsos();
}
if (empty_str(VAR_0) || (VAR_0 == ""help"")) {
this_player()->more(usage());
return;
}
if (sscanf(VAR_0, ""-%s"", VAR_0)) {
this_player()->more(usage());
return;
}
VAR_1 = normalize_path(VAR_0, ""/doc/help/"");
if (show_help(VAR_1)) {
return;
}
if (query_wizard(this_player())) {
VAR_1 = normalize_path(VAR_0, ""/doc/help/wiz/"");
if (show_help(VAR_1)) {
return;
}
}
if (show_help_for_command(VAR_0)) {
return;
}
write(capitalize(VAR_0) + "": Unknown help topic."");
if (query_wizard(this_player())) {
write(""Try one of the following for more info:\n"");
write(""\tman "" + VAR_0 + ""\n"");
write(""\t"" + VAR_0 + "" -h\n"");
} else {
write(""If "" + VAR_0 + "" is a command, for more info try: "" + 
VAR_0 + "" -h\n"");
}
VAR_5->write_log(""help"", this_player()->query_Name() +
"" on "" + ctime(time()) + "": "" + VAR_0 + ""\n"");
return;
}",sirdude/gurbalib/7fb572c700229ec29a83ebf7b5f67c62eece6082/help.c/vul/before/0.json,"static void main(string arg) {
   string file, *exparg;
   int szof;
   
   /* remove capability of path traversal */
   /* discoverd by David Byrne of X-Force Red */
   /* CVE-2020-12649 */
   exparg = explode(arg, ""/"");
   szof = sizeof(exparg);
   if (szof > 1) {
      return 1;
   }

   if (!alsos) {
      setup_alsos();
   }

   if (empty_str(arg) || (arg == ""help"")) {
      this_player()->more(usage());
      return;
   }

   if (sscanf(arg, ""-%s"", arg)) {
      this_player()->more(usage());
      return;
   }

   file = normalize_path(arg, ""/doc/help/"");
   if (show_help(file)) {
      return;
   }

   if (query_wizard(this_player())) {
      file = normalize_path(arg, ""/doc/help/wiz/"");
      if (show_help(file)) {
         return;
      }
   }

   if (show_help_for_command(arg)) {
      return;
   }

   write(capitalize(arg) + "": Unknown help topic."");
   if (query_wizard(this_player())) {
      write(""Try one of the following for more info:\n"");
      write(""\tman "" + arg + ""\n"");
      write(""\t"" + arg + "" -h\n"");
   } else {
      write(""If "" + arg + "" is a command, for more info try: "" + 
         arg + "" -h\n"");
   }
   LOG_D->write_log(""help"", this_player()->query_Name() +
      "" on "" + ctime(time()) + "": "" + arg + ""\n"");
   return;
}","static void main(string VAR_0) {
   string VAR_1, *VAR_2;
   int VAR_3;
   
   /* COMMENT_0 */
   /* COMMENT_1 */
   /* COMMENT_2 */
   VAR_2 = explode(VAR_0, ""/"");
   VAR_3 = sizeof(VAR_2);
   if (VAR_3 > 1) {
      return 1;
   }

   if (!VAR_4) {
      setup_alsos();
   }

   if (empty_str(VAR_0) || (VAR_0 == ""help"")) {
      this_player()->more(usage());
      return;
   }

   if (sscanf(VAR_0, ""-%s"", VAR_0)) {
      this_player()->more(usage());
      return;
   }

   VAR_1 = normalize_path(VAR_0, ""/doc/help/"");
   if (show_help(VAR_1)) {
      return;
   }

   if (query_wizard(this_player())) {
      VAR_1 = normalize_path(VAR_0, ""/doc/help/wiz/"");
      if (show_help(VAR_1)) {
         return;
      }
   }

   if (show_help_for_command(VAR_0)) {
      return;
   }

   write(capitalize(VAR_0) + "": Unknown help topic."");
   if (query_wizard(this_player())) {
      write(""Try one of the following for more info:\n"");
      write(""\tman "" + VAR_0 + ""\n"");
      write(""\t"" + VAR_0 + "" -h\n"");
   } else {
      write(""If "" + VAR_0 + "" is a command, for more info try: "" + 
         VAR_0 + "" -h\n"");
   }
   VAR_5->write_log(""help"", this_player()->query_Name() +
      "" on "" + ctime(time()) + "": "" + VAR_0 + ""\n"");
   return;
}",sirdude/gurbalib/7fb572c700229ec29a83ebf7b5f67c62eece6082/help.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,7 @@
    
    /* remove capability of path traversal */
    /* discoverd by David Byrne of X-Force Red */
+   /* CVE-2020-12649 */
    exparg = explode(arg, ""/"");
    szof = sizeof(exparg);
    if (szof > 1) {","{'deleted_lines': [], 'added_lines': ['   /* CVE-2020-12649 */']}",True,Gurbalib through 2020-04-30 allows lib/cmds/player/help.c directory traversal for reading administrative paths.,7.5,HIGH,2,test,2020-05-05T00:18:40Z,3
CVE-2020-23302,"['CWE-416', 'CWE-787']",AV:N/AC:L/Au:N/C:P/I:P/A:P,0,jerryscript-project/jerryscript,"Fix releasing the pattern string in regexp

The release of the regexp pattern string during creating
was incorrect as it was dereferenced a bit to early.

JerryScript-DCO-1.0-Signed-off-by: Peter Gal pgal.usz@partner.samsung.com",26d3a90de29ec38e69d135dc256adead874e8317,https://github.com/jerryscript-project/jerryscript/commit/26d3a90de29ec38e69d135dc256adead874e8317,jerry-core/ecma/operations/ecma-regexp-object.c,ecma_op_create_regexp_from_pattern,"ecma_value_t
ecma_op_create_regexp_from_pattern (ecma_object_t *regexp_obj_p, 
ecma_value_t pattern_value, 
ecma_value_t flags_value) 
{
ecma_string_t *pattern_str_p = ecma_regexp_read_pattern_str_helper (pattern_value);
uint16_t flags = 0;
if (JERRY_UNLIKELY (pattern_str_p == NULL))
{
return ECMA_VALUE_ERROR;
}
if (!ecma_is_value_undefined (flags_value))
{
ecma_string_t *flags_str_p = ecma_op_to_string (flags_value);
if (JERRY_UNLIKELY (flags_str_p == NULL))
{
ecma_deref_ecma_string (pattern_str_p);
return ECMA_VALUE_ERROR;
}
ecma_value_t parse_flags_value = ecma_regexp_parse_flags (flags_str_p, &flags);
ecma_deref_ecma_string (flags_str_p);
if (ECMA_IS_VALUE_ERROR (parse_flags_value))
{
ecma_deref_ecma_string (pattern_str_p);
return parse_flags_value;
}
JERRY_ASSERT (ecma_is_value_empty (parse_flags_value));
}
const re_compiled_code_t *bc_p = NULL;
ecma_value_t ret_value = re_compile_bytecode (&bc_p, pattern_str_p, flags);
ecma_deref_ecma_string (pattern_str_p);
if (ECMA_IS_VALUE_ERROR (ret_value))
{
return ret_value;
}
JERRY_ASSERT (ecma_is_value_empty (ret_value));
ecma_op_regexp_initialize (regexp_obj_p, bc_p, pattern_str_p, flags);
return ecma_make_object_value (regexp_obj_p);
}","ecma_value_t
ecma_op_create_regexp_from_pattern (ecma_object_t *VAR_0, 
ecma_value_t VAR_1, 
ecma_value_t VAR_2) 
{
ecma_string_t *VAR_3 = ecma_regexp_read_pattern_str_helper (VAR_1);
uint16_t VAR_4 = 0;
if (JERRY_UNLIKELY (VAR_3 == NULL))
{
return VAR_5;
}
if (!ecma_is_value_undefined (VAR_2))
{
ecma_string_t *VAR_6 = ecma_op_to_string (VAR_2);
if (JERRY_UNLIKELY (VAR_6 == NULL))
{
ecma_deref_ecma_string (VAR_3);
return VAR_5;
}
ecma_value_t VAR_7 = ecma_regexp_parse_flags (VAR_6, &VAR_4);
ecma_deref_ecma_string (VAR_6);
if (ECMA_IS_VALUE_ERROR (VAR_7))
{
ecma_deref_ecma_string (VAR_3);
return VAR_7;
}
JERRY_ASSERT (ecma_is_value_empty (VAR_7));
}
const re_compiled_code_t *VAR_8 = NULL;
ecma_value_t VAR_9 = re_compile_bytecode (&VAR_8, VAR_3, VAR_4);
ecma_deref_ecma_string (VAR_3);
if (ECMA_IS_VALUE_ERROR (VAR_9))
{
return VAR_9;
}
JERRY_ASSERT (ecma_is_value_empty (VAR_9));
ecma_op_regexp_initialize (VAR_0, VAR_8, VAR_3, VAR_4);
return ecma_make_object_value (VAR_0);
}",jerryscript-project/jerryscript/26d3a90de29ec38e69d135dc256adead874e8317/ecma-regexp-object.c/vul/before/0.json,"ecma_value_t
ecma_op_create_regexp_from_pattern (ecma_object_t *regexp_obj_p, /**< RegExp object */
                                    ecma_value_t pattern_value, /**< pattern */
                                    ecma_value_t flags_value) /**< flags */
{
  ecma_string_t *pattern_str_p = ecma_regexp_read_pattern_str_helper (pattern_value);
  uint16_t flags = 0;

  if (JERRY_UNLIKELY (pattern_str_p == NULL))
  {
    return ECMA_VALUE_ERROR;
  }

  if (!ecma_is_value_undefined (flags_value))
  {
    ecma_string_t *flags_str_p = ecma_op_to_string (flags_value);

    if (JERRY_UNLIKELY (flags_str_p == NULL))
    {
      ecma_deref_ecma_string (pattern_str_p);
      return ECMA_VALUE_ERROR;
    }

    ecma_value_t parse_flags_value = ecma_regexp_parse_flags (flags_str_p, &flags);
    ecma_deref_ecma_string (flags_str_p);

    if (ECMA_IS_VALUE_ERROR (parse_flags_value))
    {
      ecma_deref_ecma_string (pattern_str_p);
      return parse_flags_value;
    }

    JERRY_ASSERT (ecma_is_value_empty (parse_flags_value));
  }

  const re_compiled_code_t *bc_p = NULL;
  ecma_value_t ret_value = re_compile_bytecode (&bc_p, pattern_str_p, flags);

  if (ECMA_IS_VALUE_ERROR (ret_value))
  {
    ecma_deref_ecma_string (pattern_str_p);
    return ret_value;
  }

  JERRY_ASSERT (ecma_is_value_empty (ret_value));

  ecma_op_regexp_initialize (regexp_obj_p, bc_p, pattern_str_p, flags);
  ecma_deref_ecma_string (pattern_str_p);

  return ecma_make_object_value (regexp_obj_p);
}","ecma_value_t
ecma_op_create_regexp_from_pattern (ecma_object_t *VAR_0, /* COMMENT_0 */
                                    ecma_value_t VAR_1, /* COMMENT_1 */
                                    ecma_value_t VAR_2) /* COMMENT_2 */
{
  ecma_string_t *VAR_3 = ecma_regexp_read_pattern_str_helper (VAR_1);
  uint16_t VAR_4 = 0;

  if (JERRY_UNLIKELY (VAR_3 == NULL))
  {
    return VAR_5;
  }

  if (!ecma_is_value_undefined (VAR_2))
  {
    ecma_string_t *VAR_6 = ecma_op_to_string (VAR_2);

    if (JERRY_UNLIKELY (VAR_6 == NULL))
    {
      ecma_deref_ecma_string (VAR_3);
      return VAR_5;
    }

    ecma_value_t VAR_7 = ecma_regexp_parse_flags (VAR_6, &VAR_4);
    ecma_deref_ecma_string (VAR_6);

    if (ECMA_IS_VALUE_ERROR (VAR_7))
    {
      ecma_deref_ecma_string (VAR_3);
      return VAR_7;
    }

    JERRY_ASSERT (ecma_is_value_empty (VAR_7));
  }

  const re_compiled_code_t *VAR_8 = NULL;
  ecma_value_t VAR_9 = re_compile_bytecode (&VAR_8, VAR_3, VAR_4);

  if (ECMA_IS_VALUE_ERROR (VAR_9))
  {
    ecma_deref_ecma_string (VAR_3);
    return VAR_9;
  }

  JERRY_ASSERT (ecma_is_value_empty (VAR_9));

  ecma_op_regexp_initialize (VAR_0, VAR_8, VAR_3, VAR_4);
  ecma_deref_ecma_string (VAR_3);

  return ecma_make_object_value (VAR_0);
}",jerryscript-project/jerryscript/26d3a90de29ec38e69d135dc256adead874e8317/ecma-regexp-object.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,16 +35,17 @@
 
   const re_compiled_code_t *bc_p = NULL;
   ecma_value_t ret_value = re_compile_bytecode (&bc_p, pattern_str_p, flags);
-  ecma_deref_ecma_string (pattern_str_p);
 
   if (ECMA_IS_VALUE_ERROR (ret_value))
   {
+    ecma_deref_ecma_string (pattern_str_p);
     return ret_value;
   }
 
   JERRY_ASSERT (ecma_is_value_empty (ret_value));
 
   ecma_op_regexp_initialize (regexp_obj_p, bc_p, pattern_str_p, flags);
+  ecma_deref_ecma_string (pattern_str_p);
 
   return ecma_make_object_value (regexp_obj_p);
 }","{'deleted_lines': ['  ecma_deref_ecma_string (pattern_str_p);'], 'added_lines': ['    ecma_deref_ecma_string (pattern_str_p);', '  ecma_deref_ecma_string (pattern_str_p);']}",True,There is a heap-use-after-free at ecma-helpers-string.c:772 in ecma_ref_ecma_string in JerryScript 2.2.0,9.8,CRITICAL,3,test,2020-05-19T12:51:16Z,3
CVE-2020-13775,['CWE-476'],AV:N/AC:M/Au:S/C:N/I:N/A:P,0,znc,"Fix null pointer dereference in echo-message

The bug was introduced while fixing #1705. If a client did not enable
echo-message, and doesn't have a network, it crashes.

Thanks to LunarBNC for reporting this",2390ad111bde16a78c98ac44572090b33c3bd2d8,https://github.com/znc/znc/commit/2390ad111bde16a78c98ac44572090b33c3bd2d8,src/Client.cpp,CClient::EchoMessage,"void CClient::EchoMessage(const CMessage& Message) {
CMessage EchoedMessage = Message;
for (CClient* pClient : GetClients()) {
if (pClient->HasEchoMessage() ||
(pClient != this && (m_pNetwork->IsChan(Message.GetParam(0)) ||
pClient->HasSelfMessage()))) {
EchoedMessage.SetNick(GetNickMask());
pClient->PutClient(EchoedMessage);
}
}
}","void CClient::EchoMessage(const CMessage& VAR_0) {
CMessage VAR_1 = VAR_0;
for (CClient* VAR_2 : GetClients()) {
if (VAR_2->HasEchoMessage() ||
(VAR_2 != this && (VAR_3->IsChan(VAR_0.GetParam(0)) ||
VAR_2->HasSelfMessage()))) {
VAR_1.SetNick(GetNickMask());
VAR_2->PutClient(VAR_1);
}
}
}",znc/2390ad111bde16a78c98ac44572090b33c3bd2d8/Client.cpp/vul/before/0.json,"void CClient::EchoMessage(const CMessage& Message) {
    CMessage EchoedMessage = Message;
    for (CClient* pClient : GetClients()) {
        if (pClient->HasEchoMessage() ||
            (pClient != this && ((m_pNetwork && m_pNetwork->IsChan(Message.GetParam(0))) ||
                                 pClient->HasSelfMessage()))) {
            EchoedMessage.SetNick(GetNickMask());
            pClient->PutClient(EchoedMessage);
        }
    }
}","void CClient::EchoMessage(const CMessage& VAR_0) {
    CMessage VAR_1 = VAR_0;
    for (CClient* VAR_2 : GetClients()) {
        if (VAR_2->HasEchoMessage() ||
            (VAR_2 != this && ((VAR_3 && VAR_3->IsChan(VAR_0.GetParam(0))) ||
                                 VAR_2->HasSelfMessage()))) {
            VAR_1.SetNick(GetNickMask());
            VAR_2->PutClient(VAR_1);
        }
    }
}",znc/2390ad111bde16a78c98ac44572090b33c3bd2d8/Client.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
     CMessage EchoedMessage = Message;
     for (CClient* pClient : GetClients()) {
         if (pClient->HasEchoMessage() ||
-            (pClient != this && (m_pNetwork->IsChan(Message.GetParam(0)) ||
+            (pClient != this && ((m_pNetwork && m_pNetwork->IsChan(Message.GetParam(0))) ||
                                  pClient->HasSelfMessage()))) {
             EchoedMessage.SetNick(GetNickMask());
             pClient->PutClient(EchoedMessage);","{'deleted_lines': ['            (pClient != this && (m_pNetwork->IsChan(Message.GetParam(0)) ||'], 'added_lines': ['            (pClient != this && ((m_pNetwork && m_pNetwork->IsChan(Message.GetParam(0))) ||']}",True,ZNC 1.8.0 up to 1.8.1-rc1 allows authenticated users to trigger an application crash (with a NULL pointer dereference) if echo-message is not enabled and there is no network.,6.5,MEDIUM,1,test,2020-05-31T10:32:04Z,3
CVE-2020-14954,['CWE-74'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,neomutt,"tls: clear data after a starttls acknowledgement

After a starttls acknowledgement message, clear the buffers of any
incoming data / commands.  This will ensure that all future data is
handled securely.

Co-authored-by: Pietro Cerutti <gahr@gahr.ch>",fb013ec666759cb8a9e294347c7b4c1f597639cc,https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc,nntp/nntp.c,nntp_open_connection,"int nntp_open_connection(struct NntpAccountData *adata)
{
struct Connection *conn = adata->conn;
char buf[256];
int cap;
bool posting = false, auth = true;
if (adata->status == NNTP_OK)
return 0;
if (adata->status == NNTP_BYE)
return -1;
adata->status = NNTP_NONE;
if (mutt_socket_open(conn) < 0)
return -1;
if (mutt_socket_readln(buf, sizeof(buf), conn) < 0)
return nntp_connect_error(adata);
if (mutt_str_startswith(buf, ""200"", CASE_MATCH))
posting = true;
else if (!mutt_str_startswith(buf, ""201"", CASE_MATCH))
{
mutt_socket_close(conn);
mutt_str_remove_trailing_ws(buf);
mutt_error(""%s"", buf);
return -1;
}
cap = nntp_capabilities(adata);
if (cap < 0)
return -1;
if (cap > 0)
{
if ((mutt_socket_send(conn, ""MODE READER\r\n"") < 0) ||
(mutt_socket_readln(buf, sizeof(buf), conn) < 0))
{
return nntp_connect_error(adata);
}
if (mutt_str_startswith(buf, ""200"", CASE_MATCH))
posting = true;
else if (mutt_str_startswith(buf, ""201"", CASE_MATCH))
posting = false;
else if (adata->hasCAPABILITIES)
{
mutt_socket_close(conn);
mutt_error(_(""Could not switch to reader mode""));
return -1;
}
if (adata->hasCAPABILITIES)
{
cap = nntp_capabilities(adata);
if (cap < 0)
return -1;
}
}
mutt_message(_(""Connected to %s. %s""), conn->account.host,
posting ? _(""Posting is ok"") : _(""Posting is NOT ok""));
mutt_sleep(1);
#ifdef USE_SSL
if ((adata->use_tls != 1) && (adata->hasSTARTTLS || C_SslForceTls))
{
if (adata->use_tls == 0)
{
adata->use_tls =
C_SslForceTls || query_quadoption(C_SslStarttls,
_(""Secure connection with TLS?"")) == MUTT_YES ?
2 :
1;
}
if (adata->use_tls == 2)
{
if ((mutt_socket_send(conn, ""STARTTLS\r\n"") < 0) ||
(mutt_socket_readln(buf, sizeof(buf), conn) < 0))
{
return nntp_connect_error(adata);
}
if (!mutt_str_startswith(buf, ""382"", CASE_MATCH))
{
adata->use_tls = 0;
mutt_error(""STARTTLS: %s"", buf);
}
else if (mutt_ssl_starttls(conn))
{
adata->use_tls = 0;
adata->status = NNTP_NONE;
mutt_socket_close(adata->conn);
mutt_error(_(""Could not negotiate TLS connection""));
return -1;
}
else
{
cap = nntp_capabilities(adata);
if (cap < 0)
return -1;
}
}
}
#endif
if (conn->account.flags & MUTT_ACCT_USER)
{
if (!conn->account.user[0])
auth = false;
}
else
{
if ((mutt_socket_send(conn, ""STAT\r\n"") < 0) ||
(mutt_socket_readln(buf, sizeof(buf), conn) < 0))
{
return nntp_connect_error(adata);
}
if (!mutt_str_startswith(buf, ""480"", CASE_MATCH))
auth = false;
}
if (auth && (nntp_auth(adata) < 0))
return -1;
if (adata->hasCAPABILITIES && (auth || (cap > 0)))
{
cap = nntp_capabilities(adata);
if (cap < 0)
return -1;
if (cap > 0)
{
mutt_socket_close(conn);
mutt_error(_(""Could not switch to reader mode""));
return -1;
}
}
if (nntp_attempt_features(adata) < 0)
return -1;
adata->status = NNTP_OK;
return 0;
}","int nntp_open_connection(struct NntpAccountData *VAR_0)
{
struct Connection *VAR_1 = VAR_0->conn;
char VAR_2[256];
int VAR_3;
bool VAR_4 = false, VAR_5 = true;
if (VAR_0->status == VAR_6)
return 0;
if (VAR_0->status == VAR_7)
return -1;
VAR_0->status = VAR_8;
if (mutt_socket_open(VAR_1) < 0)
return -1;
if (mutt_socket_readln(VAR_2, sizeof(VAR_2), VAR_1) < 0)
return nntp_connect_error(VAR_0);
if (mutt_str_startswith(VAR_2, ""200"", VAR_9))
VAR_4 = true;
else if (!mutt_str_startswith(VAR_2, ""201"", VAR_9))
{
mutt_socket_close(VAR_1);
mutt_str_remove_trailing_ws(VAR_2);
mutt_error(""%s"", VAR_2);
return -1;
}
VAR_3 = nntp_capabilities(VAR_0);
if (VAR_3 < 0)
return -1;
if (VAR_3 > 0)
{
if ((mutt_socket_send(VAR_1, ""MODE READER\r\n"") < 0) ||
(mutt_socket_readln(VAR_2, sizeof(VAR_2), VAR_1) < 0))
{
return nntp_connect_error(VAR_0);
}
if (mutt_str_startswith(VAR_2, ""200"", VAR_9))
VAR_4 = true;
else if (mutt_str_startswith(VAR_2, ""201"", VAR_9))
VAR_4 = false;
else if (VAR_0->hasCAPABILITIES)
{
mutt_socket_close(VAR_1);
mutt_error(_(""Could not switch to reader mode""));
return -1;
}
if (VAR_0->hasCAPABILITIES)
{
VAR_3 = nntp_capabilities(VAR_0);
if (VAR_3 < 0)
return -1;
}
}
mutt_message(_(""Connected to %s. %s""), VAR_1->account.host,
VAR_4 ? _(""Posting is ok"") : _(""Posting is NOT ok""));
mutt_sleep(1);
#ifdef VAR_10
if ((VAR_0->use_tls != 1) && (VAR_0->hasSTARTTLS || VAR_11))
{
if (VAR_0->use_tls == 0)
{
VAR_0->use_tls =
VAR_11 || query_quadoption(VAR_12,
_(""Secure connection with TLS?"")) == VAR_13 ?
2 :
1;
}
if (VAR_0->use_tls == 2)
{
if ((mutt_socket_send(VAR_1, ""STARTTLS\r\n"") < 0) ||
(mutt_socket_readln(VAR_2, sizeof(VAR_2), VAR_1) < 0))
{
return nntp_connect_error(VAR_0);
}
if (!mutt_str_startswith(VAR_2, ""382"", VAR_9))
{
VAR_0->use_tls = 0;
mutt_error(""STARTTLS: %s"", VAR_2);
}
else if (mutt_ssl_starttls(VAR_1))
{
VAR_0->use_tls = 0;
VAR_0->status = VAR_8;
mutt_socket_close(VAR_0->conn);
mutt_error(_(""Could not negotiate TLS connection""));
return -1;
}
else
{
VAR_3 = nntp_capabilities(VAR_0);
if (VAR_3 < 0)
return -1;
}
}
}
#endif
if (VAR_1->account.flags & VAR_14)
{
if (!VAR_1->account.user[0])
VAR_5 = false;
}
else
{
if ((mutt_socket_send(VAR_1, ""STAT\r\n"") < 0) ||
(mutt_socket_readln(VAR_2, sizeof(VAR_2), VAR_1) < 0))
{
return nntp_connect_error(VAR_0);
}
if (!mutt_str_startswith(VAR_2, ""480"", VAR_9))
VAR_5 = false;
}
if (VAR_5 && (nntp_auth(VAR_0) < 0))
return -1;
if (VAR_0->hasCAPABILITIES && (VAR_5 || (VAR_3 > 0)))
{
VAR_3 = nntp_capabilities(VAR_0);
if (VAR_3 < 0)
return -1;
if (VAR_3 > 0)
{
mutt_socket_close(VAR_1);
mutt_error(_(""Could not switch to reader mode""));
return -1;
}
}
if (nntp_attempt_features(VAR_0) < 0)
return -1;
VAR_0->status = VAR_6;
return 0;
}",neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc/nntp.c/vul/before/0.json,"int nntp_open_connection(struct NntpAccountData *adata)
{
  struct Connection *conn = adata->conn;
  char buf[256];
  int cap;
  bool posting = false, auth = true;

  if (adata->status == NNTP_OK)
    return 0;
  if (adata->status == NNTP_BYE)
    return -1;
  adata->status = NNTP_NONE;

  if (mutt_socket_open(conn) < 0)
    return -1;

  if (mutt_socket_readln(buf, sizeof(buf), conn) < 0)
    return nntp_connect_error(adata);

  if (mutt_str_startswith(buf, ""200"", CASE_MATCH))
    posting = true;
  else if (!mutt_str_startswith(buf, ""201"", CASE_MATCH))
  {
    mutt_socket_close(conn);
    mutt_str_remove_trailing_ws(buf);
    mutt_error(""%s"", buf);
    return -1;
  }

  /* get initial capabilities */
  cap = nntp_capabilities(adata);
  if (cap < 0)
    return -1;

  /* tell news server to switch to mode reader if it isn't so */
  if (cap > 0)
  {
    if ((mutt_socket_send(conn, ""MODE READER\r\n"") < 0) ||
        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))
    {
      return nntp_connect_error(adata);
    }

    if (mutt_str_startswith(buf, ""200"", CASE_MATCH))
      posting = true;
    else if (mutt_str_startswith(buf, ""201"", CASE_MATCH))
      posting = false;
    /* error if has capabilities, ignore result if no capabilities */
    else if (adata->hasCAPABILITIES)
    {
      mutt_socket_close(conn);
      mutt_error(_(""Could not switch to reader mode""));
      return -1;
    }

    /* recheck capabilities after MODE READER */
    if (adata->hasCAPABILITIES)
    {
      cap = nntp_capabilities(adata);
      if (cap < 0)
        return -1;
    }
  }

  mutt_message(_(""Connected to %s. %s""), conn->account.host,
               posting ? _(""Posting is ok"") : _(""Posting is NOT ok""));
  mutt_sleep(1);

#ifdef USE_SSL
  /* Attempt STARTTLS if available and desired. */
  if ((adata->use_tls != 1) && (adata->hasSTARTTLS || C_SslForceTls))
  {
    if (adata->use_tls == 0)
    {
      adata->use_tls =
          C_SslForceTls || query_quadoption(C_SslStarttls,
                                            _(""Secure connection with TLS?"")) == MUTT_YES ?
              2 :
              1;
    }
    if (adata->use_tls == 2)
    {
      if ((mutt_socket_send(conn, ""STARTTLS\r\n"") < 0) ||
          (mutt_socket_readln(buf, sizeof(buf), conn) < 0))
      {
        return nntp_connect_error(adata);
      }
      // Clear any data after the STARTTLS acknowledgement
      mutt_socket_empty(conn);
      if (!mutt_str_startswith(buf, ""382"", CASE_MATCH))
      {
        adata->use_tls = 0;
        mutt_error(""STARTTLS: %s"", buf);
      }
      else if (mutt_ssl_starttls(conn))
      {
        adata->use_tls = 0;
        adata->status = NNTP_NONE;
        mutt_socket_close(adata->conn);
        mutt_error(_(""Could not negotiate TLS connection""));
        return -1;
      }
      else
      {
        /* recheck capabilities after STARTTLS */
        cap = nntp_capabilities(adata);
        if (cap < 0)
          return -1;
      }
    }
  }
#endif

  /* authentication required? */
  if (conn->account.flags & MUTT_ACCT_USER)
  {
    if (!conn->account.user[0])
      auth = false;
  }
  else
  {
    if ((mutt_socket_send(conn, ""STAT\r\n"") < 0) ||
        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))
    {
      return nntp_connect_error(adata);
    }
    if (!mutt_str_startswith(buf, ""480"", CASE_MATCH))
      auth = false;
  }

  /* authenticate */
  if (auth && (nntp_auth(adata) < 0))
    return -1;

  /* get final capabilities after authentication */
  if (adata->hasCAPABILITIES && (auth || (cap > 0)))
  {
    cap = nntp_capabilities(adata);
    if (cap < 0)
      return -1;
    if (cap > 0)
    {
      mutt_socket_close(conn);
      mutt_error(_(""Could not switch to reader mode""));
      return -1;
    }
  }

  /* attempt features */
  if (nntp_attempt_features(adata) < 0)
    return -1;

  adata->status = NNTP_OK;
  return 0;
}","int nntp_open_connection(struct NntpAccountData *VAR_0)
{
  struct Connection *VAR_1 = VAR_0->conn;
  char VAR_2[256];
  int VAR_3;
  bool VAR_4 = false, VAR_5 = true;

  if (VAR_0->status == VAR_6)
    return 0;
  if (VAR_0->status == VAR_7)
    return -1;
  VAR_0->status = VAR_8;

  if (mutt_socket_open(VAR_1) < 0)
    return -1;

  if (mutt_socket_readln(VAR_2, sizeof(VAR_2), VAR_1) < 0)
    return nntp_connect_error(VAR_0);

  if (mutt_str_startswith(VAR_2, ""200"", VAR_9))
    VAR_4 = true;
  else if (!mutt_str_startswith(VAR_2, ""201"", VAR_9))
  {
    mutt_socket_close(VAR_1);
    mutt_str_remove_trailing_ws(VAR_2);
    mutt_error(""%s"", VAR_2);
    return -1;
  }

  /* COMMENT_0 */
  VAR_3 = nntp_capabilities(VAR_0);
  if (VAR_3 < 0)
    return -1;

  /* COMMENT_1 */
  if (VAR_3 > 0)
  {
    if ((mutt_socket_send(VAR_1, ""MODE READER\r\n"") < 0) ||
        (mutt_socket_readln(VAR_2, sizeof(VAR_2), VAR_1) < 0))
    {
      return nntp_connect_error(VAR_0);
    }

    if (mutt_str_startswith(VAR_2, ""200"", VAR_9))
      VAR_4 = true;
    else if (mutt_str_startswith(VAR_2, ""201"", VAR_9))
      VAR_4 = false;
    /* COMMENT_2 */
    else if (VAR_0->hasCAPABILITIES)
    {
      mutt_socket_close(VAR_1);
      mutt_error(_(""Could not switch to reader mode""));
      return -1;
    }

    /* COMMENT_3 */
    if (VAR_0->hasCAPABILITIES)
    {
      VAR_3 = nntp_capabilities(VAR_0);
      if (VAR_3 < 0)
        return -1;
    }
  }

  mutt_message(_(""Connected to %s. %s""), VAR_1->account.host,
               VAR_4 ? _(""Posting is ok"") : _(""Posting is NOT ok""));
  mutt_sleep(1);

#ifdef VAR_10
  /* COMMENT_4 */
  if ((VAR_0->use_tls != 1) && (VAR_0->hasSTARTTLS || VAR_11))
  {
    if (VAR_0->use_tls == 0)
    {
      VAR_0->use_tls =
          VAR_11 || query_quadoption(VAR_12,
                                            _(""Secure connection with TLS?"")) == VAR_13 ?
              2 :
              1;
    }
    if (VAR_0->use_tls == 2)
    {
      if ((mutt_socket_send(VAR_1, ""STARTTLS\r\n"") < 0) ||
          (mutt_socket_readln(VAR_2, sizeof(VAR_2), VAR_1) < 0))
      {
        return nntp_connect_error(VAR_0);
      }
      /* COMMENT_5 */
      mutt_socket_empty(VAR_1);
      if (!mutt_str_startswith(VAR_2, ""382"", VAR_9))
      {
        VAR_0->use_tls = 0;
        mutt_error(""STARTTLS: %s"", VAR_2);
      }
      else if (mutt_ssl_starttls(VAR_1))
      {
        VAR_0->use_tls = 0;
        VAR_0->status = VAR_8;
        mutt_socket_close(VAR_0->conn);
        mutt_error(_(""Could not negotiate TLS connection""));
        return -1;
      }
      else
      {
        /* COMMENT_6 */
        VAR_3 = nntp_capabilities(VAR_0);
        if (VAR_3 < 0)
          return -1;
      }
    }
  }
#endif

  /* COMMENT_7 */
  if (VAR_1->account.flags & VAR_14)
  {
    if (!VAR_1->account.user[0])
      VAR_5 = false;
  }
  else
  {
    if ((mutt_socket_send(VAR_1, ""STAT\r\n"") < 0) ||
        (mutt_socket_readln(VAR_2, sizeof(VAR_2), VAR_1) < 0))
    {
      return nntp_connect_error(VAR_0);
    }
    if (!mutt_str_startswith(VAR_2, ""480"", VAR_9))
      VAR_5 = false;
  }

  /* COMMENT_8 */
  if (VAR_5 && (nntp_auth(VAR_0) < 0))
    return -1;

  /* COMMENT_9 */
  if (VAR_0->hasCAPABILITIES && (VAR_5 || (VAR_3 > 0)))
  {
    VAR_3 = nntp_capabilities(VAR_0);
    if (VAR_3 < 0)
      return -1;
    if (VAR_3 > 0)
    {
      mutt_socket_close(VAR_1);
      mutt_error(_(""Could not switch to reader mode""));
      return -1;
    }
  }

  /* COMMENT_10 */
  if (nntp_attempt_features(VAR_0) < 0)
    return -1;

  VAR_0->status = VAR_6;
  return 0;
}",neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc/nntp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -85,6 +85,8 @@
       {
         return nntp_connect_error(adata);
       }
+      // Clear any data after the STARTTLS acknowledgement
+      mutt_socket_empty(conn);
       if (!mutt_str_startswith(buf, ""382"", CASE_MATCH))
       {
         adata->use_tls = 0;","{'deleted_lines': [], 'added_lines': ['      // Clear any data after the STARTTLS acknowledgement', '      mutt_socket_empty(conn);']}",True,"Mutt before 1.14.4 and NeoMutt before 2020-06-19 have a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a ""begin TLS"" response, the client reads additional data (e.g., from a man-in-the-middle attacker) and evaluates it in a TLS context, aka ""response injection.""",5.9,MEDIUM,1,test,2020-06-18T11:11:27Z,3
CVE-2020-14954,['CWE-74'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,neomutt,"tls: clear data after a starttls acknowledgement

After a starttls acknowledgement message, clear the buffers of any
incoming data / commands.  This will ensure that all future data is
handled securely.

Co-authored-by: Pietro Cerutti <gahr@gahr.ch>",fb013ec666759cb8a9e294347c7b4c1f597639cc,https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc,imap/imap.c,imap_open_connection,"int imap_open_connection(struct ImapAccountData *adata)
{
if (mutt_socket_open(adata->conn) < 0)
return -1;
adata->state = IMAP_CONNECTED;
if (imap_cmd_step(adata) != IMAP_RES_OK)
{
imap_close_connection(adata);
return -1;
}
if (mutt_str_startswith(adata->buf, ""* OK"", CASE_IGNORE))
{
if (!mutt_str_startswith(adata->buf, ""* OK [CAPABILITY"", CASE_IGNORE) &&
check_capabilities(adata))
{
goto bail;
}
#ifdef USE_SSL
if (!adata->conn->ssf && (C_SslForceTls || (adata->capabilities & IMAP_CAP_STARTTLS)))
{
enum QuadOption ans;
if (C_SslForceTls)
ans = MUTT_YES;
else if ((ans = query_quadoption(C_SslStarttls,
_(""Secure connection with TLS?""))) == MUTT_ABORT)
{
goto err_close_conn;
}
if (ans == MUTT_YES)
{
enum ImapExecResult rc = imap_exec(adata, ""STARTTLS"", IMAP_CMD_NO_FLAGS);
if (rc == IMAP_EXEC_FATAL)
goto bail;
if (rc != IMAP_EXEC_ERROR)
{
if (mutt_ssl_starttls(adata->conn))
{
mutt_error(_(""Could not negotiate TLS connection""));
goto err_close_conn;
}
else
{
if (imap_exec(adata, ""CAPABILITY"", IMAP_CMD_NO_FLAGS))
goto bail;
}
}
}
}
if (C_SslForceTls && !adata->conn->ssf)
{
mutt_error(_(""Encrypted connection unavailable""));
goto err_close_conn;
}
#endif
}
else if (mutt_str_startswith(adata->buf, ""* PREAUTH"", CASE_IGNORE))
{
#ifdef USE_SSL
if (adata->conn->ssf == 0)
{
bool proceed = true;
if (C_SslForceTls)
{
proceed = false;
}
else if (C_SslStarttls != MUTT_NO)
{
proceed = mutt_yesorno(_(""Abort unencrypted PREAUTH connection?""),
C_SslStarttls) != MUTT_NO;
}
if (!proceed)
{
mutt_error(_(""Encrypted connection unavailable""));
goto err_close_conn;
}
}
#endif
adata->state = IMAP_AUTHENTICATED;
if (check_capabilities(adata) != 0)
goto bail;
FREE(&adata->capstr);
}
else
{
imap_error(""imap_open_connection()"", adata->buf);
goto bail;
}
return 0;
#ifdef USE_SSL
err_close_conn:
imap_close_connection(adata);
#endif
bail:
FREE(&adata->capstr);
return -1;
}","int imap_open_connection(struct ImapAccountData *VAR_0)
{
if (mutt_socket_open(VAR_0->conn) < 0)
return -1;
VAR_0->state = VAR_1;
if (imap_cmd_step(VAR_0) != VAR_2)
{
imap_close_connection(VAR_0);
return -1;
}
if (mutt_str_startswith(VAR_0->buf, ""* OK"", VAR_3))
{
if (!mutt_str_startswith(VAR_0->buf, ""* OK [CAPABILITY"", VAR_3) &&
check_capabilities(VAR_0))
{
goto bail;
}
#ifdef VAR_4
if (!VAR_0->conn->ssf && (VAR_5 || (VAR_0->capabilities & VAR_6)))
{
enum QuadOption VAR_7;
if (VAR_5)
VAR_7 = VAR_8;
else if ((VAR_7 = query_quadoption(VAR_9,
_(""Secure connection with TLS?""))) == VAR_10)
{
goto err_close_conn;
}
if (VAR_7 == VAR_8)
{
enum ImapExecResult VAR_11 = imap_exec(VAR_0, ""STARTTLS"", VAR_12);
if (VAR_11 == VAR_13)
goto bail;
if (VAR_11 != VAR_14)
{
if (mutt_ssl_starttls(VAR_0->conn))
{
mutt_error(_(""Could not negotiate TLS connection""));
goto err_close_conn;
}
else
{
if (imap_exec(VAR_0, ""CAPABILITY"", VAR_12))
goto bail;
}
}
}
}
if (VAR_5 && !VAR_0->conn->ssf)
{
mutt_error(_(""Encrypted connection unavailable""));
goto err_close_conn;
}
#endif
}
else if (mutt_str_startswith(VAR_0->buf, ""* PREAUTH"", VAR_3))
{
#ifdef VAR_4
if (VAR_0->conn->ssf == 0)
{
bool VAR_15 = true;
if (VAR_5)
{
VAR_15 = false;
}
else if (VAR_9 != VAR_16)
{
VAR_15 = mutt_yesorno(_(""Abort unencrypted PREAUTH connection?""),
VAR_9) != VAR_16;
}
if (!VAR_15)
{
mutt_error(_(""Encrypted connection unavailable""));
goto err_close_conn;
}
}
#endif
VAR_0->state = VAR_17;
if (check_capabilities(VAR_0) != 0)
goto bail;
FREE(&VAR_0->capstr);
}
else
{
imap_error(""imap_open_connection()"", VAR_0->buf);
goto bail;
}
return 0;
#ifdef VAR_4
err_close_conn:
imap_close_connection(VAR_0);
#endif
bail:
FREE(&VAR_0->capstr);
return -1;
}",neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc/imap.c/vul/before/0.json,"int imap_open_connection(struct ImapAccountData *adata)
{
  if (mutt_socket_open(adata->conn) < 0)
    return -1;

  adata->state = IMAP_CONNECTED;

  if (imap_cmd_step(adata) != IMAP_RES_OK)
  {
    imap_close_connection(adata);
    return -1;
  }

  if (mutt_str_startswith(adata->buf, ""* OK"", CASE_IGNORE))
  {
    if (!mutt_str_startswith(adata->buf, ""* OK [CAPABILITY"", CASE_IGNORE) &&
        check_capabilities(adata))
    {
      goto bail;
    }
#ifdef USE_SSL
    /* Attempt STARTTLS if available and desired. */
    if (!adata->conn->ssf && (C_SslForceTls || (adata->capabilities & IMAP_CAP_STARTTLS)))
    {
      enum QuadOption ans;

      if (C_SslForceTls)
        ans = MUTT_YES;
      else if ((ans = query_quadoption(C_SslStarttls,
                                       _(""Secure connection with TLS?""))) == MUTT_ABORT)
      {
        goto err_close_conn;
      }
      if (ans == MUTT_YES)
      {
        enum ImapExecResult rc = imap_exec(adata, ""STARTTLS"", IMAP_CMD_SINGLE);
        // Clear any data after the STARTTLS acknowledgement
        mutt_socket_empty(adata->conn);

        if (rc == IMAP_EXEC_FATAL)
          goto bail;
        if (rc != IMAP_EXEC_ERROR)
        {
          if (mutt_ssl_starttls(adata->conn))
          {
            mutt_error(_(""Could not negotiate TLS connection""));
            goto err_close_conn;
          }
          else
          {
            /* RFC2595 demands we recheck CAPABILITY after TLS completes. */
            if (imap_exec(adata, ""CAPABILITY"", IMAP_CMD_NO_FLAGS))
              goto bail;
          }
        }
      }
    }

    if (C_SslForceTls && !adata->conn->ssf)
    {
      mutt_error(_(""Encrypted connection unavailable""));
      goto err_close_conn;
    }
#endif
  }
  else if (mutt_str_startswith(adata->buf, ""* PREAUTH"", CASE_IGNORE))
  {
#ifdef USE_SSL
    /* An unencrypted PREAUTH response is most likely a MITM attack.
     * Require a confirmation. */
    if (adata->conn->ssf == 0)
    {
      bool proceed = true;
      if (C_SslForceTls)
      {
        proceed = false;
      }
      else if (C_SslStarttls != MUTT_NO)
      {
        proceed = mutt_yesorno(_(""Abort unencrypted PREAUTH connection?""),
                               C_SslStarttls) != MUTT_NO;
      }
      if (!proceed)
      {
        mutt_error(_(""Encrypted connection unavailable""));
        goto err_close_conn;
      }
    }
#endif

    adata->state = IMAP_AUTHENTICATED;
    if (check_capabilities(adata) != 0)
      goto bail;
    FREE(&adata->capstr);
  }
  else
  {
    imap_error(""imap_open_connection()"", adata->buf);
    goto bail;
  }

  return 0;

#ifdef USE_SSL
err_close_conn:
  imap_close_connection(adata);
#endif
bail:
  FREE(&adata->capstr);
  return -1;
}","int imap_open_connection(struct ImapAccountData *VAR_0)
{
  if (mutt_socket_open(VAR_0->conn) < 0)
    return -1;

  VAR_0->state = VAR_1;

  if (imap_cmd_step(VAR_0) != VAR_2)
  {
    imap_close_connection(VAR_0);
    return -1;
  }

  if (mutt_str_startswith(VAR_0->buf, ""* OK"", VAR_3))
  {
    if (!mutt_str_startswith(VAR_0->buf, ""* OK [CAPABILITY"", VAR_3) &&
        check_capabilities(VAR_0))
    {
      goto bail;
    }
#ifdef VAR_4
    /* COMMENT_0 */
    if (!VAR_0->conn->ssf && (VAR_5 || (VAR_0->capabilities & VAR_6)))
    {
      enum QuadOption VAR_7;

      if (VAR_5)
        VAR_7 = VAR_8;
      else if ((VAR_7 = query_quadoption(VAR_9,
                                       _(""Secure connection with TLS?""))) == VAR_10)
      {
        goto err_close_conn;
      }
      if (VAR_7 == VAR_8)
      {
        enum ImapExecResult VAR_11 = imap_exec(VAR_0, ""STARTTLS"", VAR_12);
        /* COMMENT_1 */
        mutt_socket_empty(VAR_0->conn);

        if (VAR_11 == VAR_13)
          goto bail;
        if (VAR_11 != VAR_14)
        {
          if (mutt_ssl_starttls(VAR_0->conn))
          {
            mutt_error(_(""Could not negotiate TLS connection""));
            goto err_close_conn;
          }
          else
          {
            /* COMMENT_2 */
            if (imap_exec(VAR_0, ""CAPABILITY"", VAR_15))
              goto bail;
          }
        }
      }
    }

    if (VAR_5 && !VAR_0->conn->ssf)
    {
      mutt_error(_(""Encrypted connection unavailable""));
      goto err_close_conn;
    }
#endif
  }
  else if (mutt_str_startswith(VAR_0->buf, ""* PREAUTH"", VAR_3))
  {
#ifdef VAR_4
    /* COMMENT_3 */
                                 
    if (VAR_0->conn->ssf == 0)
    {
      bool VAR_16 = true;
      if (VAR_5)
      {
        VAR_16 = false;
      }
      else if (VAR_9 != VAR_17)
      {
        VAR_16 = mutt_yesorno(_(""Abort unencrypted PREAUTH connection?""),
                               VAR_9) != VAR_17;
      }
      if (!VAR_16)
      {
        mutt_error(_(""Encrypted connection unavailable""));
        goto err_close_conn;
      }
    }
#endif

    VAR_0->state = VAR_18;
    if (check_capabilities(VAR_0) != 0)
      goto bail;
    FREE(&VAR_0->capstr);
  }
  else
  {
    imap_error(""imap_open_connection()"", VAR_0->buf);
    goto bail;
  }

  return 0;

#ifdef VAR_4
err_close_conn:
  imap_close_connection(VAR_0);
#endif
bail:
  FREE(&VAR_0->capstr);
  return -1;
}",neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc/imap.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -33,7 +33,10 @@
       }
       if (ans == MUTT_YES)
       {
-        enum ImapExecResult rc = imap_exec(adata, ""STARTTLS"", IMAP_CMD_NO_FLAGS);
+        enum ImapExecResult rc = imap_exec(adata, ""STARTTLS"", IMAP_CMD_SINGLE);
+        // Clear any data after the STARTTLS acknowledgement
+        mutt_socket_empty(adata->conn);
+
         if (rc == IMAP_EXEC_FATAL)
           goto bail;
         if (rc != IMAP_EXEC_ERROR)","{'deleted_lines': ['        enum ImapExecResult rc = imap_exec(adata, ""STARTTLS"", IMAP_CMD_NO_FLAGS);'], 'added_lines': ['        enum ImapExecResult rc = imap_exec(adata, ""STARTTLS"", IMAP_CMD_SINGLE);', '        // Clear any data after the STARTTLS acknowledgement', '        mutt_socket_empty(adata->conn);', '']}",True,"Mutt before 1.14.4 and NeoMutt before 2020-06-19 have a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a ""begin TLS"" response, the client reads additional data (e.g., from a man-in-the-middle attacker) and evaluates it in a TLS context, aka ""response injection.""",5.9,MEDIUM,1,test,2020-06-18T11:11:27Z,3
CVE-2020-14954,['CWE-74'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,neomutt,"tls: clear data after a starttls acknowledgement

After a starttls acknowledgement message, clear the buffers of any
incoming data / commands.  This will ensure that all future data is
handled securely.

Co-authored-by: Pietro Cerutti <gahr@gahr.ch>",fb013ec666759cb8a9e294347c7b4c1f597639cc,https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc,imap/command.c,imap_exec,"int imap_exec(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags)
{
int rc;
rc = cmd_start(adata, cmdstr, flags);
if (rc < 0)
{
cmd_handle_fatal(adata);
return IMAP_EXEC_FATAL;
}
if (flags & IMAP_CMD_QUEUE)
return IMAP_EXEC_SUCCESS;
if ((flags & IMAP_CMD_POLL) && (C_ImapPollTimeout > 0) &&
((mutt_socket_poll(adata->conn, C_ImapPollTimeout)) == 0))
{
mutt_error(_(""Connection to %s timed out""), adata->conn->account.host);
cmd_handle_fatal(adata);
return IMAP_EXEC_FATAL;
}
mutt_sig_allow_interrupt(true);
do
{
rc = imap_cmd_step(adata);
} while (rc == IMAP_RES_CONTINUE);
mutt_sig_allow_interrupt(false);
if (rc == IMAP_RES_NO)
return IMAP_EXEC_ERROR;
if (rc != IMAP_RES_OK)
{
if (adata->status != IMAP_FATAL)
return IMAP_EXEC_ERROR;
mutt_debug(LL_DEBUG1, ""command failed: %s\n"", adata->buf);
return IMAP_EXEC_FATAL;
}
return IMAP_EXEC_SUCCESS;
}","int imap_exec(struct ImapAccountData *VAR_0, const char *VAR_1, ImapCmdFlags VAR_2)
{
int VAR_3;
VAR_3 = cmd_start(VAR_0, VAR_1, VAR_2);
if (VAR_3 < 0)
{
cmd_handle_fatal(VAR_0);
return VAR_4;
}
if (VAR_2 & VAR_5)
return VAR_6;
if ((VAR_2 & VAR_7) && (VAR_8 > 0) &&
((mutt_socket_poll(VAR_0->conn, VAR_8)) == 0))
{
mutt_error(_(""Connection to %s timed out""), VAR_0->conn->account.host);
cmd_handle_fatal(VAR_0);
return VAR_4;
}
mutt_sig_allow_interrupt(true);
do
{
VAR_3 = imap_cmd_step(VAR_0);
} while (VAR_3 == VAR_9);
mutt_sig_allow_interrupt(false);
if (VAR_3 == VAR_10)
return VAR_11;
if (VAR_3 != VAR_12)
{
if (VAR_0->status != VAR_13)
return VAR_11;
mutt_debug(VAR_14, ""command failed: %s\n"", VAR_0->buf);
return VAR_4;
}
return VAR_6;
}",neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc/command.c/vul/before/0.json,"int imap_exec(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags)
{
  int rc;

  if (flags & IMAP_CMD_SINGLE)
  {
    // Process any existing commands
    if (adata->nextcmd != adata->lastcmd)
      imap_exec(adata, NULL, IMAP_CMD_POLL);
  }

  rc = cmd_start(adata, cmdstr, flags);
  if (rc < 0)
  {
    cmd_handle_fatal(adata);
    return IMAP_EXEC_FATAL;
  }

  if (flags & IMAP_CMD_QUEUE)
    return IMAP_EXEC_SUCCESS;

  if ((flags & IMAP_CMD_POLL) && (C_ImapPollTimeout > 0) &&
      ((mutt_socket_poll(adata->conn, C_ImapPollTimeout)) == 0))
  {
    mutt_error(_(""Connection to %s timed out""), adata->conn->account.host);
    cmd_handle_fatal(adata);
    return IMAP_EXEC_FATAL;
  }

  /* Allow interruptions, particularly useful if there are network problems. */
  mutt_sig_allow_interrupt(true);
  do
  {
    rc = imap_cmd_step(adata);
    // The queue is empty, so the single command has been processed
    if ((flags & IMAP_CMD_SINGLE) && (adata->nextcmd == adata->lastcmd))
      break;
  } while (rc == IMAP_RES_CONTINUE);
  mutt_sig_allow_interrupt(false);

  if (rc == IMAP_RES_NO)
    return IMAP_EXEC_ERROR;
  if (rc != IMAP_RES_OK)
  {
    if (adata->status != IMAP_FATAL)
      return IMAP_EXEC_ERROR;

    mutt_debug(LL_DEBUG1, ""command failed: %s\n"", adata->buf);
    return IMAP_EXEC_FATAL;
  }

  return IMAP_EXEC_SUCCESS;
}","int imap_exec(struct ImapAccountData *VAR_0, const char *VAR_1, ImapCmdFlags VAR_2)
{
  int VAR_3;

  if (VAR_2 & VAR_4)
  {
    /* COMMENT_0 */
    if (VAR_0->nextcmd != VAR_0->lastcmd)
      imap_exec(VAR_0, NULL, VAR_5);
  }

  VAR_3 = cmd_start(VAR_0, VAR_1, VAR_2);
  if (VAR_3 < 0)
  {
    cmd_handle_fatal(VAR_0);
    return VAR_6;
  }

  if (VAR_2 & VAR_7)
    return VAR_8;

  if ((VAR_2 & VAR_5) && (VAR_9 > 0) &&
      ((mutt_socket_poll(VAR_0->conn, VAR_9)) == 0))
  {
    mutt_error(_(""Connection to %s timed out""), VAR_0->conn->account.host);
    cmd_handle_fatal(VAR_0);
    return VAR_6;
  }

  /* COMMENT_1 */
  mutt_sig_allow_interrupt(true);
  do
  {
    VAR_3 = imap_cmd_step(VAR_0);
    /* COMMENT_2 */
    if ((VAR_2 & VAR_4) && (VAR_0->nextcmd == VAR_0->lastcmd))
      break;
  } while (VAR_3 == VAR_10);
  mutt_sig_allow_interrupt(false);

  if (VAR_3 == VAR_11)
    return VAR_12;
  if (VAR_3 != VAR_13)
  {
    if (VAR_0->status != VAR_14)
      return VAR_12;

    mutt_debug(VAR_15, ""command failed: %s\n"", VAR_0->buf);
    return VAR_6;
  }

  return VAR_8;
}",neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc/command.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,13 @@
 int imap_exec(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags)
 {
   int rc;
+
+  if (flags & IMAP_CMD_SINGLE)
+  {
+    // Process any existing commands
+    if (adata->nextcmd != adata->lastcmd)
+      imap_exec(adata, NULL, IMAP_CMD_POLL);
+  }
 
   rc = cmd_start(adata, cmdstr, flags);
   if (rc < 0)
@@ -25,6 +32,9 @@
   do
   {
     rc = imap_cmd_step(adata);
+    // The queue is empty, so the single command has been processed
+    if ((flags & IMAP_CMD_SINGLE) && (adata->nextcmd == adata->lastcmd))
+      break;
   } while (rc == IMAP_RES_CONTINUE);
   mutt_sig_allow_interrupt(false);
 ","{'deleted_lines': [], 'added_lines': ['', '  if (flags & IMAP_CMD_SINGLE)', '  {', '    // Process any existing commands', '    if (adata->nextcmd != adata->lastcmd)', '      imap_exec(adata, NULL, IMAP_CMD_POLL);', '  }', '    // The queue is empty, so the single command has been processed', '    if ((flags & IMAP_CMD_SINGLE) && (adata->nextcmd == adata->lastcmd))', '      break;']}",True,"Mutt before 1.14.4 and NeoMutt before 2020-06-19 have a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a ""begin TLS"" response, the client reads additional data (e.g., from a man-in-the-middle attacker) and evaluates it in a TLS context, aka ""response injection.""",5.9,MEDIUM,1,test,2020-06-18T11:11:27Z,3
CVE-2020-14954,['CWE-74'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,neomutt,"tls: clear data after a starttls acknowledgement

After a starttls acknowledgement message, clear the buffers of any
incoming data / commands.  This will ensure that all future data is
handled securely.

Co-authored-by: Pietro Cerutti <gahr@gahr.ch>",fb013ec666759cb8a9e294347c7b4c1f597639cc,https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc,smtp.c,smtp_open,"static int smtp_open(struct Connection *conn, bool esmtp)
{
int rc;
if (mutt_socket_open(conn))
return -1;
rc = smtp_get_resp(conn);
if (rc != 0)
return rc;
rc = smtp_helo(conn, esmtp);
if (rc != 0)
return rc;
#ifdef USE_SSL
enum QuadOption ans = MUTT_NO;
if (conn->ssf)
ans = MUTT_NO;
else if (C_SslForceTls)
ans = MUTT_YES;
else if ((Capabilities & SMTP_CAP_STARTTLS) &&
((ans = query_quadoption(C_SslStarttls,
_(""Secure connection with TLS?""))) == MUTT_ABORT))
{
return -1;
}
if (ans == MUTT_YES)
{
if (mutt_socket_send(conn, ""STARTTLS\r\n"") < 0)
return SMTP_ERR_WRITE;
rc = smtp_get_resp(conn);
if (rc != 0)
return rc;
if (mutt_ssl_starttls(conn))
{
mutt_error(_(""Could not negotiate TLS connection""));
return -1;
}
rc = smtp_helo(conn, esmtp);
if (rc != 0)
return rc;
}
#endif
if (conn->account.flags & MUTT_ACCT_USER)
{
if (!(Capabilities & SMTP_CAP_AUTH))
{
mutt_error(_(""SMTP server does not support authentication""));
return -1;
}
return smtp_auth(conn);
}
return 0;
}","static int smtp_open(struct Connection *VAR_0, bool VAR_1)
{
int VAR_2;
if (mutt_socket_open(VAR_0))
return -1;
VAR_2 = smtp_get_resp(VAR_0);
if (VAR_2 != 0)
return VAR_2;
VAR_2 = smtp_helo(VAR_0, VAR_1);
if (VAR_2 != 0)
return VAR_2;
#ifdef VAR_3
enum QuadOption VAR_4 = VAR_5;
if (VAR_0->ssf)
VAR_4 = VAR_5;
else if (VAR_6)
VAR_4 = VAR_7;
else if ((VAR_8 & VAR_9) &&
((VAR_4 = query_quadoption(VAR_10,
_(""Secure connection with TLS?""))) == VAR_11))
{
return -1;
}
if (VAR_4 == VAR_7)
{
if (mutt_socket_send(VAR_0, ""STARTTLS\r\n"") < 0)
return VAR_12;
VAR_2 = smtp_get_resp(VAR_0);
if (VAR_2 != 0)
return VAR_2;
if (mutt_ssl_starttls(VAR_0))
{
mutt_error(_(""Could not negotiate TLS connection""));
return -1;
}
VAR_2 = smtp_helo(VAR_0, VAR_1);
if (VAR_2 != 0)
return VAR_2;
}
#endif
if (VAR_0->account.flags & VAR_13)
{
if (!(VAR_8 & VAR_14))
{
mutt_error(_(""SMTP server does not support authentication""));
return -1;
}
return smtp_auth(VAR_0);
}
return 0;
}",neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc/smtp.c/vul/before/0.json,"static int smtp_open(struct Connection *conn, bool esmtp)
{
  int rc;

  if (mutt_socket_open(conn))
    return -1;

  /* get greeting string */
  rc = smtp_get_resp(conn);
  if (rc != 0)
    return rc;

  rc = smtp_helo(conn, esmtp);
  if (rc != 0)
    return rc;

#ifdef USE_SSL
  enum QuadOption ans = MUTT_NO;
  if (conn->ssf)
    ans = MUTT_NO;
  else if (C_SslForceTls)
    ans = MUTT_YES;
  else if ((Capabilities & SMTP_CAP_STARTTLS) &&
           ((ans = query_quadoption(C_SslStarttls,
                                    _(""Secure connection with TLS?""))) == MUTT_ABORT))
  {
    return -1;
  }

  if (ans == MUTT_YES)
  {
    if (mutt_socket_send(conn, ""STARTTLS\r\n"") < 0)
      return SMTP_ERR_WRITE;
    rc = smtp_get_resp(conn);
    // Clear any data after the STARTTLS acknowledgement
    mutt_socket_empty(conn);
    if (rc != 0)
      return rc;

    if (mutt_ssl_starttls(conn))
    {
      mutt_error(_(""Could not negotiate TLS connection""));
      return -1;
    }

    /* re-EHLO to get authentication mechanisms */
    rc = smtp_helo(conn, esmtp);
    if (rc != 0)
      return rc;
  }
#endif

  if (conn->account.flags & MUTT_ACCT_USER)
  {
    if (!(Capabilities & SMTP_CAP_AUTH))
    {
      mutt_error(_(""SMTP server does not support authentication""));
      return -1;
    }

    return smtp_auth(conn);
  }

  return 0;
}","static int smtp_open(struct Connection *VAR_0, bool VAR_1)
{
  int VAR_2;

  if (mutt_socket_open(VAR_0))
    return -1;

  /* COMMENT_0 */
  VAR_2 = smtp_get_resp(VAR_0);
  if (VAR_2 != 0)
    return VAR_2;

  VAR_2 = smtp_helo(VAR_0, VAR_1);
  if (VAR_2 != 0)
    return VAR_2;

#ifdef VAR_3
  enum QuadOption VAR_4 = VAR_5;
  if (VAR_0->ssf)
    VAR_4 = VAR_5;
  else if (VAR_6)
    VAR_4 = VAR_7;
  else if ((VAR_8 & VAR_9) &&
           ((VAR_4 = query_quadoption(VAR_10,
                                    _(""Secure connection with TLS?""))) == VAR_11))
  {
    return -1;
  }

  if (VAR_4 == VAR_7)
  {
    if (mutt_socket_send(VAR_0, ""STARTTLS\r\n"") < 0)
      return VAR_12;
    VAR_2 = smtp_get_resp(VAR_0);
    /* COMMENT_1 */
    mutt_socket_empty(VAR_0);
    if (VAR_2 != 0)
      return VAR_2;

    if (mutt_ssl_starttls(VAR_0))
    {
      mutt_error(_(""Could not negotiate TLS connection""));
      return -1;
    }

    /* COMMENT_2 */
    VAR_2 = smtp_helo(VAR_0, VAR_1);
    if (VAR_2 != 0)
      return VAR_2;
  }
#endif

  if (VAR_0->account.flags & VAR_13)
  {
    if (!(VAR_8 & VAR_14))
    {
      mutt_error(_(""SMTP server does not support authentication""));
      return -1;
    }

    return smtp_auth(VAR_0);
  }

  return 0;
}",neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc/smtp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -32,6 +32,8 @@
     if (mutt_socket_send(conn, ""STARTTLS\r\n"") < 0)
       return SMTP_ERR_WRITE;
     rc = smtp_get_resp(conn);
+    // Clear any data after the STARTTLS acknowledgement
+    mutt_socket_empty(conn);
     if (rc != 0)
       return rc;
 ","{'deleted_lines': [], 'added_lines': ['    // Clear any data after the STARTTLS acknowledgement', '    mutt_socket_empty(conn);']}",True,"Mutt before 1.14.4 and NeoMutt before 2020-06-19 have a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a ""begin TLS"" response, the client reads additional data (e.g., from a man-in-the-middle attacker) and evaluates it in a TLS context, aka ""response injection.""",5.9,MEDIUM,1,test,2020-06-18T11:11:27Z,3
CVE-2020-14954,['CWE-74'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,neomutt,"tls: clear data after a starttls acknowledgement

After a starttls acknowledgement message, clear the buffers of any
incoming data / commands.  This will ensure that all future data is
handled securely.

Co-authored-by: Pietro Cerutti <gahr@gahr.ch>",fb013ec666759cb8a9e294347c7b4c1f597639cc,https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc,pop/pop_lib.c,pop_open_connection,"int pop_open_connection(struct PopAccountData *adata)
{
char buf[1024];
int rc = pop_connect(adata);
if (rc < 0)
return rc;
rc = pop_capabilities(adata, 0);
if (rc == -1)
goto err_conn;
if (rc == -2)
return -2;
#ifdef USE_SSL
if (!adata->conn->ssf && (adata->cmd_stls || C_SslForceTls))
{
if (C_SslForceTls)
adata->use_stls = 2;
if (adata->use_stls == 0)
{
enum QuadOption ans =
query_quadoption(C_SslStarttls, _(""Secure connection with TLS?""));
if (ans == MUTT_ABORT)
return -2;
adata->use_stls = 1;
if (ans == MUTT_YES)
adata->use_stls = 2;
}
if (adata->use_stls == 2)
{
mutt_str_strfcpy(buf, ""STLS\r\n"", sizeof(buf));
rc = pop_query(adata, buf, sizeof(buf));
if (rc == -1)
goto err_conn;
if (rc != 0)
{
mutt_error(""%s"", adata->err_msg);
}
else if (mutt_ssl_starttls(adata->conn))
{
mutt_error(_(""Could not negotiate TLS connection""));
return -2;
}
else
{
rc = pop_capabilities(adata, 1);
if (rc == -1)
goto err_conn;
if (rc == -2)
return -2;
}
}
}
if (C_SslForceTls && !adata->conn->ssf)
{
mutt_error(_(""Encrypted connection unavailable""));
return -2;
}
#endif
rc = pop_authenticate(adata);
if (rc == -1)
goto err_conn;
if (rc == -3)
mutt_clear_error();
if (rc != 0)
return rc;
rc = pop_capabilities(adata, 2);
if (rc == -1)
goto err_conn;
if (rc == -2)
return -2;
mutt_str_strfcpy(buf, ""STAT\r\n"", sizeof(buf));
rc = pop_query(adata, buf, sizeof(buf));
if (rc == -1)
goto err_conn;
if (rc == -2)
{
mutt_error(""%s"", adata->err_msg);
return rc;
}
unsigned int n = 0, size = 0;
sscanf(buf, ""+OK %u %u"", &n, &size);
adata->size = size;
return 0;
err_conn:
adata->status = POP_DISCONNECTED;
mutt_error(_(""Server closed connection""));
return -1;
}","int pop_open_connection(struct PopAccountData *VAR_0)
{
char VAR_1[1024];
int VAR_2 = pop_connect(VAR_0);
if (VAR_2 < 0)
return VAR_2;
VAR_2 = pop_capabilities(VAR_0, 0);
if (VAR_2 == -1)
goto err_conn;
if (VAR_2 == -2)
return -2;
#ifdef VAR_3
if (!VAR_0->conn->ssf && (VAR_0->cmd_stls || VAR_4))
{
if (VAR_4)
VAR_0->use_stls = 2;
if (VAR_0->use_stls == 0)
{
enum QuadOption VAR_5 =
query_quadoption(VAR_6, _(""Secure connection with TLS?""));
if (VAR_5 == VAR_7)
return -2;
VAR_0->use_stls = 1;
if (VAR_5 == VAR_8)
VAR_0->use_stls = 2;
}
if (VAR_0->use_stls == 2)
{
mutt_str_strfcpy(VAR_1, ""STLS\r\n"", sizeof(VAR_1));
VAR_2 = pop_query(VAR_0, VAR_1, sizeof(VAR_1));
if (VAR_2 == -1)
goto err_conn;
if (VAR_2 != 0)
{
mutt_error(""%s"", VAR_0->err_msg);
}
else if (mutt_ssl_starttls(VAR_0->conn))
{
mutt_error(_(""Could not negotiate TLS connection""));
return -2;
}
else
{
VAR_2 = pop_capabilities(VAR_0, 1);
if (VAR_2 == -1)
goto err_conn;
if (VAR_2 == -2)
return -2;
}
}
}
if (VAR_4 && !VAR_0->conn->ssf)
{
mutt_error(_(""Encrypted connection unavailable""));
return -2;
}
#endif
VAR_2 = pop_authenticate(VAR_0);
if (VAR_2 == -1)
goto err_conn;
if (VAR_2 == -3)
mutt_clear_error();
if (VAR_2 != 0)
return VAR_2;
VAR_2 = pop_capabilities(VAR_0, 2);
if (VAR_2 == -1)
goto err_conn;
if (VAR_2 == -2)
return -2;
mutt_str_strfcpy(VAR_1, ""STAT\r\n"", sizeof(VAR_1));
VAR_2 = pop_query(VAR_0, VAR_1, sizeof(VAR_1));
if (VAR_2 == -1)
goto err_conn;
if (VAR_2 == -2)
{
mutt_error(""%s"", VAR_0->err_msg);
return VAR_2;
}
unsigned int VAR_9 = 0, VAR_10 = 0;
sscanf(VAR_1, ""+OK %u %u"", &VAR_9, &VAR_10);
VAR_0->size = VAR_10;
return 0;
err_conn:
VAR_0->status = VAR_11;
mutt_error(_(""Server closed connection""));
return -1;
}",neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc/pop_lib.c/vul/before/0.json,"int pop_open_connection(struct PopAccountData *adata)
{
  char buf[1024];

  int rc = pop_connect(adata);
  if (rc < 0)
    return rc;

  rc = pop_capabilities(adata, 0);
  if (rc == -1)
    goto err_conn;
  if (rc == -2)
    return -2;

#ifdef USE_SSL
  /* Attempt STLS if available and desired. */
  if (!adata->conn->ssf && (adata->cmd_stls || C_SslForceTls))
  {
    if (C_SslForceTls)
      adata->use_stls = 2;
    if (adata->use_stls == 0)
    {
      enum QuadOption ans =
          query_quadoption(C_SslStarttls, _(""Secure connection with TLS?""));
      if (ans == MUTT_ABORT)
        return -2;
      adata->use_stls = 1;
      if (ans == MUTT_YES)
        adata->use_stls = 2;
    }
    if (adata->use_stls == 2)
    {
      mutt_str_strfcpy(buf, ""STLS\r\n"", sizeof(buf));
      rc = pop_query(adata, buf, sizeof(buf));
      // Clear any data after the STLS acknowledgement
      mutt_socket_empty(adata->conn);
      if (rc == -1)
        goto err_conn;
      if (rc != 0)
      {
        mutt_error(""%s"", adata->err_msg);
      }
      else if (mutt_ssl_starttls(adata->conn))
      {
        mutt_error(_(""Could not negotiate TLS connection""));
        return -2;
      }
      else
      {
        /* recheck capabilities after STLS completes */
        rc = pop_capabilities(adata, 1);
        if (rc == -1)
          goto err_conn;
        if (rc == -2)
          return -2;
      }
    }
  }

  if (C_SslForceTls && !adata->conn->ssf)
  {
    mutt_error(_(""Encrypted connection unavailable""));
    return -2;
  }
#endif

  rc = pop_authenticate(adata);
  if (rc == -1)
    goto err_conn;
  if (rc == -3)
    mutt_clear_error();
  if (rc != 0)
    return rc;

  /* recheck capabilities after authentication */
  rc = pop_capabilities(adata, 2);
  if (rc == -1)
    goto err_conn;
  if (rc == -2)
    return -2;

  /* get total size of mailbox */
  mutt_str_strfcpy(buf, ""STAT\r\n"", sizeof(buf));
  rc = pop_query(adata, buf, sizeof(buf));
  if (rc == -1)
    goto err_conn;
  if (rc == -2)
  {
    mutt_error(""%s"", adata->err_msg);
    return rc;
  }

  unsigned int n = 0, size = 0;
  sscanf(buf, ""+OK %u %u"", &n, &size);
  adata->size = size;
  return 0;

err_conn:
  adata->status = POP_DISCONNECTED;
  mutt_error(_(""Server closed connection""));
  return -1;
}","int pop_open_connection(struct PopAccountData *VAR_0)
{
  char VAR_1[1024];

  int VAR_2 = pop_connect(VAR_0);
  if (VAR_2 < 0)
    return VAR_2;

  VAR_2 = pop_capabilities(VAR_0, 0);
  if (VAR_2 == -1)
    goto err_conn;
  if (VAR_2 == -2)
    return -2;

#ifdef VAR_3
  /* COMMENT_0 */
  if (!VAR_0->conn->ssf && (VAR_0->cmd_stls || VAR_4))
  {
    if (VAR_4)
      VAR_0->use_stls = 2;
    if (VAR_0->use_stls == 0)
    {
      enum QuadOption VAR_5 =
          query_quadoption(VAR_6, _(""Secure connection with TLS?""));
      if (VAR_5 == VAR_7)
        return -2;
      VAR_0->use_stls = 1;
      if (VAR_5 == VAR_8)
        VAR_0->use_stls = 2;
    }
    if (VAR_0->use_stls == 2)
    {
      mutt_str_strfcpy(VAR_1, ""STLS\r\n"", sizeof(VAR_1));
      VAR_2 = pop_query(VAR_0, VAR_1, sizeof(VAR_1));
      /* COMMENT_1 */
      mutt_socket_empty(VAR_0->conn);
      if (VAR_2 == -1)
        goto err_conn;
      if (VAR_2 != 0)
      {
        mutt_error(""%s"", VAR_0->err_msg);
      }
      else if (mutt_ssl_starttls(VAR_0->conn))
      {
        mutt_error(_(""Could not negotiate TLS connection""));
        return -2;
      }
      else
      {
        /* COMMENT_2 */
        VAR_2 = pop_capabilities(VAR_0, 1);
        if (VAR_2 == -1)
          goto err_conn;
        if (VAR_2 == -2)
          return -2;
      }
    }
  }

  if (VAR_4 && !VAR_0->conn->ssf)
  {
    mutt_error(_(""Encrypted connection unavailable""));
    return -2;
  }
#endif

  VAR_2 = pop_authenticate(VAR_0);
  if (VAR_2 == -1)
    goto err_conn;
  if (VAR_2 == -3)
    mutt_clear_error();
  if (VAR_2 != 0)
    return VAR_2;

  /* COMMENT_3 */
  VAR_2 = pop_capabilities(VAR_0, 2);
  if (VAR_2 == -1)
    goto err_conn;
  if (VAR_2 == -2)
    return -2;

  /* COMMENT_4 */
  mutt_str_strfcpy(VAR_1, ""STAT\r\n"", sizeof(VAR_1));
  VAR_2 = pop_query(VAR_0, VAR_1, sizeof(VAR_1));
  if (VAR_2 == -1)
    goto err_conn;
  if (VAR_2 == -2)
  {
    mutt_error(""%s"", VAR_0->err_msg);
    return VAR_2;
  }

  unsigned int VAR_9 = 0, VAR_10 = 0;
  sscanf(VAR_1, ""+OK %u %u"", &VAR_9, &VAR_10);
  VAR_0->size = VAR_10;
  return 0;

err_conn:
  VAR_0->status = VAR_11;
  mutt_error(_(""Server closed connection""));
  return -1;
}",neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc/pop_lib.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -32,6 +32,8 @@
     {
       mutt_str_strfcpy(buf, ""STLS\r\n"", sizeof(buf));
       rc = pop_query(adata, buf, sizeof(buf));
+      // Clear any data after the STLS acknowledgement
+      mutt_socket_empty(adata->conn);
       if (rc == -1)
         goto err_conn;
       if (rc != 0)","{'deleted_lines': [], 'added_lines': ['      // Clear any data after the STLS acknowledgement', '      mutt_socket_empty(adata->conn);']}",True,"Mutt before 1.14.4 and NeoMutt before 2020-06-19 have a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a ""begin TLS"" response, the client reads additional data (e.g., from a man-in-the-middle attacker) and evaluates it in a TLS context, aka ""response injection.""",5.9,MEDIUM,1,test,2020-06-18T11:11:27Z,3
CVE-2020-15389,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,uclouvain/openjpeg,"opj_decompress: fix double-free on input directory with mix of valid and invalid images (CVE-2020-15389)

Fixes #1261

Credits to @Ruia-ruia for reporting and analysis.",e8e258ab049240c2dd1f1051b4e773b21e2d3dc0,https://github.com/uclouvain/openjpeg/commit/e8e258ab049240c2dd1f1051b4e773b21e2d3dc0,src/bin/jp2/opj_decompress.c,main,"int main(int argc, char **argv)
{
opj_decompress_parameters parameters;           
opj_image_t* image = NULL;
opj_stream_t *l_stream = NULL;              
opj_codec_t* l_codec = NULL;                
opj_codestream_index_t* cstr_index = NULL;
OPJ_INT32 num_images, imageno;
img_fol_t img_fol;
dircnt_t *dirptr = NULL;
int failed = 0;
OPJ_FLOAT64 t, tCumulative = 0;
OPJ_UINT32 numDecompressedImages = 0;
OPJ_UINT32 cp_reduce;
set_default_parameters(&parameters);
memset(&img_fol, 0, sizeof(img_fol_t));
if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) {
failed = 1;
goto fin;
}
cp_reduce = parameters.core.cp_reduce;
if (getenv(""USE_OPJ_SET_DECODED_RESOLUTION_FACTOR"") != NULL) {
parameters.core.cp_reduce = 0;
}
if (img_fol.set_imgdir == 1) {
int it_image;
num_images = get_num_images(img_fol.imgdirpath);
dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));
if (!dirptr) {
destroy_parameters(&parameters);
return EXIT_FAILURE;
}
dirptr->filename_buf = (char*)malloc(sizeof(char) *
(size_t)num_images * OPJ_PATH_LEN);
if (!dirptr->filename_buf) {
failed = 1;
goto fin;
}
dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));
if (!dirptr->filename) {
failed = 1;
goto fin;
}
for (it_image = 0; it_image < num_images; it_image++) {
dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN;
}
if (load_images(dirptr, img_fol.imgdirpath) == 1) {
failed = 1;
goto fin;
}
if (num_images == 0) {
fprintf(stderr, ""Folder is empty\n"");
failed = 1;
goto fin;
}
} else {
num_images = 1;
}
for (imageno = 0; imageno < num_images ; imageno++)  {
if (!parameters.quiet) {
fprintf(stderr, ""\n"");
}
if (img_fol.set_imgdir == 1) {
if (get_next_file(imageno, dirptr, &img_fol, &parameters)) {
fprintf(stderr, ""skipping file...\n"");
destroy_parameters(&parameters);
continue;
}
}
l_stream = opj_stream_create_default_file_stream(parameters.infile, 1);
if (!l_stream) {
fprintf(stderr, ""ERROR -> failed to create the stream from the file %s\n"",
parameters.infile);
failed = 1;
goto fin;
}
switch (parameters.decod_format) {
case J2K_CFMT: { 
l_codec = opj_create_decompress(OPJ_CODEC_J2K);
break;
}
case JP2_CFMT: { 
l_codec = opj_create_decompress(OPJ_CODEC_JP2);
break;
}
case JPT_CFMT: { 
l_codec = opj_create_decompress(OPJ_CODEC_JPT);
break;
}
default:
fprintf(stderr, ""skipping file..\n"");
destroy_parameters(&parameters);
opj_stream_destroy(l_stream);
continue;
}
if (parameters.quiet) {
opj_set_info_handler(l_codec, quiet_callback, 00);
opj_set_warning_handler(l_codec, quiet_callback, 00);
opj_set_error_handler(l_codec, quiet_callback, 00);
} else {
opj_set_info_handler(l_codec, info_callback, 00);
opj_set_warning_handler(l_codec, warning_callback, 00);
opj_set_error_handler(l_codec, error_callback, 00);
}
t = opj_clock();
if (!opj_setup_decoder(l_codec, &(parameters.core))) {
fprintf(stderr, ""ERROR -> opj_decompress: failed to setup the decoder\n"");
opj_stream_destroy(l_stream);
opj_destroy_codec(l_codec);
failed = 1;
goto fin;
}
if (parameters.num_threads >= 1 &&
!opj_codec_set_threads(l_codec, parameters.num_threads)) {
fprintf(stderr, ""ERROR -> opj_decompress: failed to set number of threads\n"");
opj_stream_destroy(l_stream);
opj_destroy_codec(l_codec);
failed = 1;
goto fin;
}
if (! opj_read_header(l_stream, l_codec, &image)) {
fprintf(stderr, ""ERROR -> opj_decompress: failed to read the header\n"");
opj_stream_destroy(l_stream);
opj_destroy_codec(l_codec);
opj_image_destroy(image);
failed = 1;
goto fin;
}
if (parameters.numcomps) {
if (! opj_set_decoded_components(l_codec,
parameters.numcomps,
parameters.comps_indices,
OPJ_FALSE)) {
fprintf(stderr,
""ERROR -> opj_decompress: failed to set the component indices!\n"");
opj_destroy_codec(l_codec);
opj_stream_destroy(l_stream);
opj_image_destroy(image);
failed = 1;
goto fin;
}
}
if (getenv(""USE_OPJ_SET_DECODED_RESOLUTION_FACTOR"") != NULL) {
if (! opj_set_decoded_resolution_factor(l_codec, cp_reduce)) {
fprintf(stderr,
""ERROR -> opj_decompress: failed to set the resolution factor tile!\n"");
opj_destroy_codec(l_codec);
opj_stream_destroy(l_stream);
opj_image_destroy(image);
failed = 1;
goto fin;
}
}
if (!parameters.nb_tile_to_decode) {
if (getenv(""SKIP_OPJ_SET_DECODE_AREA"") != NULL &&
parameters.DA_x0 == 0 &&
parameters.DA_y0 == 0 &&
parameters.DA_x1 == 0 &&
parameters.DA_y1 == 0) {
}
else if (!opj_set_decode_area(l_codec, image, (OPJ_INT32)parameters.DA_x0,
(OPJ_INT32)parameters.DA_y0, (OPJ_INT32)parameters.DA_x1,
(OPJ_INT32)parameters.DA_y1)) {
fprintf(stderr, ""ERROR -> opj_decompress: failed to set the decoded area\n"");
opj_stream_destroy(l_stream);
opj_destroy_codec(l_codec);
opj_image_destroy(image);
failed = 1;
goto fin;
}
if (!(opj_decode(l_codec, l_stream, image) &&
opj_end_decompress(l_codec,   l_stream))) {
fprintf(stderr, ""ERROR -> opj_decompress: failed to decode image!\n"");
opj_destroy_codec(l_codec);
opj_stream_destroy(l_stream);
opj_image_destroy(image);
failed = 1;
goto fin;
}
} else {
if (!(parameters.DA_x0 == 0 &&
parameters.DA_y0 == 0 &&
parameters.DA_x1 == 0 &&
parameters.DA_y1 == 0)) {
if (!(parameters.quiet)) {
fprintf(stderr, ""WARNING: -d option ignored when used together with -t\n"");
}
}
if (!opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index)) {
fprintf(stderr, ""ERROR -> opj_decompress: failed to decode tile!\n"");
opj_destroy_codec(l_codec);
opj_stream_destroy(l_stream);
opj_image_destroy(image);
failed = 1;
goto fin;
}
if (!(parameters.quiet)) {
fprintf(stdout, ""tile %d is decoded!\n\n"", parameters.tile_index);
}
}
tCumulative += opj_clock() - t;
numDecompressedImages++;
opj_stream_destroy(l_stream);
if (image->color_space != OPJ_CLRSPC_SYCC
&& image->numcomps == 3 && image->comps[0].dx == image->comps[0].dy
&& image->comps[1].dx != 1) {
image->color_space = OPJ_CLRSPC_SYCC;
} else if (image->numcomps <= 2) {
image->color_space = OPJ_CLRSPC_GRAY;
}
if (image->color_space == OPJ_CLRSPC_SYCC) {
color_sycc_to_rgb(image);
} else if ((image->color_space == OPJ_CLRSPC_CMYK) &&
(parameters.cod_format != TIF_DFMT)) {
color_cmyk_to_rgb(image);
} else if (image->color_space == OPJ_CLRSPC_EYCC) {
color_esycc_to_rgb(image);
}
if (image->icc_profile_buf) {
#if defined(OPJ_HAVE_LIBLCMS1) || defined(OPJ_HAVE_LIBLCMS2)
if (image->icc_profile_len) {
color_apply_icc_profile(image);
} else {
color_cielab_to_rgb(image);
}
#endif
free(image->icc_profile_buf);
image->icc_profile_buf = NULL;
image->icc_profile_len = 0;
}
if (parameters.precision != NULL) {
OPJ_UINT32 compno;
for (compno = 0; compno < image->numcomps; ++compno) {
OPJ_UINT32 precno = compno;
OPJ_UINT32 prec;
if (precno >= parameters.nb_precision) {
precno = parameters.nb_precision - 1U;
}
prec = parameters.precision[precno].prec;
if (prec == 0) {
prec = image->comps[compno].prec;
}
switch (parameters.precision[precno].mode) {
case OPJ_PREC_MODE_CLIP:
clip_component(&(image->comps[compno]), prec);
break;
case OPJ_PREC_MODE_SCALE:
scale_component(&(image->comps[compno]), prec);
break;
default:
break;
}
}
}
if (parameters.upsample) {
image = upsample_image_components(image);
if (image == NULL) {
fprintf(stderr,
""ERROR -> opj_decompress: failed to upsample image components!\n"");
opj_destroy_codec(l_codec);
failed = 1;
goto fin;
}
}
if (parameters.force_rgb) {
switch (image->color_space) {
case OPJ_CLRSPC_SRGB:
break;
case OPJ_CLRSPC_GRAY:
image = convert_gray_to_rgb(image);
break;
default:
fprintf(stderr,
""ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\n"");
opj_image_destroy(image);
image = NULL;
break;
}
if (image == NULL) {
fprintf(stderr, ""ERROR -> opj_decompress: failed to convert to RGB image!\n"");
opj_destroy_codec(l_codec);
failed = 1;
goto fin;
}
}
switch (parameters.cod_format) {
case PXM_DFMT:          
if (imagetopnm(image, parameters.outfile, parameters.split_pnm)) {
fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
failed = 1;
} else if (!(parameters.quiet)) {
fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
}
break;
case PGX_DFMT:          
if (imagetopgx(image, parameters.outfile)) {
fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
failed = 1;
} else if (!(parameters.quiet)) {
fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
}
break;
case BMP_DFMT:          
if (imagetobmp(image, parameters.outfile)) {
fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
failed = 1;
} else if (!(parameters.quiet)) {
fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
}
break;
#ifdef OPJ_HAVE_LIBTIFF
case TIF_DFMT:          
if (imagetotif(image, parameters.outfile)) {
fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
failed = 1;
} else if (!(parameters.quiet)) {
fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
}
break;
#endif 
case RAW_DFMT:          
if (imagetoraw(image, parameters.outfile)) {
fprintf(stderr, ""[ERROR] Error generating raw file. Outfile %s not generated\n"",
parameters.outfile);
failed = 1;
} else if (!(parameters.quiet)) {
fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
}
break;
case RAWL_DFMT:         
if (imagetorawl(image, parameters.outfile)) {
fprintf(stderr,
""[ERROR] Error generating rawl file. Outfile %s not generated\n"",
parameters.outfile);
failed = 1;
} else if (!(parameters.quiet)) {
fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
}
break;
case TGA_DFMT:          
if (imagetotga(image, parameters.outfile)) {
fprintf(stderr, ""[ERROR] Error generating tga file. Outfile %s not generated\n"",
parameters.outfile);
failed = 1;
} else if (!(parameters.quiet)) {
fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
}
break;
#ifdef OPJ_HAVE_LIBPNG
case PNG_DFMT:          
if (imagetopng(image, parameters.outfile)) {
fprintf(stderr, ""[ERROR] Error generating png file. Outfile %s not generated\n"",
parameters.outfile);
failed = 1;
} else if (!(parameters.quiet)) {
fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
}
break;
#endif 
default:
fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
failed = 1;
}
if (l_codec) {
opj_destroy_codec(l_codec);
}
opj_image_destroy(image);
opj_destroy_cstr_index(&cstr_index);
if (failed) {
(void)remove(parameters.outfile);    
}
}
fin:
destroy_parameters(&parameters);
if (failed && img_fol.imgdirpath) {
free(img_fol.imgdirpath);
}
if (dirptr) {
if (dirptr->filename) {
free(dirptr->filename);
}
if (dirptr->filename_buf) {
free(dirptr->filename_buf);
}
free(dirptr);
}
if (numDecompressedImages && !failed && !(parameters.quiet)) {
fprintf(stdout, ""decode time: %d ms\n"",
(int)((tCumulative * 1000.0) / (OPJ_FLOAT64)numDecompressedImages));
}
return failed ? EXIT_FAILURE : EXIT_SUCCESS;
}","int main(int VAR_0, char **VAR_1)
{
opj_decompress_parameters VAR_2;           
opj_image_t* VAR_3 = NULL;
opj_stream_t *VAR_4 = NULL;              
opj_codec_t* VAR_5 = NULL;                
opj_codestream_index_t* VAR_6 = NULL;
OPJ_INT32 VAR_7, VAR_8;
img_fol_t VAR_9;
dircnt_t *VAR_10 = NULL;
int VAR_11 = 0;
OPJ_FLOAT64 VAR_12, VAR_13 = 0;
OPJ_UINT32 VAR_14 = 0;
OPJ_UINT32 VAR_15;
set_default_parameters(&VAR_2);
memset(&VAR_9, 0, sizeof(img_fol_t));
if (parse_cmdline_decoder(VAR_0, VAR_1, &VAR_2, &VAR_9) == 1) {
VAR_11 = 1;
goto fin;
}
VAR_15 = VAR_2.core.cp_reduce;
if (getenv(""USE_OPJ_SET_DECODED_RESOLUTION_FACTOR"") != NULL) {
VAR_2.core.cp_reduce = 0;
}
if (VAR_9.set_imgdir == 1) {
int VAR_16;
VAR_7 = get_num_images(VAR_9.imgdirpath);
VAR_10 = (dircnt_t*)malloc(sizeof(dircnt_t));
if (!VAR_10) {
destroy_parameters(&VAR_2);
return VAR_17;
}
VAR_10->filename_buf = (char*)malloc(sizeof(char) *
(size_t)VAR_7 * VAR_18);
if (!VAR_10->filename_buf) {
VAR_11 = 1;
goto fin;
}
VAR_10->filename = (char**) malloc((size_t)VAR_7 * sizeof(char*));
if (!VAR_10->filename) {
VAR_11 = 1;
goto fin;
}
for (VAR_16 = 0; VAR_16 < VAR_7; VAR_16++) {
VAR_10->filename[VAR_16] = VAR_10->filename_buf + VAR_16 * VAR_18;
}
if (load_images(VAR_10, VAR_9.imgdirpath) == 1) {
VAR_11 = 1;
goto fin;
}
if (VAR_7 == 0) {
fprintf(VAR_19, ""Folder is empty\n"");
VAR_11 = 1;
goto fin;
}
} else {
VAR_7 = 1;
}
for (VAR_8 = 0; VAR_8 < VAR_7 ; VAR_8++)  {
if (!VAR_2.quiet) {
fprintf(VAR_19, ""\n"");
}
if (VAR_9.set_imgdir == 1) {
if (get_next_file(VAR_8, VAR_10, &VAR_9, &VAR_2)) {
fprintf(VAR_19, ""skipping file...\n"");
destroy_parameters(&VAR_2);
continue;
}
}
VAR_4 = opj_stream_create_default_file_stream(VAR_2.infile, 1);
if (!VAR_4) {
fprintf(VAR_19, ""ERROR -> failed to create the stream from the file %s\n"",
VAR_2.infile);
VAR_11 = 1;
goto fin;
}
switch (VAR_2.decod_format) {
case VAR_20: { 
VAR_5 = opj_create_decompress(VAR_21);
break;
}
case VAR_22: { 
VAR_5 = opj_create_decompress(VAR_23);
break;
}
case VAR_24: { 
VAR_5 = opj_create_decompress(VAR_25);
break;
}
default:
fprintf(VAR_19, ""skipping file..\n"");
destroy_parameters(&VAR_2);
opj_stream_destroy(VAR_4);
continue;
}
if (VAR_2.quiet) {
opj_set_info_handler(VAR_5, VAR_26, 00);
opj_set_warning_handler(VAR_5, VAR_26, 00);
opj_set_error_handler(VAR_5, VAR_26, 00);
} else {
opj_set_info_handler(VAR_5, VAR_27, 00);
opj_set_warning_handler(VAR_5, VAR_28, 00);
opj_set_error_handler(VAR_5, VAR_29, 00);
}
VAR_12 = opj_clock();
if (!opj_setup_decoder(VAR_5, &(VAR_2.core))) {
fprintf(VAR_19, ""ERROR -> opj_decompress: failed to setup the decoder\n"");
opj_stream_destroy(VAR_4);
opj_destroy_codec(VAR_5);
VAR_11 = 1;
goto fin;
}
if (VAR_2.num_threads >= 1 &&
!opj_codec_set_threads(VAR_5, VAR_2.num_threads)) {
fprintf(VAR_19, ""ERROR -> opj_decompress: failed to set number of threads\n"");
opj_stream_destroy(VAR_4);
opj_destroy_codec(VAR_5);
VAR_11 = 1;
goto fin;
}
if (! opj_read_header(VAR_4, VAR_5, &VAR_3)) {
fprintf(VAR_19, ""ERROR -> opj_decompress: failed to read the header\n"");
opj_stream_destroy(VAR_4);
opj_destroy_codec(VAR_5);
opj_image_destroy(VAR_3);
VAR_11 = 1;
goto fin;
}
if (VAR_2.numcomps) {
if (! opj_set_decoded_components(VAR_5,
VAR_2.numcomps,
VAR_2.comps_indices,
VAR_30)) {
fprintf(VAR_19,
""ERROR -> opj_decompress: failed to set the component indices!\n"");
opj_destroy_codec(VAR_5);
opj_stream_destroy(VAR_4);
opj_image_destroy(VAR_3);
VAR_11 = 1;
goto fin;
}
}
if (getenv(""USE_OPJ_SET_DECODED_RESOLUTION_FACTOR"") != NULL) {
if (! opj_set_decoded_resolution_factor(VAR_5, VAR_15)) {
fprintf(VAR_19,
""ERROR -> opj_decompress: failed to set the resolution factor tile!\n"");
opj_destroy_codec(VAR_5);
opj_stream_destroy(VAR_4);
opj_image_destroy(VAR_3);
VAR_11 = 1;
goto fin;
}
}
if (!VAR_2.nb_tile_to_decode) {
if (getenv(""SKIP_OPJ_SET_DECODE_AREA"") != NULL &&
VAR_2.DA_x0 == 0 &&
VAR_2.DA_y0 == 0 &&
VAR_2.DA_x1 == 0 &&
VAR_2.DA_y1 == 0) {
}
else if (!opj_set_decode_area(VAR_5, VAR_3, (OPJ_INT32)VAR_2.DA_x0,
(OPJ_INT32)VAR_2.DA_y0, (OPJ_INT32)VAR_2.DA_x1,
(OPJ_INT32)VAR_2.DA_y1)) {
fprintf(VAR_19, ""ERROR -> opj_decompress: failed to set the decoded area\n"");
opj_stream_destroy(VAR_4);
opj_destroy_codec(VAR_5);
opj_image_destroy(VAR_3);
VAR_11 = 1;
goto fin;
}
if (!(opj_decode(VAR_5, VAR_4, VAR_3) &&
opj_end_decompress(VAR_5,   VAR_4))) {
fprintf(VAR_19, ""ERROR -> opj_decompress: failed to decode image!\n"");
opj_destroy_codec(VAR_5);
opj_stream_destroy(VAR_4);
opj_image_destroy(VAR_3);
VAR_11 = 1;
goto fin;
}
} else {
if (!(VAR_2.DA_x0 == 0 &&
VAR_2.DA_y0 == 0 &&
VAR_2.DA_x1 == 0 &&
VAR_2.DA_y1 == 0)) {
if (!(VAR_2.quiet)) {
fprintf(VAR_19, ""WARNING: -d option ignored when used together with -t\n"");
}
}
if (!opj_get_decoded_tile(VAR_5, VAR_4, VAR_3, VAR_2.tile_index)) {
fprintf(VAR_19, ""ERROR -> opj_decompress: failed to decode tile!\n"");
opj_destroy_codec(VAR_5);
opj_stream_destroy(VAR_4);
opj_image_destroy(VAR_3);
VAR_11 = 1;
goto fin;
}
if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""tile %d is decoded!\n\n"", VAR_2.tile_index);
}
}
VAR_13 += opj_clock() - VAR_12;
VAR_14++;
opj_stream_destroy(VAR_4);
if (VAR_3->color_space != VAR_32
&& VAR_3->numcomps == 3 && VAR_3->comps[0].dx == VAR_3->comps[0].dy
&& VAR_3->comps[1].dx != 1) {
VAR_3->color_space = VAR_32;
} else if (VAR_3->numcomps <= 2) {
VAR_3->color_space = VAR_33;
}
if (VAR_3->color_space == VAR_32) {
color_sycc_to_rgb(VAR_3);
} else if ((VAR_3->color_space == VAR_34) &&
(VAR_2.cod_format != VAR_35)) {
color_cmyk_to_rgb(VAR_3);
} else if (VAR_3->color_space == VAR_36) {
color_esycc_to_rgb(VAR_3);
}
if (VAR_3->icc_profile_buf) {
#if defined(VAR_37) || defined(VAR_38)
if (VAR_3->icc_profile_len) {
color_apply_icc_profile(VAR_3);
} else {
color_cielab_to_rgb(VAR_3);
}
#endif
free(VAR_3->icc_profile_buf);
VAR_3->icc_profile_buf = NULL;
VAR_3->icc_profile_len = 0;
}
if (VAR_2.precision != NULL) {
OPJ_UINT32 VAR_39;
for (VAR_39 = 0; VAR_39 < VAR_3->numcomps; ++VAR_39) {
OPJ_UINT32 VAR_40 = VAR_39;
OPJ_UINT32 VAR_41;
if (VAR_40 >= VAR_2.nb_precision) {
VAR_40 = VAR_2.nb_precision - 1U;
}
VAR_41 = VAR_2.precision[VAR_40].prec;
if (VAR_41 == 0) {
VAR_41 = VAR_3->comps[VAR_39].prec;
}
switch (VAR_2.precision[VAR_40].mode) {
case VAR_42:
clip_component(&(VAR_3->comps[VAR_39]), VAR_41);
break;
case VAR_43:
scale_component(&(VAR_3->comps[VAR_39]), VAR_41);
break;
default:
break;
}
}
}
if (VAR_2.upsample) {
VAR_3 = upsample_image_components(VAR_3);
if (VAR_3 == NULL) {
fprintf(VAR_19,
""ERROR -> opj_decompress: failed to upsample image components!\n"");
opj_destroy_codec(VAR_5);
VAR_11 = 1;
goto fin;
}
}
if (VAR_2.force_rgb) {
switch (VAR_3->color_space) {
case VAR_44:
break;
case VAR_33:
VAR_3 = convert_gray_to_rgb(VAR_3);
break;
default:
fprintf(VAR_19,
""ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\n"");
opj_image_destroy(VAR_3);
VAR_3 = NULL;
break;
}
if (VAR_3 == NULL) {
fprintf(VAR_19, ""ERROR -> opj_decompress: failed to convert to RGB image!\n"");
opj_destroy_codec(VAR_5);
VAR_11 = 1;
goto fin;
}
}
switch (VAR_2.cod_format) {
case VAR_45:          
if (imagetopnm(VAR_3, VAR_2.outfile, VAR_2.split_pnm)) {
fprintf(VAR_19, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
VAR_11 = 1;
} else if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
}
break;
case VAR_46:          
if (imagetopgx(VAR_3, VAR_2.outfile)) {
fprintf(VAR_19, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
VAR_11 = 1;
} else if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
}
break;
case VAR_47:          
if (imagetobmp(VAR_3, VAR_2.outfile)) {
fprintf(VAR_19, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
VAR_11 = 1;
} else if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
}
break;
#ifdef VAR_48
case VAR_35:          
if (imagetotif(VAR_3, VAR_2.outfile)) {
fprintf(VAR_19, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
VAR_11 = 1;
} else if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
}
break;
#endif 
case VAR_49:          
if (imagetoraw(VAR_3, VAR_2.outfile)) {
fprintf(VAR_19, ""[ERROR] Error generating raw file. Outfile %s not generated\n"",
VAR_2.outfile);
VAR_11 = 1;
} else if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
}
break;
case VAR_50:         
if (imagetorawl(VAR_3, VAR_2.outfile)) {
fprintf(VAR_19,
""[ERROR] Error generating rawl file. Outfile %s not generated\n"",
VAR_2.outfile);
VAR_11 = 1;
} else if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
}
break;
case VAR_51:          
if (imagetotga(VAR_3, VAR_2.outfile)) {
fprintf(VAR_19, ""[ERROR] Error generating tga file. Outfile %s not generated\n"",
VAR_2.outfile);
VAR_11 = 1;
} else if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
}
break;
#ifdef VAR_52
case VAR_53:          
if (imagetopng(VAR_3, VAR_2.outfile)) {
fprintf(VAR_19, ""[ERROR] Error generating png file. Outfile %s not generated\n"",
VAR_2.outfile);
VAR_11 = 1;
} else if (!(VAR_2.quiet)) {
fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
}
break;
#endif 
default:
fprintf(VAR_19, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
VAR_11 = 1;
}
if (VAR_5) {
opj_destroy_codec(VAR_5);
}
opj_image_destroy(VAR_3);
opj_destroy_cstr_index(&VAR_6);
if (VAR_11) {
(void)remove(VAR_2.outfile);    
}
}
fin:
destroy_parameters(&VAR_2);
if (VAR_11 && VAR_9.imgdirpath) {
free(VAR_9.imgdirpath);
}
if (VAR_10) {
if (VAR_10->filename) {
free(VAR_10->filename);
}
if (VAR_10->filename_buf) {
free(VAR_10->filename_buf);
}
free(VAR_10);
}
if (VAR_14 && !VAR_11 && !(VAR_2.quiet)) {
fprintf(VAR_31, ""decode time: %d ms\n"",
(int)((VAR_13 * 1000.0) / (OPJ_FLOAT64)VAR_14));
}
return VAR_11 ? VAR_17 : VAR_54;
}",uclouvain/openjpeg/e8e258ab049240c2dd1f1051b4e773b21e2d3dc0/opj_decompress.c/vul/before/0.json,"int main(int argc, char **argv)
{
    opj_decompress_parameters parameters;           /* decompression parameters */

    OPJ_INT32 num_images, imageno;
    img_fol_t img_fol;
    dircnt_t *dirptr = NULL;
    int failed = 0;
    OPJ_FLOAT64 t, tCumulative = 0;
    OPJ_UINT32 numDecompressedImages = 0;
    OPJ_UINT32 cp_reduce;

    /* set decoding parameters to default values */
    set_default_parameters(&parameters);

    /* Initialize img_fol */
    memset(&img_fol, 0, sizeof(img_fol_t));

    /* parse input and get user encoding parameters */
    if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) {
        failed = 1;
        goto fin;
    }

    cp_reduce = parameters.core.cp_reduce;
    if (getenv(""USE_OPJ_SET_DECODED_RESOLUTION_FACTOR"") != NULL) {
        /* For debugging/testing purposes, do not set the cp_reduce member */
        /* if USE_OPJ_SET_DECODED_RESOLUTION_FACTOR is defined, but used */
        /* the opj_set_decoded_resolution_factor() API instead */
        parameters.core.cp_reduce = 0;
    }


    /* Initialize reading of directory */
    if (img_fol.set_imgdir == 1) {
        int it_image;
        num_images = get_num_images(img_fol.imgdirpath);

        dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));
        if (!dirptr) {
            destroy_parameters(&parameters);
            return EXIT_FAILURE;
        }
        /* Stores at max 10 image file names */
        dirptr->filename_buf = (char*)malloc(sizeof(char) *
                                             (size_t)num_images * OPJ_PATH_LEN);
        if (!dirptr->filename_buf) {
            failed = 1;
            goto fin;
        }

        dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));

        if (!dirptr->filename) {
            failed = 1;
            goto fin;
        }
        for (it_image = 0; it_image < num_images; it_image++) {
            dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN;
        }

        if (load_images(dirptr, img_fol.imgdirpath) == 1) {
            failed = 1;
            goto fin;
        }
        if (num_images == 0) {
            fprintf(stderr, ""Folder is empty\n"");
            failed = 1;
            goto fin;
        }
    } else {
        num_images = 1;
    }

    /*Decoding image one by one*/
    for (imageno = 0; imageno < num_images ; imageno++)  {
        opj_image_t* image = NULL;
        opj_stream_t *l_stream = NULL;              /* Stream */
        opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */
        opj_codestream_index_t* cstr_index = NULL;

        if (!parameters.quiet) {
            fprintf(stderr, ""\n"");
        }

        if (img_fol.set_imgdir == 1) {
            if (get_next_file(imageno, dirptr, &img_fol, &parameters)) {
                fprintf(stderr, ""skipping file...\n"");
                destroy_parameters(&parameters);
                continue;
            }
        }

        /* read the input file and put it in memory */
        /* ---------------------------------------- */

        l_stream = opj_stream_create_default_file_stream(parameters.infile, 1);
        if (!l_stream) {
            fprintf(stderr, ""ERROR -> failed to create the stream from the file %s\n"",
                    parameters.infile);
            failed = 1;
            goto fin;
        }

        /* decode the JPEG2000 stream */
        /* ---------------------- */

        switch (parameters.decod_format) {
        case J2K_CFMT: { /* JPEG-2000 codestream */
            /* Get a decoder handle */
            l_codec = opj_create_decompress(OPJ_CODEC_J2K);
            break;
        }
        case JP2_CFMT: { /* JPEG 2000 compressed image data */
            /* Get a decoder handle */
            l_codec = opj_create_decompress(OPJ_CODEC_JP2);
            break;
        }
        case JPT_CFMT: { /* JPEG 2000, JPIP */
            /* Get a decoder handle */
            l_codec = opj_create_decompress(OPJ_CODEC_JPT);
            break;
        }
        default:
            fprintf(stderr, ""skipping file..\n"");
            destroy_parameters(&parameters);
            opj_stream_destroy(l_stream);
            continue;
        }

        if (parameters.quiet) {
            /* Set all callbacks to quiet */
            opj_set_info_handler(l_codec, quiet_callback, 00);
            opj_set_warning_handler(l_codec, quiet_callback, 00);
            opj_set_error_handler(l_codec, quiet_callback, 00);
        } else {
            /* catch events using our callbacks and give a local context */
            opj_set_info_handler(l_codec, info_callback, 00);
            opj_set_warning_handler(l_codec, warning_callback, 00);
            opj_set_error_handler(l_codec, error_callback, 00);
        }


        t = opj_clock();

        /* Setup the decoder decoding parameters using user parameters */
        if (!opj_setup_decoder(l_codec, &(parameters.core))) {
            fprintf(stderr, ""ERROR -> opj_decompress: failed to setup the decoder\n"");
            opj_stream_destroy(l_stream);
            opj_destroy_codec(l_codec);
            failed = 1;
            goto fin;
        }

        if (parameters.num_threads >= 1 &&
                !opj_codec_set_threads(l_codec, parameters.num_threads)) {
            fprintf(stderr, ""ERROR -> opj_decompress: failed to set number of threads\n"");
            opj_stream_destroy(l_stream);
            opj_destroy_codec(l_codec);
            failed = 1;
            goto fin;
        }

        /* Read the main header of the codestream and if necessary the JP2 boxes*/
        if (! opj_read_header(l_stream, l_codec, &image)) {
            fprintf(stderr, ""ERROR -> opj_decompress: failed to read the header\n"");
            opj_stream_destroy(l_stream);
            opj_destroy_codec(l_codec);
            opj_image_destroy(image);
            failed = 1;
            goto fin;
        }

        if (parameters.numcomps) {
            if (! opj_set_decoded_components(l_codec,
                                             parameters.numcomps,
                                             parameters.comps_indices,
                                             OPJ_FALSE)) {
                fprintf(stderr,
                        ""ERROR -> opj_decompress: failed to set the component indices!\n"");
                opj_destroy_codec(l_codec);
                opj_stream_destroy(l_stream);
                opj_image_destroy(image);
                failed = 1;
                goto fin;
            }
        }

        if (getenv(""USE_OPJ_SET_DECODED_RESOLUTION_FACTOR"") != NULL) {
            /* For debugging/testing purposes, and also an illustration on how to */
            /* use the alternative API opj_set_decoded_resolution_factor() instead */
            /* of setting parameters.cp_reduce */
            if (! opj_set_decoded_resolution_factor(l_codec, cp_reduce)) {
                fprintf(stderr,
                        ""ERROR -> opj_decompress: failed to set the resolution factor tile!\n"");
                opj_destroy_codec(l_codec);
                opj_stream_destroy(l_stream);
                opj_image_destroy(image);
                failed = 1;
                goto fin;
            }
        }

        if (!parameters.nb_tile_to_decode) {
            if (getenv(""SKIP_OPJ_SET_DECODE_AREA"") != NULL &&
                    parameters.DA_x0 == 0 &&
                    parameters.DA_y0 == 0 &&
                    parameters.DA_x1 == 0 &&
                    parameters.DA_y1 == 0) {
                /* For debugging/testing purposes, */
                /* do nothing if SKIP_OPJ_SET_DECODE_AREA env variable */
                /* is defined and no decoded area has been set */
            }
            /* Optional if you want decode the entire image */
            else if (!opj_set_decode_area(l_codec, image, (OPJ_INT32)parameters.DA_x0,
                                          (OPJ_INT32)parameters.DA_y0, (OPJ_INT32)parameters.DA_x1,
                                          (OPJ_INT32)parameters.DA_y1)) {
                fprintf(stderr, ""ERROR -> opj_decompress: failed to set the decoded area\n"");
                opj_stream_destroy(l_stream);
                opj_destroy_codec(l_codec);
                opj_image_destroy(image);
                failed = 1;
                goto fin;
            }

            /* Get the decoded image */
            if (!(opj_decode(l_codec, l_stream, image) &&
                    opj_end_decompress(l_codec,   l_stream))) {
                fprintf(stderr, ""ERROR -> opj_decompress: failed to decode image!\n"");
                opj_destroy_codec(l_codec);
                opj_stream_destroy(l_stream);
                opj_image_destroy(image);
                failed = 1;
                goto fin;
            }
        } else {
            if (!(parameters.DA_x0 == 0 &&
                    parameters.DA_y0 == 0 &&
                    parameters.DA_x1 == 0 &&
                    parameters.DA_y1 == 0)) {
                if (!(parameters.quiet)) {
                    fprintf(stderr, ""WARNING: -d option ignored when used together with -t\n"");
                }
            }

            if (!opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index)) {
                fprintf(stderr, ""ERROR -> opj_decompress: failed to decode tile!\n"");
                opj_destroy_codec(l_codec);
                opj_stream_destroy(l_stream);
                opj_image_destroy(image);
                failed = 1;
                goto fin;
            }
            if (!(parameters.quiet)) {
                fprintf(stdout, ""tile %d is decoded!\n\n"", parameters.tile_index);
            }
        }

        tCumulative += opj_clock() - t;
        numDecompressedImages++;

        /* Close the byte stream */
        opj_stream_destroy(l_stream);

        if (image->color_space != OPJ_CLRSPC_SYCC
                && image->numcomps == 3 && image->comps[0].dx == image->comps[0].dy
                && image->comps[1].dx != 1) {
            image->color_space = OPJ_CLRSPC_SYCC;
        } else if (image->numcomps <= 2) {
            image->color_space = OPJ_CLRSPC_GRAY;
        }

        if (image->color_space == OPJ_CLRSPC_SYCC) {
            color_sycc_to_rgb(image);
        } else if ((image->color_space == OPJ_CLRSPC_CMYK) &&
                   (parameters.cod_format != TIF_DFMT)) {
            color_cmyk_to_rgb(image);
        } else if (image->color_space == OPJ_CLRSPC_EYCC) {
            color_esycc_to_rgb(image);
        }

        if (image->icc_profile_buf) {
#if defined(OPJ_HAVE_LIBLCMS1) || defined(OPJ_HAVE_LIBLCMS2)
            if (image->icc_profile_len) {
                color_apply_icc_profile(image);
            } else {
                color_cielab_to_rgb(image);
            }
#endif
            free(image->icc_profile_buf);
            image->icc_profile_buf = NULL;
            image->icc_profile_len = 0;
        }

        /* Force output precision */
        /* ---------------------- */
        if (parameters.precision != NULL) {
            OPJ_UINT32 compno;
            for (compno = 0; compno < image->numcomps; ++compno) {
                OPJ_UINT32 precno = compno;
                OPJ_UINT32 prec;

                if (precno >= parameters.nb_precision) {
                    precno = parameters.nb_precision - 1U;
                }

                prec = parameters.precision[precno].prec;
                if (prec == 0) {
                    prec = image->comps[compno].prec;
                }

                switch (parameters.precision[precno].mode) {
                case OPJ_PREC_MODE_CLIP:
                    clip_component(&(image->comps[compno]), prec);
                    break;
                case OPJ_PREC_MODE_SCALE:
                    scale_component(&(image->comps[compno]), prec);
                    break;
                default:
                    break;
                }

            }
        }

        /* Upsample components */
        /* ------------------- */
        if (parameters.upsample) {
            image = upsample_image_components(image);
            if (image == NULL) {
                fprintf(stderr,
                        ""ERROR -> opj_decompress: failed to upsample image components!\n"");
                opj_destroy_codec(l_codec);
                failed = 1;
                goto fin;
            }
        }

        /* Force RGB output */
        /* ---------------- */
        if (parameters.force_rgb) {
            switch (image->color_space) {
            case OPJ_CLRSPC_SRGB:
                break;
            case OPJ_CLRSPC_GRAY:
                image = convert_gray_to_rgb(image);
                break;
            default:
                fprintf(stderr,
                        ""ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\n"");
                opj_image_destroy(image);
                image = NULL;
                break;
            }
            if (image == NULL) {
                fprintf(stderr, ""ERROR -> opj_decompress: failed to convert to RGB image!\n"");
                opj_destroy_codec(l_codec);
                failed = 1;
                goto fin;
            }
        }

        /* create output image */
        /* ------------------- */
        switch (parameters.cod_format) {
        case PXM_DFMT:          /* PNM PGM PPM */
            if (imagetopnm(image, parameters.outfile, parameters.split_pnm)) {
                fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
                failed = 1;
            } else if (!(parameters.quiet)) {
                fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
            }
            break;

        case PGX_DFMT:          /* PGX */
            if (imagetopgx(image, parameters.outfile)) {
                fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
                failed = 1;
            } else if (!(parameters.quiet)) {
                fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
            }
            break;

        case BMP_DFMT:          /* BMP */
            if (imagetobmp(image, parameters.outfile)) {
                fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
                failed = 1;
            } else if (!(parameters.quiet)) {
                fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
            }
            break;
#ifdef OPJ_HAVE_LIBTIFF
        case TIF_DFMT:          /* TIFF */
            if (imagetotif(image, parameters.outfile)) {
                fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
                failed = 1;
            } else if (!(parameters.quiet)) {
                fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
            }
            break;
#endif /* OPJ_HAVE_LIBTIFF */
        case RAW_DFMT:          /* RAW */
            if (imagetoraw(image, parameters.outfile)) {
                fprintf(stderr, ""[ERROR] Error generating raw file. Outfile %s not generated\n"",
                        parameters.outfile);
                failed = 1;
            } else if (!(parameters.quiet)) {
                fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
            }
            break;

        case RAWL_DFMT:         /* RAWL */
            if (imagetorawl(image, parameters.outfile)) {
                fprintf(stderr,
                        ""[ERROR] Error generating rawl file. Outfile %s not generated\n"",
                        parameters.outfile);
                failed = 1;
            } else if (!(parameters.quiet)) {
                fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
            }
            break;

        case TGA_DFMT:          /* TGA */
            if (imagetotga(image, parameters.outfile)) {
                fprintf(stderr, ""[ERROR] Error generating tga file. Outfile %s not generated\n"",
                        parameters.outfile);
                failed = 1;
            } else if (!(parameters.quiet)) {
                fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
            }
            break;
#ifdef OPJ_HAVE_LIBPNG
        case PNG_DFMT:          /* PNG */
            if (imagetopng(image, parameters.outfile)) {
                fprintf(stderr, ""[ERROR] Error generating png file. Outfile %s not generated\n"",
                        parameters.outfile);
                failed = 1;
            } else if (!(parameters.quiet)) {
                fprintf(stdout, ""[INFO] Generated Outfile %s\n"", parameters.outfile);
            }
            break;
#endif /* OPJ_HAVE_LIBPNG */
        /* Can happen if output file is TIFF or PNG
         * and OPJ_HAVE_LIBTIF or OPJ_HAVE_LIBPNG is undefined
        */
        default:
            fprintf(stderr, ""[ERROR] Outfile %s not generated\n"", parameters.outfile);
            failed = 1;
        }

        /* free remaining structures */
        if (l_codec) {
            opj_destroy_codec(l_codec);
        }


        /* free image data structure */
        opj_image_destroy(image);

        /* destroy the codestream index */
        opj_destroy_cstr_index(&cstr_index);

        if (failed) {
            (void)remove(parameters.outfile);    /* ignore return value */
        }
    }
fin:
    destroy_parameters(&parameters);
    if (failed && img_fol.imgdirpath) {
        free(img_fol.imgdirpath);
    }
    if (dirptr) {
        if (dirptr->filename) {
            free(dirptr->filename);
        }
        if (dirptr->filename_buf) {
            free(dirptr->filename_buf);
        }
        free(dirptr);
    }
    if (numDecompressedImages && !failed && !(parameters.quiet)) {
        fprintf(stdout, ""decode time: %d ms\n"",
                (int)((tCumulative * 1000.0) / (OPJ_FLOAT64)numDecompressedImages));
    }
    return failed ? EXIT_FAILURE : EXIT_SUCCESS;
}","int main(int VAR_0, char **VAR_1)
{
    opj_decompress_parameters VAR_2;           /* COMMENT_0 */

    OPJ_INT32 VAR_3, VAR_4;
    img_fol_t VAR_5;
    dircnt_t *VAR_6 = NULL;
    int VAR_7 = 0;
    OPJ_FLOAT64 VAR_8, VAR_9 = 0;
    OPJ_UINT32 VAR_10 = 0;
    OPJ_UINT32 VAR_11;

    /* COMMENT_1 */
    set_default_parameters(&VAR_2);

    /* COMMENT_2 */
    memset(&VAR_5, 0, sizeof(img_fol_t));

    /* COMMENT_3 */
    if (parse_cmdline_decoder(VAR_0, VAR_1, &VAR_2, &VAR_5) == 1) {
        VAR_7 = 1;
        goto fin;
    }

    VAR_11 = VAR_2.core.cp_reduce;
    if (getenv(""USE_OPJ_SET_DECODED_RESOLUTION_FACTOR"") != NULL) {
        /* COMMENT_4 */
        /* COMMENT_5 */
        /* COMMENT_6 */
        VAR_2.core.cp_reduce = 0;
    }


    /* COMMENT_7 */
    if (VAR_5.set_imgdir == 1) {
        int VAR_12;
        VAR_3 = get_num_images(VAR_5.imgdirpath);

        VAR_6 = (dircnt_t*)malloc(sizeof(dircnt_t));
        if (!VAR_6) {
            destroy_parameters(&VAR_2);
            return VAR_13;
        }
        /* COMMENT_8 */
        VAR_6->filename_buf = (char*)malloc(sizeof(char) *
                                             (size_t)VAR_3 * VAR_14);
        if (!VAR_6->filename_buf) {
            VAR_7 = 1;
            goto fin;
        }

        VAR_6->filename = (char**) malloc((size_t)VAR_3 * sizeof(char*));

        if (!VAR_6->filename) {
            VAR_7 = 1;
            goto fin;
        }
        for (VAR_12 = 0; VAR_12 < VAR_3; VAR_12++) {
            VAR_6->filename[VAR_12] = VAR_6->filename_buf + VAR_12 * VAR_14;
        }

        if (load_images(VAR_6, VAR_5.imgdirpath) == 1) {
            VAR_7 = 1;
            goto fin;
        }
        if (VAR_3 == 0) {
            fprintf(VAR_15, ""Folder is empty\n"");
            VAR_7 = 1;
            goto fin;
        }
    } else {
        VAR_3 = 1;
    }

    /* COMMENT_9 */
    for (VAR_4 = 0; VAR_4 < VAR_3 ; VAR_4++)  {
        opj_image_t* VAR_16 = NULL;
        opj_stream_t *VAR_17 = NULL;              /* COMMENT_10 */
        opj_codec_t* VAR_18 = NULL;                /* COMMENT_11 */
        opj_codestream_index_t* VAR_19 = NULL;

        if (!VAR_2.quiet) {
            fprintf(VAR_15, ""\n"");
        }

        if (VAR_5.set_imgdir == 1) {
            if (get_next_file(VAR_4, VAR_6, &VAR_5, &VAR_2)) {
                fprintf(VAR_15, ""skipping file...\n"");
                destroy_parameters(&VAR_2);
                continue;
            }
        }

        /* COMMENT_12 */
        /* COMMENT_13 */

        VAR_17 = opj_stream_create_default_file_stream(VAR_2.infile, 1);
        if (!VAR_17) {
            fprintf(VAR_15, ""ERROR -> failed to create the stream from the file %s\n"",
                    VAR_2.infile);
            VAR_7 = 1;
            goto fin;
        }

        /* COMMENT_14 */
        /* COMMENT_15 */

        switch (VAR_2.decod_format) {
        case VAR_20: { /* COMMENT_16 */
            /* COMMENT_17 */
            VAR_18 = opj_create_decompress(VAR_21);
            break;
        }
        case VAR_22: { /* COMMENT_18 */
            /* COMMENT_17 */
            VAR_18 = opj_create_decompress(VAR_23);
            break;
        }
        case VAR_24: { /* COMMENT_19 */
            /* COMMENT_17 */
            VAR_18 = opj_create_decompress(VAR_25);
            break;
        }
        default:
            fprintf(VAR_15, ""skipping file..\n"");
            destroy_parameters(&VAR_2);
            opj_stream_destroy(VAR_17);
            continue;
        }

        if (VAR_2.quiet) {
            /* COMMENT_20 */
            opj_set_info_handler(VAR_18, VAR_26, 00);
            opj_set_warning_handler(VAR_18, VAR_26, 00);
            opj_set_error_handler(VAR_18, VAR_26, 00);
        } else {
            /* COMMENT_21 */
            opj_set_info_handler(VAR_18, VAR_27, 00);
            opj_set_warning_handler(VAR_18, VAR_28, 00);
            opj_set_error_handler(VAR_18, VAR_29, 00);
        }


        VAR_8 = opj_clock();

        /* COMMENT_22 */
        if (!opj_setup_decoder(VAR_18, &(VAR_2.core))) {
            fprintf(VAR_15, ""ERROR -> opj_decompress: failed to setup the decoder\n"");
            opj_stream_destroy(VAR_17);
            opj_destroy_codec(VAR_18);
            VAR_7 = 1;
            goto fin;
        }

        if (VAR_2.num_threads >= 1 &&
                !opj_codec_set_threads(VAR_18, VAR_2.num_threads)) {
            fprintf(VAR_15, ""ERROR -> opj_decompress: failed to set number of threads\n"");
            opj_stream_destroy(VAR_17);
            opj_destroy_codec(VAR_18);
            VAR_7 = 1;
            goto fin;
        }

        /* COMMENT_23 */
        if (! opj_read_header(VAR_17, VAR_18, &VAR_16)) {
            fprintf(VAR_15, ""ERROR -> opj_decompress: failed to read the header\n"");
            opj_stream_destroy(VAR_17);
            opj_destroy_codec(VAR_18);
            opj_image_destroy(VAR_16);
            VAR_7 = 1;
            goto fin;
        }

        if (VAR_2.numcomps) {
            if (! opj_set_decoded_components(VAR_18,
                                             VAR_2.numcomps,
                                             VAR_2.comps_indices,
                                             VAR_30)) {
                fprintf(VAR_15,
                        ""ERROR -> opj_decompress: failed to set the component indices!\n"");
                opj_destroy_codec(VAR_18);
                opj_stream_destroy(VAR_17);
                opj_image_destroy(VAR_16);
                VAR_7 = 1;
                goto fin;
            }
        }

        if (getenv(""USE_OPJ_SET_DECODED_RESOLUTION_FACTOR"") != NULL) {
            /* COMMENT_24 */
            /* COMMENT_25 */
            /* COMMENT_26 */
            if (! opj_set_decoded_resolution_factor(VAR_18, VAR_11)) {
                fprintf(VAR_15,
                        ""ERROR -> opj_decompress: failed to set the resolution factor tile!\n"");
                opj_destroy_codec(VAR_18);
                opj_stream_destroy(VAR_17);
                opj_image_destroy(VAR_16);
                VAR_7 = 1;
                goto fin;
            }
        }

        if (!VAR_2.nb_tile_to_decode) {
            if (getenv(""SKIP_OPJ_SET_DECODE_AREA"") != NULL &&
                    VAR_2.DA_x0 == 0 &&
                    VAR_2.DA_y0 == 0 &&
                    VAR_2.DA_x1 == 0 &&
                    VAR_2.DA_y1 == 0) {
                /* COMMENT_27 */
                /* COMMENT_28 */
                /* COMMENT_29 */
            }
            /* COMMENT_30 */
            else if (!opj_set_decode_area(VAR_18, VAR_16, (OPJ_INT32)VAR_2.DA_x0,
                                          (OPJ_INT32)VAR_2.DA_y0, (OPJ_INT32)VAR_2.DA_x1,
                                          (OPJ_INT32)VAR_2.DA_y1)) {
                fprintf(VAR_15, ""ERROR -> opj_decompress: failed to set the decoded area\n"");
                opj_stream_destroy(VAR_17);
                opj_destroy_codec(VAR_18);
                opj_image_destroy(VAR_16);
                VAR_7 = 1;
                goto fin;
            }

            /* COMMENT_31 */
            if (!(opj_decode(VAR_18, VAR_17, VAR_16) &&
                    opj_end_decompress(VAR_18,   VAR_17))) {
                fprintf(VAR_15, ""ERROR -> opj_decompress: failed to decode image!\n"");
                opj_destroy_codec(VAR_18);
                opj_stream_destroy(VAR_17);
                opj_image_destroy(VAR_16);
                VAR_7 = 1;
                goto fin;
            }
        } else {
            if (!(VAR_2.DA_x0 == 0 &&
                    VAR_2.DA_y0 == 0 &&
                    VAR_2.DA_x1 == 0 &&
                    VAR_2.DA_y1 == 0)) {
                if (!(VAR_2.quiet)) {
                    fprintf(VAR_15, ""WARNING: -d option ignored when used together with -t\n"");
                }
            }

            if (!opj_get_decoded_tile(VAR_18, VAR_17, VAR_16, VAR_2.tile_index)) {
                fprintf(VAR_15, ""ERROR -> opj_decompress: failed to decode tile!\n"");
                opj_destroy_codec(VAR_18);
                opj_stream_destroy(VAR_17);
                opj_image_destroy(VAR_16);
                VAR_7 = 1;
                goto fin;
            }
            if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""tile %d is decoded!\n\n"", VAR_2.tile_index);
            }
        }

        VAR_9 += opj_clock() - VAR_8;
        VAR_10++;

        /* COMMENT_32 */
        opj_stream_destroy(VAR_17);

        if (VAR_16->color_space != VAR_32
                && VAR_16->numcomps == 3 && VAR_16->comps[0].dx == VAR_16->comps[0].dy
                && VAR_16->comps[1].dx != 1) {
            VAR_16->color_space = VAR_32;
        } else if (VAR_16->numcomps <= 2) {
            VAR_16->color_space = VAR_33;
        }

        if (VAR_16->color_space == VAR_32) {
            color_sycc_to_rgb(VAR_16);
        } else if ((VAR_16->color_space == VAR_34) &&
                   (VAR_2.cod_format != VAR_35)) {
            color_cmyk_to_rgb(VAR_16);
        } else if (VAR_16->color_space == VAR_36) {
            color_esycc_to_rgb(VAR_16);
        }

        if (VAR_16->icc_profile_buf) {
#if defined(VAR_37) || defined(VAR_38)
            if (VAR_16->icc_profile_len) {
                color_apply_icc_profile(VAR_16);
            } else {
                color_cielab_to_rgb(VAR_16);
            }
#endif
            free(VAR_16->icc_profile_buf);
            VAR_16->icc_profile_buf = NULL;
            VAR_16->icc_profile_len = 0;
        }

        /* COMMENT_33 */
        /* COMMENT_15 */
        if (VAR_2.precision != NULL) {
            OPJ_UINT32 VAR_39;
            for (VAR_39 = 0; VAR_39 < VAR_16->numcomps; ++VAR_39) {
                OPJ_UINT32 VAR_40 = VAR_39;
                OPJ_UINT32 VAR_41;

                if (VAR_40 >= VAR_2.nb_precision) {
                    VAR_40 = VAR_2.nb_precision - 1U;
                }

                VAR_41 = VAR_2.precision[VAR_40].prec;
                if (VAR_41 == 0) {
                    VAR_41 = VAR_16->comps[VAR_39].prec;
                }

                switch (VAR_2.precision[VAR_40].mode) {
                case VAR_42:
                    clip_component(&(VAR_16->comps[VAR_39]), VAR_41);
                    break;
                case VAR_43:
                    scale_component(&(VAR_16->comps[VAR_39]), VAR_41);
                    break;
                default:
                    break;
                }

            }
        }

        /* COMMENT_34 */
        /* COMMENT_35 */
        if (VAR_2.upsample) {
            VAR_16 = upsample_image_components(VAR_16);
            if (VAR_16 == NULL) {
                fprintf(VAR_15,
                        ""ERROR -> opj_decompress: failed to upsample image components!\n"");
                opj_destroy_codec(VAR_18);
                VAR_7 = 1;
                goto fin;
            }
        }

        /* COMMENT_36 */
        /* COMMENT_37 */
        if (VAR_2.force_rgb) {
            switch (VAR_16->color_space) {
            case VAR_44:
                break;
            case VAR_33:
                VAR_16 = convert_gray_to_rgb(VAR_16);
                break;
            default:
                fprintf(VAR_15,
                        ""ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\n"");
                opj_image_destroy(VAR_16);
                VAR_16 = NULL;
                break;
            }
            if (VAR_16 == NULL) {
                fprintf(VAR_15, ""ERROR -> opj_decompress: failed to convert to RGB image!\n"");
                opj_destroy_codec(VAR_18);
                VAR_7 = 1;
                goto fin;
            }
        }

        /* COMMENT_38 */
        /* COMMENT_35 */
        switch (VAR_2.cod_format) {
        case VAR_45:          /* COMMENT_39 */
            if (imagetopnm(VAR_16, VAR_2.outfile, VAR_2.split_pnm)) {
                fprintf(VAR_15, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
                VAR_7 = 1;
            } else if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
            }
            break;

        case VAR_46:          /* COMMENT_40 */
            if (imagetopgx(VAR_16, VAR_2.outfile)) {
                fprintf(VAR_15, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
                VAR_7 = 1;
            } else if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
            }
            break;

        case VAR_47:          /* COMMENT_41 */
            if (imagetobmp(VAR_16, VAR_2.outfile)) {
                fprintf(VAR_15, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
                VAR_7 = 1;
            } else if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
            }
            break;
#ifdef VAR_48
        case VAR_35:          /* COMMENT_42 */
            if (imagetotif(VAR_16, VAR_2.outfile)) {
                fprintf(VAR_15, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
                VAR_7 = 1;
            } else if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
            }
            break;
#endif /* COMMENT_43 */
        case VAR_49:          /* COMMENT_44 */
            if (imagetoraw(VAR_16, VAR_2.outfile)) {
                fprintf(VAR_15, ""[ERROR] Error generating raw file. Outfile %s not generated\n"",
                        VAR_2.outfile);
                VAR_7 = 1;
            } else if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
            }
            break;

        case VAR_50:         /* COMMENT_45 */
            if (imagetorawl(VAR_16, VAR_2.outfile)) {
                fprintf(VAR_15,
                        ""[ERROR] Error generating rawl file. Outfile %s not generated\n"",
                        VAR_2.outfile);
                VAR_7 = 1;
            } else if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
            }
            break;

        case VAR_51:          /* COMMENT_46 */
            if (imagetotga(VAR_16, VAR_2.outfile)) {
                fprintf(VAR_15, ""[ERROR] Error generating tga file. Outfile %s not generated\n"",
                        VAR_2.outfile);
                VAR_7 = 1;
            } else if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
            }
            break;
#ifdef VAR_52
        case VAR_53:          /* COMMENT_47 */
            if (imagetopng(VAR_16, VAR_2.outfile)) {
                fprintf(VAR_15, ""[ERROR] Error generating png file. Outfile %s not generated\n"",
                        VAR_2.outfile);
                VAR_7 = 1;
            } else if (!(VAR_2.quiet)) {
                fprintf(VAR_31, ""[INFO] Generated Outfile %s\n"", VAR_2.outfile);
            }
            break;
#endif /* COMMENT_48 */
        /* COMMENT_49 */
                                                              
          
        default:
            fprintf(VAR_15, ""[ERROR] Outfile %s not generated\n"", VAR_2.outfile);
            VAR_7 = 1;
        }

        /* COMMENT_52 */
        if (VAR_18) {
            opj_destroy_codec(VAR_18);
        }


        /* COMMENT_53 */
        opj_image_destroy(VAR_16);

        /* COMMENT_54 */
        opj_destroy_cstr_index(&VAR_19);

        if (VAR_7) {
            (void)remove(VAR_2.outfile);    /* COMMENT_55 */
        }
    }
fin:
    destroy_parameters(&VAR_2);
    if (VAR_7 && VAR_5.imgdirpath) {
        free(VAR_5.imgdirpath);
    }
    if (VAR_6) {
        if (VAR_6->filename) {
            free(VAR_6->filename);
        }
        if (VAR_6->filename_buf) {
            free(VAR_6->filename_buf);
        }
        free(VAR_6);
    }
    if (VAR_10 && !VAR_7 && !(VAR_2.quiet)) {
        fprintf(VAR_31, ""decode time: %d ms\n"",
                (int)((VAR_9 * 1000.0) / (OPJ_FLOAT64)VAR_10));
    }
    return VAR_7 ? VAR_13 : VAR_54;
}",uclouvain/openjpeg/e8e258ab049240c2dd1f1051b4e773b21e2d3dc0/opj_decompress.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,10 +1,6 @@
 int main(int argc, char **argv)
 {
     opj_decompress_parameters parameters;           /* decompression parameters */
-    opj_image_t* image = NULL;
-    opj_stream_t *l_stream = NULL;              /* Stream */
-    opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */
-    opj_codestream_index_t* cstr_index = NULL;
 
     OPJ_INT32 num_images, imageno;
     img_fol_t img_fol;
@@ -78,6 +74,10 @@
 
     /*Decoding image one by one*/
     for (imageno = 0; imageno < num_images ; imageno++)  {
+        opj_image_t* image = NULL;
+        opj_stream_t *l_stream = NULL;              /* Stream */
+        opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */
+        opj_codestream_index_t* cstr_index = NULL;
 
         if (!parameters.quiet) {
             fprintf(stderr, ""\n"");","{'deleted_lines': ['    opj_image_t* image = NULL;', '    opj_stream_t *l_stream = NULL;              /* Stream */', '    opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */', '    opj_codestream_index_t* cstr_index = NULL;'], 'added_lines': ['        opj_image_t* image = NULL;', '        opj_stream_t *l_stream = NULL;              /* Stream */', '        opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */', '        opj_codestream_index_t* cstr_index = NULL;']}",True,jp2/opj_decompress.c in OpenJPEG through 2.3.1 has a use-after-free that can be triggered if there is a mix of valid and invalid files in a directory operated on by the decompressor. Triggering a double-free may also be possible. This is related to calling opj_image_destroy twice.,6.5,MEDIUM,1,test,2020-06-28T12:19:59Z,3
CVE-2021-27845,['CWE-369'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,jasper-software/jasper,"jpc_enc: validate raw_size, prevent division by zero in cp_create()

Closes https://github.com/mdadams/jasper/issues/194 (part 1)",fd564ee3377d9fc2484c657e4f464a3fb9764d31,https://github.com/jasper-software/jasper/commit/fd564ee3377d9fc2484c657e4f464a3fb9764d31,src/libjasper/jpc/jpc_enc.c,cp_create,"static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image)
{
jpc_enc_cp_t *cp;
jas_tvparser_t *tvp;
int ret;
int numilyrrates;
double *ilyrrates;
int i;
int tagid;
jpc_enc_tcp_t *tcp;
jpc_enc_tccp_t *tccp;
jpc_enc_ccp_t *ccp;
int cmptno;
uint_fast16_t rlvlno;
uint_fast16_t prcwidthexpn;
uint_fast16_t prcheightexpn;
bool enablemct;
uint_fast32_t jp2overhead;
uint_fast16_t lyrno;
uint_fast32_t hsteplcm;
uint_fast32_t vsteplcm;
bool mctvalid;
tvp = 0;
cp = 0;
ilyrrates = 0;
numilyrrates = 0;
if (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {
goto error;
}
prcwidthexpn = 15;
prcheightexpn = 15;
enablemct = true;
jp2overhead = 0;
cp->ccps = 0;
cp->debug = 0;
cp->imgareatlx = UINT_FAST32_MAX;
cp->imgareatly = UINT_FAST32_MAX;
cp->refgrdwidth = 0;
cp->refgrdheight = 0;
cp->tilegrdoffx = UINT_FAST32_MAX;
cp->tilegrdoffy = UINT_FAST32_MAX;
cp->tilewidth = 0;
cp->tileheight = 0;
cp->numcmpts = jas_image_numcmpts(image);
hsteplcm = 1;
vsteplcm = 1;
for (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {
if (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=
jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +
jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {
jas_eprintf(""unsupported image type\n"");
goto error;
}
hsteplcm *= jas_image_cmpthstep(image, cmptno);
vsteplcm *= jas_image_cmptvstep(image, cmptno);
}
if (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {
goto error;
}
for (cmptno = 0, ccp = cp->ccps; cmptno < JAS_CAST(int, cp->numcmpts); ++cmptno,
++ccp) {
ccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);
ccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);
ccp->sampgrdsubstepx = 0;
ccp->sampgrdsubstepx = 0;
ccp->prec = jas_image_cmptprec(image, cmptno);
ccp->sgnd = jas_image_cmptsgnd(image, cmptno);
ccp->numstepsizes = 0;
memset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));
}
cp->rawsize = jas_image_rawsize(image);
cp->totalsize = UINT_FAST32_MAX;
tcp = &cp->tcp;
tcp->csty = 0;
tcp->intmode = true;
tcp->prg = JPC_COD_LRCPPRG;
tcp->numlyrs = 1;
tcp->ilyrrates = 0;
tccp = &cp->tccp;
tccp->csty = 0;
tccp->maxrlvls = 6;
tccp->cblkwidthexpn = 6;
tccp->cblkheightexpn = 6;
tccp->cblksty = 0;
tccp->numgbits = 2;
if (!(tvp = jas_tvparser_create(optstr ? optstr : """"))) {
goto error;
}
while (!(ret = jas_tvparser_next(tvp))) {
switch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,
jas_tvparser_gettag(tvp)))->id) {
case OPT_DEBUG:
cp->debug = atoi(jas_tvparser_getval(tvp));
break;
case OPT_IMGAREAOFFX:
cp->imgareatlx = atoi(jas_tvparser_getval(tvp));
break;
case OPT_IMGAREAOFFY:
cp->imgareatly = atoi(jas_tvparser_getval(tvp));
break;
case OPT_TILEGRDOFFX:
cp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));
break;
case OPT_TILEGRDOFFY:
cp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));
break;
case OPT_TILEWIDTH:
cp->tilewidth = atoi(jas_tvparser_getval(tvp));
break;
case OPT_TILEHEIGHT:
cp->tileheight = atoi(jas_tvparser_getval(tvp));
break;
case OPT_PRCWIDTH:
prcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));
break;
case OPT_PRCHEIGHT:
prcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));
break;
case OPT_CBLKWIDTH:
tccp->cblkwidthexpn =
jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));
break;
case OPT_CBLKHEIGHT:
tccp->cblkheightexpn =
jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));
break;
case OPT_MODE:
if ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,
jas_tvparser_getval(tvp)))->id) < 0) {
jas_eprintf(""ignoring invalid mode %s\n"",
jas_tvparser_getval(tvp));
} else {
tcp->intmode = (tagid == MODE_INT);
}
break;
case OPT_PRG:
if ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,
jas_tvparser_getval(tvp)))->id) < 0) {
jas_eprintf(""ignoring invalid progression order %s\n"",
jas_tvparser_getval(tvp));
} else {
tcp->prg = tagid;
}
break;
case OPT_NOMCT:
enablemct = false;
break;
case OPT_MAXRLVLS:
tccp->maxrlvls = atoi(jas_tvparser_getval(tvp));
break;
case OPT_SOP:
cp->tcp.csty |= JPC_COD_SOP;
break;
case OPT_EPH:
cp->tcp.csty |= JPC_COD_EPH;
break;
case OPT_LAZY:
tccp->cblksty |= JPC_COX_LAZY;
break;
case OPT_TERMALL:
tccp->cblksty |= JPC_COX_TERMALL;
break;
case OPT_SEGSYM:
tccp->cblksty |= JPC_COX_SEGSYM;
break;
case OPT_VCAUSAL:
tccp->cblksty |= JPC_COX_VSC;
break;
case OPT_RESET:
tccp->cblksty |= JPC_COX_RESET;
break;
case OPT_PTERM:
tccp->cblksty |= JPC_COX_PTERM;
break;
case OPT_NUMGBITS:
cp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));
break;
case OPT_RATE:
if (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,
&cp->totalsize)) {
jas_eprintf(""ignoring bad rate specifier %s\n"",
jas_tvparser_getval(tvp));
}
break;
case OPT_ILYRRATES:
if (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,
&ilyrrates)) {
jas_eprintf(""warning: invalid intermediate layer rates specifier ignored (%s)\n"",
jas_tvparser_getval(tvp));
}
break;
case OPT_JP2OVERHEAD:
jp2overhead = atoi(jas_tvparser_getval(tvp));
break;
default:
jas_eprintf(""warning: ignoring invalid option %s\n"",
jas_tvparser_gettag(tvp));
break;
}
}
jas_tvparser_destroy(tvp);
tvp = 0;
if (cp->totalsize != UINT_FAST32_MAX) {
cp->totalsize = (cp->totalsize > jp2overhead) ?
(cp->totalsize - jp2overhead) : 0;
}
if (cp->imgareatlx == UINT_FAST32_MAX) {
cp->imgareatlx = 0;
} else {
if (hsteplcm != 1) {
jas_eprintf(""warning: overriding imgareatlx value\n"");
}
cp->imgareatlx *= hsteplcm;
}
if (cp->imgareatly == UINT_FAST32_MAX) {
cp->imgareatly = 0;
} else {
if (vsteplcm != 1) {
jas_eprintf(""warning: overriding imgareatly value\n"");
}
cp->imgareatly *= vsteplcm;
}
cp->refgrdwidth = cp->imgareatlx + jas_image_width(image);
cp->refgrdheight = cp->imgareatly + jas_image_height(image);
if (cp->tilegrdoffx == UINT_FAST32_MAX) {
cp->tilegrdoffx = cp->imgareatlx;
}
if (cp->tilegrdoffy == UINT_FAST32_MAX) {
cp->tilegrdoffy = cp->imgareatly;
}
if (!cp->tilewidth) {
cp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;
}
if (!cp->tileheight) {
cp->tileheight = cp->refgrdheight - cp->tilegrdoffy;
}
if (cp->numcmpts == 3) {
mctvalid = true;
for (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {
if (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||
jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||
jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||
jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {
mctvalid = false;
}
}
} else {
mctvalid = false;
}
if (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {
jas_eprintf(""warning: color space apparently not RGB\n"");
}
if (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {
tcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);
} else {
tcp->mctid = JPC_MCT_NONE;
}
tccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);
for (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {
tccp->prcwidthexpns[rlvlno] = prcwidthexpn;
tccp->prcheightexpns[rlvlno] = prcheightexpn;
}
if (prcwidthexpn != 15 || prcheightexpn != 15) {
tccp->csty |= JPC_COX_PRT;
}
if (!cp->tilewidth) {
jas_eprintf(""invalid tile width %lu\n"", (unsigned long)
cp->tilewidth);
goto error;
}
if (!cp->tileheight) {
jas_eprintf(""invalid tile height %lu\n"", (unsigned long)
cp->tileheight);
goto error;
}
if (cp->tilegrdoffx > cp->imgareatlx ||
cp->tilegrdoffy > cp->imgareatly ||
cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||
cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {
jas_eprintf(""invalid tile grid offset (%lu, %lu)\n"",
(unsigned long) cp->tilegrdoffx, (unsigned long)
cp->tilegrdoffy);
goto error;
}
cp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,
cp->tilewidth);
cp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,
cp->tileheight);
cp->numtiles = cp->numhtiles * cp->numvtiles;
if (ilyrrates && numilyrrates > 0) {
tcp->numlyrs = numilyrrates + 1;
if (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),
sizeof(jpc_fix_t)))) {
goto error;
}
for (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {
tcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);
}
}
if (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {
jas_eprintf(""cannot use real mode for lossless coding\n"");
goto error;
}
if (prcwidthexpn > 15) {
jas_eprintf(""invalid precinct width\n"");
goto error;
}
if (prcheightexpn > 15) {
jas_eprintf(""invalid precinct height\n"");
goto error;
}
if (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {
jas_eprintf(""invalid code block width %d\n"",
JPC_POW2(cp->tccp.cblkwidthexpn));
goto error;
}
if (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {
jas_eprintf(""invalid code block height %d\n"",
JPC_POW2(cp->tccp.cblkheightexpn));
goto error;
}
if (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {
jas_eprintf(""code block size too large\n"");
goto error;
}
if (cp->tcp.numlyrs > 16384) {
jas_eprintf(""too many layers\n"");
goto error;
}
if (cp->tccp.maxrlvls < 1) {
jas_eprintf(""must be at least one resolution level\n"");
goto error;
}
if (cp->tccp.numgbits > 8) {
jas_eprintf(""invalid number of guard bits\n"");
goto error;
}
if (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {
jas_eprintf(""warning: specified rate is unreasonably large (%lu > %lu)\n"", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);
}
if (tcp->numlyrs > 1) {
for (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {
if (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {
jas_eprintf(""intermediate layer rates must increase monotonically\n"");
goto error;
}
}
if (cp->totalsize != UINT_FAST32_MAX) {
for (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {
if (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)
/ cp->rawsize) {
jas_eprintf(""warning: intermediate layer rates must be less than overall rate\n"");
goto error;
}
}
}
}
if (ilyrrates) {
jas_free(ilyrrates);
}
return cp;
error:
if (ilyrrates) {
jas_free(ilyrrates);
}
if (tvp) {
jas_tvparser_destroy(tvp);
}
if (cp) {
jpc_enc_cp_destroy(cp);
}
return 0;
}","static jpc_enc_cp_t *cp_create(const char *VAR_0, jas_image_t *VAR_1)
{
jpc_enc_cp_t *VAR_2;
jas_tvparser_t *VAR_3;
int VAR_4;
int VAR_5;
double *VAR_6;
int VAR_7;
int VAR_8;
jpc_enc_tcp_t *VAR_9;
jpc_enc_tccp_t *VAR_10;
jpc_enc_ccp_t *VAR_11;
int VAR_12;
uint_fast16_t VAR_13;
uint_fast16_t VAR_14;
uint_fast16_t VAR_15;
bool VAR_16;
uint_fast32_t VAR_17;
uint_fast16_t VAR_18;
uint_fast32_t VAR_19;
uint_fast32_t VAR_20;
bool VAR_21;
VAR_3 = 0;
VAR_2 = 0;
VAR_6 = 0;
VAR_5 = 0;
if (!(VAR_2 = jas_malloc(sizeof(jpc_enc_cp_t)))) {
goto error;
}
VAR_14 = 15;
VAR_15 = 15;
VAR_16 = true;
VAR_17 = 0;
VAR_2->ccps = 0;
VAR_2->debug = 0;
VAR_2->imgareatlx = VAR_22;
VAR_2->imgareatly = VAR_22;
VAR_2->refgrdwidth = 0;
VAR_2->refgrdheight = 0;
VAR_2->tilegrdoffx = VAR_22;
VAR_2->tilegrdoffy = VAR_22;
VAR_2->tilewidth = 0;
VAR_2->tileheight = 0;
VAR_2->numcmpts = jas_image_numcmpts(VAR_1);
VAR_19 = 1;
VAR_20 = 1;
for (VAR_12 = 0; VAR_12 < jas_image_numcmpts(VAR_1); ++VAR_12) {
if (jas_image_cmptbrx(VAR_1, VAR_12) + jas_image_cmpthstep(VAR_1, VAR_12) <=
jas_image_brx(VAR_1) || jas_image_cmptbry(VAR_1, VAR_12) +
jas_image_cmptvstep(VAR_1, VAR_12) <= jas_image_bry(VAR_1)) {
jas_eprintf(""unsupported image type\n"");
goto error;
}
VAR_19 *= jas_image_cmpthstep(VAR_1, VAR_12);
VAR_20 *= jas_image_cmptvstep(VAR_1, VAR_12);
}
if (!(VAR_2->ccps = jas_alloc2(VAR_2->numcmpts, sizeof(jpc_enc_ccp_t)))) {
goto error;
}
for (VAR_12 = 0, VAR_11 = VAR_2->ccps; VAR_12 < JAS_CAST(int, VAR_2->numcmpts); ++VAR_12,
++VAR_11) {
VAR_11->sampgrdstepx = jas_image_cmpthstep(VAR_1, VAR_12);
VAR_11->sampgrdstepy = jas_image_cmptvstep(VAR_1, VAR_12);
VAR_11->sampgrdsubstepx = 0;
VAR_11->sampgrdsubstepx = 0;
VAR_11->prec = jas_image_cmptprec(VAR_1, VAR_12);
VAR_11->sgnd = jas_image_cmptsgnd(VAR_1, VAR_12);
VAR_11->numstepsizes = 0;
memset(VAR_11->stepsizes, 0, sizeof(VAR_11->stepsizes));
}
VAR_2->rawsize = jas_image_rawsize(VAR_1);
VAR_2->totalsize = VAR_22;
VAR_9 = &VAR_2->tcp;
VAR_9->csty = 0;
VAR_9->intmode = true;
VAR_9->prg = VAR_23;
VAR_9->numlyrs = 1;
VAR_9->ilyrrates = 0;
VAR_10 = &VAR_2->tccp;
VAR_10->csty = 0;
VAR_10->maxrlvls = 6;
VAR_10->cblkwidthexpn = 6;
VAR_10->cblkheightexpn = 6;
VAR_10->cblksty = 0;
VAR_10->numgbits = 2;
if (!(VAR_3 = jas_tvparser_create(VAR_0 ? VAR_0 : """"))) {
goto error;
}
while (!(VAR_4 = jas_tvparser_next(VAR_3))) {
switch (jas_taginfo_nonull(jas_taginfos_lookup(VAR_24,
jas_tvparser_gettag(VAR_3)))->id) {
case VAR_25:
VAR_2->debug = atoi(jas_tvparser_getval(VAR_3));
break;
case VAR_26:
VAR_2->imgareatlx = atoi(jas_tvparser_getval(VAR_3));
break;
case VAR_27:
VAR_2->imgareatly = atoi(jas_tvparser_getval(VAR_3));
break;
case VAR_28:
VAR_2->tilegrdoffx = atoi(jas_tvparser_getval(VAR_3));
break;
case VAR_29:
VAR_2->tilegrdoffy = atoi(jas_tvparser_getval(VAR_3));
break;
case VAR_30:
VAR_2->tilewidth = atoi(jas_tvparser_getval(VAR_3));
break;
case VAR_31:
VAR_2->tileheight = atoi(jas_tvparser_getval(VAR_3));
break;
case VAR_32:
VAR_14 = jpc_floorlog2(atoi(jas_tvparser_getval(VAR_3)));
break;
case VAR_33:
VAR_15 = jpc_floorlog2(atoi(jas_tvparser_getval(VAR_3)));
break;
case VAR_34:
VAR_10->cblkwidthexpn =
jpc_floorlog2(atoi(jas_tvparser_getval(VAR_3)));
break;
case VAR_35:
VAR_10->cblkheightexpn =
jpc_floorlog2(atoi(jas_tvparser_getval(VAR_3)));
break;
case VAR_36:
if ((VAR_8 = jas_taginfo_nonull(jas_taginfos_lookup(VAR_37,
jas_tvparser_getval(VAR_3)))->id) < 0) {
jas_eprintf(""ignoring invalid mode %s\n"",
jas_tvparser_getval(VAR_3));
} else {
VAR_9->intmode = (VAR_8 == VAR_38);
}
break;
case VAR_39:
if ((VAR_8 = jas_taginfo_nonull(jas_taginfos_lookup(VAR_40,
jas_tvparser_getval(VAR_3)))->id) < 0) {
jas_eprintf(""ignoring invalid progression order %s\n"",
jas_tvparser_getval(VAR_3));
} else {
VAR_9->prg = VAR_8;
}
break;
case VAR_41:
VAR_16 = false;
break;
case VAR_42:
VAR_10->maxrlvls = atoi(jas_tvparser_getval(VAR_3));
break;
case VAR_43:
VAR_2->tcp.csty |= VAR_44;
break;
case VAR_45:
VAR_2->tcp.csty |= VAR_46;
break;
case VAR_47:
VAR_10->cblksty |= VAR_48;
break;
case VAR_49:
VAR_10->cblksty |= VAR_50;
break;
case VAR_51:
VAR_10->cblksty |= VAR_52;
break;
case VAR_53:
VAR_10->cblksty |= VAR_54;
break;
case VAR_55:
VAR_10->cblksty |= VAR_56;
break;
case VAR_57:
VAR_10->cblksty |= VAR_58;
break;
case VAR_59:
VAR_2->tccp.numgbits = atoi(jas_tvparser_getval(VAR_3));
break;
case VAR_60:
if (ratestrtosize(jas_tvparser_getval(VAR_3), VAR_2->rawsize,
&VAR_2->totalsize)) {
jas_eprintf(""ignoring bad rate specifier %s\n"",
jas_tvparser_getval(VAR_3));
}
break;
case VAR_61:
if (jpc_atoaf(jas_tvparser_getval(VAR_3), &VAR_5,
&VAR_6)) {
jas_eprintf(""warning: invalid intermediate layer rates specifier ignored (%s)\n"",
jas_tvparser_getval(VAR_3));
}
break;
case VAR_62:
VAR_17 = atoi(jas_tvparser_getval(VAR_3));
break;
default:
jas_eprintf(""warning: ignoring invalid option %s\n"",
jas_tvparser_gettag(VAR_3));
break;
}
}
jas_tvparser_destroy(VAR_3);
VAR_3 = 0;
if (VAR_2->totalsize != VAR_22) {
VAR_2->totalsize = (VAR_2->totalsize > VAR_17) ?
(VAR_2->totalsize - VAR_17) : 0;
}
if (VAR_2->imgareatlx == VAR_22) {
VAR_2->imgareatlx = 0;
} else {
if (VAR_19 != 1) {
jas_eprintf(""warning: overriding imgareatlx value\n"");
}
VAR_2->imgareatlx *= VAR_19;
}
if (VAR_2->imgareatly == VAR_22) {
VAR_2->imgareatly = 0;
} else {
if (VAR_20 != 1) {
jas_eprintf(""warning: overriding imgareatly value\n"");
}
VAR_2->imgareatly *= VAR_20;
}
VAR_2->refgrdwidth = VAR_2->imgareatlx + jas_image_width(VAR_1);
VAR_2->refgrdheight = VAR_2->imgareatly + jas_image_height(VAR_1);
if (VAR_2->tilegrdoffx == VAR_22) {
VAR_2->tilegrdoffx = VAR_2->imgareatlx;
}
if (VAR_2->tilegrdoffy == VAR_22) {
VAR_2->tilegrdoffy = VAR_2->imgareatly;
}
if (!VAR_2->tilewidth) {
VAR_2->tilewidth = VAR_2->refgrdwidth - VAR_2->tilegrdoffx;
}
if (!VAR_2->tileheight) {
VAR_2->tileheight = VAR_2->refgrdheight - VAR_2->tilegrdoffy;
}
if (VAR_2->numcmpts == 3) {
VAR_21 = true;
for (VAR_12 = 0; VAR_12 < jas_image_numcmpts(VAR_1); ++VAR_12) {
if (jas_image_cmptprec(VAR_1, VAR_12) != jas_image_cmptprec(VAR_1, 0) ||
jas_image_cmptsgnd(VAR_1, VAR_12) != jas_image_cmptsgnd(VAR_1, 0) ||
jas_image_cmptwidth(VAR_1, VAR_12) != jas_image_cmptwidth(VAR_1, 0) ||
jas_image_cmptheight(VAR_1, VAR_12) != jas_image_cmptheight(VAR_1, 0)) {
VAR_21 = false;
}
}
} else {
VAR_21 = false;
}
if (VAR_21 && VAR_16 && jas_clrspc_fam(jas_image_clrspc(VAR_1)) != VAR_63) {
jas_eprintf(""warning: color space apparently not RGB\n"");
}
if (VAR_21 && VAR_16 && jas_clrspc_fam(jas_image_clrspc(VAR_1)) == VAR_63) {
VAR_9->mctid = (VAR_9->intmode) ? (VAR_64) : (VAR_65);
} else {
VAR_9->mctid = VAR_66;
}
VAR_10->qmfbid = (VAR_9->intmode) ? (VAR_67) : (VAR_68);
for (VAR_13 = 0; VAR_13 < VAR_10->maxrlvls; ++VAR_13) {
VAR_10->prcwidthexpns[VAR_13] = VAR_14;
VAR_10->prcheightexpns[VAR_13] = VAR_15;
}
if (VAR_14 != 15 || VAR_15 != 15) {
VAR_10->csty |= VAR_69;
}
if (!VAR_2->tilewidth) {
jas_eprintf(""invalid tile width %lu\n"", (unsigned long)
VAR_2->tilewidth);
goto error;
}
if (!VAR_2->tileheight) {
jas_eprintf(""invalid tile height %lu\n"", (unsigned long)
VAR_2->tileheight);
goto error;
}
if (VAR_2->tilegrdoffx > VAR_2->imgareatlx ||
VAR_2->tilegrdoffy > VAR_2->imgareatly ||
VAR_2->tilegrdoffx + VAR_2->tilewidth < VAR_2->imgareatlx ||
VAR_2->tilegrdoffy + VAR_2->tileheight < VAR_2->imgareatly) {
jas_eprintf(""invalid tile grid offset (%lu, %lu)\n"",
(unsigned long) VAR_2->tilegrdoffx, (unsigned long)
VAR_2->tilegrdoffy);
goto error;
}
VAR_2->numhtiles = JPC_CEILDIV(VAR_2->refgrdwidth - VAR_2->tilegrdoffx,
VAR_2->tilewidth);
VAR_2->numvtiles = JPC_CEILDIV(VAR_2->refgrdheight - VAR_2->tilegrdoffy,
VAR_2->tileheight);
VAR_2->numtiles = VAR_2->numhtiles * VAR_2->numvtiles;
if (VAR_6 && VAR_5 > 0) {
VAR_9->numlyrs = VAR_5 + 1;
if (!(VAR_9->ilyrrates = jas_alloc2((VAR_9->numlyrs - 1),
sizeof(VAR_70)))) {
goto error;
}
for (VAR_7 = 0; VAR_7 < JAS_CAST(int, VAR_9->numlyrs - 1); ++VAR_7) {
VAR_9->ilyrrates[VAR_7] = jpc_dbltofix(VAR_6[VAR_7]);
}
}
if (VAR_2->totalsize == VAR_22 && (!VAR_2->tcp.intmode)) {
jas_eprintf(""cannot use real mode for lossless coding\n"");
goto error;
}
if (VAR_14 > 15) {
jas_eprintf(""invalid precinct width\n"");
goto error;
}
if (VAR_15 > 15) {
jas_eprintf(""invalid precinct height\n"");
goto error;
}
if (VAR_2->tccp.cblkwidthexpn < 2 || VAR_2->tccp.cblkwidthexpn > 12) {
jas_eprintf(""invalid code block width %d\n"",
JPC_POW2(VAR_2->tccp.cblkwidthexpn));
goto error;
}
if (VAR_2->tccp.cblkheightexpn < 2 || VAR_2->tccp.cblkheightexpn > 12) {
jas_eprintf(""invalid code block height %d\n"",
JPC_POW2(VAR_2->tccp.cblkheightexpn));
goto error;
}
if (VAR_2->tccp.cblkwidthexpn + VAR_2->tccp.cblkheightexpn > 12) {
jas_eprintf(""code block size too large\n"");
goto error;
}
if (VAR_2->tcp.numlyrs > 16384) {
jas_eprintf(""too many layers\n"");
goto error;
}
if (VAR_2->tccp.maxrlvls < 1) {
jas_eprintf(""must be at least one resolution level\n"");
goto error;
}
if (VAR_2->tccp.numgbits > 8) {
jas_eprintf(""invalid number of guard bits\n"");
goto error;
}
if (VAR_2->totalsize != VAR_22 && VAR_2->totalsize > VAR_2->rawsize) {
jas_eprintf(""warning: specified rate is unreasonably large (%lu > %lu)\n"", (unsigned long) VAR_2->totalsize, (unsigned long) VAR_2->rawsize);
}
if (VAR_9->numlyrs > 1) {
for (VAR_18 = 0; VAR_18 + 2 < VAR_9->numlyrs; ++VAR_18) {
if (VAR_9->ilyrrates[VAR_18] >= VAR_9->ilyrrates[VAR_18 + 1]) {
jas_eprintf(""intermediate layer rates must increase monotonically\n"");
goto error;
}
}
if (VAR_2->totalsize != VAR_22) {
for (VAR_18 = 0; VAR_18 < VAR_9->numlyrs - 1; ++VAR_18) {
if (jpc_fixtodbl(VAR_9->ilyrrates[VAR_18]) > ((double) VAR_2->totalsize)
/ VAR_2->rawsize) {
jas_eprintf(""warning: intermediate layer rates must be less than overall rate\n"");
goto error;
}
}
}
}
if (VAR_6) {
jas_free(VAR_6);
}
return VAR_2;
error:
if (VAR_6) {
jas_free(VAR_6);
}
if (VAR_3) {
jas_tvparser_destroy(VAR_3);
}
if (VAR_2) {
jpc_enc_cp_destroy(VAR_2);
}
return 0;
}",jasper-software/jasper/fd564ee3377d9fc2484c657e4f464a3fb9764d31/jpc_enc.c/vul/before/0.json,"static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image)
{
	jpc_enc_cp_t *cp;
	jas_tvparser_t *tvp;
	int ret;
	int numilyrrates;
	double *ilyrrates;
	int i;
	int tagid;
	jpc_enc_tcp_t *tcp;
	jpc_enc_tccp_t *tccp;
	jpc_enc_ccp_t *ccp;
	int cmptno;
	uint_fast16_t rlvlno;
	uint_fast16_t prcwidthexpn;
	uint_fast16_t prcheightexpn;
	bool enablemct;
	uint_fast32_t jp2overhead;
	uint_fast16_t lyrno;
	uint_fast32_t hsteplcm;
	uint_fast32_t vsteplcm;
	bool mctvalid;

	tvp = 0;
	cp = 0;
	ilyrrates = 0;
	numilyrrates = 0;

	if (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {
		goto error;
	}

	prcwidthexpn = 15;
	prcheightexpn = 15;
	enablemct = true;
	jp2overhead = 0;

	cp->ccps = 0;
	cp->debug = 0;
	cp->imgareatlx = UINT_FAST32_MAX;
	cp->imgareatly = UINT_FAST32_MAX;
	cp->refgrdwidth = 0;
	cp->refgrdheight = 0;
	cp->tilegrdoffx = UINT_FAST32_MAX;
	cp->tilegrdoffy = UINT_FAST32_MAX;
	cp->tilewidth = 0;
	cp->tileheight = 0;
	cp->numcmpts = jas_image_numcmpts(image);

	hsteplcm = 1;
	vsteplcm = 1;
	for (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {
		if (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=
		  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +
		  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {
			jas_eprintf(""unsupported image type\n"");
			goto error;
		}
		/* Note: We ought to be calculating the LCMs here.  Fix some day. */
		hsteplcm *= jas_image_cmpthstep(image, cmptno);
		vsteplcm *= jas_image_cmptvstep(image, cmptno);
	}

	if (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {
		goto error;
	}
	for (cmptno = 0, ccp = cp->ccps; cmptno < JAS_CAST(int, cp->numcmpts); ++cmptno,
	  ++ccp) {
		ccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);
		ccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);
		/* XXX - this isn't quite correct for more general image */
		ccp->sampgrdsubstepx = 0;
		ccp->sampgrdsubstepx = 0;
		ccp->prec = jas_image_cmptprec(image, cmptno);
		ccp->sgnd = jas_image_cmptsgnd(image, cmptno);
		ccp->numstepsizes = 0;
		memset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));
	}

	cp->rawsize = jas_image_rawsize(image);
	if (cp->rawsize == 0) {
		/* prevent division by zero in cp_create() */
		goto error;
	}
	cp->totalsize = UINT_FAST32_MAX;

	tcp = &cp->tcp;
	tcp->csty = 0;
	tcp->intmode = true;
	tcp->prg = JPC_COD_LRCPPRG;
	tcp->numlyrs = 1;
	tcp->ilyrrates = 0;

	tccp = &cp->tccp;
	tccp->csty = 0;
	tccp->maxrlvls = 6;
	tccp->cblkwidthexpn = 6;
	tccp->cblkheightexpn = 6;
	tccp->cblksty = 0;
	tccp->numgbits = 2;

	if (!(tvp = jas_tvparser_create(optstr ? optstr : """"))) {
		goto error;
	}

	while (!(ret = jas_tvparser_next(tvp))) {
		switch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,
		  jas_tvparser_gettag(tvp)))->id) {
		case OPT_DEBUG:
			cp->debug = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_IMGAREAOFFX:
			cp->imgareatlx = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_IMGAREAOFFY:
			cp->imgareatly = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_TILEGRDOFFX:
			cp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_TILEGRDOFFY:
			cp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_TILEWIDTH:
			cp->tilewidth = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_TILEHEIGHT:
			cp->tileheight = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_PRCWIDTH:
			prcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));
			break;
		case OPT_PRCHEIGHT:
			prcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));
			break;
		case OPT_CBLKWIDTH:
			tccp->cblkwidthexpn =
			  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));
			break;
		case OPT_CBLKHEIGHT:
			tccp->cblkheightexpn =
			  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));
			break;
		case OPT_MODE:
			if ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,
			  jas_tvparser_getval(tvp)))->id) < 0) {
				jas_eprintf(""ignoring invalid mode %s\n"",
				  jas_tvparser_getval(tvp));
			} else {
				tcp->intmode = (tagid == MODE_INT);
			}
			break;
		case OPT_PRG:
			if ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,
			  jas_tvparser_getval(tvp)))->id) < 0) {
				jas_eprintf(""ignoring invalid progression order %s\n"",
				  jas_tvparser_getval(tvp));
			} else {
				tcp->prg = tagid;
			}
			break;
		case OPT_NOMCT:
			enablemct = false;
			break;
		case OPT_MAXRLVLS:
			tccp->maxrlvls = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_SOP:
			cp->tcp.csty |= JPC_COD_SOP;
			break;
		case OPT_EPH:
			cp->tcp.csty |= JPC_COD_EPH;
			break;
		case OPT_LAZY:
			tccp->cblksty |= JPC_COX_LAZY;
			break;
		case OPT_TERMALL:
			tccp->cblksty |= JPC_COX_TERMALL;
			break;
		case OPT_SEGSYM:
			tccp->cblksty |= JPC_COX_SEGSYM;
			break;
		case OPT_VCAUSAL:
			tccp->cblksty |= JPC_COX_VSC;
			break;
		case OPT_RESET:
			tccp->cblksty |= JPC_COX_RESET;
			break;
		case OPT_PTERM:
			tccp->cblksty |= JPC_COX_PTERM;
			break;
		case OPT_NUMGBITS:
			cp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));
			break;
		case OPT_RATE:
			if (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,
			  &cp->totalsize)) {
				jas_eprintf(""ignoring bad rate specifier %s\n"",
				  jas_tvparser_getval(tvp));
			}
			break;
		case OPT_ILYRRATES:
			if (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,
			  &ilyrrates)) {
				jas_eprintf(""warning: invalid intermediate layer rates specifier ignored (%s)\n"",
				  jas_tvparser_getval(tvp));
			}
			break;

		case OPT_JP2OVERHEAD:
			jp2overhead = atoi(jas_tvparser_getval(tvp));
			break;
		default:
			jas_eprintf(""warning: ignoring invalid option %s\n"",
			 jas_tvparser_gettag(tvp));
			break;
		}
	}

	jas_tvparser_destroy(tvp);
	tvp = 0;

	if (cp->totalsize != UINT_FAST32_MAX) {
		cp->totalsize = (cp->totalsize > jp2overhead) ?
		  (cp->totalsize - jp2overhead) : 0;
	}

	if (cp->imgareatlx == UINT_FAST32_MAX) {
		cp->imgareatlx = 0;
	} else {
		if (hsteplcm != 1) {
			jas_eprintf(""warning: overriding imgareatlx value\n"");
		}
		cp->imgareatlx *= hsteplcm;
	}
	if (cp->imgareatly == UINT_FAST32_MAX) {
		cp->imgareatly = 0;
	} else {
		if (vsteplcm != 1) {
			jas_eprintf(""warning: overriding imgareatly value\n"");
		}
		cp->imgareatly *= vsteplcm;
	}
	cp->refgrdwidth = cp->imgareatlx + jas_image_width(image);
	cp->refgrdheight = cp->imgareatly + jas_image_height(image);
	if (cp->tilegrdoffx == UINT_FAST32_MAX) {
		cp->tilegrdoffx = cp->imgareatlx;
	}
	if (cp->tilegrdoffy == UINT_FAST32_MAX) {
		cp->tilegrdoffy = cp->imgareatly;
	}
	if (!cp->tilewidth) {
		cp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;
	}
	if (!cp->tileheight) {
		cp->tileheight = cp->refgrdheight - cp->tilegrdoffy;
	}

	if (cp->numcmpts == 3) {
		mctvalid = true;
		for (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {
			if (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||
			  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||
			  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||
			  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {
				mctvalid = false;
			}
		}
	} else {
		mctvalid = false;
	}
	if (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {
		jas_eprintf(""warning: color space apparently not RGB\n"");
	}
	if (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {
		tcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);
	} else {
		tcp->mctid = JPC_MCT_NONE;
	}
	tccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);

	for (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {
		tccp->prcwidthexpns[rlvlno] = prcwidthexpn;
		tccp->prcheightexpns[rlvlno] = prcheightexpn;
	}
	if (prcwidthexpn != 15 || prcheightexpn != 15) {
		tccp->csty |= JPC_COX_PRT;
	}

	/* Ensure that the tile width and height is valid. */
	if (!cp->tilewidth) {
		jas_eprintf(""invalid tile width %lu\n"", (unsigned long)
		  cp->tilewidth);
		goto error;
	}
	if (!cp->tileheight) {
		jas_eprintf(""invalid tile height %lu\n"", (unsigned long)
		  cp->tileheight);
		goto error;
	}

	/* Ensure that the tile grid offset is valid. */
	if (cp->tilegrdoffx > cp->imgareatlx ||
	  cp->tilegrdoffy > cp->imgareatly ||
	  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||
	  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {
		jas_eprintf(""invalid tile grid offset (%lu, %lu)\n"",
		  (unsigned long) cp->tilegrdoffx, (unsigned long)
		  cp->tilegrdoffy);
		goto error;
	}

	cp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,
	  cp->tilewidth);
	cp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,
	  cp->tileheight);
	cp->numtiles = cp->numhtiles * cp->numvtiles;

	if (ilyrrates && numilyrrates > 0) {
		tcp->numlyrs = numilyrrates + 1;
		if (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),
		  sizeof(jpc_fix_t)))) {
			goto error;
		}
		for (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {
			tcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);
		}
	}

	/* Ensure that the integer mode is used in the case of lossless
	  coding. */
	if (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {
		jas_eprintf(""cannot use real mode for lossless coding\n"");
		goto error;
	}

	/* Ensure that the precinct width is valid. */
	if (prcwidthexpn > 15) {
		jas_eprintf(""invalid precinct width\n"");
		goto error;
	}

	/* Ensure that the precinct height is valid. */
	if (prcheightexpn > 15) {
		jas_eprintf(""invalid precinct height\n"");
		goto error;
	}

	/* Ensure that the code block width is valid. */
	if (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {
		jas_eprintf(""invalid code block width %d\n"",
		  JPC_POW2(cp->tccp.cblkwidthexpn));
		goto error;
	}

	/* Ensure that the code block height is valid. */
	if (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {
		jas_eprintf(""invalid code block height %d\n"",
		  JPC_POW2(cp->tccp.cblkheightexpn));
		goto error;
	}

	/* Ensure that the code block size is not too large. */
	if (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {
		jas_eprintf(""code block size too large\n"");
		goto error;
	}

	/* Ensure that the number of layers is valid. */
	if (cp->tcp.numlyrs > 16384) {
		jas_eprintf(""too many layers\n"");
		goto error;
	}

	/* There must be at least one resolution level. */
	if (cp->tccp.maxrlvls < 1) {
		jas_eprintf(""must be at least one resolution level\n"");
		goto error;
	}

	/* Ensure that the number of guard bits is valid. */
	if (cp->tccp.numgbits > 8) {
		jas_eprintf(""invalid number of guard bits\n"");
		goto error;
	}

	/* Ensure that the rate is within the legal range. */
	if (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {
		jas_eprintf(""warning: specified rate is unreasonably large (%lu > %lu)\n"", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);
	}

	/* Ensure that the intermediate layer rates are valid. */
	if (tcp->numlyrs > 1) {
		/* The intermediate layers rates must increase monotonically. */
		for (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {
			if (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {
				jas_eprintf(""intermediate layer rates must increase monotonically\n"");
				goto error;
			}
		}
		/* The intermediate layer rates must be less than the overall rate. */
		if (cp->totalsize != UINT_FAST32_MAX) {
			for (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {
				if (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)
				  / cp->rawsize) {
					jas_eprintf(""warning: intermediate layer rates must be less than overall rate\n"");
					goto error;
				}
			}
		}
	}

	if (ilyrrates) {
		jas_free(ilyrrates);
	}

	return cp;

error:

	if (ilyrrates) {
		jas_free(ilyrrates);
	}
	if (tvp) {
		jas_tvparser_destroy(tvp);
	}
	if (cp) {
		jpc_enc_cp_destroy(cp);
	}
	return 0;
}","static jpc_enc_cp_t *cp_create(const char *VAR_0, jas_image_t *VAR_1)
{
	jpc_enc_cp_t *VAR_2;
	jas_tvparser_t *VAR_3;
	int VAR_4;
	int VAR_5;
	double *VAR_6;
	int VAR_7;
	int VAR_8;
	jpc_enc_tcp_t *VAR_9;
	jpc_enc_tccp_t *VAR_10;
	jpc_enc_ccp_t *VAR_11;
	int VAR_12;
	uint_fast16_t VAR_13;
	uint_fast16_t VAR_14;
	uint_fast16_t VAR_15;
	bool VAR_16;
	uint_fast32_t VAR_17;
	uint_fast16_t VAR_18;
	uint_fast32_t VAR_19;
	uint_fast32_t VAR_20;
	bool VAR_21;

	VAR_3 = 0;
	VAR_2 = 0;
	VAR_6 = 0;
	VAR_5 = 0;

	if (!(VAR_2 = jas_malloc(sizeof(jpc_enc_cp_t)))) {
		goto error;
	}

	VAR_14 = 15;
	VAR_15 = 15;
	VAR_16 = true;
	VAR_17 = 0;

	VAR_2->ccps = 0;
	VAR_2->debug = 0;
	VAR_2->imgareatlx = VAR_22;
	VAR_2->imgareatly = VAR_22;
	VAR_2->refgrdwidth = 0;
	VAR_2->refgrdheight = 0;
	VAR_2->tilegrdoffx = VAR_22;
	VAR_2->tilegrdoffy = VAR_22;
	VAR_2->tilewidth = 0;
	VAR_2->tileheight = 0;
	VAR_2->numcmpts = jas_image_numcmpts(VAR_1);

	VAR_19 = 1;
	VAR_20 = 1;
	for (VAR_12 = 0; VAR_12 < jas_image_numcmpts(VAR_1); ++VAR_12) {
		if (jas_image_cmptbrx(VAR_1, VAR_12) + jas_image_cmpthstep(VAR_1, VAR_12) <=
		  jas_image_brx(VAR_1) || jas_image_cmptbry(VAR_1, VAR_12) +
		  jas_image_cmptvstep(VAR_1, VAR_12) <= jas_image_bry(VAR_1)) {
			jas_eprintf(""unsupported image type\n"");
			goto error;
		}
		/* COMMENT_0 */
		VAR_19 *= jas_image_cmpthstep(VAR_1, VAR_12);
		VAR_20 *= jas_image_cmptvstep(VAR_1, VAR_12);
	}

	if (!(VAR_2->ccps = jas_alloc2(VAR_2->numcmpts, sizeof(jpc_enc_ccp_t)))) {
		goto error;
	}
	for (VAR_12 = 0, VAR_11 = VAR_2->ccps; VAR_12 < JAS_CAST(int, VAR_2->numcmpts); ++VAR_12,
	  ++VAR_11) {
		VAR_11->sampgrdstepx = jas_image_cmpthstep(VAR_1, VAR_12);
		VAR_11->sampgrdstepy = jas_image_cmptvstep(VAR_1, VAR_12);
		/* COMMENT_1 */
		VAR_11->sampgrdsubstepx = 0;
		VAR_11->sampgrdsubstepx = 0;
		VAR_11->prec = jas_image_cmptprec(VAR_1, VAR_12);
		VAR_11->sgnd = jas_image_cmptsgnd(VAR_1, VAR_12);
		VAR_11->numstepsizes = 0;
		memset(VAR_11->stepsizes, 0, sizeof(VAR_11->stepsizes));
	}

	VAR_2->rawsize = jas_image_rawsize(VAR_1);
	if (VAR_2->rawsize == 0) {
		/* COMMENT_2 */
		goto error;
	}
	VAR_2->totalsize = VAR_22;

	VAR_9 = &VAR_2->tcp;
	VAR_9->csty = 0;
	VAR_9->intmode = true;
	VAR_9->prg = VAR_23;
	VAR_9->numlyrs = 1;
	VAR_9->ilyrrates = 0;

	VAR_10 = &VAR_2->tccp;
	VAR_10->csty = 0;
	VAR_10->maxrlvls = 6;
	VAR_10->cblkwidthexpn = 6;
	VAR_10->cblkheightexpn = 6;
	VAR_10->cblksty = 0;
	VAR_10->numgbits = 2;

	if (!(VAR_3 = jas_tvparser_create(VAR_0 ? VAR_0 : """"))) {
		goto error;
	}

	while (!(VAR_4 = jas_tvparser_next(VAR_3))) {
		switch (jas_taginfo_nonull(jas_taginfos_lookup(VAR_24,
		  jas_tvparser_gettag(VAR_3)))->id) {
		case VAR_25:
			VAR_2->debug = atoi(jas_tvparser_getval(VAR_3));
			break;
		case VAR_26:
			VAR_2->imgareatlx = atoi(jas_tvparser_getval(VAR_3));
			break;
		case VAR_27:
			VAR_2->imgareatly = atoi(jas_tvparser_getval(VAR_3));
			break;
		case VAR_28:
			VAR_2->tilegrdoffx = atoi(jas_tvparser_getval(VAR_3));
			break;
		case VAR_29:
			VAR_2->tilegrdoffy = atoi(jas_tvparser_getval(VAR_3));
			break;
		case VAR_30:
			VAR_2->tilewidth = atoi(jas_tvparser_getval(VAR_3));
			break;
		case VAR_31:
			VAR_2->tileheight = atoi(jas_tvparser_getval(VAR_3));
			break;
		case VAR_32:
			VAR_14 = jpc_floorlog2(atoi(jas_tvparser_getval(VAR_3)));
			break;
		case VAR_33:
			VAR_15 = jpc_floorlog2(atoi(jas_tvparser_getval(VAR_3)));
			break;
		case VAR_34:
			VAR_10->cblkwidthexpn =
			  jpc_floorlog2(atoi(jas_tvparser_getval(VAR_3)));
			break;
		case VAR_35:
			VAR_10->cblkheightexpn =
			  jpc_floorlog2(atoi(jas_tvparser_getval(VAR_3)));
			break;
		case VAR_36:
			if ((VAR_8 = jas_taginfo_nonull(jas_taginfos_lookup(VAR_37,
			  jas_tvparser_getval(VAR_3)))->id) < 0) {
				jas_eprintf(""ignoring invalid mode %s\n"",
				  jas_tvparser_getval(VAR_3));
			} else {
				VAR_9->intmode = (VAR_8 == VAR_38);
			}
			break;
		case VAR_39:
			if ((VAR_8 = jas_taginfo_nonull(jas_taginfos_lookup(VAR_40,
			  jas_tvparser_getval(VAR_3)))->id) < 0) {
				jas_eprintf(""ignoring invalid progression order %s\n"",
				  jas_tvparser_getval(VAR_3));
			} else {
				VAR_9->prg = VAR_8;
			}
			break;
		case VAR_41:
			VAR_16 = false;
			break;
		case VAR_42:
			VAR_10->maxrlvls = atoi(jas_tvparser_getval(VAR_3));
			break;
		case VAR_43:
			VAR_2->tcp.csty |= VAR_44;
			break;
		case VAR_45:
			VAR_2->tcp.csty |= VAR_46;
			break;
		case VAR_47:
			VAR_10->cblksty |= VAR_48;
			break;
		case VAR_49:
			VAR_10->cblksty |= VAR_50;
			break;
		case VAR_51:
			VAR_10->cblksty |= VAR_52;
			break;
		case VAR_53:
			VAR_10->cblksty |= VAR_54;
			break;
		case VAR_55:
			VAR_10->cblksty |= VAR_56;
			break;
		case VAR_57:
			VAR_10->cblksty |= VAR_58;
			break;
		case VAR_59:
			VAR_2->tccp.numgbits = atoi(jas_tvparser_getval(VAR_3));
			break;
		case VAR_60:
			if (ratestrtosize(jas_tvparser_getval(VAR_3), VAR_2->rawsize,
			  &VAR_2->totalsize)) {
				jas_eprintf(""ignoring bad rate specifier %s\n"",
				  jas_tvparser_getval(VAR_3));
			}
			break;
		case VAR_61:
			if (jpc_atoaf(jas_tvparser_getval(VAR_3), &VAR_5,
			  &VAR_6)) {
				jas_eprintf(""warning: invalid intermediate layer rates specifier ignored (%s)\n"",
				  jas_tvparser_getval(VAR_3));
			}
			break;

		case VAR_62:
			VAR_17 = atoi(jas_tvparser_getval(VAR_3));
			break;
		default:
			jas_eprintf(""warning: ignoring invalid option %s\n"",
			 jas_tvparser_gettag(VAR_3));
			break;
		}
	}

	jas_tvparser_destroy(VAR_3);
	VAR_3 = 0;

	if (VAR_2->totalsize != VAR_22) {
		VAR_2->totalsize = (VAR_2->totalsize > VAR_17) ?
		  (VAR_2->totalsize - VAR_17) : 0;
	}

	if (VAR_2->imgareatlx == VAR_22) {
		VAR_2->imgareatlx = 0;
	} else {
		if (VAR_19 != 1) {
			jas_eprintf(""warning: overriding imgareatlx value\n"");
		}
		VAR_2->imgareatlx *= VAR_19;
	}
	if (VAR_2->imgareatly == VAR_22) {
		VAR_2->imgareatly = 0;
	} else {
		if (VAR_20 != 1) {
			jas_eprintf(""warning: overriding imgareatly value\n"");
		}
		VAR_2->imgareatly *= VAR_20;
	}
	VAR_2->refgrdwidth = VAR_2->imgareatlx + jas_image_width(VAR_1);
	VAR_2->refgrdheight = VAR_2->imgareatly + jas_image_height(VAR_1);
	if (VAR_2->tilegrdoffx == VAR_22) {
		VAR_2->tilegrdoffx = VAR_2->imgareatlx;
	}
	if (VAR_2->tilegrdoffy == VAR_22) {
		VAR_2->tilegrdoffy = VAR_2->imgareatly;
	}
	if (!VAR_2->tilewidth) {
		VAR_2->tilewidth = VAR_2->refgrdwidth - VAR_2->tilegrdoffx;
	}
	if (!VAR_2->tileheight) {
		VAR_2->tileheight = VAR_2->refgrdheight - VAR_2->tilegrdoffy;
	}

	if (VAR_2->numcmpts == 3) {
		VAR_21 = true;
		for (VAR_12 = 0; VAR_12 < jas_image_numcmpts(VAR_1); ++VAR_12) {
			if (jas_image_cmptprec(VAR_1, VAR_12) != jas_image_cmptprec(VAR_1, 0) ||
			  jas_image_cmptsgnd(VAR_1, VAR_12) != jas_image_cmptsgnd(VAR_1, 0) ||
			  jas_image_cmptwidth(VAR_1, VAR_12) != jas_image_cmptwidth(VAR_1, 0) ||
			  jas_image_cmptheight(VAR_1, VAR_12) != jas_image_cmptheight(VAR_1, 0)) {
				VAR_21 = false;
			}
		}
	} else {
		VAR_21 = false;
	}
	if (VAR_21 && VAR_16 && jas_clrspc_fam(jas_image_clrspc(VAR_1)) != VAR_63) {
		jas_eprintf(""warning: color space apparently not RGB\n"");
	}
	if (VAR_21 && VAR_16 && jas_clrspc_fam(jas_image_clrspc(VAR_1)) == VAR_63) {
		VAR_9->mctid = (VAR_9->intmode) ? (VAR_64) : (VAR_65);
	} else {
		VAR_9->mctid = VAR_66;
	}
	VAR_10->qmfbid = (VAR_9->intmode) ? (VAR_67) : (VAR_68);

	for (VAR_13 = 0; VAR_13 < VAR_10->maxrlvls; ++VAR_13) {
		VAR_10->prcwidthexpns[VAR_13] = VAR_14;
		VAR_10->prcheightexpns[VAR_13] = VAR_15;
	}
	if (VAR_14 != 15 || VAR_15 != 15) {
		VAR_10->csty |= VAR_69;
	}

	/* COMMENT_3 */
	if (!VAR_2->tilewidth) {
		jas_eprintf(""invalid tile width %lu\n"", (unsigned long)
		  VAR_2->tilewidth);
		goto error;
	}
	if (!VAR_2->tileheight) {
		jas_eprintf(""invalid tile height %lu\n"", (unsigned long)
		  VAR_2->tileheight);
		goto error;
	}

	/* COMMENT_4 */
	if (VAR_2->tilegrdoffx > VAR_2->imgareatlx ||
	  VAR_2->tilegrdoffy > VAR_2->imgareatly ||
	  VAR_2->tilegrdoffx + VAR_2->tilewidth < VAR_2->imgareatlx ||
	  VAR_2->tilegrdoffy + VAR_2->tileheight < VAR_2->imgareatly) {
		jas_eprintf(""invalid tile grid offset (%lu, %lu)\n"",
		  (unsigned long) VAR_2->tilegrdoffx, (unsigned long)
		  VAR_2->tilegrdoffy);
		goto error;
	}

	VAR_2->numhtiles = JPC_CEILDIV(VAR_2->refgrdwidth - VAR_2->tilegrdoffx,
	  VAR_2->tilewidth);
	VAR_2->numvtiles = JPC_CEILDIV(VAR_2->refgrdheight - VAR_2->tilegrdoffy,
	  VAR_2->tileheight);
	VAR_2->numtiles = VAR_2->numhtiles * VAR_2->numvtiles;

	if (VAR_6 && VAR_5 > 0) {
		VAR_9->numlyrs = VAR_5 + 1;
		if (!(VAR_9->ilyrrates = jas_alloc2((VAR_9->numlyrs - 1),
		  sizeof(VAR_70)))) {
			goto error;
		}
		for (VAR_7 = 0; VAR_7 < JAS_CAST(int, VAR_9->numlyrs - 1); ++VAR_7) {
			VAR_9->ilyrrates[VAR_7] = jpc_dbltofix(VAR_6[VAR_7]);
		}
	}

	/* COMMENT_5 */
             
	if (VAR_2->totalsize == VAR_22 && (!VAR_2->tcp.intmode)) {
		jas_eprintf(""cannot use real mode for lossless coding\n"");
		goto error;
	}

	/* COMMENT_7 */
	if (VAR_14 > 15) {
		jas_eprintf(""invalid precinct width\n"");
		goto error;
	}

	/* COMMENT_8 */
	if (VAR_15 > 15) {
		jas_eprintf(""invalid precinct height\n"");
		goto error;
	}

	/* COMMENT_9 */
	if (VAR_2->tccp.cblkwidthexpn < 2 || VAR_2->tccp.cblkwidthexpn > 12) {
		jas_eprintf(""invalid code block width %d\n"",
		  JPC_POW2(VAR_2->tccp.cblkwidthexpn));
		goto error;
	}

	/* COMMENT_10 */
	if (VAR_2->tccp.cblkheightexpn < 2 || VAR_2->tccp.cblkheightexpn > 12) {
		jas_eprintf(""invalid code block height %d\n"",
		  JPC_POW2(VAR_2->tccp.cblkheightexpn));
		goto error;
	}

	/* COMMENT_11 */
	if (VAR_2->tccp.cblkwidthexpn + VAR_2->tccp.cblkheightexpn > 12) {
		jas_eprintf(""code block size too large\n"");
		goto error;
	}

	/* COMMENT_12 */
	if (VAR_2->tcp.numlyrs > 16384) {
		jas_eprintf(""too many layers\n"");
		goto error;
	}

	/* COMMENT_13 */
	if (VAR_2->tccp.maxrlvls < 1) {
		jas_eprintf(""must be at least one resolution level\n"");
		goto error;
	}

	/* COMMENT_14 */
	if (VAR_2->tccp.numgbits > 8) {
		jas_eprintf(""invalid number of guard bits\n"");
		goto error;
	}

	/* COMMENT_15 */
	if (VAR_2->totalsize != VAR_22 && VAR_2->totalsize > VAR_2->rawsize) {
		jas_eprintf(""warning: specified rate is unreasonably large (%lu > %lu)\n"", (unsigned long) VAR_2->totalsize, (unsigned long) VAR_2->rawsize);
	}

	/* COMMENT_16 */
	if (VAR_9->numlyrs > 1) {
		/* COMMENT_17 */
		for (VAR_18 = 0; VAR_18 + 2 < VAR_9->numlyrs; ++VAR_18) {
			if (VAR_9->ilyrrates[VAR_18] >= VAR_9->ilyrrates[VAR_18 + 1]) {
				jas_eprintf(""intermediate layer rates must increase monotonically\n"");
				goto error;
			}
		}
		/* COMMENT_18 */
		if (VAR_2->totalsize != VAR_22) {
			for (VAR_18 = 0; VAR_18 < VAR_9->numlyrs - 1; ++VAR_18) {
				if (jpc_fixtodbl(VAR_9->ilyrrates[VAR_18]) > ((double) VAR_2->totalsize)
				  / VAR_2->rawsize) {
					jas_eprintf(""warning: intermediate layer rates must be less than overall rate\n"");
					goto error;
				}
			}
		}
	}

	if (VAR_6) {
		jas_free(VAR_6);
	}

	return VAR_2;

error:

	if (VAR_6) {
		jas_free(VAR_6);
	}
	if (VAR_3) {
		jas_tvparser_destroy(VAR_3);
	}
	if (VAR_2) {
		jpc_enc_cp_destroy(VAR_2);
	}
	return 0;
}",jasper-software/jasper/fd564ee3377d9fc2484c657e4f464a3fb9764d31/jpc_enc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -78,6 +78,10 @@
 	}
 
 	cp->rawsize = jas_image_rawsize(image);
+	if (cp->rawsize == 0) {
+		/* prevent division by zero in cp_create() */
+		goto error;
+	}
 	cp->totalsize = UINT_FAST32_MAX;
 
 	tcp = &cp->tcp;","{'deleted_lines': [], 'added_lines': ['\tif (cp->rawsize == 0) {', '\t\t/* prevent division by zero in cp_create() */', '\t\tgoto error;', '\t}']}",True,A Divide-by-zero vulnerability exists in JasPer Image Coding Toolkit 2.0 in jasper/src/libjasper/jpc/jpc_enc.c,5.5,MEDIUM,1,test,2020-06-29T11:47:09Z,3
CVE-2020-26154,['CWE-120'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libproxy,"Fix buffer overflow when PAC is enabled

The bug was found on Windows 10 (MINGW64) when PAC is enabled. It turned
out to be the large PAC file (more than 102400 bytes) returned by a
local proxy program with no content-length present.",4411b523545b22022b4be7d0cac25aa170ae1d3e,https://github.com/libproxy/libproxy/commit/4411b523545b22022b4be7d0cac25aa170ae1d3e,libproxy/url.cpp,url::get_pac,"char* url::get_pac() {
int sock = -1;
bool chunked = false;
unsigned long int content_length = 0, status = 0;
char* buffer = NULL;
string request;
if (m_scheme == ""file"" || m_scheme == ""pac+file"") {
struct stat st;
if ((sock = ::open(m_path.c_str(), O_RDONLY)) < 0)
return NULL;
if (!fstat(sock, &st) && st.st_size < PAC_MAX_SIZE) {
buffer = new char[st.st_size+1];
memset(buffer, 0, st.st_size+1);
if (read(sock, buffer, st.st_size) == 0) {
delete[] buffer;
buffer = NULL;
}
}
close(sock);
return buffer;
}
if (!get_ips(true))
return NULL;
for (int i=0 ; m_ips[i] ; i++) {
sock = socket(m_ips[i]->sa_family, SOCK_STREAM, 0);
if (sock < 0) continue;
if (m_ips[i]->sa_family == AF_INET &&
!connect(sock, m_ips[i], sizeof(struct sockaddr_in)))
break;
else if (m_ips[i]->sa_family == AF_INET6 &&
!connect(sock, m_ips[i], sizeof(struct sockaddr_in6)))
break;
closesocket(sock);
sock = -1;
}
if (sock < 0) return NULL;
request  = ""GET "" + (m_path.size() > 0 ? m_path : ""/"") + m_query + "" HTTP/1.1\r\n"";
request += ""Host: "" + m_host + ""\r\n"";
request += ""Accept: "" + string(PAC_MIME_TYPE) + ""\r\n"";
request += ""Connection: close\r\n"";
request += ""\r\n"";
if ((size_t) send(sock, request.c_str(), request.size(), 0) != request.size()) {
closesocket(sock);
return NULL;
}
string line = recvline(sock);
if (sscanf(line.c_str(), ""HTTP/1.%*d %lu"", &status) == 1 && status == 200) {
content_length = 0;
for (line = recvline(sock) ; line != ""\r"" && line != """" ; line = recvline(sock)) {
if (line.find(""Content-Transfer-Encoding: chunked"") == 0 || line.find(""Transfer-Encoding: chunked"") == 0)
chunked = true;
else if (content_length == 0)
sscanf(line.c_str(), ""Content-Length: %lu"", &content_length);
}
unsigned int recvd = 0;
buffer = new char[PAC_MAX_SIZE];
memset(buffer, 0, PAC_MAX_SIZE);
do {
unsigned int chunk_length;
if (chunked) {
if (recvd > 0) recvline(sock);
if (sscanf(recvline(sock).c_str(), ""%x"", &chunk_length) != 1 || chunk_length == 0) break;
content_length += chunk_length;
}
if (content_length >= PAC_MAX_SIZE) break;
while (content_length == 0 || recvd != content_length) {
int r = recv(sock, buffer + recvd,
content_length == 0 ? PAC_HTTP_BLOCK_SIZE
: content_length - recvd, 0);
if (r <= 0) {
chunked = false;
break;
}
recvd += r;
}
} while (chunked);
if (content_length != 0 && string(buffer).size() != content_length) {
delete[] buffer;
buffer = NULL;
}
}
shutdown(sock, SHUT_RDWR);
closesocket(sock);
return buffer;
}","char* url::get_pac() {
int VAR_0 = -1;
bool VAR_1 = false;
unsigned long int VAR_2 = 0, VAR_3 = 0;
char* VAR_4 = NULL;
string VAR_5;
if (VAR_6 == ""file"" || VAR_6 == ""pac+file"") {
struct stat VAR_7;
if ((VAR_0 = ::open(VAR_8.c_str(), VAR_9)) < 0)
return NULL;
if (!fstat(VAR_0, &VAR_7) && VAR_7.st_size < VAR_10) {
VAR_4 = new char[VAR_7.st_size+1];
memset(VAR_4, 0, VAR_7.st_size+1);
if (read(VAR_0, VAR_4, VAR_7.st_size) == 0) {
delete[] VAR_4;
VAR_4 = NULL;
}
}
close(VAR_0);
return VAR_4;
}
if (!get_ips(true))
return NULL;
for (int VAR_11=0 ; VAR_12[VAR_11] ; VAR_11++) {
VAR_0 = socket(VAR_12[VAR_11]->sa_family, VAR_13, 0);
if (VAR_0 < 0) continue;
if (VAR_12[VAR_11]->sa_family == VAR_14 &&
!connect(VAR_0, VAR_12[VAR_11], sizeof(struct sockaddr_in)))
break;
else if (VAR_12[VAR_11]->sa_family == VAR_15 &&
!connect(VAR_0, VAR_12[VAR_11], sizeof(struct sockaddr_in6)))
break;
closesocket(VAR_0);
VAR_0 = -1;
}
if (VAR_0 < 0) return NULL;
VAR_5  = ""GET "" + (VAR_8.size() > 0 ? VAR_8 : ""/"") + VAR_16 + "" HTTP/1.1\r\n"";
VAR_5 += ""Host: "" + VAR_17 + ""\r\n"";
VAR_5 += ""Accept: "" + string(VAR_18) + ""\r\n"";
VAR_5 += ""Connection: close\r\n"";
VAR_5 += ""\r\n"";
if ((size_t) send(VAR_0, VAR_5.c_str(), VAR_5.size(), 0) != VAR_5.size()) {
closesocket(VAR_0);
return NULL;
}
string VAR_19 = recvline(VAR_0);
if (sscanf(VAR_19.c_str(), ""HTTP/1.%*d %lu"", &VAR_3) == 1 && VAR_3 == 200) {
VAR_2 = 0;
for (VAR_19 = recvline(VAR_0) ; VAR_19 != ""\r"" && VAR_19 != """" ; VAR_19 = recvline(VAR_0)) {
if (VAR_19.find(""Content-Transfer-Encoding: chunked"") == 0 || VAR_19.find(""Transfer-Encoding: chunked"") == 0)
VAR_1 = true;
else if (VAR_2 == 0)
sscanf(VAR_19.c_str(), ""Content-Length: %lu"", &VAR_2);
}
unsigned int VAR_20 = 0;
VAR_4 = new char[VAR_10];
memset(VAR_4, 0, VAR_10);
do {
unsigned int VAR_21;
if (VAR_1) {
if (VAR_20 > 0) recvline(VAR_0);
if (sscanf(recvline(VAR_0).c_str(), ""%x"", &VAR_21) != 1 || VAR_21 == 0) break;
VAR_2 += VAR_21;
}
if (VAR_2 >= VAR_10) break;
while (VAR_2 == 0 || VAR_20 != VAR_2) {
int VAR_22 = recv(VAR_0, VAR_4 + VAR_20,
VAR_2 == 0 ? VAR_23
: VAR_2 - VAR_20, 0);
if (VAR_22 <= 0) {
VAR_1 = false;
break;
}
VAR_20 += VAR_22;
}
} while (VAR_1);
if (VAR_2 != 0 && string(VAR_4).size() != VAR_2) {
delete[] VAR_4;
VAR_4 = NULL;
}
}
shutdown(VAR_0, VAR_24);
closesocket(VAR_0);
return VAR_4;
}",libproxy/4411b523545b22022b4be7d0cac25aa170ae1d3e/url.cpp/vul/before/0.json,"char* url::get_pac() {
	int sock = -1;
	bool chunked = false;
	unsigned long int content_length = 0, status = 0;
	char* buffer = NULL;
	string request;

	// In case of a file:// url we open the file and read it
	if (m_scheme == ""file"" || m_scheme == ""pac+file"") {
		struct stat st;
		if ((sock = ::open(m_path.c_str(), O_RDONLY)) < 0)
			return NULL;

		if (!fstat(sock, &st) && st.st_size < PAC_MAX_SIZE) {
			buffer = new char[st.st_size+1];
			memset(buffer, 0, st.st_size+1);
			if (read(sock, buffer, st.st_size) == 0) {
				delete[] buffer;
				buffer = NULL;
			}
		}
		close(sock);
		return buffer;
	}

	// DNS lookup of host
	if (!get_ips(true))
		return NULL;

	// Iterate through each IP trying to make a connection
	// Stop at the first one
	for (int i=0 ; m_ips[i] ; i++) {
		sock = socket(m_ips[i]->sa_family, SOCK_STREAM, 0);
		if (sock < 0) continue;

		if (m_ips[i]->sa_family == AF_INET &&
			!connect(sock, m_ips[i], sizeof(struct sockaddr_in)))
			break;
		else if (m_ips[i]->sa_family == AF_INET6 &&
			!connect(sock, m_ips[i], sizeof(struct sockaddr_in6)))
			break;

		closesocket(sock);
		sock = -1;
	}

	// Test our socket
	if (sock < 0) return NULL;

	// Build the request string
	request  = ""GET "" + (m_path.size() > 0 ? m_path : ""/"") + m_query + "" HTTP/1.1\r\n"";
	request += ""Host: "" + m_host + ""\r\n"";
	request += ""Accept: "" + string(PAC_MIME_TYPE) + ""\r\n"";
	request += ""Connection: close\r\n"";
	request += ""\r\n"";

	// Send HTTP request
	if ((size_t) send(sock, request.c_str(), request.size(), 0) != request.size()) {
		closesocket(sock);
		return NULL;
	}

	/* Verify status line */
	string line = recvline(sock);
	if (sscanf(line.c_str(), ""HTTP/1.%*d %lu"", &status) == 1 && status == 200) {
		/* Check for correct mime type and content length */
		content_length = 0;
		for (line = recvline(sock) ; line != ""\r"" && line != """" ; line = recvline(sock)) {
			// Check for chunked encoding
			if (line.find(""Content-Transfer-Encoding: chunked"") == 0 || line.find(""Transfer-Encoding: chunked"") == 0)
				chunked = true;

			// Check for content length
			else if (content_length == 0)
				sscanf(line.c_str(), ""Content-Length: %lu"", &content_length);
		}

		// Get content
		std::vector<char> dynamic_buffer;
		do {
			unsigned int chunk_length;

			if (chunked) {
				// Discard the empty line if we received a previous chunk
				if (!dynamic_buffer.empty()) recvline(sock);

				// Get the chunk-length line as an integer
				if (sscanf(recvline(sock).c_str(), ""%x"", &chunk_length) != 1 || chunk_length == 0) break;

				// Add this chunk to our content length,
				// ensuring that we aren't over our max size
				content_length += chunk_length;
			}

			if (content_length >= PAC_MAX_SIZE) break;

			while (content_length == 0 || dynamic_buffer.size() != content_length) {
				// Calculate length to recv
				unsigned int length_to_read = PAC_HTTP_BLOCK_SIZE;
				if (content_length > 0)
					length_to_read = content_length - dynamic_buffer.size();

				// Prepare buffer
				dynamic_buffer.resize(dynamic_buffer.size() + length_to_read);

				int r = recv(sock, dynamic_buffer.data() + dynamic_buffer.size() - length_to_read, length_to_read, 0);

				// Shrink buffer to fit
				if (r >= 0)
					dynamic_buffer.resize(dynamic_buffer.size() - length_to_read + r);

				// PAC size too large, discard
				if (dynamic_buffer.size() >= PAC_MAX_SIZE) {
					chunked = false;
					dynamic_buffer.clear();
					break;
				}

				if (r <= 0) {
					chunked = false;
					break;
				}
			}
		} while (chunked);

		if (content_length == 0 || content_length == dynamic_buffer.size()) {
			buffer = new char[dynamic_buffer.size() + 1];
			if (!dynamic_buffer.empty()) {
				memcpy(buffer, dynamic_buffer.data(), dynamic_buffer.size());
			}
			buffer[dynamic_buffer.size()] = '\0';
		}
	}

	// Clean up
	shutdown(sock, SHUT_RDWR);
	closesocket(sock);
	return buffer;
}","char* url::get_pac() {
	int VAR_0 = -1;
	bool VAR_1 = false;
	unsigned long int VAR_2 = 0, VAR_3 = 0;
	char* VAR_4 = NULL;
	string VAR_5;

	/* COMMENT_0 */
	if (VAR_6 == ""file"" || VAR_6 == ""pac+file"") {
		struct stat VAR_7;
		if ((VAR_0 = ::open(VAR_8.c_str(), VAR_9)) < 0)
			return NULL;

		if (!fstat(VAR_0, &VAR_7) && VAR_7.st_size < VAR_10) {
			VAR_4 = new char[VAR_7.st_size+1];
			memset(VAR_4, 0, VAR_7.st_size+1);
			if (read(VAR_0, VAR_4, VAR_7.st_size) == 0) {
				delete[] VAR_4;
				VAR_4 = NULL;
			}
		}
		close(VAR_0);
		return VAR_4;
	}

	/* COMMENT_1 */
	if (!get_ips(true))
		return NULL;

	/* COMMENT_2 */
	/* COMMENT_3 */
	for (int VAR_11=0 ; VAR_12[VAR_11] ; VAR_11++) {
		VAR_0 = socket(VAR_12[VAR_11]->sa_family, VAR_13, 0);
		if (VAR_0 < 0) continue;

		if (VAR_12[VAR_11]->sa_family == VAR_14 &&
			!connect(VAR_0, VAR_12[VAR_11], sizeof(struct sockaddr_in)))
			break;
		else if (VAR_12[VAR_11]->sa_family == VAR_15 &&
			!connect(VAR_0, VAR_12[VAR_11], sizeof(struct sockaddr_in6)))
			break;

		closesocket(VAR_0);
		VAR_0 = -1;
	}

	/* COMMENT_4 */
	if (VAR_0 < 0) return NULL;

	/* COMMENT_5 */
	VAR_5  = ""GET "" + (VAR_8.size() > 0 ? VAR_8 : ""/"") + VAR_16 + "" HTTP/1.1\r\n"";
	VAR_5 += ""Host: "" + VAR_17 + ""\r\n"";
	VAR_5 += ""Accept: "" + string(VAR_18) + ""\r\n"";
	VAR_5 += ""Connection: close\r\n"";
	VAR_5 += ""\r\n"";

	/* COMMENT_6 */
	if ((size_t) send(VAR_0, VAR_5.c_str(), VAR_5.size(), 0) != VAR_5.size()) {
		closesocket(VAR_0);
		return NULL;
	}

	/* COMMENT_7 */
	string VAR_19 = recvline(VAR_0);
	if (sscanf(VAR_19.c_str(), ""HTTP/1.%*d %lu"", &VAR_3) == 1 && VAR_3 == 200) {
		/* COMMENT_8 */
		VAR_2 = 0;
		for (VAR_19 = recvline(VAR_0) ; VAR_19 != ""\r"" && VAR_19 != """" ; VAR_19 = recvline(VAR_0)) {
			/* COMMENT_9 */
			if (VAR_19.find(""Content-Transfer-Encoding: chunked"") == 0 || VAR_19.find(""Transfer-Encoding: chunked"") == 0)
				VAR_1 = true;

			/* COMMENT_10 */
			else if (VAR_2 == 0)
				sscanf(VAR_19.c_str(), ""Content-Length: %lu"", &VAR_2);
		}

		/* COMMENT_11 */
		std::vector<char> VAR_20;
		do {
			unsigned int VAR_21;

			if (VAR_1) {
				/* COMMENT_12 */
				if (!VAR_20.empty()) recvline(VAR_0);

				/* COMMENT_13 */
				if (sscanf(recvline(VAR_0).c_str(), ""%x"", &VAR_21) != 1 || VAR_21 == 0) break;

				/* COMMENT_14 */
				/* COMMENT_15 */
				VAR_2 += VAR_21;
			}

			if (VAR_2 >= VAR_10) break;

			while (VAR_2 == 0 || VAR_20.size() != VAR_2) {
				/* COMMENT_16 */
				unsigned int VAR_22 = VAR_23;
				if (VAR_2 > 0)
					VAR_22 = VAR_2 - VAR_20.size();

				/* COMMENT_17 */
				VAR_20.resize(VAR_20.size() + VAR_22);

				int VAR_24 = recv(VAR_0, VAR_20.data() + VAR_20.size() - VAR_22, VAR_22, 0);

				/* COMMENT_18 */
				if (VAR_24 >= 0)
					VAR_20.resize(VAR_20.size() - VAR_22 + VAR_24);

				/* COMMENT_19 */
				if (VAR_20.size() >= VAR_10) {
					VAR_1 = false;
					VAR_20.clear();
					break;
				}

				if (VAR_24 <= 0) {
					VAR_1 = false;
					break;
				}
			}
		} while (VAR_1);

		if (VAR_2 == 0 || VAR_2 == VAR_20.size()) {
			VAR_4 = new char[VAR_20.size() + 1];
			if (!VAR_20.empty()) {
				memcpy(VAR_4, VAR_20.data(), VAR_20.size());
			}
			VAR_4[VAR_20.size()] = '\0';
		}
	}

	/* COMMENT_20 */
	shutdown(VAR_0, VAR_25);
	closesocket(VAR_0);
	return VAR_4;
}",libproxy/4411b523545b22022b4be7d0cac25aa170ae1d3e/url.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -76,15 +76,13 @@
 		}
 
 		// Get content
-		unsigned int recvd = 0;
-		buffer = new char[PAC_MAX_SIZE];
-		memset(buffer, 0, PAC_MAX_SIZE);
+		std::vector<char> dynamic_buffer;
 		do {
 			unsigned int chunk_length;
 
 			if (chunked) {
 				// Discard the empty line if we received a previous chunk
-				if (recvd > 0) recvline(sock);
+				if (!dynamic_buffer.empty()) recvline(sock);
 
 				// Get the chunk-length line as an integer
 				if (sscanf(recvline(sock).c_str(), ""%x"", &chunk_length) != 1 || chunk_length == 0) break;
@@ -96,21 +94,41 @@
 
 			if (content_length >= PAC_MAX_SIZE) break;
 
-			while (content_length == 0 || recvd != content_length) {
-				int r = recv(sock, buffer + recvd,
-				             content_length == 0 ? PAC_HTTP_BLOCK_SIZE
-				                                 : content_length - recvd, 0);
+			while (content_length == 0 || dynamic_buffer.size() != content_length) {
+				// Calculate length to recv
+				unsigned int length_to_read = PAC_HTTP_BLOCK_SIZE;
+				if (content_length > 0)
+					length_to_read = content_length - dynamic_buffer.size();
+
+				// Prepare buffer
+				dynamic_buffer.resize(dynamic_buffer.size() + length_to_read);
+
+				int r = recv(sock, dynamic_buffer.data() + dynamic_buffer.size() - length_to_read, length_to_read, 0);
+
+				// Shrink buffer to fit
+				if (r >= 0)
+					dynamic_buffer.resize(dynamic_buffer.size() - length_to_read + r);
+
+				// PAC size too large, discard
+				if (dynamic_buffer.size() >= PAC_MAX_SIZE) {
+					chunked = false;
+					dynamic_buffer.clear();
+					break;
+				}
+
 				if (r <= 0) {
 					chunked = false;
 					break;
 				}
-				recvd += r;
 			}
 		} while (chunked);
 
-		if (content_length != 0 && string(buffer).size() != content_length) {
-			delete[] buffer;
-			buffer = NULL;
+		if (content_length == 0 || content_length == dynamic_buffer.size()) {
+			buffer = new char[dynamic_buffer.size() + 1];
+			if (!dynamic_buffer.empty()) {
+				memcpy(buffer, dynamic_buffer.data(), dynamic_buffer.size());
+			}
+			buffer[dynamic_buffer.size()] = '\0';
 		}
 	}
 ","{'deleted_lines': ['\t\tunsigned int recvd = 0;', '\t\tbuffer = new char[PAC_MAX_SIZE];', '\t\tmemset(buffer, 0, PAC_MAX_SIZE);', '\t\t\t\tif (recvd > 0) recvline(sock);', '\t\t\twhile (content_length == 0 || recvd != content_length) {', '\t\t\t\tint r = recv(sock, buffer + recvd,', '\t\t\t\t             content_length == 0 ? PAC_HTTP_BLOCK_SIZE', '\t\t\t\t                                 : content_length - recvd, 0);', '\t\t\t\trecvd += r;', '\t\tif (content_length != 0 && string(buffer).size() != content_length) {', '\t\t\tdelete[] buffer;', '\t\t\tbuffer = NULL;'], 'added_lines': ['\t\tstd::vector<char> dynamic_buffer;', '\t\t\t\tif (!dynamic_buffer.empty()) recvline(sock);', '\t\t\twhile (content_length == 0 || dynamic_buffer.size() != content_length) {', '\t\t\t\t// Calculate length to recv', '\t\t\t\tunsigned int length_to_read = PAC_HTTP_BLOCK_SIZE;', '\t\t\t\tif (content_length > 0)', '\t\t\t\t\tlength_to_read = content_length - dynamic_buffer.size();', '', '\t\t\t\t// Prepare buffer', '\t\t\t\tdynamic_buffer.resize(dynamic_buffer.size() + length_to_read);', '', '\t\t\t\tint r = recv(sock, dynamic_buffer.data() + dynamic_buffer.size() - length_to_read, length_to_read, 0);', '', '\t\t\t\t// Shrink buffer to fit', '\t\t\t\tif (r >= 0)', '\t\t\t\t\tdynamic_buffer.resize(dynamic_buffer.size() - length_to_read + r);', '', '\t\t\t\t// PAC size too large, discard', '\t\t\t\tif (dynamic_buffer.size() >= PAC_MAX_SIZE) {', '\t\t\t\t\tchunked = false;', '\t\t\t\t\tdynamic_buffer.clear();', '\t\t\t\t\tbreak;', '\t\t\t\t}', '', '\t\tif (content_length == 0 || content_length == dynamic_buffer.size()) {', '\t\t\tbuffer = new char[dynamic_buffer.size() + 1];', '\t\t\tif (!dynamic_buffer.empty()) {', '\t\t\t\tmemcpy(buffer, dynamic_buffer.data(), dynamic_buffer.size());', '\t\t\t}', ""\t\t\tbuffer[dynamic_buffer.size()] = '\\0';""]}",True,"url.cpp in libproxy through 0.4.15 is prone to a buffer overflow when PAC is enabled, as demonstrated by a large PAC file that is delivered without a Content-length header.",9.8,CRITICAL,3,test,2020-07-16T18:18:37Z,3
CVE-2020-15900,"['CWE-787', 'CWE-191']",AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ArtifexSoftware/ghostpdl,"Bug 702582, CVE 2020-15900 Memory Corruption in Ghostscript 9.52

Fix the 'rsearch' calculation for the 'post' size to give the correct
size.  Previous calculation would result in a size that was too large,
and could underflow to max uint32_t. Also fix 'rsearch' to return the
correct 'pre' string with empty string match.

A future change may 'undefine' this undocumented, non-standard operator
during initialization as we do with the many other non-standard internal
PostScript operators and procedures.",5d499272b95a6b890a1397e11d20937de000d31b,https://github.com/ArtifexSoftware/ghostpdl/commit/5d499272b95a6b890a1397e11d20937de000d31b,psi/zstring.c,search_impl,"static int
search_impl(i_ctx_t *i_ctx_p, bool forward)
{
os_ptr op = osp;
os_ptr op1 = op - 1;
uint size = r_size(op);
uint count;
byte *pat;
byte *ptr;
byte ch;
int incr = forward ? 1 : -1;
check_read_type(*op1, t_string);
check_read_type(*op, t_string);
if (size > r_size(op1)) {
make_false(op);
return 0;
}
count = r_size(op1) - size;
ptr = op1->value.bytes;
if (size == 0)
goto found;
if (!forward)
ptr += count;
pat = op->value.bytes;
ch = pat[0];
do {
if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))
goto found;
ptr += incr;
}
while (count--);
make_false(op);
return 0;
found:
op->tas.type_attrs = op1->tas.type_attrs;
op->value.bytes = ptr;
r_set_size(op, size);
push(2);
op[-1] = *op1;
r_set_size(op - 1, ptr - op[-1].value.bytes);
op1->value.bytes = ptr + size;
r_set_size(op1, count + (!forward ? (size - 1) : 0));
make_true(op);
return 0;
}","static int
search_impl(i_ctx_t *VAR_0, bool VAR_1)
{
os_ptr VAR_2 = VAR_3;
os_ptr VAR_4 = VAR_2 - 1;
uint VAR_5 = r_size(VAR_2);
uint VAR_6;
byte *VAR_7;
byte *VAR_8;
byte VAR_9;
int VAR_10 = VAR_1 ? 1 : -1;
check_read_type(*VAR_4, VAR_11);
check_read_type(*VAR_2, VAR_11);
if (VAR_5 > r_size(VAR_4)) {
make_false(VAR_2);
return 0;
}
VAR_6 = r_size(VAR_4) - VAR_5;
VAR_8 = VAR_4->value.bytes;
if (VAR_5 == 0)
goto found;
if (!VAR_1)
VAR_8 += VAR_6;
VAR_7 = VAR_2->value.bytes;
VAR_9 = VAR_7[0];
do {
if (*VAR_8 == VAR_9 && (VAR_5 == 1 || !memcmp(VAR_8, VAR_7, VAR_5)))
goto found;
VAR_8 += VAR_10;
}
while (VAR_6--);
make_false(VAR_2);
return 0;
found:
VAR_2->tas.type_attrs = VAR_4->tas.type_attrs;
VAR_2->value.bytes = VAR_8;
r_set_size(VAR_2, VAR_5);
push(2);
VAR_2[-1] = *VAR_4;
r_set_size(VAR_2 - 1, VAR_8 - VAR_2[-1].value.bytes);
VAR_4->value.bytes = VAR_8 + VAR_5;
r_set_size(VAR_4, VAR_6 + (!VAR_1 ? (VAR_5 - 1) : 0));
make_true(VAR_2);
return 0;
}",ArtifexSoftware/ghostpdl/5d499272b95a6b890a1397e11d20937de000d31b/zstring.c/vul/before/0.json,"static int
search_impl(i_ctx_t *i_ctx_p, bool forward)
{
    os_ptr op = osp;
    os_ptr op1 = op - 1;
    uint size = r_size(op);
    uint count;
    byte *pat;
    byte *ptr;
    byte ch;
    int incr = forward ? 1 : -1;

    check_read_type(*op1, t_string);
    check_read_type(*op, t_string);
    if (size > r_size(op1)) {	/* can't match */
        make_false(op);
        return 0;
    }
    count = r_size(op1) - size;
    ptr = op1->value.bytes;
    if (size == 0)
        goto found;
    if (!forward)
        ptr += count;
    pat = op->value.bytes;
    ch = pat[0];
    do {
        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))
            goto found;
        ptr += incr;
    }
    while (count--);
    /* No match */
    make_false(op);
    return 0;
found:
    op->tas.type_attrs = op1->tas.type_attrs;
    op->value.bytes = ptr;				/* match */
    op->tas.rsize = size;				/* match */
    push(2);
    op[-1] = *op1;					/* pre */
    op[-3].value.bytes = ptr + size;			/* post */
    if (forward) {
        op[-1].tas.rsize = ptr - op[-1].value.bytes;	/* pre */
        op[-3].tas.rsize = count;			/* post */
    } else {
        op[-1].tas.rsize = count;			/* pre */
        op[-3].tas.rsize -= count + size;		/* post */
    }
    make_true(op);
    return 0;
}","static int
search_impl(i_ctx_t *VAR_0, bool VAR_1)
{
    os_ptr VAR_2 = VAR_3;
    os_ptr VAR_4 = VAR_2 - 1;
    uint VAR_5 = r_size(VAR_2);
    uint VAR_6;
    byte *VAR_7;
    byte *VAR_8;
    byte VAR_9;
    int VAR_10 = VAR_1 ? 1 : -1;

    check_read_type(*VAR_4, VAR_11);
    check_read_type(*VAR_2, VAR_11);
    if (VAR_5 > r_size(VAR_4)) {	/* COMMENT_0 */
        make_false(VAR_2);
        return 0;
    }
    VAR_6 = r_size(VAR_4) - VAR_5;
    VAR_8 = VAR_4->value.bytes;
    if (VAR_5 == 0)
        goto found;
    if (!VAR_1)
        VAR_8 += VAR_6;
    VAR_7 = VAR_2->value.bytes;
    VAR_9 = VAR_7[0];
    do {
        if (*VAR_8 == VAR_9 && (VAR_5 == 1 || !memcmp(VAR_8, VAR_7, VAR_5)))
            goto found;
        VAR_8 += VAR_10;
    }
    while (VAR_6--);
    /* COMMENT_1 */
    make_false(VAR_2);
    return 0;
found:
    VAR_2->tas.type_attrs = VAR_4->tas.type_attrs;
    VAR_2->value.bytes = VAR_8;				/* COMMENT_2 */
    VAR_2->tas.rsize = VAR_5;				/* COMMENT_2 */
    push(2);
    VAR_2[-1] = *VAR_4;					/* COMMENT_3 */
    VAR_2[-3].value.bytes = VAR_8 + VAR_5;			/* COMMENT_4 */
    if (VAR_1) {
        VAR_2[-1].tas.rsize = VAR_8 - VAR_2[-1].value.bytes;	/* COMMENT_3 */
        VAR_2[-3].tas.rsize = VAR_6;			/* COMMENT_4 */
    } else {
        VAR_2[-1].tas.rsize = VAR_6;			/* COMMENT_3 */
        VAR_2[-3].tas.rsize -= VAR_6 + VAR_5;		/* COMMENT_4 */
    }
    make_true(VAR_2);
    return 0;
}",ArtifexSoftware/ghostpdl/5d499272b95a6b890a1397e11d20937de000d31b/zstring.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,13 +35,18 @@
     return 0;
 found:
     op->tas.type_attrs = op1->tas.type_attrs;
-    op->value.bytes = ptr;
-    r_set_size(op, size);
+    op->value.bytes = ptr;				/* match */
+    op->tas.rsize = size;				/* match */
     push(2);
-    op[-1] = *op1;
-    r_set_size(op - 1, ptr - op[-1].value.bytes);
-    op1->value.bytes = ptr + size;
-    r_set_size(op1, count + (!forward ? (size - 1) : 0));
+    op[-1] = *op1;					/* pre */
+    op[-3].value.bytes = ptr + size;			/* post */
+    if (forward) {
+        op[-1].tas.rsize = ptr - op[-1].value.bytes;	/* pre */
+        op[-3].tas.rsize = count;			/* post */
+    } else {
+        op[-1].tas.rsize = count;			/* pre */
+        op[-3].tas.rsize -= count + size;		/* post */
+    }
     make_true(op);
     return 0;
 }","{'deleted_lines': ['    op->value.bytes = ptr;', '    r_set_size(op, size);', '    op[-1] = *op1;', '    r_set_size(op - 1, ptr - op[-1].value.bytes);', '    op1->value.bytes = ptr + size;', '    r_set_size(op1, count + (!forward ? (size - 1) : 0));'], 'added_lines': ['    op->value.bytes = ptr;\t\t\t\t/* match */', '    op->tas.rsize = size;\t\t\t\t/* match */', '    op[-1] = *op1;\t\t\t\t\t/* pre */', '    op[-3].value.bytes = ptr + size;\t\t\t/* post */', '    if (forward) {', '        op[-1].tas.rsize = ptr - op[-1].value.bytes;\t/* pre */', '        op[-3].tas.rsize = count;\t\t\t/* post */', '    } else {', '        op[-1].tas.rsize = count;\t\t\t/* pre */', '        op[-3].tas.rsize -= count + size;\t\t/* post */', '    }']}",True,"A memory corruption issue was found in Artifex Ghostscript 9.50 and 9.52. Use of a non-standard PostScript operator can allow overriding of file access controls. The 'rsearch' calculation for the 'post' size resulted in a size that was too large, and could underflow to max uint32_t. This was fixed in commit 5d499272b95a6b890a1397e11d20937de000d31b.",9.8,CRITICAL,3,test,2020-07-22T16:57:54Z,3
CVE-2020-27798,['CWE-763'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,upx,"Check de-compressed SHT_SYMTAB

https://github.com/upx/upx/issues/396
	modified:   p_lx_elf.cpp",77c914bce58aab9459029bed699f2bfb7ff2f90f,https://github.com/upx/upx/commit/77c914bce58aab9459029bed699f2bfb7ff2f90f,src/p_lx_elf.cpp,PackLinuxElf64::adjABS,"int
PackLinuxElf64::adjABS(Elf64_Sym *sym, unsigned delta)
{
for (int j = 0; abs_symbol_names[j][0]; ++j) {
unsigned st_name = get_te32(&sym->st_name);
if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
sym->st_value += delta;
return 1;
}
}
return 0;
}","int
PackLinuxElf64::adjABS(Elf64_Sym *VAR_0, unsigned VAR_1)
{
for (int VAR_2 = 0; VAR_3[VAR_2][0]; ++VAR_2) {
unsigned VAR_4 = get_te32(&VAR_0->st_name);
if (!strcmp(VAR_3[VAR_2], get_str_name(VAR_4, (unsigned)-1))) {
VAR_0->st_value += VAR_1;
return 1;
}
}
return 0;
}",upx/77c914bce58aab9459029bed699f2bfb7ff2f90f/p_lx_elf.cpp/vul/before/0.json,"int
PackLinuxElf64::adjABS(Elf64_Sym *sym, unsigned delta)
{
    unsigned st_name = get_te32(&sym->st_name);
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}","int
PackLinuxElf64::adjABS(Elf64_Sym *VAR_0, unsigned VAR_1)
{
    unsigned VAR_2 = get_te32(&VAR_0->st_name);
    for (int VAR_3 = 0; VAR_4[VAR_3][0]; ++VAR_3) {
        if (!strcmp(VAR_4[VAR_3], get_str_name(VAR_2, (unsigned)-1))) {
            VAR_0->st_value += VAR_1;
            return 1;
        }
    }
    return 0;
}",upx/77c914bce58aab9459029bed699f2bfb7ff2f90f/p_lx_elf.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,8 +1,8 @@
 int
 PackLinuxElf64::adjABS(Elf64_Sym *sym, unsigned delta)
 {
+    unsigned st_name = get_te32(&sym->st_name);
     for (int j = 0; abs_symbol_names[j][0]; ++j) {
-        unsigned st_name = get_te32(&sym->st_name);
         if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
             sym->st_value += delta;
             return 1;","{'deleted_lines': ['        unsigned st_name = get_te32(&sym->st_name);'], 'added_lines': ['    unsigned st_name = get_te32(&sym->st_name);']}",True,An invalid memory address reference was discovered in the adjABS function in p_lx_elf.cpp in UPX 4.0.0 via a crafted Mach-O file.,5.5,MEDIUM,1,test,2020-07-25T16:28:02Z,3
CVE-2020-27798,['CWE-763'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,upx,"Check de-compressed SHT_SYMTAB

https://github.com/upx/upx/issues/396
	modified:   p_lx_elf.cpp",77c914bce58aab9459029bed699f2bfb7ff2f90f,https://github.com/upx/upx/commit/77c914bce58aab9459029bed699f2bfb7ff2f90f,src/p_lx_elf.cpp,PackLinuxElf32::unpack,"void PackLinuxElf32::unpack(OutputFile *fo)
{
if (e_phoff != sizeof(Elf32_Ehdr)) {        throwCantUnpack(""bad e_phoff"");
}
unsigned const c_phnum = get_te16(&ehdri.e_phnum);
unsigned old_data_off = 0;
unsigned old_data_len = 0;
unsigned old_dtinit = 0;
unsigned is_asl = 0;  
unsigned szb_info = sizeof(b_info);
{
if (get_te32(&ehdri.e_entry) < 0x401180
&&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)
&&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {
szb_info = 2*sizeof(unsigned);
}
}
fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);
fi->readx(&linfo, sizeof(linfo));
lsize = get_te16(&linfo.l_lsize);
if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {
throwCantUnpack(""l_info corrupted"");
}
p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));
unsigned orig_file_size = get_te32(&hbuf.p_filesize);
blocksize = get_te32(&hbuf.p_blocksize);
if ((u32_t)file_size > orig_file_size || blocksize > orig_file_size
|| !mem_size_valid(1, blocksize, OVERHEAD))
throwCantUnpack(""p_info corrupted"");
ibuf.alloc(blocksize + OVERHEAD);
b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));
fi->readx(&bhdr, szb_info);
ph.u_len = get_te32(&bhdr.sz_unc);
ph.c_len = get_te32(&bhdr.sz_cpr);
if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0
||  ph.u_len > orig_file_size)
throwCantUnpack(""b_info corrupted"");
ph.filter_cto = bhdr.b_cto8;
MemBuffer u(ph.u_len);
Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)&u[0];
Elf32_Phdr const *phdr = 0;
if (ibuf.getSize() < ph.c_len) {
throwCompressedDataViolation();
}
fi->readx(ibuf, ph.c_len);
decompress(ibuf, (upx_byte *)ehdr, false);
if (ehdr->e_type   !=ehdri.e_type
||  ehdr->e_machine!=ehdri.e_machine
||  ehdr->e_version!=ehdri.e_version
||  ehdr->e_flags  !=ehdri.e_flags
||  ehdr->e_ehsize !=ehdri.e_ehsize
||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI)) {
throwCantUnpack(""ElfXX_Ehdr corrupted"");
}
fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);
unsigned const u_phnum = get_te16(&ehdr->e_phnum);
unsigned total_in = 0;
unsigned total_out = 0;
unsigned c_adler = upx_adler32(NULL, 0);
unsigned u_adler = upx_adler32(NULL, 0);
#define MAX_ELF_HDR 512
if ((umin(MAX_ELF_HDR, ph.u_len) - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {
throwCantUnpack(""bad compressed e_phnum"");
}
#undef MAX_ELF_HDR
Elf32_Phdr const *const dynhdr = elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);
bool const is_shlib = !!dynhdr;
if (is_shlib) {
unpackExtent(ph.u_len, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
fi->seek(0, SEEK_SET);
fi->readx(ibuf, get_te32(&dynhdr->p_offset) + get_te32(&dynhdr->p_filesz));
overlay_offset -= sizeof(linfo);
xct_off = overlay_offset;
e_shoff = get_te32(&ehdri.e_shoff);
ibuf.subref(""bad .e_shoff %#x for %#x"", e_shoff, sizeof(Elf32_Shdr) * e_shnum);
if (e_shoff && e_shnum) {             shdri = (Elf32_Shdr  *)ibuf.subref(
""bad Shdr table"", e_shoff, sizeof(Elf32_Shdr)*e_shnum);
unsigned xct_off2 = get_te32(&shdri->sh_offset);
if (e_shoff == xct_off2) {
xct_off = e_shoff;
}
dynseg = (Elf32_Dyn const *)ibuf.subref(
""bad DYNAMIC"", get_te32(&dynhdr->p_offset), get_te32(&dynhdr->p_filesz));
dynstr = (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);
sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);
if (sec_dynsym) {
unsigned const off_dynsym = get_te32(&sec_dynsym->sh_offset);
unsigned const sz_dynsym  = get_te32(&sec_dynsym->sh_size);
Elf32_Sym *const sym0 = (Elf32_Sym *)ibuf.subref(
""bad dynsym"", off_dynsym, sz_dynsym);
Elf32_Sym *sym = sym0;
for (int j = sz_dynsym / sizeof(Elf32_Sym); --j>=0; ++sym) {
unsigned symval = get_te32(&sym->st_value);
unsigned symsec = get_te16(&sym->st_shndx);
if (Elf32_Sym::SHN_UNDEF != symsec
&&  Elf32_Sym::SHN_ABS   != symsec
&&  xct_off <= symval) {
set_te32(&sym->st_value, symval - asl_delta);
}
if (Elf32_Sym::SHN_ABS == symsec && xct_off <= symval) {
adjABS(sym, 0u - asl_delta);
}
}
}
}
if (fo) {
fo->write(ibuf + ph.u_len, xct_off - ph.u_len);
}
int n_ptload = 0;
phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);
for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {
old_data_off = get_te32(&phdr->p_offset);
old_data_len = get_te32(&phdr->p_filesz);
break;
}
}
total_in  = xct_off;
total_out = xct_off;
ph.u_len = 0;
fi->seek(sizeof(linfo) + overlay_offset + sizeof(hbuf) + szb_info + ph.c_len, SEEK_SET);
phdr = (Elf32_Phdr *) (void *) (1+ ehdr);
for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD32==get_te32(&phdr->p_type)) {
ph.u_len = get_te32(&phdr->p_filesz) - xct_off;
break;
}
}
unpackExtent(ph.u_len, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
}
else {                  bool first_PF_X = true;
phdr = (Elf32_Phdr *) (void *) (1+ ehdr);          for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD32==get_te32(&phdr->p_type)) {
unsigned const filesz = get_te32(&phdr->p_filesz);
unsigned const offset = get_te32(&phdr->p_offset);
if (fo)
fo->seek(offset, SEEK_SET);
if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {
unpackExtent(filesz, fo, total_in, total_out,
c_adler, u_adler, first_PF_X, szb_info);
first_PF_X = false;
}
else {
unpackExtent(filesz, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
}
}
}
}
phdr = phdri;
load_va = 0;
for (unsigned j=0; j < c_phnum; ++j) {
if (PT_LOAD32==get_te32(&phdr->p_type)) {
load_va = get_te32(&phdr->p_vaddr);
break;
}
}
if (0x1000==get_te32(&phdri[0].p_filesz)      &&  0==get_te32(&phdri[1].p_offset)
&&  0==get_te32(&phdri[0].p_offset)
&&     get_te32(&phdri[1].p_filesz) == get_te32(&phdri[1].p_memsz)) {
fi->seek(up4(get_te32(&phdr[1].p_memsz)), SEEK_SET);      }
else if (is_shlib
||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +
ph.getPackHeaderSize() + sizeof(overlay_offset))
< up4(file_size)) {
funpad4(fi);          unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));
if (0==old_dtinit) {
old_dtinit = get_te32(&d_info[2 + (0==d_info[0])]);
is_asl = 1u& get_te32(&d_info[0 + (0==d_info[0])]);
}
fi->seek(lsize - sizeof(d_info), SEEK_CUR);
}
phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];
unsigned hi_offset(0);
for (unsigned j = 0; j < u_phnum; ++j) {
if (PT_LOAD32==phdr[j].p_type
&&  hi_offset < phdr[j].p_offset)
hi_offset = phdr[j].p_offset;
}
for (unsigned j = 0; j < u_phnum; ++j) {
unsigned const size = find_LOAD_gap(phdr, j, u_phnum);
if (size) {
unsigned const where = get_te32(&phdr[j].p_offset) +
get_te32(&phdr[j].p_filesz);
if (fo)
fo->seek(where, SEEK_SET);
unpackExtent(size, fo, total_in, total_out,
c_adler, u_adler, false, szb_info,
(phdr[j].p_offset != hi_offset));
}
}
fi->readx(&bhdr, szb_info);
unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);
if (sz_unc == 0) {                 unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);
if (sz_cpr != UPX_MAGIC_LE32)              throwCompressedDataViolation();
}
else {         throwCompressedDataViolation();
}
if (is_shlib) {
int n_ptload = 0;
unsigned load_off = 0;
phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];
for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {
load_off = get_te32(&phdr->p_offset);
load_va  = get_te32(&phdr->p_vaddr);
fi->seek(old_data_off, SEEK_SET);
fi->readx(ibuf, old_data_len);
total_in  += old_data_len;
total_out += old_data_len;
Elf32_Phdr const *udynhdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];
for (unsigned j3= 0; j3 < u_phnum; ++j3, ++udynhdr)
if (Elf32_Phdr::PT_DYNAMIC==get_te32(&udynhdr->p_type)) {
unsigned dt_pltrelsz(0), dt_jmprel(0);
unsigned dt_relsz(0), dt_rel(0);
unsigned const dyn_len = get_te32(&udynhdr->p_filesz);
unsigned const dyn_off = get_te32(&udynhdr->p_offset);
if ((unsigned long)file_size < (dyn_len + dyn_off)) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad PT_DYNAMIC .p_filesz %#x"", dyn_len);
throwCantUnpack(msg);
}
if (dyn_off < load_off) {
continue;                      }
Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +
(dyn_off - load_off));
dynseg = dyn; invert_pt_dynamic(dynseg, get_te32(&udynhdr->p_filesz));
for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {
unsigned const tag = get_te32(&dyn->d_tag);
unsigned       val = get_te32(&dyn->d_val);
if (is_asl) switch (tag) {
case Elf32_Dyn::DT_RELSZ:    { dt_relsz    = val; } break;
case Elf32_Dyn::DT_REL:      { dt_rel      = val; } break;
case Elf32_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;
case Elf32_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;
case Elf32_Dyn::DT_PLTGOT:
case Elf32_Dyn::DT_PREINIT_ARRAY:
case Elf32_Dyn::DT_INIT_ARRAY:
case Elf32_Dyn::DT_FINI_ARRAY:
case Elf32_Dyn::DT_FINI: {
set_te32(&dyn->d_val, val -= asl_delta);
}; break;
}                         if (upx_dt_init == tag) {
if (Elf32_Dyn::DT_INIT == tag) {
set_te32(&dyn->d_val, old_dtinit);
if (!old_dtinit) {                                     dyn->d_tag = Elf32_Dyn::DT_NULL;
dyn->d_val = 0;
}
}
else if (Elf32_Dyn::DT_INIT_ARRAY    == tag
||       Elf32_Dyn::DT_PREINIT_ARRAY == tag) {
if (val < load_va || (unsigned)file_size < (unsigned)val) {
char msg[50]; snprintf(msg, sizeof(msg),
""Bad Dynamic tag %#x %#x"",
(unsigned)tag, (unsigned)val);
throwCantUnpack(msg);
}
set_te32(&ibuf[val - load_va], old_dtinit
+ (is_asl ? asl_delta : 0));                              }
}
}
if (is_asl) {
lowmem.alloc(xct_off);
fi->seek(0, SEEK_SET);
fi->read(lowmem, xct_off);                          if (dt_relsz && dt_rel) {
Elf32_Rel *const rel0 = (Elf32_Rel *)lowmem.subref(
""bad Rel offset"", dt_rel, dt_relsz);
unRel32(dt_rel, rel0, dt_relsz, ibuf, load_va, fo);
}
if (dt_pltrelsz && dt_jmprel) {                             Elf32_Rel *const jmp0 = (Elf32_Rel *)lowmem.subref(
""bad Jmprel offset"", dt_jmprel, dt_pltrelsz);
unRel32(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);
}
}
}
if (fo) {
fo->seek(get_te32(&phdr->p_offset), SEEK_SET);
fo->rewrite(ibuf, old_data_len);
}
}
}
}
ph.c_len = total_in;
ph.u_len = total_out;
if (total_out != orig_file_size)
throwEOFException();
if (ph.c_adler != c_adler || ph.u_adler != u_adler)
throwChecksumError();
}","void PackLinuxElf32::unpack(OutputFile *VAR_0)
{
if (VAR_1 != sizeof(VAR_2)) {
throwCantUnpack(""bad e_phoff"");
}
unsigned const VAR_3 = get_te16(&VAR_4.e_phnum);
unsigned VAR_5 = 0;
unsigned VAR_6 = 0;
unsigned VAR_7 = 0;
unsigned VAR_8 = 0;  
unsigned VAR_9 = sizeof(VAR_10);
{
if (get_te32(&VAR_4.e_entry) < 0x401180
&&  Elf32_Ehdr::EM_386 ==get_te16(&VAR_4.e_machine)
&&  Elf32_Ehdr::ET_EXEC==get_te16(&VAR_4.e_type)) {
VAR_9 = 2*sizeof(unsigned);
}
}
VAR_11->seek(VAR_12 - sizeof(VAR_13), VAR_14);
VAR_11->readx(&VAR_15, sizeof(VAR_15));
VAR_16 = get_te16(&VAR_15.l_lsize);
if (VAR_17 != get_le32(&VAR_15.l_magic)) {
throwCantUnpack(""l_info corrupted"");
}
p_info VAR_18;  VAR_11->readx(&VAR_18, sizeof(VAR_18));
unsigned VAR_19 = get_te32(&VAR_18.p_filesize);
VAR_20 = get_te32(&VAR_18.p_blocksize);
if ((u32_t)VAR_21 > VAR_19 || VAR_20 > VAR_19
|| !mem_size_valid(1, VAR_20, VAR_22))
throwCantUnpack(""p_info corrupted"");
VAR_23.alloc(VAR_20 + VAR_22);
b_info VAR_24; memset(&VAR_24, 0, sizeof(VAR_24));
VAR_11->readx(&VAR_24, VAR_9);
VAR_25.u_len = get_te32(&VAR_24.sz_unc);
VAR_25.c_len = get_te32(&VAR_24.sz_cpr);
if (VAR_25.c_len > (unsigned)VAR_21 || VAR_25.c_len == 0 || VAR_25.u_len == 0
||  VAR_25.u_len > VAR_19)
throwCantUnpack(""b_info corrupted"");
VAR_25.filter_cto = VAR_24.b_cto8;
MemBuffer VAR_26(VAR_25.u_len);
Elf32_Ehdr *const VAR_27 = (Elf32_Ehdr *)&VAR_26[0];
Elf32_Phdr const *VAR_28 = 0;
if (VAR_23.getSize() < VAR_25.c_len) {
throwCompressedDataViolation();
}
VAR_11->readx(VAR_23, VAR_25.c_len);
decompress(VAR_23, (upx_byte *)VAR_27, false);
if (VAR_27->e_type   !=VAR_4.e_type
||  VAR_27->e_machine!=VAR_4.e_machine
||  VAR_27->e_version!=VAR_4.e_version
||  VAR_27->e_flags  !=VAR_4.e_flags
||  VAR_27->e_ehsize !=VAR_4.e_ehsize
||  memcmp(VAR_27->e_ident, VAR_4.e_ident, Elf32_Ehdr::EI_OSABI)) {
throwCantUnpack(""ElfXX_Ehdr corrupted"");
}
VAR_11->seek(- (VAR_29) (VAR_9 + VAR_25.c_len), VAR_30);
unsigned const VAR_31 = get_te16(&VAR_27->e_phnum);
unsigned VAR_32 = 0;
unsigned VAR_33 = 0;
unsigned VAR_34 = upx_adler32(NULL, 0);
unsigned VAR_35 = upx_adler32(NULL, 0);
#define VAR_36 512
if ((umin(VAR_36, VAR_25.u_len) - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < VAR_31) {
throwCantUnpack(""bad compressed e_phnum"");
}
#undef MAX_ELF_HDR
Elf32_Phdr const *const VAR_37 = elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, VAR_38, VAR_3);
bool const VAR_39 = !!VAR_37;
if (VAR_39) {
unpackExtent(VAR_25.u_len, VAR_0, VAR_32, VAR_33,
VAR_34, VAR_35, false, VAR_9);
VAR_11->seek(0, VAR_14);
VAR_11->readx(VAR_23, get_te32(&VAR_37->p_offset) + get_te32(&VAR_37->p_filesz));
VAR_12 -= sizeof(VAR_15);
VAR_40 = VAR_12;
VAR_41 = get_te32(&VAR_4.e_shoff);
VAR_23.subref(""bad .e_shoff %#x for %#x"", VAR_41, sizeof(VAR_42) * VAR_43);
if (VAR_41 && VAR_43) { 
VAR_44 = (Elf32_Shdr  *)VAR_23.subref(
""bad Shdr table"", VAR_41, sizeof(Elf32_Shdr)*VAR_43);
unsigned VAR_45 = get_te32(&VAR_44->sh_offset);
if (VAR_41 == VAR_45) {
VAR_40 = VAR_41;
}
VAR_46 = (Elf32_Dyn const *)VAR_23.subref(
""bad DYNAMIC"", get_te32(&VAR_37->p_offset), get_te32(&VAR_37->p_filesz));
VAR_47 = (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);
VAR_48 = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);
if (VAR_48) {
unsigned const VAR_49 = get_te32(&VAR_48->sh_offset);
unsigned const VAR_50  = get_te32(&VAR_48->sh_size);
Elf32_Sym *const VAR_51 = (Elf32_Sym *)VAR_23.subref(
""bad dynsym"", VAR_49, VAR_50);
Elf32_Sym *VAR_52 = VAR_51;
for (int VAR_53 = VAR_50 / sizeof(Elf32_Sym); --VAR_53>=0; ++VAR_52) {
unsigned VAR_54 = get_te32(&VAR_52->st_value);
unsigned VAR_55 = get_te16(&VAR_52->st_shndx);
if (Elf32_Sym::SHN_UNDEF != VAR_55
&&  Elf32_Sym::SHN_ABS   != VAR_55
&&  VAR_40 <= VAR_54) {
set_te32(&VAR_52->st_value, VAR_54 - VAR_56);
}
if (Elf32_Sym::SHN_ABS == VAR_55 && VAR_40 <= VAR_54) {
adjABS(VAR_52, 0u - VAR_56);
}
}
}
}
if (VAR_0) {
VAR_0->write(VAR_23 + VAR_25.u_len, VAR_40 - VAR_25.u_len);
}
int VAR_57 = 0;
VAR_28 = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)VAR_23);
for (unsigned VAR_53=0; VAR_53 < VAR_31; ++VAR_28, ++VAR_53) {
if (VAR_58==get_te32(&VAR_28->p_type) && 0!=VAR_57++) {
VAR_5 = get_te32(&VAR_28->p_offset);
VAR_6 = get_te32(&VAR_28->p_filesz);
break;
}
}
VAR_32  = VAR_40;
VAR_33 = VAR_40;
VAR_25.u_len = 0;
VAR_11->seek(sizeof(VAR_15) + VAR_12 + sizeof(VAR_18) + VAR_9 + VAR_25.c_len, VAR_14);
VAR_28 = (Elf32_Phdr *) (void *) (1+ VAR_27);
for (unsigned VAR_53=0; VAR_53 < VAR_31; ++VAR_28, ++VAR_53) {
if (VAR_58==get_te32(&VAR_28->p_type)) {
VAR_25.u_len = get_te32(&VAR_28->p_filesz) - VAR_40;
break;
}
}
unpackExtent(VAR_25.u_len, VAR_0, VAR_32, VAR_33,
VAR_34, VAR_35, false, VAR_9);
}
else {  
bool VAR_59 = true;
VAR_28 = (Elf32_Phdr *) (void *) (1+ VAR_27);  
for (unsigned VAR_53=0; VAR_53 < VAR_31; ++VAR_28, ++VAR_53) {
if (VAR_58==get_te32(&VAR_28->p_type)) {
unsigned const VAR_60 = get_te32(&VAR_28->p_filesz);
unsigned const VAR_61 = get_te32(&VAR_28->p_offset);
if (VAR_0)
VAR_0->seek(VAR_61, VAR_14);
if (Elf32_Phdr::PF_X & get_te32(&VAR_28->p_flags)) {
unpackExtent(VAR_60, VAR_0, VAR_32, VAR_33,
VAR_34, VAR_35, VAR_59, VAR_9);
VAR_59 = false;
}
else {
unpackExtent(VAR_60, VAR_0, VAR_32, VAR_33,
VAR_34, VAR_35, false, VAR_9);
}
}
}
}
VAR_28 = VAR_38;
VAR_62 = 0;
for (unsigned VAR_53=0; VAR_53 < VAR_3; ++VAR_53) {
if (VAR_58==get_te32(&VAR_28->p_type)) {
VAR_62 = get_te32(&VAR_28->p_vaddr);
break;
}
}
if (0x1000==get_te32(&VAR_38[0].p_filesz)  
&&  0==get_te32(&VAR_38[1].p_offset)
&&  0==get_te32(&VAR_38[0].p_offset)
&&     get_te32(&VAR_38[1].p_filesz) == get_te32(&VAR_38[1].p_memsz)) {
VAR_11->seek(up4(get_te32(&VAR_28[1].p_memsz)), VAR_14);  
}
else if (VAR_39
||  ((unsigned)(get_te32(&VAR_4.e_entry) - VAR_62) + up4(VAR_16) +
VAR_25.getPackHeaderSize() + sizeof(VAR_12))
< up4(VAR_21)) {
funpad4(VAR_11);  
unsigned VAR_63[4]; VAR_11->readx(VAR_63, sizeof(VAR_63));
if (0==VAR_7) {
VAR_7 = get_te32(&VAR_63[2 + (0==VAR_63[0])]);
VAR_8 = 1u& get_te32(&VAR_63[0 + (0==VAR_63[0])]);
}
VAR_11->seek(VAR_16 - sizeof(VAR_63), VAR_30);
}
VAR_28 = (Elf32_Phdr *)&VAR_26[sizeof(*VAR_27)];
unsigned VAR_64(0);
for (unsigned VAR_53 = 0; VAR_53 < VAR_31; ++VAR_53) {
if (VAR_58==VAR_28[VAR_53].p_type
&&  VAR_64 < VAR_28[VAR_53].p_offset)
VAR_64 = VAR_28[VAR_53].p_offset;
}
for (unsigned VAR_53 = 0; VAR_53 < VAR_31; ++VAR_53) {
unsigned const VAR_65 = find_LOAD_gap(VAR_28, VAR_53, VAR_31);
if (VAR_65) {
unsigned const VAR_66 = get_te32(&VAR_28[VAR_53].p_offset) +
get_te32(&VAR_28[VAR_53].p_filesz);
if (VAR_0)
VAR_0->seek(VAR_66, VAR_14);
unpackExtent(VAR_65, VAR_0, VAR_32, VAR_33,
VAR_34, VAR_35, false, VAR_9,
(VAR_28[VAR_53].p_offset != VAR_64));
}
}
VAR_11->readx(&VAR_24, VAR_9);
unsigned const VAR_67 = VAR_25.u_len = get_te32(&VAR_24.sz_unc);
if (VAR_67 == 0) { 
unsigned const VAR_68 = get_le32(&VAR_24.sz_cpr);
if (VAR_68 != VAR_17)  
throwCompressedDataViolation();
}
else { 
throwCompressedDataViolation();
}
if (VAR_39) {
int VAR_57 = 0;
unsigned VAR_69 = 0;
VAR_28 = (Elf32_Phdr *)&VAR_26[sizeof(*VAR_27)];
for (unsigned VAR_53= 0; VAR_53 < VAR_31; ++VAR_53, ++VAR_28) {
if (VAR_58==get_te32(&VAR_28->p_type) && 0!=VAR_57++) {
VAR_69 = get_te32(&VAR_28->p_offset);
VAR_62  = get_te32(&VAR_28->p_vaddr);
VAR_11->seek(VAR_5, VAR_14);
VAR_11->readx(VAR_23, VAR_6);
VAR_32  += VAR_6;
VAR_33 += VAR_6;
Elf32_Phdr const *VAR_70 = (Elf32_Phdr *)&VAR_26[sizeof(*VAR_27)];
for (unsigned VAR_71= 0; VAR_71 < VAR_31; ++VAR_71, ++VAR_70)
if (Elf32_Phdr::PT_DYNAMIC==get_te32(&VAR_70->p_type)) {
unsigned VAR_72(0), VAR_73(0);
unsigned VAR_74(0), VAR_75(0);
unsigned const VAR_76 = get_te32(&VAR_70->p_filesz);
unsigned const VAR_77 = get_te32(&VAR_70->p_offset);
if ((unsigned long)VAR_21 < (VAR_76 + VAR_77)) {
char VAR_78[50]; snprintf(VAR_78, sizeof(VAR_78),
""bad PT_DYNAMIC .p_filesz %#x"", VAR_76);
throwCantUnpack(VAR_78);
}
if (VAR_77 < VAR_69) {
continue;  
}
Elf32_Dyn *VAR_79 = (Elf32_Dyn *)((unsigned char *)VAR_23 +
(VAR_77 - VAR_69));
VAR_46 = VAR_79; invert_pt_dynamic(VAR_46, get_te32(&VAR_70->p_filesz));
for (unsigned VAR_80= 0; VAR_80 < VAR_76; ++VAR_79, VAR_80 += sizeof(*VAR_79)) {
unsigned const VAR_81 = get_te32(&VAR_79->d_tag);
unsigned       VAR_82 = get_te32(&VAR_79->d_val);
if (VAR_8) switch (VAR_81) {
case Elf32_Dyn::DT_RELSZ:    { VAR_74    = VAR_82; } break;
case Elf32_Dyn::DT_REL:      { VAR_75      = VAR_82; } break;
case Elf32_Dyn::DT_PLTRELSZ: { VAR_72 = VAR_82; } break;
case Elf32_Dyn::DT_JMPREL:   { VAR_73   = VAR_82; } break;
case Elf32_Dyn::DT_PLTGOT:
case Elf32_Dyn::DT_PREINIT_ARRAY:
case Elf32_Dyn::DT_INIT_ARRAY:
case Elf32_Dyn::DT_FINI_ARRAY:
case Elf32_Dyn::DT_FINI: {
set_te32(&VAR_79->d_val, VAR_82 -= VAR_56);
}; break;
} 
if (VAR_83 == VAR_81) {
if (Elf32_Dyn::DT_INIT == VAR_81) {
set_te32(&VAR_79->d_val, VAR_7);
if (!VAR_7) { 
VAR_79->d_tag = Elf32_Dyn::DT_NULL;
VAR_79->d_val = 0;
}
}
else if (Elf32_Dyn::DT_INIT_ARRAY    == VAR_81
||       Elf32_Dyn::DT_PREINIT_ARRAY == VAR_81) {
if (VAR_82 < VAR_62 || (unsigned)VAR_21 < (unsigned)VAR_82) {
char VAR_78[50]; snprintf(VAR_78, sizeof(VAR_78),
""Bad Dynamic tag %#x %#x"",
(unsigned)VAR_81, (unsigned)VAR_82);
throwCantUnpack(VAR_78);
}
set_te32(&VAR_23[VAR_82 - VAR_62], VAR_7
+ (VAR_8 ? VAR_56 : 0));  
}
}
}
if (VAR_8) {
VAR_84.alloc(VAR_40);
VAR_11->seek(0, VAR_14);
VAR_11->read(VAR_84, VAR_40);  
if (VAR_74 && VAR_75) {
Elf32_Rel *const VAR_85 = (Elf32_Rel *)VAR_84.subref(
""bad Rel offset"", VAR_75, VAR_74);
unRel32(VAR_75, VAR_85, VAR_74, VAR_23, VAR_62, VAR_0);
}
if (VAR_72 && VAR_73) { 
Elf32_Rel *const VAR_86 = (Elf32_Rel *)VAR_84.subref(
""bad Jmprel offset"", VAR_73, VAR_72);
unRel32(VAR_73, VAR_86, VAR_72, VAR_23, VAR_62, VAR_0);
}
}
}
if (VAR_0) {
VAR_0->seek(get_te32(&VAR_28->p_offset), VAR_14);
VAR_0->rewrite(VAR_23, VAR_6);
}
}
}
}
VAR_25.c_len = VAR_32;
VAR_25.u_len = VAR_33;
if (VAR_33 != VAR_19)
throwEOFException();
if (VAR_25.c_adler != VAR_34 || VAR_25.u_adler != VAR_35)
throwChecksumError();
}",upx/77c914bce58aab9459029bed699f2bfb7ff2f90f/p_lx_elf.cpp/vul/before/3.json,"void PackLinuxElf32::unpack(OutputFile *fo)
{
    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr
        throwCantUnpack(""bad e_phoff"");
    }
    unsigned const c_phnum = get_te16(&ehdri.e_phnum);
    unsigned old_data_off = 0;
    unsigned old_data_len = 0;
    unsigned old_dtinit = 0;
    unsigned is_asl = 0;  // is Android Shared Library

    unsigned szb_info = sizeof(b_info);
    {
        if (get_te32(&ehdri.e_entry) < 0x401180
        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)
        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {
            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.
            /* old style, 8-byte b_info */
            szb_info = 2*sizeof(unsigned);
        }
    }

    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);
    fi->readx(&linfo, sizeof(linfo));
    lsize = get_te16(&linfo.l_lsize);
    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {
        throwCantUnpack(""l_info corrupted"");
    }
    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));
    unsigned orig_file_size = get_te32(&hbuf.p_filesize);
    blocksize = get_te32(&hbuf.p_blocksize);
    if ((u32_t)file_size > orig_file_size || blocksize > orig_file_size
        || !mem_size_valid(1, blocksize, OVERHEAD))
        throwCantUnpack(""p_info corrupted"");

    ibuf.alloc(blocksize + OVERHEAD);
    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));
    fi->readx(&bhdr, szb_info);
    ph.u_len = get_te32(&bhdr.sz_unc);
    ph.c_len = get_te32(&bhdr.sz_cpr);
    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0
    ||  ph.u_len > orig_file_size)
        throwCantUnpack(""b_info corrupted"");
    ph.filter_cto = bhdr.b_cto8;

    MemBuffer u(ph.u_len);
    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)&u[0];
    Elf32_Phdr const *phdr = 0;

    // Uncompress Ehdr and Phdrs.
    if (ibuf.getSize() < ph.c_len) {
        throwCompressedDataViolation();
    }
    fi->readx(ibuf, ph.c_len);
    decompress(ibuf, (upx_byte *)ehdr, false);
    if (ehdr->e_type   !=ehdri.e_type
    ||  ehdr->e_machine!=ehdri.e_machine
    ||  ehdr->e_version!=ehdri.e_version
    ||  ehdr->e_flags  !=ehdri.e_flags
    ||  ehdr->e_ehsize !=ehdri.e_ehsize
        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION
    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI)) {
        throwCantUnpack(""ElfXX_Ehdr corrupted"");
    }
    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);

    unsigned const u_phnum = get_te16(&ehdr->e_phnum);
    unsigned total_in = 0;
    unsigned total_out = 0;
    unsigned c_adler = upx_adler32(NULL, 0);
    unsigned u_adler = upx_adler32(NULL, 0);
#define MAX_ELF_HDR 512
    if ((umin(MAX_ELF_HDR, ph.u_len) - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {
        throwCantUnpack(""bad compressed e_phnum"");
    }
#undef MAX_ELF_HDR

    // Packed ET_EXE has no PT_DYNAMIC.
    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.
    Elf32_Phdr const *const dynhdr = elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);
    bool const is_shlib = !!dynhdr;
    if (is_shlib) {
        // Unpack and output the Ehdr and Phdrs for real.
        // This depends on position within input file fi.
        unpackExtent(ph.u_len, fo, total_in, total_out,
            c_adler, u_adler, false, szb_info);

        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)
        fi->seek(0, SEEK_SET);
        fi->readx(ibuf, get_te32(&dynhdr->p_offset) + get_te32(&dynhdr->p_filesz));
        overlay_offset -= sizeof(linfo);
        xct_off = overlay_offset;
        e_shoff = get_te32(&ehdri.e_shoff);
        ibuf.subref(""bad .e_shoff %#x for %#x"", e_shoff, sizeof(Elf32_Shdr) * e_shnum);
        if (e_shoff && e_shnum) { // --android-shlib
            shdri = (Elf32_Shdr /*const*/ *)ibuf.subref(
                ""bad Shdr table"", e_shoff, sizeof(Elf32_Shdr)*e_shnum);
            unsigned xct_off2 = get_te32(&shdri->sh_offset);
            if (e_shoff == xct_off2) {
                xct_off = e_shoff;
            }
            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off
            unsigned dyn_offset = get_te32(&dynhdr->p_offset);
            unsigned dyn_filesz = get_te32(&dynhdr->p_filesz);
            if (orig_file_size < dyn_offset
            || (orig_file_size - dyn_offset) < dyn_filesz) {
                throwCantUnpack(""bad PT_DYNAMIC"");
            }
            dynseg = (Elf32_Dyn const *)ibuf.subref(""bad DYNAMIC"", dyn_offset, dyn_filesz);
            dynstr = (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);
            sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);
            if (sec_dynsym) {
                unsigned const off_dynsym = get_te32(&sec_dynsym->sh_offset);
                unsigned const sz_dynsym  = get_te32(&sec_dynsym->sh_size);
                if (orig_file_size < sz_dynsym
                ||  orig_file_size < off_dynsym
                || (orig_file_size - off_dynsym) < sz_dynsym) {
                    throwCantUnpack(""bad SHT_DYNSYM"");
                }
                Elf32_Sym *const sym0 = (Elf32_Sym *)ibuf.subref(
                    ""bad dynsym"", off_dynsym, sz_dynsym);
                Elf32_Sym *sym = sym0;
                for (int j = sz_dynsym / sizeof(Elf32_Sym); --j>=0; ++sym) {
                    unsigned symval = get_te32(&sym->st_value);
                    unsigned symsec = get_te16(&sym->st_shndx);
                    if (Elf32_Sym::SHN_UNDEF != symsec
                    &&  Elf32_Sym::SHN_ABS   != symsec
                    &&  xct_off <= symval) {
                        set_te32(&sym->st_value, symval - asl_delta);
                    }
                    if (Elf32_Sym::SHN_ABS == symsec && xct_off <= symval) {
                        adjABS(sym, 0u - asl_delta);
                    }
                }
            }
        }
        if (fo) {
            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);
        }
        // Search the Phdrs of compressed
        int n_ptload = 0;
        phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {
                old_data_off = get_te32(&phdr->p_offset);
                old_data_len = get_te32(&phdr->p_filesz);
                break;
            }
        }

        total_in  = xct_off;
        total_out = xct_off;
        ph.u_len = 0;
        // Position the input for next unpackExtent.
        fi->seek(sizeof(linfo) + overlay_offset + sizeof(hbuf) + szb_info + ph.c_len, SEEK_SET);

        // Decompress and unfilter the tail of first PT_LOAD.
        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD32==get_te32(&phdr->p_type)) {
                ph.u_len = get_te32(&phdr->p_filesz) - xct_off;
                break;
            }
        }
        unpackExtent(ph.u_len, fo, total_in, total_out,
            c_adler, u_adler, false, szb_info);
    }
    else {  // main executable
        // Decompress each PT_LOAD.
        bool first_PF_X = true;
        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD32==get_te32(&phdr->p_type)) {
                unsigned const filesz = get_te32(&phdr->p_filesz);
                unsigned const offset = get_te32(&phdr->p_offset);
                if (fo)
                    fo->seek(offset, SEEK_SET);
                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {
                    unpackExtent(filesz, fo, total_in, total_out,
                        c_adler, u_adler, first_PF_X, szb_info);
                    first_PF_X = false;
                }
                else {
                    unpackExtent(filesz, fo, total_in, total_out,
                        c_adler, u_adler, false, szb_info);
                }
            }
        }
    }
    phdr = phdri;
    load_va = 0;
    for (unsigned j=0; j < c_phnum; ++j) {
        if (PT_LOAD32==get_te32(&phdr->p_type)) {
            load_va = get_te32(&phdr->p_vaddr);
            break;
        }
    }
    if (0x1000==get_te32(&phdri[0].p_filesz)  // detect C_BASE style
    &&  0==get_te32(&phdri[1].p_offset)
    &&  0==get_te32(&phdri[0].p_offset)
    &&     get_te32(&phdri[1].p_filesz) == get_te32(&phdri[1].p_memsz)) {
        fi->seek(up4(get_te32(&phdr[1].p_memsz)), SEEK_SET);  // past the loader
    }
    else if (is_shlib
    ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +
                ph.getPackHeaderSize() + sizeof(overlay_offset))
            < up4(file_size)) {
        // Loader is not at end; skip past it.
        funpad4(fi);  // MATCH01
        unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));
        if (0==old_dtinit) {
            old_dtinit = get_te32(&d_info[2 + (0==d_info[0])]);
            is_asl = 1u& get_te32(&d_info[0 + (0==d_info[0])]);
        }
        fi->seek(lsize - sizeof(d_info), SEEK_CUR);
    }

    // The gaps between PT_LOAD and after last PT_LOAD
    phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];
    unsigned hi_offset(0);
    for (unsigned j = 0; j < u_phnum; ++j) {
        if (PT_LOAD32==phdr[j].p_type
        &&  hi_offset < phdr[j].p_offset)
            hi_offset = phdr[j].p_offset;
    }
    for (unsigned j = 0; j < u_phnum; ++j) {
        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);
        if (size) {
            unsigned const where = get_te32(&phdr[j].p_offset) +
                                   get_te32(&phdr[j].p_filesz);
            if (fo)
                fo->seek(where, SEEK_SET);
            unpackExtent(size, fo, total_in, total_out,
                c_adler, u_adler, false, szb_info,
                (phdr[j].p_offset != hi_offset));
        }
    }

    // check for end-of-file
    fi->readx(&bhdr, szb_info);
    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);

    if (sz_unc == 0) { // uncompressed size 0 -> EOF
        // note: magic is always stored le32
        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);
        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic
            throwCompressedDataViolation();
    }
    else { // extra bytes after end?
        throwCompressedDataViolation();
    }

    if (is_shlib) {
        // DT_INIT must be restored.
        // If android_shlib, then the asl_delta relocations must be un-done.
        int n_ptload = 0;
        unsigned load_off = 0;
        phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];
        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {
                load_off = get_te32(&phdr->p_offset);
                load_va  = get_te32(&phdr->p_vaddr);
                fi->seek(old_data_off, SEEK_SET);
                fi->readx(ibuf, old_data_len);
                total_in  += old_data_len;
                total_out += old_data_len;

                Elf32_Phdr const *udynhdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];
                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++udynhdr)
                if (Elf32_Phdr::PT_DYNAMIC==get_te32(&udynhdr->p_type)) {
                    unsigned dt_pltrelsz(0), dt_jmprel(0);
                    unsigned dt_relsz(0), dt_rel(0);
                    unsigned const dyn_len = get_te32(&udynhdr->p_filesz);
                    unsigned const dyn_off = get_te32(&udynhdr->p_offset);
                    if ((unsigned long)file_size < (dyn_len + dyn_off)) {
                        char msg[50]; snprintf(msg, sizeof(msg),
                                ""bad PT_DYNAMIC .p_filesz %#x"", dyn_len);
                        throwCantUnpack(msg);
                    }
                    if (dyn_off < load_off) {
                        continue;  // Oops.  Not really is_shlib ?  [built by 'rust' ?]
                    }
                    Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +
                        (dyn_off - load_off));
                    dynseg = dyn; invert_pt_dynamic(dynseg, get_te32(&udynhdr->p_filesz));
                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {
                        unsigned const tag = get_te32(&dyn->d_tag);
                        unsigned       val = get_te32(&dyn->d_val);
                        if (is_asl) switch (tag) {
                        case Elf32_Dyn::DT_RELSZ:    { dt_relsz    = val; } break;
                        case Elf32_Dyn::DT_REL:      { dt_rel      = val; } break;
                        case Elf32_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;
                        case Elf32_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;

                        case Elf32_Dyn::DT_PLTGOT:
                        case Elf32_Dyn::DT_PREINIT_ARRAY:
                        case Elf32_Dyn::DT_INIT_ARRAY:
                        case Elf32_Dyn::DT_FINI_ARRAY:
                        case Elf32_Dyn::DT_FINI: {
                            set_te32(&dyn->d_val, val -= asl_delta);
                        }; break;
                        } // end switch()
                        if (upx_dt_init == tag) {
                            if (Elf32_Dyn::DT_INIT == tag) {
                                set_te32(&dyn->d_val, old_dtinit);
                                if (!old_dtinit) { // compressor took the slot
                                    dyn->d_tag = Elf32_Dyn::DT_NULL;
                                    dyn->d_val = 0;
                                }
                            }
                            else if (Elf32_Dyn::DT_INIT_ARRAY    == tag
                            ||       Elf32_Dyn::DT_PREINIT_ARRAY == tag) {
                                if (val < load_va || (unsigned)file_size < (unsigned)val) {
                                    char msg[50]; snprintf(msg, sizeof(msg),
                                            ""Bad Dynamic tag %#x %#x"",
                                            (unsigned)tag, (unsigned)val);
                                    throwCantUnpack(msg);
                                }
                                set_te32(&ibuf[val - load_va], old_dtinit
                                    + (is_asl ? asl_delta : 0));  // counter-act unRel32
                            }
                        }
                        // Modified DT_*.d_val are re-written later from ibuf[]
                    }
                    if (is_asl) {
                        lowmem.alloc(xct_off);
                        fi->seek(0, SEEK_SET);
                        fi->read(lowmem, xct_off);  // contains relocation tables
                        if (dt_relsz && dt_rel) {
                            Elf32_Rel *const rel0 = (Elf32_Rel *)lowmem.subref(
                                ""bad Rel offset"", dt_rel, dt_relsz);
                            unRel32(dt_rel, rel0, dt_relsz, ibuf, load_va, fo);
                        }
                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?
                            Elf32_Rel *const jmp0 = (Elf32_Rel *)lowmem.subref(
                                ""bad Jmprel offset"", dt_jmprel, dt_pltrelsz);
                            unRel32(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);
                        }
                        // Modified relocation tables are re-written by unRel32
                    }
                }
                if (fo) {
                    fo->seek(get_te32(&phdr->p_offset), SEEK_SET);
                    fo->rewrite(ibuf, old_data_len);
                }
            }
        }
    }

    // update header with totals
    ph.c_len = total_in;
    ph.u_len = total_out;

    // all bytes must be written
    if (total_out != orig_file_size)
        throwEOFException();

    // finally test the checksums
    if (ph.c_adler != c_adler || ph.u_adler != u_adler)
        throwChecksumError();
}","void PackLinuxElf32::unpack(OutputFile *VAR_0)
{
    if (VAR_1 != sizeof(VAR_2)) {/* COMMENT_0 */
        throwCantUnpack(""bad e_phoff"");
    }
    unsigned const VAR_3 = get_te16(&VAR_4.e_phnum);
    unsigned VAR_5 = 0;
    unsigned VAR_6 = 0;
    unsigned VAR_7 = 0;
    unsigned VAR_8 = 0;  /* COMMENT_1 */

    unsigned VAR_9 = sizeof(VAR_10);
    {
        if (get_te32(&VAR_4.e_entry) < 0x401180
        &&  Elf32_Ehdr::EM_386 ==get_te16(&VAR_4.e_machine)
        &&  Elf32_Ehdr::ET_EXEC==get_te16(&VAR_4.e_type)) {
            /* COMMENT_2 */
            /* COMMENT_3 */
            VAR_9 = 2*sizeof(unsigned);
        }
    }

    VAR_11->seek(VAR_12 - sizeof(VAR_13), VAR_14);
    VAR_11->readx(&VAR_15, sizeof(VAR_15));
    VAR_16 = get_te16(&VAR_15.l_lsize);
    if (VAR_17 != get_le32(&VAR_15.l_magic)) {
        throwCantUnpack(""l_info corrupted"");
    }
    p_info VAR_18;  VAR_11->readx(&VAR_18, sizeof(VAR_18));
    unsigned VAR_19 = get_te32(&VAR_18.p_filesize);
    VAR_20 = get_te32(&VAR_18.p_blocksize);
    if ((u32_t)VAR_21 > VAR_19 || VAR_20 > VAR_19
        || !mem_size_valid(1, VAR_20, VAR_22))
        throwCantUnpack(""p_info corrupted"");

    VAR_23.alloc(VAR_20 + VAR_22);
    b_info VAR_24; memset(&VAR_24, 0, sizeof(VAR_24));
    VAR_11->readx(&VAR_24, VAR_9);
    VAR_25.u_len = get_te32(&VAR_24.sz_unc);
    VAR_25.c_len = get_te32(&VAR_24.sz_cpr);
    if (VAR_25.c_len > (unsigned)VAR_21 || VAR_25.c_len == 0 || VAR_25.u_len == 0
    ||  VAR_25.u_len > VAR_19)
        throwCantUnpack(""b_info corrupted"");
    VAR_25.filter_cto = VAR_24.b_cto8;

    MemBuffer VAR_26(VAR_25.u_len);
    Elf32_Ehdr *const VAR_27 = (Elf32_Ehdr *)&VAR_26[0];
    Elf32_Phdr const *VAR_28 = 0;

    /* COMMENT_4 */
    if (VAR_23.getSize() < VAR_25.c_len) {
        throwCompressedDataViolation();
    }
    VAR_11->readx(VAR_23, VAR_25.c_len);
    decompress(VAR_23, (upx_byte *)VAR_27, false);
    if (VAR_27->e_type   !=VAR_4.e_type
    ||  VAR_27->e_machine!=VAR_4.e_machine
    ||  VAR_27->e_version!=VAR_4.e_version
    ||  VAR_27->e_flags  !=VAR_4.e_flags
    ||  VAR_27->e_ehsize !=VAR_4.e_ehsize
        /* COMMENT_5 */
    ||  memcmp(VAR_27->e_ident, VAR_4.e_ident, Elf32_Ehdr::EI_OSABI)) {
        throwCantUnpack(""ElfXX_Ehdr corrupted"");
    }
    VAR_11->seek(- (VAR_29) (VAR_9 + VAR_25.c_len), VAR_30);

    unsigned const VAR_31 = get_te16(&VAR_27->e_phnum);
    unsigned VAR_32 = 0;
    unsigned VAR_33 = 0;
    unsigned VAR_34 = upx_adler32(NULL, 0);
    unsigned VAR_35 = upx_adler32(NULL, 0);
#define VAR_36 512
    if ((umin(VAR_36, VAR_25.u_len) - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < VAR_31) {
        throwCantUnpack(""bad compressed e_phnum"");
    }
#undef MAX_ELF_HDR

    /* COMMENT_6 */
    /* COMMENT_7 */
    Elf32_Phdr const *const VAR_37 = elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, VAR_38, VAR_3);
    bool const VAR_39 = !!VAR_37;
    if (VAR_39) {
        /* COMMENT_8 */
        /* COMMENT_9 */
        unpackExtent(VAR_25.u_len, VAR_0, VAR_32, VAR_33,
            VAR_34, VAR_35, false, VAR_9);

        /* COMMENT_10 */
        VAR_11->seek(0, VAR_14);
        VAR_11->readx(VAR_23, get_te32(&VAR_37->p_offset) + get_te32(&VAR_37->p_filesz));
        VAR_12 -= sizeof(VAR_15);
        VAR_40 = VAR_12;
        VAR_41 = get_te32(&VAR_4.e_shoff);
        VAR_23.subref(""bad .e_shoff %#x for %#x"", VAR_41, sizeof(VAR_42) * VAR_43);
        if (VAR_41 && VAR_43) { /* COMMENT_11 */
            VAR_44 = (Elf32_Shdr /* COMMENT_12 */ *)VAR_23.subref(
                ""bad Shdr table"", VAR_41, sizeof(Elf32_Shdr)*VAR_43);
            unsigned VAR_45 = get_te32(&VAR_44->sh_offset);
            if (VAR_41 == VAR_45) {
                VAR_40 = VAR_41;
            }
            /* COMMENT_13 */
            unsigned VAR_46 = get_te32(&VAR_37->p_offset);
            unsigned VAR_47 = get_te32(&VAR_37->p_filesz);
            if (VAR_19 < VAR_46
            || (VAR_19 - VAR_46) < VAR_47) {
                throwCantUnpack(""bad PT_DYNAMIC"");
            }
            VAR_48 = (Elf32_Dyn const *)VAR_23.subref(""bad DYNAMIC"", VAR_46, VAR_47);
            VAR_49 = (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);
            VAR_50 = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);
            if (VAR_50) {
                unsigned const VAR_51 = get_te32(&VAR_50->sh_offset);
                unsigned const VAR_52  = get_te32(&VAR_50->sh_size);
                if (VAR_19 < VAR_52
                ||  VAR_19 < VAR_51
                || (VAR_19 - VAR_51) < VAR_52) {
                    throwCantUnpack(""bad SHT_DYNSYM"");
                }
                Elf32_Sym *const VAR_53 = (Elf32_Sym *)VAR_23.subref(
                    ""bad dynsym"", VAR_51, VAR_52);
                Elf32_Sym *VAR_54 = VAR_53;
                for (int VAR_55 = VAR_52 / sizeof(Elf32_Sym); --VAR_55>=0; ++VAR_54) {
                    unsigned VAR_56 = get_te32(&VAR_54->st_value);
                    unsigned VAR_57 = get_te16(&VAR_54->st_shndx);
                    if (Elf32_Sym::SHN_UNDEF != VAR_57
                    &&  Elf32_Sym::SHN_ABS   != VAR_57
                    &&  VAR_40 <= VAR_56) {
                        set_te32(&VAR_54->st_value, VAR_56 - VAR_58);
                    }
                    if (Elf32_Sym::SHN_ABS == VAR_57 && VAR_40 <= VAR_56) {
                        adjABS(VAR_54, 0u - VAR_58);
                    }
                }
            }
        }
        if (VAR_0) {
            VAR_0->write(VAR_23 + VAR_25.u_len, VAR_40 - VAR_25.u_len);
        }
        /* COMMENT_14 */
        int VAR_59 = 0;
        VAR_28 = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)VAR_23);
        for (unsigned VAR_55=0; VAR_55 < VAR_31; ++VAR_28, ++VAR_55) {
            if (VAR_60==get_te32(&VAR_28->p_type) && 0!=VAR_59++) {
                VAR_5 = get_te32(&VAR_28->p_offset);
                VAR_6 = get_te32(&VAR_28->p_filesz);
                break;
            }
        }

        VAR_32  = VAR_40;
        VAR_33 = VAR_40;
        VAR_25.u_len = 0;
        /* COMMENT_15 */
        VAR_11->seek(sizeof(VAR_15) + VAR_12 + sizeof(VAR_18) + VAR_9 + VAR_25.c_len, VAR_14);

        /* COMMENT_16 */
        VAR_28 = (Elf32_Phdr *) (void *) (1+ VAR_27);
        for (unsigned VAR_55=0; VAR_55 < VAR_31; ++VAR_28, ++VAR_55) {
            if (VAR_60==get_te32(&VAR_28->p_type)) {
                VAR_25.u_len = get_te32(&VAR_28->p_filesz) - VAR_40;
                break;
            }
        }
        unpackExtent(VAR_25.u_len, VAR_0, VAR_32, VAR_33,
            VAR_34, VAR_35, false, VAR_9);
    }
    else {  /* COMMENT_17 */
        /* COMMENT_18 */
        bool VAR_61 = true;
        VAR_28 = (Elf32_Phdr *) (void *) (1+ VAR_27);  /* COMMENT_19 */
        for (unsigned VAR_55=0; VAR_55 < VAR_31; ++VAR_28, ++VAR_55) {
            if (VAR_60==get_te32(&VAR_28->p_type)) {
                unsigned const VAR_62 = get_te32(&VAR_28->p_filesz);
                unsigned const VAR_63 = get_te32(&VAR_28->p_offset);
                if (VAR_0)
                    VAR_0->seek(VAR_63, VAR_14);
                if (Elf32_Phdr::PF_X & get_te32(&VAR_28->p_flags)) {
                    unpackExtent(VAR_62, VAR_0, VAR_32, VAR_33,
                        VAR_34, VAR_35, VAR_61, VAR_9);
                    VAR_61 = false;
                }
                else {
                    unpackExtent(VAR_62, VAR_0, VAR_32, VAR_33,
                        VAR_34, VAR_35, false, VAR_9);
                }
            }
        }
    }
    VAR_28 = VAR_38;
    VAR_64 = 0;
    for (unsigned VAR_55=0; VAR_55 < VAR_3; ++VAR_55) {
        if (VAR_60==get_te32(&VAR_28->p_type)) {
            VAR_64 = get_te32(&VAR_28->p_vaddr);
            break;
        }
    }
    if (0x1000==get_te32(&VAR_38[0].p_filesz)  /* COMMENT_20 */
    &&  0==get_te32(&VAR_38[1].p_offset)
    &&  0==get_te32(&VAR_38[0].p_offset)
    &&     get_te32(&VAR_38[1].p_filesz) == get_te32(&VAR_38[1].p_memsz)) {
        VAR_11->seek(up4(get_te32(&VAR_28[1].p_memsz)), VAR_14);  /* COMMENT_21 */
    }
    else if (VAR_39
    ||  ((unsigned)(get_te32(&VAR_4.e_entry) - VAR_64) + up4(VAR_16) +
                VAR_25.getPackHeaderSize() + sizeof(VAR_12))
            < up4(VAR_21)) {
        /* COMMENT_22 */
        funpad4(VAR_11);  /* COMMENT_23 */
        unsigned VAR_65[4]; VAR_11->readx(VAR_65, sizeof(VAR_65));
        if (0==VAR_7) {
            VAR_7 = get_te32(&VAR_65[2 + (0==VAR_65[0])]);
            VAR_8 = 1u& get_te32(&VAR_65[0 + (0==VAR_65[0])]);
        }
        VAR_11->seek(VAR_16 - sizeof(VAR_65), VAR_30);
    }

    /* COMMENT_24 */
    VAR_28 = (Elf32_Phdr *)&VAR_26[sizeof(*VAR_27)];
    unsigned VAR_66(0);
    for (unsigned VAR_55 = 0; VAR_55 < VAR_31; ++VAR_55) {
        if (VAR_60==VAR_28[VAR_55].p_type
        &&  VAR_66 < VAR_28[VAR_55].p_offset)
            VAR_66 = VAR_28[VAR_55].p_offset;
    }
    for (unsigned VAR_55 = 0; VAR_55 < VAR_31; ++VAR_55) {
        unsigned const VAR_67 = find_LOAD_gap(VAR_28, VAR_55, VAR_31);
        if (VAR_67) {
            unsigned const VAR_68 = get_te32(&VAR_28[VAR_55].p_offset) +
                                   get_te32(&VAR_28[VAR_55].p_filesz);
            if (VAR_0)
                VAR_0->seek(VAR_68, VAR_14);
            unpackExtent(VAR_67, VAR_0, VAR_32, VAR_33,
                VAR_34, VAR_35, false, VAR_9,
                (VAR_28[VAR_55].p_offset != VAR_66));
        }
    }

    /* COMMENT_25 */
    VAR_11->readx(&VAR_24, VAR_9);
    unsigned const VAR_69 = VAR_25.u_len = get_te32(&VAR_24.sz_unc);

    if (VAR_69 == 0) { /* COMMENT_26 */
        /* COMMENT_27 */
        unsigned const VAR_70 = get_le32(&VAR_24.sz_cpr);
        if (VAR_70 != VAR_17)  /* COMMENT_28 */
            throwCompressedDataViolation();
    }
    else { /* COMMENT_29 */
        throwCompressedDataViolation();
    }

    if (VAR_39) {
        /* COMMENT_30 */
        /* COMMENT_31 */
        int VAR_59 = 0;
        unsigned VAR_71 = 0;
        VAR_28 = (Elf32_Phdr *)&VAR_26[sizeof(*VAR_27)];
        for (unsigned VAR_55= 0; VAR_55 < VAR_31; ++VAR_55, ++VAR_28) {
            if (VAR_60==get_te32(&VAR_28->p_type) && 0!=VAR_59++) {
                VAR_71 = get_te32(&VAR_28->p_offset);
                VAR_64  = get_te32(&VAR_28->p_vaddr);
                VAR_11->seek(VAR_5, VAR_14);
                VAR_11->readx(VAR_23, VAR_6);
                VAR_32  += VAR_6;
                VAR_33 += VAR_6;

                Elf32_Phdr const *VAR_72 = (Elf32_Phdr *)&VAR_26[sizeof(*VAR_27)];
                for (unsigned VAR_73= 0; VAR_73 < VAR_31; ++VAR_73, ++VAR_72)
                if (Elf32_Phdr::PT_DYNAMIC==get_te32(&VAR_72->p_type)) {
                    unsigned VAR_74(0), VAR_75(0);
                    unsigned VAR_76(0), VAR_77(0);
                    unsigned const VAR_78 = get_te32(&VAR_72->p_filesz);
                    unsigned const VAR_79 = get_te32(&VAR_72->p_offset);
                    if ((unsigned long)VAR_21 < (VAR_78 + VAR_79)) {
                        char VAR_80[50]; snprintf(VAR_80, sizeof(VAR_80),
                                ""bad PT_DYNAMIC .p_filesz %#x"", VAR_78);
                        throwCantUnpack(VAR_80);
                    }
                    if (VAR_79 < VAR_71) {
                        continue;  /* COMMENT_32 */
                    }
                    Elf32_Dyn *VAR_81 = (Elf32_Dyn *)((unsigned char *)VAR_23 +
                        (VAR_79 - VAR_71));
                    VAR_48 = VAR_81; invert_pt_dynamic(VAR_48, get_te32(&VAR_72->p_filesz));
                    for (unsigned VAR_82= 0; VAR_82 < VAR_78; ++VAR_81, VAR_82 += sizeof(*VAR_81)) {
                        unsigned const VAR_83 = get_te32(&VAR_81->d_tag);
                        unsigned       VAR_84 = get_te32(&VAR_81->d_val);
                        if (VAR_8) switch (VAR_83) {
                        case Elf32_Dyn::DT_RELSZ:    { VAR_76    = VAR_84; } break;
                        case Elf32_Dyn::DT_REL:      { VAR_77      = VAR_84; } break;
                        case Elf32_Dyn::DT_PLTRELSZ: { VAR_74 = VAR_84; } break;
                        case Elf32_Dyn::DT_JMPREL:   { VAR_75   = VAR_84; } break;

                        case Elf32_Dyn::DT_PLTGOT:
                        case Elf32_Dyn::DT_PREINIT_ARRAY:
                        case Elf32_Dyn::DT_INIT_ARRAY:
                        case Elf32_Dyn::DT_FINI_ARRAY:
                        case Elf32_Dyn::DT_FINI: {
                            set_te32(&VAR_81->d_val, VAR_84 -= VAR_58);
                        }; break;
                        } /* COMMENT_33 */
                        if (VAR_85 == VAR_83) {
                            if (Elf32_Dyn::DT_INIT == VAR_83) {
                                set_te32(&VAR_81->d_val, VAR_7);
                                if (!VAR_7) { /* COMMENT_34 */
                                    VAR_81->d_tag = Elf32_Dyn::DT_NULL;
                                    VAR_81->d_val = 0;
                                }
                            }
                            else if (Elf32_Dyn::DT_INIT_ARRAY    == VAR_83
                            ||       Elf32_Dyn::DT_PREINIT_ARRAY == VAR_83) {
                                if (VAR_84 < VAR_64 || (unsigned)VAR_21 < (unsigned)VAR_84) {
                                    char VAR_80[50]; snprintf(VAR_80, sizeof(VAR_80),
                                            ""Bad Dynamic tag %#x %#x"",
                                            (unsigned)VAR_83, (unsigned)VAR_84);
                                    throwCantUnpack(VAR_80);
                                }
                                set_te32(&VAR_23[VAR_84 - VAR_64], VAR_7
                                    + (VAR_8 ? VAR_58 : 0));  /* COMMENT_35 */
                            }
                        }
                        /* COMMENT_36 */
                    }
                    if (VAR_8) {
                        VAR_86.alloc(VAR_40);
                        VAR_11->seek(0, VAR_14);
                        VAR_11->read(VAR_86, VAR_40);  /* COMMENT_37 */
                        if (VAR_76 && VAR_77) {
                            Elf32_Rel *const VAR_87 = (Elf32_Rel *)VAR_86.subref(
                                ""bad Rel offset"", VAR_77, VAR_76);
                            unRel32(VAR_77, VAR_87, VAR_76, VAR_23, VAR_64, VAR_0);
                        }
                        if (VAR_74 && VAR_75) { /* COMMENT_38 */
                            Elf32_Rel *const VAR_88 = (Elf32_Rel *)VAR_86.subref(
                                ""bad Jmprel offset"", VAR_75, VAR_74);
                            unRel32(VAR_75, VAR_88, VAR_74, VAR_23, VAR_64, VAR_0);
                        }
                        /* COMMENT_39 */
                    }
                }
                if (VAR_0) {
                    VAR_0->seek(get_te32(&VAR_28->p_offset), VAR_14);
                    VAR_0->rewrite(VAR_23, VAR_6);
                }
            }
        }
    }

    /* COMMENT_40 */
    VAR_25.c_len = VAR_32;
    VAR_25.u_len = VAR_33;

    /* COMMENT_41 */
    if (VAR_33 != VAR_19)
        throwEOFException();

    /* COMMENT_42 */
    if (VAR_25.c_adler != VAR_34 || VAR_25.u_adler != VAR_35)
        throwChecksumError();
}",upx/77c914bce58aab9459029bed699f2bfb7ff2f90f/p_lx_elf.cpp/vul/after/3.json,"--- func_before
+++ func_after
@@ -100,13 +100,23 @@
                 xct_off = e_shoff;
             }
             // un-Relocate dynsym (DT_SYMTAB) which is below xct_off
-            dynseg = (Elf32_Dyn const *)ibuf.subref(
-                ""bad DYNAMIC"", get_te32(&dynhdr->p_offset), get_te32(&dynhdr->p_filesz));
+            unsigned dyn_offset = get_te32(&dynhdr->p_offset);
+            unsigned dyn_filesz = get_te32(&dynhdr->p_filesz);
+            if (orig_file_size < dyn_offset
+            || (orig_file_size - dyn_offset) < dyn_filesz) {
+                throwCantUnpack(""bad PT_DYNAMIC"");
+            }
+            dynseg = (Elf32_Dyn const *)ibuf.subref(""bad DYNAMIC"", dyn_offset, dyn_filesz);
             dynstr = (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);
             sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);
             if (sec_dynsym) {
                 unsigned const off_dynsym = get_te32(&sec_dynsym->sh_offset);
                 unsigned const sz_dynsym  = get_te32(&sec_dynsym->sh_size);
+                if (orig_file_size < sz_dynsym
+                ||  orig_file_size < off_dynsym
+                || (orig_file_size - off_dynsym) < sz_dynsym) {
+                    throwCantUnpack(""bad SHT_DYNSYM"");
+                }
                 Elf32_Sym *const sym0 = (Elf32_Sym *)ibuf.subref(
                     ""bad dynsym"", off_dynsym, sz_dynsym);
                 Elf32_Sym *sym = sym0;","{'deleted_lines': ['            dynseg = (Elf32_Dyn const *)ibuf.subref(', '                ""bad DYNAMIC"", get_te32(&dynhdr->p_offset), get_te32(&dynhdr->p_filesz));'], 'added_lines': ['            unsigned dyn_offset = get_te32(&dynhdr->p_offset);', '            unsigned dyn_filesz = get_te32(&dynhdr->p_filesz);', '            if (orig_file_size < dyn_offset', '            || (orig_file_size - dyn_offset) < dyn_filesz) {', '                throwCantUnpack(""bad PT_DYNAMIC"");', '            }', '            dynseg = (Elf32_Dyn const *)ibuf.subref(""bad DYNAMIC"", dyn_offset, dyn_filesz);', '                if (orig_file_size < sz_dynsym', '                ||  orig_file_size < off_dynsym', '                || (orig_file_size - off_dynsym) < sz_dynsym) {', '                    throwCantUnpack(""bad SHT_DYNSYM"");', '                }']}",True,An invalid memory address reference was discovered in the adjABS function in p_lx_elf.cpp in UPX 4.0.0 via a crafted Mach-O file.,5.5,MEDIUM,1,test,2020-07-25T16:28:02Z,3
CVE-2020-27798,['CWE-763'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,upx,"Check de-compressed SHT_SYMTAB

https://github.com/upx/upx/issues/396
	modified:   p_lx_elf.cpp",77c914bce58aab9459029bed699f2bfb7ff2f90f,https://github.com/upx/upx/commit/77c914bce58aab9459029bed699f2bfb7ff2f90f,src/p_lx_elf.cpp,PackLinuxElf32::adjABS,"int
PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
for (int j = 0; abs_symbol_names[j][0]; ++j) {
unsigned st_name = get_te32(&sym->st_name);
if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
sym->st_value += delta;
return 1;
}
}
return 0;
}","int
PackLinuxElf32::adjABS(Elf32_Sym *VAR_0, unsigned VAR_1)
{
for (int VAR_2 = 0; VAR_3[VAR_2][0]; ++VAR_2) {
unsigned VAR_4 = get_te32(&VAR_0->st_name);
if (!strcmp(VAR_3[VAR_2], get_str_name(VAR_4, (unsigned)-1))) {
VAR_0->st_value += VAR_1;
return 1;
}
}
return 0;
}",upx/77c914bce58aab9459029bed699f2bfb7ff2f90f/p_lx_elf.cpp/vul/before/2.json,"int
PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
    unsigned st_name = get_te32(&sym->st_name);
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}","int
PackLinuxElf32::adjABS(Elf32_Sym *VAR_0, unsigned VAR_1)
{
    unsigned VAR_2 = get_te32(&VAR_0->st_name);
    for (int VAR_3 = 0; VAR_4[VAR_3][0]; ++VAR_3) {
        if (!strcmp(VAR_4[VAR_3], get_str_name(VAR_2, (unsigned)-1))) {
            VAR_0->st_value += VAR_1;
            return 1;
        }
    }
    return 0;
}",upx/77c914bce58aab9459029bed699f2bfb7ff2f90f/p_lx_elf.cpp/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,8 +1,8 @@
 int
 PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
 {
+    unsigned st_name = get_te32(&sym->st_name);
     for (int j = 0; abs_symbol_names[j][0]; ++j) {
-        unsigned st_name = get_te32(&sym->st_name);
         if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
             sym->st_value += delta;
             return 1;","{'deleted_lines': ['        unsigned st_name = get_te32(&sym->st_name);'], 'added_lines': ['    unsigned st_name = get_te32(&sym->st_name);']}",True,An invalid memory address reference was discovered in the adjABS function in p_lx_elf.cpp in UPX 4.0.0 via a crafted Mach-O file.,5.5,MEDIUM,1,test,2020-07-25T16:28:02Z,3
CVE-2020-27798,['CWE-763'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,upx,"Check de-compressed SHT_SYMTAB

https://github.com/upx/upx/issues/396
	modified:   p_lx_elf.cpp",77c914bce58aab9459029bed699f2bfb7ff2f90f,https://github.com/upx/upx/commit/77c914bce58aab9459029bed699f2bfb7ff2f90f,src/p_lx_elf.cpp,PackLinuxElf64::unpack,"void PackLinuxElf64::unpack(OutputFile *fo)
{
if (e_phoff != sizeof(Elf64_Ehdr)) {        throwCantUnpack(""bad e_phoff"");
}
unsigned const c_phnum = get_te16(&ehdri.e_phnum);
upx_uint64_t old_data_off = 0;
upx_uint64_t old_data_len = 0;
upx_uint64_t old_dtinit = 0;
unsigned is_asl = 0;  
unsigned szb_info = sizeof(b_info);
{
upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);
if (e_entry < 0x401180
&&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { 
szb_info = 2*sizeof(unsigned);
}
}
fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);
fi->readx(&linfo, sizeof(linfo));
lsize = get_te16(&linfo.l_lsize);
if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {
throwCantUnpack(""l_info corrupted"");
}
p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));
unsigned orig_file_size = get_te32(&hbuf.p_filesize);
blocksize = get_te32(&hbuf.p_blocksize);
if ((u32_t)file_size > orig_file_size || blocksize > orig_file_size
|| !mem_size_valid(1, blocksize, OVERHEAD))
throwCantUnpack(""p_info corrupted"");
ibuf.alloc(blocksize + OVERHEAD);
b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));
fi->readx(&bhdr, szb_info);
ph.u_len = get_te32(&bhdr.sz_unc);
ph.c_len = get_te32(&bhdr.sz_cpr);
if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0
||  ph.u_len > orig_file_size)
throwCantUnpack(""b_info corrupted"");
ph.filter_cto = bhdr.b_cto8;
MemBuffer u(ph.u_len);
Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&u[0];
Elf64_Phdr const *phdr = 0;
if (ibuf.getSize() < ph.c_len)
throwCompressedDataViolation();
fi->readx(ibuf, ph.c_len);
decompress(ibuf, (upx_byte *)ehdr, false);
if (ehdr->e_type   !=ehdri.e_type
||  ehdr->e_machine!=ehdri.e_machine
||  ehdr->e_version!=ehdri.e_version
||  !( ehdr->e_flags==ehdri.e_flags
|| Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))
||  ehdr->e_ehsize !=ehdri.e_ehsize
||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {
throwCantUnpack(""ElfXX_Ehdr corrupted"");
}
fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);
unsigned const u_phnum = get_te16(&ehdr->e_phnum);
unsigned total_in = 0;
unsigned total_out = 0;
unsigned c_adler = upx_adler32(NULL, 0);
unsigned u_adler = upx_adler32(NULL, 0);
#define MAX_ELF_HDR 1024
if ((umin64(MAX_ELF_HDR, ph.u_len) - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {
throwCantUnpack(""bad compressed e_phnum"");
}
#undef MAX_ELF_HDR
Elf64_Phdr const *const dynhdr = elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);
bool const is_shlib = !!dynhdr;
if (is_shlib) {
unpackExtent(ph.u_len, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
fi->seek(0, SEEK_SET);
fi->readx(ibuf, get_te64(&dynhdr->p_offset) + get_te64(&dynhdr->p_filesz));
overlay_offset -= sizeof(linfo);
xct_off = overlay_offset;
e_shoff = get_te64(&ehdri.e_shoff);
ibuf.subref(""bad .e_shoff %#lx for %#lx"", e_shoff, sizeof(Elf64_Shdr) * e_shnum);
if (e_shoff && e_shnum) {             shdri = (Elf64_Shdr  *)ibuf.subref(
""bad Shdr table"", e_shoff, sizeof(Elf64_Shdr)*e_shnum);
upx_uint64_t xct_off2 = get_te64(&shdri->sh_offset);
if (e_shoff == xct_off2) {
xct_off = e_shoff;
}
dynseg = (Elf64_Dyn const *)ibuf.subref(
""bad DYNAMIC"", get_te64(&dynhdr->p_offset), get_te64(&dynhdr->p_filesz));
dynstr = (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);
sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);
if (sec_dynsym) {
upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);
upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);
if ((upx_uint64_t)file_size < sz_dynsym
||  (upx_uint64_t)file_size < off_dynsym
|| ((upx_uint64_t)file_size - off_dynsym) < sz_dynsym) {
throwCantUnpack(""bad SHT_DYNSYM"");
}
Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(
""bad dynsym"", off_dynsym, sz_dynsym);
Elf64_Sym *sym = sym0;
for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {
upx_uint64_t symval = get_te64(&sym->st_value);
unsigned symsec = get_te16(&sym->st_shndx);
if (Elf64_Sym::SHN_UNDEF != symsec
&&  Elf64_Sym::SHN_ABS   != symsec
&&  xct_off <= symval) {
set_te64(&sym->st_value, symval - asl_delta);
}
if (Elf64_Sym::SHN_ABS == symsec && xct_off <= symval) {
adjABS(sym, 0u - asl_delta);
}
}
}
}
if (fo) {
fo->write(ibuf + ph.u_len, xct_off - ph.u_len);
}
int n_ptload = 0;
phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);
for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {
old_data_off = get_te64(&phdr->p_offset);
old_data_len = get_te64(&phdr->p_filesz);
break;
}
}
total_in  = xct_off;
total_out = xct_off;
ph.u_len = 0;
fi->seek(sizeof(linfo) + overlay_offset + sizeof(hbuf) + szb_info + ph.c_len, SEEK_SET);
phdr = (Elf64_Phdr *) (void *) (1+ ehdr);
for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD64==get_te32(&phdr->p_type)) {
ph.u_len = get_te64(&phdr->p_filesz) - xct_off;
break;
}
}
unpackExtent(ph.u_len, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
}
else {                  bool first_PF_X = true;
phdr = (Elf64_Phdr *) (void *) (1+ ehdr);          for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD64==get_te32(&phdr->p_type)) {
unsigned const filesz = get_te64(&phdr->p_filesz);
unsigned const offset = get_te64(&phdr->p_offset);
if (fo)
fo->seek(offset, SEEK_SET);
if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {
unpackExtent(filesz, fo, total_in, total_out,
c_adler, u_adler, first_PF_X, szb_info);
first_PF_X = false;
}
else {
unpackExtent(filesz, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
}
}
}
}
phdr = phdri;
load_va = 0;
for (unsigned j=0; j < c_phnum; ++j) {
if (PT_LOAD64==get_te32(&phdr->p_type)) {
load_va = get_te64(&phdr->p_vaddr);
break;
}
}
if (0x1000==get_te64(&phdri[0].p_filesz)      &&  0==get_te64(&phdri[1].p_offset)
&&  0==get_te64(&phdri[0].p_offset)
&&     get_te64(&phdri[1].p_filesz) == get_te64(&phdri[1].p_memsz)) {
fi->seek(up4(get_te64(&phdr[1].p_memsz)), SEEK_SET);      }
else if (is_shlib
||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +
ph.getPackHeaderSize() + sizeof(overlay_offset))
< up4(file_size)) {
funpad4(fi);          unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));
if (0==old_dtinit) {
old_dtinit = get_te32(&d_info[2 + (0==d_info[0])]);
is_asl = 1u& get_te32(&d_info[0 + (0==d_info[0])]);
}
fi->seek(lsize - sizeof(d_info), SEEK_CUR);
}
phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];
upx_uint64_t hi_offset(0);
for (unsigned j = 0; j < u_phnum; ++j) {
if (PT_LOAD64==phdr[j].p_type
&&  hi_offset < phdr[j].p_offset)
hi_offset = phdr[j].p_offset;
}
for (unsigned j = 0; j < u_phnum; ++j) {
unsigned const size = find_LOAD_gap(phdr, j, u_phnum);
if (size) {
unsigned const where = get_te64(&phdr[j].p_offset) +
get_te64(&phdr[j].p_filesz);
if (fo)
fo->seek(where, SEEK_SET);
unpackExtent(size, fo, total_in, total_out,
c_adler, u_adler, false, szb_info,
(phdr[j].p_offset != hi_offset));
}
}
fi->readx(&bhdr, szb_info);
unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);
if (sz_unc == 0) {                 unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);
if (sz_cpr != UPX_MAGIC_LE32)              throwCompressedDataViolation();
}
else {         throwCompressedDataViolation();
}
if (is_shlib) {
int n_ptload = 0;
upx_uint64_t load_off = 0;
phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];
for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {
load_off = get_te64(&phdr->p_offset);
load_va = get_te64(&phdr->p_vaddr);
fi->seek(old_data_off, SEEK_SET);
fi->readx(ibuf, old_data_len);
total_in  += old_data_len;
total_out += old_data_len;
Elf64_Phdr const *udynhdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];
for (unsigned j3= 0; j3 < u_phnum; ++j3, ++udynhdr)
if (Elf64_Phdr::PT_DYNAMIC==get_te32(&udynhdr->p_type)) {
upx_uint64_t dt_pltrelsz(0), dt_jmprel(0);
upx_uint64_t dt_relasz(0), dt_rela(0);
upx_uint64_t const dyn_len = get_te64(&udynhdr->p_filesz);
upx_uint64_t const dyn_off = get_te64(&udynhdr->p_offset);
if ((unsigned long)file_size < (dyn_len + dyn_off)) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad PT_DYNAMIC .p_filesz %#lx"", (long unsigned)dyn_len);
throwCantUnpack(msg);
}
if (dyn_off < load_off) {
continue;                      }
Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +
(dyn_off - load_off));
dynseg = dyn; invert_pt_dynamic(dynseg, get_te64(&udynhdr->p_filesz));
for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {
upx_uint64_t const tag = get_te64(&dyn->d_tag);
upx_uint64_t       val = get_te64(&dyn->d_val);
if (is_asl) switch (tag) {
case Elf64_Dyn::DT_RELASZ:   { dt_relasz   = val; } break;
case Elf64_Dyn::DT_RELA:     { dt_rela     = val; } break;
case Elf64_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;
case Elf64_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;
case Elf64_Dyn::DT_PLTGOT:
case Elf64_Dyn::DT_PREINIT_ARRAY:
case Elf64_Dyn::DT_INIT_ARRAY:
case Elf64_Dyn::DT_FINI_ARRAY:
case Elf64_Dyn::DT_FINI: {
set_te64(&dyn->d_val, val - asl_delta);
}; break;
}                         if (upx_dt_init == tag) {
if (Elf64_Dyn::DT_INIT == tag) {
set_te64(&dyn->d_val, old_dtinit);
if (!old_dtinit) {                                     dyn->d_tag = Elf64_Dyn::DT_NULL;
dyn->d_val = 0;
}
}
else if (Elf64_Dyn::DT_INIT_ARRAY    == tag
||       Elf64_Dyn::DT_PREINIT_ARRAY == tag) {
if (val < load_va || (long unsigned)file_size < (long unsigned)val) {
char msg[50]; snprintf(msg, sizeof(msg),
""Bad Dynamic tag %#lx %#lx"",
(long unsigned)tag, (long unsigned)val);
throwCantUnpack(msg);
}
set_te64(&ibuf[val - load_va], old_dtinit
+ (is_asl ? asl_delta : 0));                              }
}
}
if (is_asl) {
lowmem.alloc(xct_off);
fi->seek(0, SEEK_SET);
fi->read(lowmem, xct_off);                          if (dt_relasz && dt_rela) {
Elf64_Rela *const rela0 = (Elf64_Rela *)lowmem.subref(
""bad Rela offset"", dt_rela, dt_relasz);
unRela64(dt_rela, rela0, dt_relasz, ibuf, load_va, old_dtinit, fo);
}
if (dt_pltrelsz && dt_jmprel) {                             Elf64_Rela *const jmp0 = (Elf64_Rela *)lowmem.subref(
""bad Jmprel offset"", dt_jmprel, dt_pltrelsz);
unRela64(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, old_dtinit, fo);
}
}
}
if (fo) {
fo->seek(get_te64(&phdr->p_offset), SEEK_SET);
fo->rewrite(ibuf, old_data_len);
}
}
}
}
ph.c_len = total_in;
ph.u_len = total_out;
if (total_out != orig_file_size)
throwEOFException();
if (ph.c_adler != c_adler || ph.u_adler != u_adler)
throwChecksumError();
}","void PackLinuxElf64::unpack(OutputFile *VAR_0)
{
if (VAR_1 != sizeof(VAR_2)) {
throwCantUnpack(""bad e_phoff"");
}
unsigned const VAR_3 = get_te16(&VAR_4.e_phnum);
upx_uint64_t VAR_5 = 0;
upx_uint64_t VAR_6 = 0;
upx_uint64_t VAR_7 = 0;
unsigned VAR_8 = 0;  
unsigned VAR_9 = sizeof(VAR_10);
{
upx_uint64_t const VAR_11 = get_te64(&VAR_4.e_entry);
if (VAR_11 < 0x401180
&&  get_te16(&VAR_4.e_machine)==Elf64_Ehdr::EM_386) { 
VAR_9 = 2*sizeof(unsigned);
}
}
VAR_12->seek(VAR_13 - sizeof(VAR_14), VAR_15);
VAR_12->readx(&VAR_16, sizeof(VAR_16));
VAR_17 = get_te16(&VAR_16.l_lsize);
if (VAR_18 != get_le32(&VAR_16.l_magic)) {
throwCantUnpack(""l_info corrupted"");
}
p_info VAR_19;  VAR_12->readx(&VAR_19, sizeof(VAR_19));
unsigned VAR_20 = get_te32(&VAR_19.p_filesize);
VAR_21 = get_te32(&VAR_19.p_blocksize);
if ((u32_t)VAR_22 > VAR_20 || VAR_21 > VAR_20
|| !mem_size_valid(1, VAR_21, VAR_23))
throwCantUnpack(""p_info corrupted"");
VAR_24.alloc(VAR_21 + VAR_23);
b_info VAR_25; memset(&VAR_25, 0, sizeof(VAR_25));
VAR_12->readx(&VAR_25, VAR_9);
VAR_26.u_len = get_te32(&VAR_25.sz_unc);
VAR_26.c_len = get_te32(&VAR_25.sz_cpr);
if (VAR_26.c_len > (unsigned)VAR_22 || VAR_26.c_len == 0 || VAR_26.u_len == 0
||  VAR_26.u_len > VAR_20)
throwCantUnpack(""b_info corrupted"");
VAR_26.filter_cto = VAR_25.b_cto8;
MemBuffer VAR_27(VAR_26.u_len);
Elf64_Ehdr *const VAR_28 = (Elf64_Ehdr *)&VAR_27[0];
Elf64_Phdr const *VAR_29 = 0;
if (VAR_24.getSize() < VAR_26.c_len)
throwCompressedDataViolation();
VAR_12->readx(VAR_24, VAR_26.c_len);
decompress(VAR_24, (upx_byte *)VAR_28, false);
if (VAR_28->e_type   !=VAR_4.e_type
||  VAR_28->e_machine!=VAR_4.e_machine
||  VAR_28->e_version!=VAR_4.e_version
||  !( VAR_28->e_flags==VAR_4.e_flags
|| Elf64_Ehdr::EM_PPC64 == get_te16(&VAR_4.e_machine))
||  VAR_28->e_ehsize !=VAR_4.e_ehsize
||  memcmp(VAR_28->e_ident, VAR_4.e_ident, Elf64_Ehdr::EI_OSABI)) {
throwCantUnpack(""ElfXX_Ehdr corrupted"");
}
VAR_12->seek(- (VAR_30) (VAR_9 + VAR_26.c_len), VAR_31);
unsigned const VAR_32 = get_te16(&VAR_28->e_phnum);
unsigned VAR_33 = 0;
unsigned VAR_34 = 0;
unsigned VAR_35 = upx_adler32(NULL, 0);
unsigned VAR_36 = upx_adler32(NULL, 0);
#define VAR_37 1024
if ((umin64(VAR_37, VAR_26.u_len) - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < VAR_32) {
throwCantUnpack(""bad compressed e_phnum"");
}
#undef MAX_ELF_HDR
Elf64_Phdr const *const VAR_38 = elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, VAR_39, VAR_3);
bool const VAR_40 = !!VAR_38;
if (VAR_40) {
unpackExtent(VAR_26.u_len, VAR_0, VAR_33, VAR_34,
VAR_35, VAR_36, false, VAR_9);
VAR_12->seek(0, VAR_15);
VAR_12->readx(VAR_24, get_te64(&VAR_38->p_offset) + get_te64(&VAR_38->p_filesz));
VAR_13 -= sizeof(VAR_16);
VAR_41 = VAR_13;
VAR_42 = get_te64(&VAR_4.e_shoff);
VAR_24.subref(""bad .e_shoff %#lx for %#lx"", VAR_42, sizeof(VAR_43) * VAR_44);
if (VAR_42 && VAR_44) { 
VAR_45 = (Elf64_Shdr  *)VAR_24.subref(
""bad Shdr table"", VAR_42, sizeof(Elf64_Shdr)*VAR_44);
upx_uint64_t VAR_46 = get_te64(&VAR_45->sh_offset);
if (VAR_42 == VAR_46) {
VAR_41 = VAR_42;
}
VAR_47 = (Elf64_Dyn const *)VAR_24.subref(
""bad DYNAMIC"", get_te64(&VAR_38->p_offset), get_te64(&VAR_38->p_filesz));
VAR_48 = (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);
VAR_49 = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);
if (VAR_49) {
upx_uint64_t const VAR_50 = get_te64(&VAR_49->sh_offset);
upx_uint64_t const VAR_51  = get_te64(&VAR_49->sh_size);
if ((upx_uint64_t)VAR_22 < VAR_51
||  (upx_uint64_t)VAR_22 < VAR_50
|| ((upx_uint64_t)VAR_22 - VAR_50) < VAR_51) {
throwCantUnpack(""bad SHT_DYNSYM"");
}
Elf64_Sym *const VAR_52 = (Elf64_Sym *)VAR_24.subref(
""bad dynsym"", VAR_50, VAR_51);
Elf64_Sym *VAR_53 = VAR_52;
for (int VAR_54 = VAR_51 / sizeof(Elf64_Sym); --VAR_54>=0; ++VAR_53) {
upx_uint64_t VAR_55 = get_te64(&VAR_53->st_value);
unsigned VAR_56 = get_te16(&VAR_53->st_shndx);
if (Elf64_Sym::SHN_UNDEF != VAR_56
&&  Elf64_Sym::SHN_ABS   != VAR_56
&&  VAR_41 <= VAR_55) {
set_te64(&VAR_53->st_value, VAR_55 - VAR_57);
}
if (Elf64_Sym::SHN_ABS == VAR_56 && VAR_41 <= VAR_55) {
adjABS(VAR_53, 0u - VAR_57);
}
}
}
}
if (VAR_0) {
VAR_0->write(VAR_24 + VAR_26.u_len, VAR_41 - VAR_26.u_len);
}
int VAR_58 = 0;
VAR_29 = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)VAR_24);
for (unsigned VAR_54=0; VAR_54 < VAR_32; ++VAR_29, ++VAR_54) {
if (VAR_59==get_te32(&VAR_29->p_type) && 0!=VAR_58++) {
VAR_5 = get_te64(&VAR_29->p_offset);
VAR_6 = get_te64(&VAR_29->p_filesz);
break;
}
}
VAR_33  = VAR_41;
VAR_34 = VAR_41;
VAR_26.u_len = 0;
VAR_12->seek(sizeof(VAR_16) + VAR_13 + sizeof(VAR_19) + VAR_9 + VAR_26.c_len, VAR_15);
VAR_29 = (Elf64_Phdr *) (void *) (1+ VAR_28);
for (unsigned VAR_54=0; VAR_54 < VAR_32; ++VAR_29, ++VAR_54) {
if (VAR_59==get_te32(&VAR_29->p_type)) {
VAR_26.u_len = get_te64(&VAR_29->p_filesz) - VAR_41;
break;
}
}
unpackExtent(VAR_26.u_len, VAR_0, VAR_33, VAR_34,
VAR_35, VAR_36, false, VAR_9);
}
else {  
bool VAR_60 = true;
VAR_29 = (Elf64_Phdr *) (void *) (1+ VAR_28);  
for (unsigned VAR_54=0; VAR_54 < VAR_32; ++VAR_29, ++VAR_54) {
if (VAR_59==get_te32(&VAR_29->p_type)) {
unsigned const VAR_61 = get_te64(&VAR_29->p_filesz);
unsigned const VAR_62 = get_te64(&VAR_29->p_offset);
if (VAR_0)
VAR_0->seek(VAR_62, VAR_15);
if (Elf64_Phdr::PF_X & get_te32(&VAR_29->p_flags)) {
unpackExtent(VAR_61, VAR_0, VAR_33, VAR_34,
VAR_35, VAR_36, VAR_60, VAR_9);
VAR_60 = false;
}
else {
unpackExtent(VAR_61, VAR_0, VAR_33, VAR_34,
VAR_35, VAR_36, false, VAR_9);
}
}
}
}
VAR_29 = VAR_39;
VAR_63 = 0;
for (unsigned VAR_54=0; VAR_54 < VAR_3; ++VAR_54) {
if (VAR_59==get_te32(&VAR_29->p_type)) {
VAR_63 = get_te64(&VAR_29->p_vaddr);
break;
}
}
if (0x1000==get_te64(&VAR_39[0].p_filesz)  
&&  0==get_te64(&VAR_39[1].p_offset)
&&  0==get_te64(&VAR_39[0].p_offset)
&&     get_te64(&VAR_39[1].p_filesz) == get_te64(&VAR_39[1].p_memsz)) {
VAR_12->seek(up4(get_te64(&VAR_29[1].p_memsz)), VAR_15);  
}
else if (VAR_40
||  ((unsigned)(get_te64(&VAR_4.e_entry) - VAR_63) + up4(VAR_17) +
VAR_26.getPackHeaderSize() + sizeof(VAR_13))
< up4(VAR_22)) {
funpad4(VAR_12);  
unsigned VAR_64[6]; VAR_12->readx(VAR_64, sizeof(VAR_64));
if (0==VAR_7) {
VAR_7 = get_te32(&VAR_64[2 + (0==VAR_64[0])]);
VAR_8 = 1u& get_te32(&VAR_64[0 + (0==VAR_64[0])]);
}
VAR_12->seek(VAR_17 - sizeof(VAR_64), VAR_31);
}
VAR_29 = (Elf64_Phdr *)&VAR_27[sizeof(*VAR_28)];
upx_uint64_t VAR_65(0);
for (unsigned VAR_54 = 0; VAR_54 < VAR_32; ++VAR_54) {
if (VAR_59==VAR_29[VAR_54].p_type
&&  VAR_65 < VAR_29[VAR_54].p_offset)
VAR_65 = VAR_29[VAR_54].p_offset;
}
for (unsigned VAR_54 = 0; VAR_54 < VAR_32; ++VAR_54) {
unsigned const VAR_66 = find_LOAD_gap(VAR_29, VAR_54, VAR_32);
if (VAR_66) {
unsigned const VAR_67 = get_te64(&VAR_29[VAR_54].p_offset) +
get_te64(&VAR_29[VAR_54].p_filesz);
if (VAR_0)
VAR_0->seek(VAR_67, VAR_15);
unpackExtent(VAR_66, VAR_0, VAR_33, VAR_34,
VAR_35, VAR_36, false, VAR_9,
(VAR_29[VAR_54].p_offset != VAR_65));
}
}
VAR_12->readx(&VAR_25, VAR_9);
unsigned const VAR_68 = VAR_26.u_len = get_te32(&VAR_25.sz_unc);
if (VAR_68 == 0) { 
unsigned const VAR_69 = get_le32(&VAR_25.sz_cpr);
if (VAR_69 != VAR_18)  
throwCompressedDataViolation();
}
else { 
throwCompressedDataViolation();
}
if (VAR_40) {
int VAR_58 = 0;
upx_uint64_t VAR_70 = 0;
VAR_29 = (Elf64_Phdr *)&VAR_27[sizeof(*VAR_28)];
for (unsigned VAR_54= 0; VAR_54 < VAR_32; ++VAR_54, ++VAR_29) {
if (VAR_59==get_te32(&VAR_29->p_type) && 0!=VAR_58++) {
VAR_70 = get_te64(&VAR_29->p_offset);
VAR_63 = get_te64(&VAR_29->p_vaddr);
VAR_12->seek(VAR_5, VAR_15);
VAR_12->readx(VAR_24, VAR_6);
VAR_33  += VAR_6;
VAR_34 += VAR_6;
Elf64_Phdr const *VAR_71 = (Elf64_Phdr *)&VAR_27[sizeof(*VAR_28)];
for (unsigned VAR_72= 0; VAR_72 < VAR_32; ++VAR_72, ++VAR_71)
if (Elf64_Phdr::PT_DYNAMIC==get_te32(&VAR_71->p_type)) {
upx_uint64_t VAR_73(0), VAR_74(0);
upx_uint64_t VAR_75(0), VAR_76(0);
upx_uint64_t const VAR_77 = get_te64(&VAR_71->p_filesz);
upx_uint64_t const VAR_78 = get_te64(&VAR_71->p_offset);
if ((unsigned long)VAR_22 < (VAR_77 + VAR_78)) {
char VAR_79[50]; snprintf(VAR_79, sizeof(VAR_79),
""bad PT_DYNAMIC .p_filesz %#lx"", (long unsigned)VAR_77);
throwCantUnpack(VAR_79);
}
if (VAR_78 < VAR_70) {
continue;  
}
Elf64_Dyn *VAR_80 = (Elf64_Dyn *)((unsigned char *)VAR_24 +
(VAR_78 - VAR_70));
VAR_47 = VAR_80; invert_pt_dynamic(VAR_47, get_te64(&VAR_71->p_filesz));
for (unsigned VAR_81= 0; VAR_81 < VAR_77; ++VAR_80, VAR_81 += sizeof(*VAR_80)) {
upx_uint64_t const VAR_82 = get_te64(&VAR_80->d_tag);
upx_uint64_t       VAR_83 = get_te64(&VAR_80->d_val);
if (VAR_8) switch (VAR_82) {
case Elf64_Dyn::DT_RELASZ:   { VAR_75   = VAR_83; } break;
case Elf64_Dyn::DT_RELA:     { VAR_76     = VAR_83; } break;
case Elf64_Dyn::DT_PLTRELSZ: { VAR_73 = VAR_83; } break;
case Elf64_Dyn::DT_JMPREL:   { VAR_74   = VAR_83; } break;
case Elf64_Dyn::DT_PLTGOT:
case Elf64_Dyn::DT_PREINIT_ARRAY:
case Elf64_Dyn::DT_INIT_ARRAY:
case Elf64_Dyn::DT_FINI_ARRAY:
case Elf64_Dyn::DT_FINI: {
set_te64(&VAR_80->d_val, VAR_83 - VAR_57);
}; break;
} 
if (VAR_84 == VAR_82) {
if (Elf64_Dyn::DT_INIT == VAR_82) {
set_te64(&VAR_80->d_val, VAR_7);
if (!VAR_7) { 
VAR_80->d_tag = Elf64_Dyn::DT_NULL;
VAR_80->d_val = 0;
}
}
else if (Elf64_Dyn::DT_INIT_ARRAY    == VAR_82
||       Elf64_Dyn::DT_PREINIT_ARRAY == VAR_82) {
if (VAR_83 < VAR_63 || (long unsigned)VAR_22 < (long unsigned)VAR_83) {
char VAR_79[50]; snprintf(VAR_79, sizeof(VAR_79),
""Bad Dynamic tag %#lx %#lx"",
(long unsigned)VAR_82, (long unsigned)VAR_83);
throwCantUnpack(VAR_79);
}
set_te64(&VAR_24[VAR_83 - VAR_63], VAR_7
+ (VAR_8 ? VAR_57 : 0));  
}
}
}
if (VAR_8) {
VAR_85.alloc(VAR_41);
VAR_12->seek(0, VAR_15);
VAR_12->read(VAR_85, VAR_41);  
if (VAR_75 && VAR_76) {
Elf64_Rela *const VAR_86 = (Elf64_Rela *)VAR_85.subref(
""bad Rela offset"", VAR_76, VAR_75);
unRela64(VAR_76, VAR_86, VAR_75, VAR_24, VAR_63, VAR_7, VAR_0);
}
if (VAR_73 && VAR_74) { 
Elf64_Rela *const VAR_87 = (Elf64_Rela *)VAR_85.subref(
""bad Jmprel offset"", VAR_74, VAR_73);
unRela64(VAR_74, VAR_87, VAR_73, VAR_24, VAR_63, VAR_7, VAR_0);
}
}
}
if (VAR_0) {
VAR_0->seek(get_te64(&VAR_29->p_offset), VAR_15);
VAR_0->rewrite(VAR_24, VAR_6);
}
}
}
}
VAR_26.c_len = VAR_33;
VAR_26.u_len = VAR_34;
if (VAR_34 != VAR_20)
throwEOFException();
if (VAR_26.c_adler != VAR_35 || VAR_26.u_adler != VAR_36)
throwChecksumError();
}",upx/77c914bce58aab9459029bed699f2bfb7ff2f90f/p_lx_elf.cpp/vul/before/1.json,"void PackLinuxElf64::unpack(OutputFile *fo)
{
    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr
        throwCantUnpack(""bad e_phoff"");
    }
    unsigned const c_phnum = get_te16(&ehdri.e_phnum);
    upx_uint64_t old_data_off = 0;
    upx_uint64_t old_data_len = 0;
    upx_uint64_t old_dtinit = 0;
    unsigned is_asl = 0;  // is Android Shared Library

    unsigned szb_info = sizeof(b_info);
    {
        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);
        if (e_entry < 0x401180
        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */
            szb_info = 2*sizeof(unsigned);
        }
    }

    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);
    fi->readx(&linfo, sizeof(linfo));
    lsize = get_te16(&linfo.l_lsize);
    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {
        throwCantUnpack(""l_info corrupted"");
    }
    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));
    unsigned orig_file_size = get_te32(&hbuf.p_filesize);
    blocksize = get_te32(&hbuf.p_blocksize);
    if ((u32_t)file_size > orig_file_size || blocksize > orig_file_size
        || !mem_size_valid(1, blocksize, OVERHEAD))
        throwCantUnpack(""p_info corrupted"");

    ibuf.alloc(blocksize + OVERHEAD);
    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));
    fi->readx(&bhdr, szb_info);
    ph.u_len = get_te32(&bhdr.sz_unc);
    ph.c_len = get_te32(&bhdr.sz_cpr);
    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0
    ||  ph.u_len > orig_file_size)
        throwCantUnpack(""b_info corrupted"");
    ph.filter_cto = bhdr.b_cto8;

    MemBuffer u(ph.u_len);
    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&u[0];
    Elf64_Phdr const *phdr = 0;

    // Uncompress Ehdr and Phdrs.
    if (ibuf.getSize() < ph.c_len)
        throwCompressedDataViolation();
    fi->readx(ibuf, ph.c_len);
    decompress(ibuf, (upx_byte *)ehdr, false);
    if (ehdr->e_type   !=ehdri.e_type
    ||  ehdr->e_machine!=ehdri.e_machine
    ||  ehdr->e_version!=ehdri.e_version
        // less strict for EM_PPC64 to workaround earlier bug
    ||  !( ehdr->e_flags==ehdri.e_flags
        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))
    ||  ehdr->e_ehsize !=ehdri.e_ehsize
        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION
    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {
        throwCantUnpack(""ElfXX_Ehdr corrupted"");
    }
    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);

    unsigned const u_phnum = get_te16(&ehdr->e_phnum);
    unsigned total_in = 0;
    unsigned total_out = 0;
    unsigned c_adler = upx_adler32(NULL, 0);
    unsigned u_adler = upx_adler32(NULL, 0);
#define MAX_ELF_HDR 1024
    if ((umin64(MAX_ELF_HDR, ph.u_len) - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {
        throwCantUnpack(""bad compressed e_phnum"");
    }
#undef MAX_ELF_HDR

    // Packed ET_EXE has no PT_DYNAMIC.
    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.
    Elf64_Phdr const *const dynhdr = elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);
    bool const is_shlib = !!dynhdr;
    if (is_shlib) {
        // Unpack and output the Ehdr and Phdrs for real.
        // This depends on position within input file fi.
        unpackExtent(ph.u_len, fo, total_in, total_out,
            c_adler, u_adler, false, szb_info);

        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)
        fi->seek(0, SEEK_SET);
        fi->readx(ibuf, get_te64(&dynhdr->p_offset) + get_te64(&dynhdr->p_filesz));
        overlay_offset -= sizeof(linfo);
        xct_off = overlay_offset;
        e_shoff = get_te64(&ehdri.e_shoff);
        ibuf.subref(""bad .e_shoff %#lx for %#lx"", e_shoff, sizeof(Elf64_Shdr) * e_shnum);
        if (e_shoff && e_shnum) { // --android-shlib
            shdri = (Elf64_Shdr /*const*/ *)ibuf.subref(
                ""bad Shdr table"", e_shoff, sizeof(Elf64_Shdr)*e_shnum);
            upx_uint64_t xct_off2 = get_te64(&shdri->sh_offset);
            if (e_shoff == xct_off2) {
                xct_off = e_shoff;
            }
            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off
            upx_uint64_t dyn_offset = get_te64(&dynhdr->p_offset);
            upx_uint64_t dyn_filesz = get_te64(&dynhdr->p_filesz);
            if (orig_file_size < dyn_offset
            || (orig_file_size - dyn_offset) < dyn_filesz) {
                throwCantUnpack(""bad PT_DYNAMIC"");
            }
            dynseg = (Elf64_Dyn const *)ibuf.subref(""bad DYNAMIC"", dyn_offset, dyn_filesz);
            dynstr = (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);
            sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);
            if (sec_dynsym) {
                upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);
                upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);
                if (orig_file_size < sz_dynsym
                ||  orig_file_size < off_dynsym
                || (orig_file_size - off_dynsym) < sz_dynsym) {
                    throwCantUnpack(""bad SHT_DYNSYM"");
                }
                Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(
                    ""bad dynsym"", off_dynsym, sz_dynsym);
                Elf64_Sym *sym = sym0;
                for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {
                    upx_uint64_t symval = get_te64(&sym->st_value);
                    unsigned symsec = get_te16(&sym->st_shndx);
                    if (Elf64_Sym::SHN_UNDEF != symsec
                    &&  Elf64_Sym::SHN_ABS   != symsec
                    &&  xct_off <= symval) {
                        set_te64(&sym->st_value, symval - asl_delta);
                    }
                    if (Elf64_Sym::SHN_ABS == symsec && xct_off <= symval) {
                        adjABS(sym, 0u - asl_delta);
                    }
                }
            }
        }
        if (fo) {
            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);
        }
        // Search the Phdrs of compressed
        int n_ptload = 0;
        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {
                old_data_off = get_te64(&phdr->p_offset);
                old_data_len = get_te64(&phdr->p_filesz);
                break;
            }
        }

        total_in  = xct_off;
        total_out = xct_off;
        ph.u_len = 0;
        // Position the input for next unpackExtent.
        fi->seek(sizeof(linfo) + overlay_offset + sizeof(hbuf) + szb_info + ph.c_len, SEEK_SET);

        // Decompress and unfilter the tail of first PT_LOAD.
        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD64==get_te32(&phdr->p_type)) {
                ph.u_len = get_te64(&phdr->p_filesz) - xct_off;
                break;
            }
        }
        unpackExtent(ph.u_len, fo, total_in, total_out,
            c_adler, u_adler, false, szb_info);
    }
    else {  // main executable
        // Decompress each PT_LOAD.
        bool first_PF_X = true;
        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD64==get_te32(&phdr->p_type)) {
                unsigned const filesz = get_te64(&phdr->p_filesz);
                unsigned const offset = get_te64(&phdr->p_offset);
                if (fo)
                    fo->seek(offset, SEEK_SET);
                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {
                    unpackExtent(filesz, fo, total_in, total_out,
                        c_adler, u_adler, first_PF_X, szb_info);
                    first_PF_X = false;
                }
                else {
                    unpackExtent(filesz, fo, total_in, total_out,
                        c_adler, u_adler, false, szb_info);
                }
            }
        }
    }
    phdr = phdri;
    load_va = 0;
    for (unsigned j=0; j < c_phnum; ++j) {
        if (PT_LOAD64==get_te32(&phdr->p_type)) {
            load_va = get_te64(&phdr->p_vaddr);
            break;
        }
    }
    if (0x1000==get_te64(&phdri[0].p_filesz)  // detect C_BASE style
    &&  0==get_te64(&phdri[1].p_offset)
    &&  0==get_te64(&phdri[0].p_offset)
    &&     get_te64(&phdri[1].p_filesz) == get_te64(&phdri[1].p_memsz)) {
        fi->seek(up4(get_te64(&phdr[1].p_memsz)), SEEK_SET);  // past the loader
    }
    else if (is_shlib
    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +
                ph.getPackHeaderSize() + sizeof(overlay_offset))
            < up4(file_size)) {
        // Loader is not at end; skip past it.
        funpad4(fi);  // MATCH01
        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));
        if (0==old_dtinit) {
            old_dtinit = get_te32(&d_info[2 + (0==d_info[0])]);
            is_asl = 1u& get_te32(&d_info[0 + (0==d_info[0])]);
        }
        fi->seek(lsize - sizeof(d_info), SEEK_CUR);
    }

    // The gaps between PT_LOAD and after last PT_LOAD
    phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];
    upx_uint64_t hi_offset(0);
    for (unsigned j = 0; j < u_phnum; ++j) {
        if (PT_LOAD64==phdr[j].p_type
        &&  hi_offset < phdr[j].p_offset)
            hi_offset = phdr[j].p_offset;
    }
    for (unsigned j = 0; j < u_phnum; ++j) {
        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);
        if (size) {
            unsigned const where = get_te64(&phdr[j].p_offset) +
                                   get_te64(&phdr[j].p_filesz);
            if (fo)
                fo->seek(where, SEEK_SET);
            unpackExtent(size, fo, total_in, total_out,
                c_adler, u_adler, false, szb_info,
                (phdr[j].p_offset != hi_offset));
        }
    }

    // check for end-of-file
    fi->readx(&bhdr, szb_info);
    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);

    if (sz_unc == 0) { // uncompressed size 0 -> EOF
        // note: magic is always stored le32
        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);
        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic
            throwCompressedDataViolation();
    }
    else { // extra bytes after end?
        throwCompressedDataViolation();
    }

    if (is_shlib) {
        // DT_INIT must be restored.
        // If android_shlib, then the asl_delta relocations must be un-done.
        int n_ptload = 0;
        upx_uint64_t load_off = 0;
        phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];
        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {
                load_off = get_te64(&phdr->p_offset);
                load_va = get_te64(&phdr->p_vaddr);
                fi->seek(old_data_off, SEEK_SET);
                fi->readx(ibuf, old_data_len);
                total_in  += old_data_len;
                total_out += old_data_len;

                Elf64_Phdr const *udynhdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];
                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++udynhdr)
                if (Elf64_Phdr::PT_DYNAMIC==get_te32(&udynhdr->p_type)) {
                    upx_uint64_t dt_pltrelsz(0), dt_jmprel(0);
                    upx_uint64_t dt_relasz(0), dt_rela(0);
                    upx_uint64_t const dyn_len = get_te64(&udynhdr->p_filesz);
                    upx_uint64_t const dyn_off = get_te64(&udynhdr->p_offset);
                    if ((unsigned long)file_size < (dyn_len + dyn_off)) {
                        char msg[50]; snprintf(msg, sizeof(msg),
                                ""bad PT_DYNAMIC .p_filesz %#lx"", (long unsigned)dyn_len);
                        throwCantUnpack(msg);
                    }
                    if (dyn_off < load_off) {
                        continue;  // Oops.  Not really is_shlib ?  [built by 'rust' ?]
                    }
                    Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +
                        (dyn_off - load_off));
                    dynseg = dyn; invert_pt_dynamic(dynseg, get_te64(&udynhdr->p_filesz));
                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {
                        upx_uint64_t const tag = get_te64(&dyn->d_tag);
                        upx_uint64_t       val = get_te64(&dyn->d_val);
                        if (is_asl) switch (tag) {
                        case Elf64_Dyn::DT_RELASZ:   { dt_relasz   = val; } break;
                        case Elf64_Dyn::DT_RELA:     { dt_rela     = val; } break;
                        case Elf64_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;
                        case Elf64_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;

                        case Elf64_Dyn::DT_PLTGOT:
                        case Elf64_Dyn::DT_PREINIT_ARRAY:
                        case Elf64_Dyn::DT_INIT_ARRAY:
                        case Elf64_Dyn::DT_FINI_ARRAY:
                        case Elf64_Dyn::DT_FINI: {
                            set_te64(&dyn->d_val, val - asl_delta);
                        }; break;
                        } // end switch()
                        if (upx_dt_init == tag) {
                            if (Elf64_Dyn::DT_INIT == tag) {
                                set_te64(&dyn->d_val, old_dtinit);
                                if (!old_dtinit) { // compressor took the slot
                                    dyn->d_tag = Elf64_Dyn::DT_NULL;
                                    dyn->d_val = 0;
                                }
                            }
                            else if (Elf64_Dyn::DT_INIT_ARRAY    == tag
                            ||       Elf64_Dyn::DT_PREINIT_ARRAY == tag) {
                                if (val < load_va || (long unsigned)file_size < (long unsigned)val) {
                                    char msg[50]; snprintf(msg, sizeof(msg),
                                            ""Bad Dynamic tag %#lx %#lx"",
                                            (long unsigned)tag, (long unsigned)val);
                                    throwCantUnpack(msg);
                                }
                                set_te64(&ibuf[val - load_va], old_dtinit
                                    + (is_asl ? asl_delta : 0));  // counter-act unRel64
                            }
                        }
                        // Modified DT_*.d_val are re-written later from ibuf[]
                    }
                    if (is_asl) {
                        lowmem.alloc(xct_off);
                        fi->seek(0, SEEK_SET);
                        fi->read(lowmem, xct_off);  // contains relocation tables
                        if (dt_relasz && dt_rela) {
                            Elf64_Rela *const rela0 = (Elf64_Rela *)lowmem.subref(
                                ""bad Rela offset"", dt_rela, dt_relasz);
                            unRela64(dt_rela, rela0, dt_relasz, ibuf, load_va, old_dtinit, fo);
                        }
                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?
                            Elf64_Rela *const jmp0 = (Elf64_Rela *)lowmem.subref(
                                ""bad Jmprel offset"", dt_jmprel, dt_pltrelsz);
                            unRela64(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, old_dtinit, fo);
                        }
                        // Modified relocation tables are re-written by unRela64
                    }
                }
                if (fo) {
                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);
                    fo->rewrite(ibuf, old_data_len);
                }
            }
        }
    }

    // update header with totals
    ph.c_len = total_in;
    ph.u_len = total_out;

    // all bytes must be written
    if (total_out != orig_file_size)
        throwEOFException();

    // finally test the checksums
    if (ph.c_adler != c_adler || ph.u_adler != u_adler)
        throwChecksumError();
}","void PackLinuxElf64::unpack(OutputFile *VAR_0)
{
    if (VAR_1 != sizeof(VAR_2)) {/* COMMENT_0 */
        throwCantUnpack(""bad e_phoff"");
    }
    unsigned const VAR_3 = get_te16(&VAR_4.e_phnum);
    upx_uint64_t VAR_5 = 0;
    upx_uint64_t VAR_6 = 0;
    upx_uint64_t VAR_7 = 0;
    unsigned VAR_8 = 0;  /* COMMENT_1 */

    unsigned VAR_9 = sizeof(VAR_10);
    {
        upx_uint64_t const VAR_11 = get_te64(&VAR_4.e_entry);
        if (VAR_11 < 0x401180
        &&  get_te16(&VAR_4.e_machine)==Elf64_Ehdr::EM_386) { /* COMMENT_2 */
            VAR_9 = 2*sizeof(unsigned);
        }
    }

    VAR_12->seek(VAR_13 - sizeof(VAR_14), VAR_15);
    VAR_12->readx(&VAR_16, sizeof(VAR_16));
    VAR_17 = get_te16(&VAR_16.l_lsize);
    if (VAR_18 != get_le32(&VAR_16.l_magic)) {
        throwCantUnpack(""l_info corrupted"");
    }
    p_info VAR_19;  VAR_12->readx(&VAR_19, sizeof(VAR_19));
    unsigned VAR_20 = get_te32(&VAR_19.p_filesize);
    VAR_21 = get_te32(&VAR_19.p_blocksize);
    if ((u32_t)VAR_22 > VAR_20 || VAR_21 > VAR_20
        || !mem_size_valid(1, VAR_21, VAR_23))
        throwCantUnpack(""p_info corrupted"");

    VAR_24.alloc(VAR_21 + VAR_23);
    b_info VAR_25; memset(&VAR_25, 0, sizeof(VAR_25));
    VAR_12->readx(&VAR_25, VAR_9);
    VAR_26.u_len = get_te32(&VAR_25.sz_unc);
    VAR_26.c_len = get_te32(&VAR_25.sz_cpr);
    if (VAR_26.c_len > (unsigned)VAR_22 || VAR_26.c_len == 0 || VAR_26.u_len == 0
    ||  VAR_26.u_len > VAR_20)
        throwCantUnpack(""b_info corrupted"");
    VAR_26.filter_cto = VAR_25.b_cto8;

    MemBuffer VAR_27(VAR_26.u_len);
    Elf64_Ehdr *const VAR_28 = (Elf64_Ehdr *)&VAR_27[0];
    Elf64_Phdr const *VAR_29 = 0;

    /* COMMENT_3 */
    if (VAR_24.getSize() < VAR_26.c_len)
        throwCompressedDataViolation();
    VAR_12->readx(VAR_24, VAR_26.c_len);
    decompress(VAR_24, (upx_byte *)VAR_28, false);
    if (VAR_28->e_type   !=VAR_4.e_type
    ||  VAR_28->e_machine!=VAR_4.e_machine
    ||  VAR_28->e_version!=VAR_4.e_version
        /* COMMENT_4 */
    ||  !( VAR_28->e_flags==VAR_4.e_flags
        || Elf64_Ehdr::EM_PPC64 == get_te16(&VAR_4.e_machine))
    ||  VAR_28->e_ehsize !=VAR_4.e_ehsize
        /* COMMENT_5 */
    ||  memcmp(VAR_28->e_ident, VAR_4.e_ident, Elf64_Ehdr::EI_OSABI)) {
        throwCantUnpack(""ElfXX_Ehdr corrupted"");
    }
    VAR_12->seek(- (VAR_30) (VAR_9 + VAR_26.c_len), VAR_31);

    unsigned const VAR_32 = get_te16(&VAR_28->e_phnum);
    unsigned VAR_33 = 0;
    unsigned VAR_34 = 0;
    unsigned VAR_35 = upx_adler32(NULL, 0);
    unsigned VAR_36 = upx_adler32(NULL, 0);
#define VAR_37 1024
    if ((umin64(VAR_37, VAR_26.u_len) - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < VAR_32) {
        throwCantUnpack(""bad compressed e_phnum"");
    }
#undef MAX_ELF_HDR

    /* COMMENT_6 */
    /* COMMENT_7 */
    Elf64_Phdr const *const VAR_38 = elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, VAR_39, VAR_3);
    bool const VAR_40 = !!VAR_38;
    if (VAR_40) {
        /* COMMENT_8 */
        /* COMMENT_9 */
        unpackExtent(VAR_26.u_len, VAR_0, VAR_33, VAR_34,
            VAR_35, VAR_36, false, VAR_9);

        /* COMMENT_10 */
        VAR_12->seek(0, VAR_15);
        VAR_12->readx(VAR_24, get_te64(&VAR_38->p_offset) + get_te64(&VAR_38->p_filesz));
        VAR_13 -= sizeof(VAR_16);
        VAR_41 = VAR_13;
        VAR_42 = get_te64(&VAR_4.e_shoff);
        VAR_24.subref(""bad .e_shoff %#lx for %#lx"", VAR_42, sizeof(VAR_43) * VAR_44);
        if (VAR_42 && VAR_44) { /* COMMENT_11 */
            VAR_45 = (Elf64_Shdr /* COMMENT_12 */ *)VAR_24.subref(
                ""bad Shdr table"", VAR_42, sizeof(Elf64_Shdr)*VAR_44);
            upx_uint64_t VAR_46 = get_te64(&VAR_45->sh_offset);
            if (VAR_42 == VAR_46) {
                VAR_41 = VAR_42;
            }
            /* COMMENT_13 */
            upx_uint64_t VAR_47 = get_te64(&VAR_38->p_offset);
            upx_uint64_t VAR_48 = get_te64(&VAR_38->p_filesz);
            if (VAR_20 < VAR_47
            || (VAR_20 - VAR_47) < VAR_48) {
                throwCantUnpack(""bad PT_DYNAMIC"");
            }
            VAR_49 = (Elf64_Dyn const *)VAR_24.subref(""bad DYNAMIC"", VAR_47, VAR_48);
            VAR_50 = (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);
            VAR_51 = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);
            if (VAR_51) {
                upx_uint64_t const VAR_52 = get_te64(&VAR_51->sh_offset);
                upx_uint64_t const VAR_53  = get_te64(&VAR_51->sh_size);
                if (VAR_20 < VAR_53
                ||  VAR_20 < VAR_52
                || (VAR_20 - VAR_52) < VAR_53) {
                    throwCantUnpack(""bad SHT_DYNSYM"");
                }
                Elf64_Sym *const VAR_54 = (Elf64_Sym *)VAR_24.subref(
                    ""bad dynsym"", VAR_52, VAR_53);
                Elf64_Sym *VAR_55 = VAR_54;
                for (int VAR_56 = VAR_53 / sizeof(Elf64_Sym); --VAR_56>=0; ++VAR_55) {
                    upx_uint64_t VAR_57 = get_te64(&VAR_55->st_value);
                    unsigned VAR_58 = get_te16(&VAR_55->st_shndx);
                    if (Elf64_Sym::SHN_UNDEF != VAR_58
                    &&  Elf64_Sym::SHN_ABS   != VAR_58
                    &&  VAR_41 <= VAR_57) {
                        set_te64(&VAR_55->st_value, VAR_57 - VAR_59);
                    }
                    if (Elf64_Sym::SHN_ABS == VAR_58 && VAR_41 <= VAR_57) {
                        adjABS(VAR_55, 0u - VAR_59);
                    }
                }
            }
        }
        if (VAR_0) {
            VAR_0->write(VAR_24 + VAR_26.u_len, VAR_41 - VAR_26.u_len);
        }
        /* COMMENT_14 */
        int VAR_60 = 0;
        VAR_29 = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)VAR_24);
        for (unsigned VAR_56=0; VAR_56 < VAR_32; ++VAR_29, ++VAR_56) {
            if (VAR_61==get_te32(&VAR_29->p_type) && 0!=VAR_60++) {
                VAR_5 = get_te64(&VAR_29->p_offset);
                VAR_6 = get_te64(&VAR_29->p_filesz);
                break;
            }
        }

        VAR_33  = VAR_41;
        VAR_34 = VAR_41;
        VAR_26.u_len = 0;
        /* COMMENT_15 */
        VAR_12->seek(sizeof(VAR_16) + VAR_13 + sizeof(VAR_19) + VAR_9 + VAR_26.c_len, VAR_15);

        /* COMMENT_16 */
        VAR_29 = (Elf64_Phdr *) (void *) (1+ VAR_28);
        for (unsigned VAR_56=0; VAR_56 < VAR_32; ++VAR_29, ++VAR_56) {
            if (VAR_61==get_te32(&VAR_29->p_type)) {
                VAR_26.u_len = get_te64(&VAR_29->p_filesz) - VAR_41;
                break;
            }
        }
        unpackExtent(VAR_26.u_len, VAR_0, VAR_33, VAR_34,
            VAR_35, VAR_36, false, VAR_9);
    }
    else {  /* COMMENT_17 */
        /* COMMENT_18 */
        bool VAR_62 = true;
        VAR_29 = (Elf64_Phdr *) (void *) (1+ VAR_28);  /* COMMENT_19 */
        for (unsigned VAR_56=0; VAR_56 < VAR_32; ++VAR_29, ++VAR_56) {
            if (VAR_61==get_te32(&VAR_29->p_type)) {
                unsigned const VAR_63 = get_te64(&VAR_29->p_filesz);
                unsigned const VAR_64 = get_te64(&VAR_29->p_offset);
                if (VAR_0)
                    VAR_0->seek(VAR_64, VAR_15);
                if (Elf64_Phdr::PF_X & get_te32(&VAR_29->p_flags)) {
                    unpackExtent(VAR_63, VAR_0, VAR_33, VAR_34,
                        VAR_35, VAR_36, VAR_62, VAR_9);
                    VAR_62 = false;
                }
                else {
                    unpackExtent(VAR_63, VAR_0, VAR_33, VAR_34,
                        VAR_35, VAR_36, false, VAR_9);
                }
            }
        }
    }
    VAR_29 = VAR_39;
    VAR_65 = 0;
    for (unsigned VAR_56=0; VAR_56 < VAR_3; ++VAR_56) {
        if (VAR_61==get_te32(&VAR_29->p_type)) {
            VAR_65 = get_te64(&VAR_29->p_vaddr);
            break;
        }
    }
    if (0x1000==get_te64(&VAR_39[0].p_filesz)  /* COMMENT_20 */
    &&  0==get_te64(&VAR_39[1].p_offset)
    &&  0==get_te64(&VAR_39[0].p_offset)
    &&     get_te64(&VAR_39[1].p_filesz) == get_te64(&VAR_39[1].p_memsz)) {
        VAR_12->seek(up4(get_te64(&VAR_29[1].p_memsz)), VAR_15);  /* COMMENT_21 */
    }
    else if (VAR_40
    ||  ((unsigned)(get_te64(&VAR_4.e_entry) - VAR_65) + up4(VAR_17) +
                VAR_26.getPackHeaderSize() + sizeof(VAR_13))
            < up4(VAR_22)) {
        /* COMMENT_22 */
        funpad4(VAR_12);  /* COMMENT_23 */
        unsigned VAR_66[6]; VAR_12->readx(VAR_66, sizeof(VAR_66));
        if (0==VAR_7) {
            VAR_7 = get_te32(&VAR_66[2 + (0==VAR_66[0])]);
            VAR_8 = 1u& get_te32(&VAR_66[0 + (0==VAR_66[0])]);
        }
        VAR_12->seek(VAR_17 - sizeof(VAR_66), VAR_31);
    }

    /* COMMENT_24 */
    VAR_29 = (Elf64_Phdr *)&VAR_27[sizeof(*VAR_28)];
    upx_uint64_t VAR_67(0);
    for (unsigned VAR_56 = 0; VAR_56 < VAR_32; ++VAR_56) {
        if (VAR_61==VAR_29[VAR_56].p_type
        &&  VAR_67 < VAR_29[VAR_56].p_offset)
            VAR_67 = VAR_29[VAR_56].p_offset;
    }
    for (unsigned VAR_56 = 0; VAR_56 < VAR_32; ++VAR_56) {
        unsigned const VAR_68 = find_LOAD_gap(VAR_29, VAR_56, VAR_32);
        if (VAR_68) {
            unsigned const VAR_69 = get_te64(&VAR_29[VAR_56].p_offset) +
                                   get_te64(&VAR_29[VAR_56].p_filesz);
            if (VAR_0)
                VAR_0->seek(VAR_69, VAR_15);
            unpackExtent(VAR_68, VAR_0, VAR_33, VAR_34,
                VAR_35, VAR_36, false, VAR_9,
                (VAR_29[VAR_56].p_offset != VAR_67));
        }
    }

    /* COMMENT_25 */
    VAR_12->readx(&VAR_25, VAR_9);
    unsigned const VAR_70 = VAR_26.u_len = get_te32(&VAR_25.sz_unc);

    if (VAR_70 == 0) { /* COMMENT_26 */
        /* COMMENT_27 */
        unsigned const VAR_71 = get_le32(&VAR_25.sz_cpr);
        if (VAR_71 != VAR_18)  /* COMMENT_28 */
            throwCompressedDataViolation();
    }
    else { /* COMMENT_29 */
        throwCompressedDataViolation();
    }

    if (VAR_40) {
        /* COMMENT_30 */
        /* COMMENT_31 */
        int VAR_60 = 0;
        upx_uint64_t VAR_72 = 0;
        VAR_29 = (Elf64_Phdr *)&VAR_27[sizeof(*VAR_28)];
        for (unsigned VAR_56= 0; VAR_56 < VAR_32; ++VAR_56, ++VAR_29) {
            if (VAR_61==get_te32(&VAR_29->p_type) && 0!=VAR_60++) {
                VAR_72 = get_te64(&VAR_29->p_offset);
                VAR_65 = get_te64(&VAR_29->p_vaddr);
                VAR_12->seek(VAR_5, VAR_15);
                VAR_12->readx(VAR_24, VAR_6);
                VAR_33  += VAR_6;
                VAR_34 += VAR_6;

                Elf64_Phdr const *VAR_73 = (Elf64_Phdr *)&VAR_27[sizeof(*VAR_28)];
                for (unsigned VAR_74= 0; VAR_74 < VAR_32; ++VAR_74, ++VAR_73)
                if (Elf64_Phdr::PT_DYNAMIC==get_te32(&VAR_73->p_type)) {
                    upx_uint64_t VAR_75(0), VAR_76(0);
                    upx_uint64_t VAR_77(0), VAR_78(0);
                    upx_uint64_t const VAR_79 = get_te64(&VAR_73->p_filesz);
                    upx_uint64_t const VAR_80 = get_te64(&VAR_73->p_offset);
                    if ((unsigned long)VAR_22 < (VAR_79 + VAR_80)) {
                        char VAR_81[50]; snprintf(VAR_81, sizeof(VAR_81),
                                ""bad PT_DYNAMIC .p_filesz %#lx"", (long unsigned)VAR_79);
                        throwCantUnpack(VAR_81);
                    }
                    if (VAR_80 < VAR_72) {
                        continue;  /* COMMENT_32 */
                    }
                    Elf64_Dyn *VAR_82 = (Elf64_Dyn *)((unsigned char *)VAR_24 +
                        (VAR_80 - VAR_72));
                    VAR_49 = VAR_82; invert_pt_dynamic(VAR_49, get_te64(&VAR_73->p_filesz));
                    for (unsigned VAR_83= 0; VAR_83 < VAR_79; ++VAR_82, VAR_83 += sizeof(*VAR_82)) {
                        upx_uint64_t const VAR_84 = get_te64(&VAR_82->d_tag);
                        upx_uint64_t       VAR_85 = get_te64(&VAR_82->d_val);
                        if (VAR_8) switch (VAR_84) {
                        case Elf64_Dyn::DT_RELASZ:   { VAR_77   = VAR_85; } break;
                        case Elf64_Dyn::DT_RELA:     { VAR_78     = VAR_85; } break;
                        case Elf64_Dyn::DT_PLTRELSZ: { VAR_75 = VAR_85; } break;
                        case Elf64_Dyn::DT_JMPREL:   { VAR_76   = VAR_85; } break;

                        case Elf64_Dyn::DT_PLTGOT:
                        case Elf64_Dyn::DT_PREINIT_ARRAY:
                        case Elf64_Dyn::DT_INIT_ARRAY:
                        case Elf64_Dyn::DT_FINI_ARRAY:
                        case Elf64_Dyn::DT_FINI: {
                            set_te64(&VAR_82->d_val, VAR_85 - VAR_59);
                        }; break;
                        } /* COMMENT_33 */
                        if (VAR_86 == VAR_84) {
                            if (Elf64_Dyn::DT_INIT == VAR_84) {
                                set_te64(&VAR_82->d_val, VAR_7);
                                if (!VAR_7) { /* COMMENT_34 */
                                    VAR_82->d_tag = Elf64_Dyn::DT_NULL;
                                    VAR_82->d_val = 0;
                                }
                            }
                            else if (Elf64_Dyn::DT_INIT_ARRAY    == VAR_84
                            ||       Elf64_Dyn::DT_PREINIT_ARRAY == VAR_84) {
                                if (VAR_85 < VAR_65 || (long unsigned)VAR_22 < (long unsigned)VAR_85) {
                                    char VAR_81[50]; snprintf(VAR_81, sizeof(VAR_81),
                                            ""Bad Dynamic tag %#lx %#lx"",
                                            (long unsigned)VAR_84, (long unsigned)VAR_85);
                                    throwCantUnpack(VAR_81);
                                }
                                set_te64(&VAR_24[VAR_85 - VAR_65], VAR_7
                                    + (VAR_8 ? VAR_59 : 0));  /* COMMENT_35 */
                            }
                        }
                        /* COMMENT_36 */
                    }
                    if (VAR_8) {
                        VAR_87.alloc(VAR_41);
                        VAR_12->seek(0, VAR_15);
                        VAR_12->read(VAR_87, VAR_41);  /* COMMENT_37 */
                        if (VAR_77 && VAR_78) {
                            Elf64_Rela *const VAR_88 = (Elf64_Rela *)VAR_87.subref(
                                ""bad Rela offset"", VAR_78, VAR_77);
                            unRela64(VAR_78, VAR_88, VAR_77, VAR_24, VAR_65, VAR_7, VAR_0);
                        }
                        if (VAR_75 && VAR_76) { /* COMMENT_38 */
                            Elf64_Rela *const VAR_89 = (Elf64_Rela *)VAR_87.subref(
                                ""bad Jmprel offset"", VAR_76, VAR_75);
                            unRela64(VAR_76, VAR_89, VAR_75, VAR_24, VAR_65, VAR_7, VAR_0);
                        }
                        /* COMMENT_39 */
                    }
                }
                if (VAR_0) {
                    VAR_0->seek(get_te64(&VAR_29->p_offset), VAR_15);
                    VAR_0->rewrite(VAR_24, VAR_6);
                }
            }
        }
    }

    /* COMMENT_40 */
    VAR_26.c_len = VAR_33;
    VAR_26.u_len = VAR_34;

    /* COMMENT_41 */
    if (VAR_34 != VAR_20)
        throwEOFException();

    /* COMMENT_42 */
    if (VAR_26.c_adler != VAR_35 || VAR_26.u_adler != VAR_36)
        throwChecksumError();
}",upx/77c914bce58aab9459029bed699f2bfb7ff2f90f/p_lx_elf.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -99,16 +99,21 @@
                 xct_off = e_shoff;
             }
             // un-Relocate dynsym (DT_SYMTAB) which is below xct_off
-            dynseg = (Elf64_Dyn const *)ibuf.subref(
-                ""bad DYNAMIC"", get_te64(&dynhdr->p_offset), get_te64(&dynhdr->p_filesz));
+            upx_uint64_t dyn_offset = get_te64(&dynhdr->p_offset);
+            upx_uint64_t dyn_filesz = get_te64(&dynhdr->p_filesz);
+            if (orig_file_size < dyn_offset
+            || (orig_file_size - dyn_offset) < dyn_filesz) {
+                throwCantUnpack(""bad PT_DYNAMIC"");
+            }
+            dynseg = (Elf64_Dyn const *)ibuf.subref(""bad DYNAMIC"", dyn_offset, dyn_filesz);
             dynstr = (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);
             sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);
             if (sec_dynsym) {
                 upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);
                 upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);
-                if ((upx_uint64_t)file_size < sz_dynsym
-                ||  (upx_uint64_t)file_size < off_dynsym
-                || ((upx_uint64_t)file_size - off_dynsym) < sz_dynsym) {
+                if (orig_file_size < sz_dynsym
+                ||  orig_file_size < off_dynsym
+                || (orig_file_size - off_dynsym) < sz_dynsym) {
                     throwCantUnpack(""bad SHT_DYNSYM"");
                 }
                 Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(","{'deleted_lines': ['            dynseg = (Elf64_Dyn const *)ibuf.subref(', '                ""bad DYNAMIC"", get_te64(&dynhdr->p_offset), get_te64(&dynhdr->p_filesz));', '                if ((upx_uint64_t)file_size < sz_dynsym', '                ||  (upx_uint64_t)file_size < off_dynsym', '                || ((upx_uint64_t)file_size - off_dynsym) < sz_dynsym) {'], 'added_lines': ['            upx_uint64_t dyn_offset = get_te64(&dynhdr->p_offset);', '            upx_uint64_t dyn_filesz = get_te64(&dynhdr->p_filesz);', '            if (orig_file_size < dyn_offset', '            || (orig_file_size - dyn_offset) < dyn_filesz) {', '                throwCantUnpack(""bad PT_DYNAMIC"");', '            }', '            dynseg = (Elf64_Dyn const *)ibuf.subref(""bad DYNAMIC"", dyn_offset, dyn_filesz);', '                if (orig_file_size < sz_dynsym', '                ||  orig_file_size < off_dynsym', '                || (orig_file_size - off_dynsym) < sz_dynsym) {']}",True,An invalid memory address reference was discovered in the adjABS function in p_lx_elf.cpp in UPX 4.0.0 via a crafted Mach-O file.,5.5,MEDIUM,1,test,2020-07-25T16:28:02Z,3
CVE-2020-16088,['CWE-287'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,openbsd/src,"Fix return value check for openssl API used during pubkey validation.

Found thanks to bug report by Michael Scheibel <m.Scheibel (at) tuvit (dot) de>
ok patrick@, markus@, tb@",7afb2d41c6d373cf965285840b85c45011357115,https://github.com/openbsd/src/commit/7afb2d41c6d373cf965285840b85c45011357115,sbin/iked/ca.c,ca_validate_pubkey,"int
ca_validate_pubkey(struct iked *env, struct iked_static_id *id,
void *data, size_t len, struct iked_id *out)
{
BIO*rawcert = NULL;
RSA*peerrsa = NULL, *localrsa = NULL;
EC_KEY*peerec = NULL;
EVP_PKEY*peerkey = NULL, *localkey = NULL;
int ret = -1;
FILE*fp = NULL;
char idstr[IKED_ID_SIZE];
char file[PATH_MAX];
struct iked_id idp;
switch (id->id_type) {
case IKEV2_ID_IPV4:
case IKEV2_ID_FQDN:
case IKEV2_ID_UFQDN:
case IKEV2_ID_IPV6:
break;
default:
log_debug(""%s: unsupported public key type %s"",
__func__, print_map(id->id_type, ikev2_id_map));
return (-1);
}
bzero(&idp, sizeof(idp));
if ((idp.id_buf = ibuf_new(id->id_data, id->id_length)) == NULL)
goto done;
idp.id_type = id->id_type;
idp.id_offset = id->id_offset;
if (ikev2_print_id(&idp, idstr, sizeof(idstr)) == -1)
goto done;
if (len == 0 && data) {
peerkey = (EVP_PKEY *)data;
}
if (len > 0) {
if ((rawcert = BIO_new_mem_buf(data, len)) == NULL)
goto done;
if ((peerkey = EVP_PKEY_new()) == NULL)
goto sslerr;
if ((peerrsa = d2i_RSAPublicKey_bio(rawcert, NULL))) {
if (!EVP_PKEY_set1_RSA(peerkey, peerrsa)) {
goto sslerr;
}
} else if (BIO_reset(rawcert) == 1 &&
(peerec = d2i_EC_PUBKEY_bio(rawcert, NULL))) {
if (!EVP_PKEY_set1_EC_KEY(peerkey, peerec)) {
goto sslerr;
}
} else {
log_debug(""%s: unknown key type received"", __func__);
goto sslerr;
}
}
lc_idtype(idstr);
if (strlcpy(file, IKED_PUBKEY_DIR, sizeof(file)) >= sizeof(file) ||
strlcat(file, idstr, sizeof(file)) >= sizeof(file)) {
log_debug(""%s: public key id too long %s"", __func__, idstr);
goto done;
}
if ((fp = fopen(file, ""r"")) == NULL) {
logit(len == 0 ? LOG_DEBUG : LOG_INFO,
""%s: could not open public key %s"", __func__, file);
goto done;
}
localkey = PEM_read_PUBKEY(fp, NULL, NULL, NULL);
if (localkey == NULL) {
rewind(fp);
localrsa = PEM_read_RSAPublicKey(fp, NULL, NULL, NULL);
fclose(fp);
if (localrsa == NULL)
goto sslerr;
if ((localkey = EVP_PKEY_new()) == NULL)
goto sslerr;
if (!EVP_PKEY_set1_RSA(localkey, localrsa))
goto sslerr;
} else {
fclose(fp);
}
if (localkey == NULL)
goto sslerr;
if (peerkey && !EVP_PKEY_cmp(peerkey, localkey)) {
log_debug(""%s: public key does not match %s"", __func__, file);
goto done;
}
log_debug(""%s: valid public key in file %s"", __func__, file);
if (out && ca_pubkey_serialize(localkey, out))
goto done;
ret = 0;
sslerr:
if (ret != 0)
ca_sslerror(__func__);
done:
ibuf_release(idp.id_buf);
if (localkey != NULL)
EVP_PKEY_free(localkey);
if (peerrsa != NULL)
RSA_free(peerrsa);
if (peerec != NULL)
EC_KEY_free(peerec);
if (localrsa != NULL)
RSA_free(localrsa);
if (rawcert != NULL) {
BIO_free(rawcert);
if (peerkey != NULL)
EVP_PKEY_free(peerkey);
}
return (ret);
}","int
ca_validate_pubkey(struct iked *VAR_0, struct iked_static_id *VAR_1,
void *VAR_2, size_t VAR_3, struct iked_id *VAR_4)
{
BIO*VAR_5 = NULL;
RSA*VAR_6 = NULL, *VAR_7 = NULL;
EC_KEY*VAR_8 = NULL;
EVP_PKEY*VAR_9 = NULL, *VAR_10 = NULL;
int VAR_11 = -1;
FILE*VAR_12 = NULL;
char VAR_13[VAR_14];
char VAR_15[VAR_16];
struct iked_id VAR_17;
switch (VAR_1->id_type) {
case VAR_18:
case VAR_19:
case VAR_20:
case VAR_21:
break;
default:
log_debug(""%s: unsupported public key type %s"",
VAR_22, print_map(VAR_1->id_type, VAR_23));
return (-1);
}
bzero(&VAR_17, sizeof(VAR_17));
if ((VAR_17.id_buf = ibuf_new(VAR_1->id_data, VAR_1->id_length)) == NULL)
goto done;
VAR_17.id_type = VAR_1->id_type;
VAR_17.id_offset = VAR_1->id_offset;
if (ikev2_print_id(&VAR_17, VAR_13, sizeof(VAR_13)) == -1)
goto done;
if (VAR_3 == 0 && VAR_2) {
VAR_9 = (EVP_PKEY *)VAR_2;
}
if (VAR_3 > 0) {
if ((VAR_5 = BIO_new_mem_buf(VAR_2, VAR_3)) == NULL)
goto done;
if ((VAR_9 = EVP_PKEY_new()) == NULL)
goto sslerr;
if ((VAR_6 = d2i_RSAPublicKey_bio(VAR_5, NULL))) {
if (!EVP_PKEY_set1_RSA(VAR_9, VAR_6)) {
goto sslerr;
}
} else if (BIO_reset(VAR_5) == 1 &&
(VAR_8 = d2i_EC_PUBKEY_bio(VAR_5, NULL))) {
if (!EVP_PKEY_set1_EC_KEY(VAR_9, VAR_8)) {
goto sslerr;
}
} else {
log_debug(""%s: unknown key type received"", VAR_22);
goto sslerr;
}
}
lc_idtype(VAR_13);
if (strlcpy(VAR_15, VAR_24, sizeof(VAR_15)) >= sizeof(VAR_15) ||
strlcat(VAR_15, VAR_13, sizeof(VAR_15)) >= sizeof(VAR_15)) {
log_debug(""%s: public key id too long %s"", VAR_22, VAR_13);
goto done;
}
if ((VAR_12 = fopen(VAR_15, ""r"")) == NULL) {
logit(VAR_3 == 0 ? VAR_25 : VAR_26,
""%s: could not open public key %s"", VAR_22, VAR_15);
goto done;
}
VAR_10 = PEM_read_PUBKEY(VAR_12, NULL, NULL, NULL);
if (VAR_10 == NULL) {
rewind(VAR_12);
VAR_7 = PEM_read_RSAPublicKey(VAR_12, NULL, NULL, NULL);
fclose(VAR_12);
if (VAR_7 == NULL)
goto sslerr;
if ((VAR_10 = EVP_PKEY_new()) == NULL)
goto sslerr;
if (!EVP_PKEY_set1_RSA(VAR_10, VAR_7))
goto sslerr;
} else {
fclose(VAR_12);
}
if (VAR_10 == NULL)
goto sslerr;
if (VAR_9 && !EVP_PKEY_cmp(VAR_9, VAR_10)) {
log_debug(""%s: public key does not match %s"", VAR_22, VAR_15);
goto done;
}
log_debug(""%s: valid public key in file %s"", VAR_22, VAR_15);
if (VAR_4 && ca_pubkey_serialize(VAR_10, VAR_4))
goto done;
VAR_11 = 0;
sslerr:
if (VAR_11 != 0)
ca_sslerror(VAR_22);
done:
ibuf_release(VAR_17.id_buf);
if (VAR_10 != NULL)
EVP_PKEY_free(VAR_10);
if (VAR_6 != NULL)
RSA_free(VAR_6);
if (VAR_8 != NULL)
EC_KEY_free(VAR_8);
if (VAR_7 != NULL)
RSA_free(VAR_7);
if (VAR_5 != NULL) {
BIO_free(VAR_5);
if (VAR_9 != NULL)
EVP_PKEY_free(VAR_9);
}
return (VAR_11);
}",openbsd/src/7afb2d41c6d373cf965285840b85c45011357115/ca.c/vul/before/0.json,"int
ca_validate_pubkey(struct iked *env, struct iked_static_id *id,
    void *data, size_t len, struct iked_id *out)
{
	BIO		*rawcert = NULL;
	RSA		*peerrsa = NULL, *localrsa = NULL;
	EC_KEY		*peerec = NULL;
	EVP_PKEY	*peerkey = NULL, *localkey = NULL;
	int		 ret = -1;
	FILE		*fp = NULL;
	char		 idstr[IKED_ID_SIZE];
	char		 file[PATH_MAX];
	struct iked_id	 idp;

	switch (id->id_type) {
	case IKEV2_ID_IPV4:
	case IKEV2_ID_FQDN:
	case IKEV2_ID_UFQDN:
	case IKEV2_ID_IPV6:
		break;
	default:
		/* Some types like ASN1_DN will not be mapped to file names */
		log_debug(""%s: unsupported public key type %s"",
		    __func__, print_map(id->id_type, ikev2_id_map));
		return (-1);
	}

	bzero(&idp, sizeof(idp));
	if ((idp.id_buf = ibuf_new(id->id_data, id->id_length)) == NULL)
		goto done;

	idp.id_type = id->id_type;
	idp.id_offset = id->id_offset;
	if (ikev2_print_id(&idp, idstr, sizeof(idstr)) == -1)
		goto done;

	if (len == 0 && data) {
		/* Data is already an public key */
		peerkey = (EVP_PKEY *)data;
	}
	if (len > 0) {
		if ((rawcert = BIO_new_mem_buf(data, len)) == NULL)
			goto done;

		if ((peerkey = EVP_PKEY_new()) == NULL)
			goto sslerr;
		if ((peerrsa = d2i_RSAPublicKey_bio(rawcert, NULL))) {
			if (!EVP_PKEY_set1_RSA(peerkey, peerrsa)) {
				goto sslerr;
			}
		} else if (BIO_reset(rawcert) == 1 &&
		    (peerec = d2i_EC_PUBKEY_bio(rawcert, NULL))) {
			if (!EVP_PKEY_set1_EC_KEY(peerkey, peerec)) {
				goto sslerr;
			}
		} else {
			log_debug(""%s: unknown key type received"", __func__);
			goto sslerr;
		}
	}

	lc_idtype(idstr);
	if (strlcpy(file, IKED_PUBKEY_DIR, sizeof(file)) >= sizeof(file) ||
	    strlcat(file, idstr, sizeof(file)) >= sizeof(file)) {
		log_debug(""%s: public key id too long %s"", __func__, idstr);
		goto done;
	}

	if ((fp = fopen(file, ""r"")) == NULL) {
		/* Log to debug when called from ca_validate_cert */
		logit(len == 0 ? LOG_DEBUG : LOG_INFO,
		    ""%s: could not open public key %s"", __func__, file);
		goto done;
	}
	localkey = PEM_read_PUBKEY(fp, NULL, NULL, NULL);
	if (localkey == NULL) {
		/* reading PKCS #8 failed, try PEM RSA */
		rewind(fp);
		localrsa = PEM_read_RSAPublicKey(fp, NULL, NULL, NULL);
		fclose(fp);
		if (localrsa == NULL)
			goto sslerr;
		if ((localkey = EVP_PKEY_new()) == NULL)
			goto sslerr;
		if (!EVP_PKEY_set1_RSA(localkey, localrsa))
			goto sslerr;
	} else {
		fclose(fp);
	}
	if (localkey == NULL)
		goto sslerr;

	if (peerkey && EVP_PKEY_cmp(peerkey, localkey) != 1) {
		log_debug(""%s: public key does not match %s"", __func__, file);
		goto done;
	}

	log_debug(""%s: valid public key in file %s"", __func__, file);

	if (out && ca_pubkey_serialize(localkey, out))
		goto done;

	ret = 0;
 sslerr:
	if (ret != 0)
		ca_sslerror(__func__);
 done:
	ibuf_release(idp.id_buf);
	if (localkey != NULL)
		EVP_PKEY_free(localkey);
	if (peerrsa != NULL)
		RSA_free(peerrsa);
	if (peerec != NULL)
		EC_KEY_free(peerec);
	if (localrsa != NULL)
		RSA_free(localrsa);
	if (rawcert != NULL) {
		BIO_free(rawcert);
		if (peerkey != NULL)
			EVP_PKEY_free(peerkey);
	}

	return (ret);
}","int
ca_validate_pubkey(struct iked *VAR_0, struct iked_static_id *VAR_1,
    void *VAR_2, size_t VAR_3, struct iked_id *VAR_4)
{
	BIO		*VAR_5 = NULL;
	RSA		*VAR_6 = NULL, *VAR_7 = NULL;
	EC_KEY		*VAR_8 = NULL;
	EVP_PKEY	*VAR_9 = NULL, *VAR_10 = NULL;
	int		 VAR_11 = -1;
	FILE		*VAR_12 = NULL;
	char		 VAR_13[VAR_14];
	char		 VAR_15[VAR_16];
	struct iked_id	 VAR_17;

	switch (VAR_1->id_type) {
	case VAR_18:
	case VAR_19:
	case VAR_20:
	case VAR_21:
		break;
	default:
		/* COMMENT_0 */
		log_debug(""%s: unsupported public key type %s"",
		    VAR_22, print_map(VAR_1->id_type, VAR_23));
		return (-1);
	}

	bzero(&VAR_17, sizeof(VAR_17));
	if ((VAR_17.id_buf = ibuf_new(VAR_1->id_data, VAR_1->id_length)) == NULL)
		goto done;

	VAR_17.id_type = VAR_1->id_type;
	VAR_17.id_offset = VAR_1->id_offset;
	if (ikev2_print_id(&VAR_17, VAR_13, sizeof(VAR_13)) == -1)
		goto done;

	if (VAR_3 == 0 && VAR_2) {
		/* COMMENT_1 */
		VAR_9 = (EVP_PKEY *)VAR_2;
	}
	if (VAR_3 > 0) {
		if ((VAR_5 = BIO_new_mem_buf(VAR_2, VAR_3)) == NULL)
			goto done;

		if ((VAR_9 = EVP_PKEY_new()) == NULL)
			goto sslerr;
		if ((VAR_6 = d2i_RSAPublicKey_bio(VAR_5, NULL))) {
			if (!EVP_PKEY_set1_RSA(VAR_9, VAR_6)) {
				goto sslerr;
			}
		} else if (BIO_reset(VAR_5) == 1 &&
		    (VAR_8 = d2i_EC_PUBKEY_bio(VAR_5, NULL))) {
			if (!EVP_PKEY_set1_EC_KEY(VAR_9, VAR_8)) {
				goto sslerr;
			}
		} else {
			log_debug(""%s: unknown key type received"", VAR_22);
			goto sslerr;
		}
	}

	lc_idtype(VAR_13);
	if (strlcpy(VAR_15, VAR_24, sizeof(VAR_15)) >= sizeof(VAR_15) ||
	    strlcat(VAR_15, VAR_13, sizeof(VAR_15)) >= sizeof(VAR_15)) {
		log_debug(""%s: public key id too long %s"", VAR_22, VAR_13);
		goto done;
	}

	if ((VAR_12 = fopen(VAR_15, ""r"")) == NULL) {
		/* COMMENT_2 */
		logit(VAR_3 == 0 ? VAR_25 : VAR_26,
		    ""%s: could not open public key %s"", VAR_22, VAR_15);
		goto done;
	}
	VAR_10 = PEM_read_PUBKEY(VAR_12, NULL, NULL, NULL);
	if (VAR_10 == NULL) {
		/* COMMENT_3 */
		rewind(VAR_12);
		VAR_7 = PEM_read_RSAPublicKey(VAR_12, NULL, NULL, NULL);
		fclose(VAR_12);
		if (VAR_7 == NULL)
			goto sslerr;
		if ((VAR_10 = EVP_PKEY_new()) == NULL)
			goto sslerr;
		if (!EVP_PKEY_set1_RSA(VAR_10, VAR_7))
			goto sslerr;
	} else {
		fclose(VAR_12);
	}
	if (VAR_10 == NULL)
		goto sslerr;

	if (VAR_9 && EVP_PKEY_cmp(VAR_9, VAR_10) != 1) {
		log_debug(""%s: public key does not match %s"", VAR_22, VAR_15);
		goto done;
	}

	log_debug(""%s: valid public key in file %s"", VAR_22, VAR_15);

	if (VAR_4 && ca_pubkey_serialize(VAR_10, VAR_4))
		goto done;

	VAR_11 = 0;
 sslerr:
	if (VAR_11 != 0)
		ca_sslerror(VAR_22);
 done:
	ibuf_release(VAR_17.id_buf);
	if (VAR_10 != NULL)
		EVP_PKEY_free(VAR_10);
	if (VAR_6 != NULL)
		RSA_free(VAR_6);
	if (VAR_8 != NULL)
		EC_KEY_free(VAR_8);
	if (VAR_7 != NULL)
		RSA_free(VAR_7);
	if (VAR_5 != NULL) {
		BIO_free(VAR_5);
		if (VAR_9 != NULL)
			EVP_PKEY_free(VAR_9);
	}

	return (VAR_11);
}",openbsd/src/7afb2d41c6d373cf965285840b85c45011357115/ca.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -90,7 +90,7 @@
 	if (localkey == NULL)
 		goto sslerr;
 
-	if (peerkey && !EVP_PKEY_cmp(peerkey, localkey)) {
+	if (peerkey && EVP_PKEY_cmp(peerkey, localkey) != 1) {
 		log_debug(""%s: public key does not match %s"", __func__, file);
 		goto done;
 	}","{'deleted_lines': ['\tif (peerkey && !EVP_PKEY_cmp(peerkey, localkey)) {'], 'added_lines': ['\tif (peerkey && EVP_PKEY_cmp(peerkey, localkey) != 1) {']}",True,"iked in OpenIKED, as used in OpenBSD through 6.7, allows authentication bypass because ca.c has the wrong logic for checking whether a public key matches.",9.8,CRITICAL,3,test,2020-07-27T14:22:53Z,3
CVE-2021-39523,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,LibreDWG/libredwg,"decode: fix check_POLYLINE_handles NULL deref

detected by @seviezhou via fuzzing. Fixes GH #251",8ebc76a03390197745a94b4e2d374aee636b84a7,https://github.com/LibreDWG/libredwg/commit/8ebc76a03390197745a94b4e2d374aee636b84a7,src/decode.c,dwg_decode_add_object,"int
dwg_decode_add_object (Dwg_Data *restrict dwg, Bit_Chain *dat,
Bit_Chain *hdl_dat, long unsigned int address)
{
long unsigned int objpos, restartpos;
Bit_Chain abs_dat = { NULL };
unsigned char previous_bit;
Dwg_Object *restrict obj;
BITCODE_BL num = dwg->num_objects;
int error = 0;
int realloced = 0;
abs_dat = *dat;
dat->byte = address;
dat->bit = 0;
realloced = dwg_add_object (dwg);
if (realloced > 0)
{
*dat = abs_dat;
return realloced;     }
obj = &dwg->object[num];
LOG_INFO (""==========================================\n""
""Object number: %lu/%lX"",
(unsigned long)num, (unsigned long)num)
obj->size = bit_read_MS (dat);
LOG_INFO ("", Size: %d [MS]"", obj->size)
SINCE (R_2010)
{
obj->handlestream_size = bit_read_UMC (dat);
LOG_INFO ("", Hdlsize: "" FORMAT_UMC "" [UMC] "", obj->handlestream_size);
obj->bitsize = obj->size * 8 - obj->handlestream_size;
}
objpos = bit_position (dat);   obj->address = dat->byte;
bit_reset_chain (dat);
if (obj->size > dat->size || dat->chain + dat->size > abs_dat.chain + abs_dat.size)
{
LOG_TRACE (""\n"");
LOG_WARN (""Invalid object size %u > %ld. Would overflow"", obj->size,
dat->size);
error |= DWG_ERR_VALUEOUTOFBOUNDS;
#if 0
obj->size = dat->size - 1;
#else
*dat = abs_dat;
return error;
#endif
}
dat->size = obj->size;
SINCE (R_2010) { obj->type = bit_read_BOT (dat); }
else { obj->type = bit_read_BS (dat); }
LOG_INFO ("", Type: %d [%s], Address: %lu\n"", obj->type,
dat->from_version >= R_2010 ? ""BOT"" : ""BS"", obj->address);
restartpos = bit_position (dat); 
switch (obj->type)
{
case DWG_TYPE_TEXT:
error = dwg_decode_TEXT (dat, obj);
break;
case DWG_TYPE_ATTRIB:
error = dwg_decode_ATTRIB (dat, obj);
break;
case DWG_TYPE_ATTDEF:
error = dwg_decode_ATTDEF (dat, obj);
break;
case DWG_TYPE_BLOCK:
error = dwg_decode_BLOCK (dat, obj);
break;
case DWG_TYPE_ENDBLK:
error = dwg_decode_ENDBLK (dat, obj);
break;
case DWG_TYPE_SEQEND:
error = dwg_decode_SEQEND (dat, obj);
if (dat->from_version >= R_13 && obj->tio.entity->ownerhandle)
{
Dwg_Object *restrict owner = dwg_resolve_handle (
dwg, obj->tio.entity->ownerhandle->absolute_ref);
if (!owner)
{
LOG_WARN (""no SEQEND.ownerhandle"")
}
else if (owner->fixedtype == DWG_TYPE_INSERT
|| owner->fixedtype == DWG_TYPE_MINSERT)
{
hash_set (dwg->object_map, obj->handle.value, (uint32_t)num);
(void)dwg_validate_INSERT (owner);
}
else if (owner->fixedtype == DWG_TYPE_POLYLINE_2D
|| owner->fixedtype == DWG_TYPE_POLYLINE_3D
|| owner->fixedtype == DWG_TYPE_POLYLINE_PFACE
|| owner->fixedtype == DWG_TYPE_POLYLINE_MESH)
{
Dwg_Entity_POLYLINE_2D *restrict _obj
= owner->tio.entity->tio.POLYLINE_2D;
if (!_obj->seqend)
hash_set (dwg->object_map, obj->handle.value, (uint32_t)num);
(void)dwg_validate_POLYLINE (owner);
}
}
break;
case DWG_TYPE_INSERT:
error = dwg_decode_INSERT (dat, obj);
break;
case DWG_TYPE_MINSERT:
error = dwg_decode_MINSERT (dat, obj);
break;
case DWG_TYPE_VERTEX_2D:
error = dwg_decode_VERTEX_2D (dat, obj);
break;
case DWG_TYPE_VERTEX_3D:
error = dwg_decode_VERTEX_3D (dat, obj);
break;
case DWG_TYPE_VERTEX_MESH:
error = dwg_decode_VERTEX_MESH (dat, obj);
break;
case DWG_TYPE_VERTEX_PFACE:
error = dwg_decode_VERTEX_PFACE (dat, obj);
break;
case DWG_TYPE_VERTEX_PFACE_FACE:
error = dwg_decode_VERTEX_PFACE_FACE (dat, obj);
break;
case DWG_TYPE_POLYLINE_2D:
error = dwg_decode_POLYLINE_2D (dat, obj);
if (dat->from_version >= R_2010)
check_POLYLINE_handles (obj);
break;
case DWG_TYPE_POLYLINE_3D:
error = dwg_decode_POLYLINE_3D (dat, obj);
if (dat->from_version >= R_2010)
check_POLYLINE_handles (obj);
break;
case DWG_TYPE_ARC:
error = dwg_decode_ARC (dat, obj);
break;
case DWG_TYPE_CIRCLE:
error = dwg_decode_CIRCLE (dat, obj);
break;
case DWG_TYPE_LINE:
error = dwg_decode_LINE (dat, obj);
break;
case DWG_TYPE_DIMENSION_ORDINATE:
error = dwg_decode_DIMENSION_ORDINATE (dat, obj);
break;
case DWG_TYPE_DIMENSION_LINEAR:
error = dwg_decode_DIMENSION_LINEAR (dat, obj);
break;
case DWG_TYPE_DIMENSION_ALIGNED:
error = dwg_decode_DIMENSION_ALIGNED (dat, obj);
break;
case DWG_TYPE_DIMENSION_ANG3PT:
error = dwg_decode_DIMENSION_ANG3PT (dat, obj);
break;
case DWG_TYPE_DIMENSION_ANG2LN:
error = dwg_decode_DIMENSION_ANG2LN (dat, obj);
break;
case DWG_TYPE_DIMENSION_RADIUS:
error = dwg_decode_DIMENSION_RADIUS (dat, obj);
break;
case DWG_TYPE_DIMENSION_DIAMETER:
error = dwg_decode_DIMENSION_DIAMETER (dat, obj);
break;
case DWG_TYPE_POINT:
error = dwg_decode_POINT (dat, obj);
break;
case DWG_TYPE__3DFACE:
error = dwg_decode__3DFACE (dat, obj);
break;
case DWG_TYPE_POLYLINE_PFACE:
error = dwg_decode_POLYLINE_PFACE (dat, obj);
if (dat->from_version >= R_2010)
check_POLYLINE_handles (obj);
break;
case DWG_TYPE_POLYLINE_MESH:
error = dwg_decode_POLYLINE_MESH (dat, obj);
if (dat->from_version >= R_2010)
check_POLYLINE_handles (obj);
break;
case DWG_TYPE_SOLID:
error = dwg_decode_SOLID (dat, obj);
break;
case DWG_TYPE_TRACE:
error = dwg_decode_TRACE (dat, obj);
break;
case DWG_TYPE_SHAPE:
error = dwg_decode_SHAPE (dat, obj);
break;
case DWG_TYPE_VIEWPORT:
error = dwg_decode_VIEWPORT (dat, obj);
break;
case DWG_TYPE_ELLIPSE:
error = dwg_decode_ELLIPSE (dat, obj);
break;
case DWG_TYPE_SPLINE:
error = dwg_decode_SPLINE (dat, obj);
break;
case DWG_TYPE_REGION:
error = dwg_decode_REGION (dat, obj);
break;
case DWG_TYPE__3DSOLID:
error = dwg_decode__3DSOLID (dat, obj);
break;
case DWG_TYPE_BODY:
error = dwg_decode_BODY (dat, obj);
break;
case DWG_TYPE_RAY:
error = dwg_decode_RAY (dat, obj);
break;
case DWG_TYPE_XLINE:
error = dwg_decode_XLINE (dat, obj);
break;
case DWG_TYPE_DICTIONARY:
error = dwg_decode_DICTIONARY (dat, obj);
break;
case DWG_TYPE_MTEXT:
error = dwg_decode_MTEXT (dat, obj);
break;
case DWG_TYPE_LEADER:
error = dwg_decode_LEADER (dat, obj);
break;
case DWG_TYPE_TOLERANCE:
error = dwg_decode_TOLERANCE (dat, obj);
break;
case DWG_TYPE_MLINE:
error = dwg_decode_MLINE (dat, obj);
break;
case DWG_TYPE_BLOCK_CONTROL:
error = dwg_decode_BLOCK_CONTROL (dat, obj);
if (!error && obj->tio.object->tio.BLOCK_CONTROL)
{
obj->tio.object->tio.BLOCK_CONTROL->objid = num;
if (!dwg->block_control.parent)             dwg->block_control = *obj->tio.object->tio.BLOCK_CONTROL;
else
LOG_WARN (""Second BLOCK_CONTROL object ignored"");
}
break;
case DWG_TYPE_BLOCK_HEADER:
error = dwg_decode_BLOCK_HEADER (dat, obj);
break;
case DWG_TYPE_LAYER_CONTROL:
error = dwg_decode_LAYER_CONTROL (dat, obj);
if (!error && obj->tio.object->tio.LAYER_CONTROL)
{
obj->tio.object->tio.LAYER_CONTROL->objid = num;
dwg->layer_control = *obj->tio.object->tio.LAYER_CONTROL;
}
break;
case DWG_TYPE_LAYER:
error = dwg_decode_LAYER (dat, obj);
break;
case DWG_TYPE_STYLE_CONTROL:
error = dwg_decode_STYLE_CONTROL (dat, obj);
if (!error && obj->tio.object->tio.STYLE_CONTROL)
{
obj->tio.object->tio.STYLE_CONTROL->objid = num;
dwg->style_control = *obj->tio.object->tio.STYLE_CONTROL;
}
break;
case DWG_TYPE_STYLE:
error = dwg_decode_STYLE (dat, obj);
break;
case DWG_TYPE_LTYPE_CONTROL:
error = dwg_decode_LTYPE_CONTROL (dat, obj);
if (!error && obj->tio.object->tio.LTYPE_CONTROL)
{
obj->tio.object->tio.LTYPE_CONTROL->objid = num;
dwg->ltype_control = *obj->tio.object->tio.LTYPE_CONTROL;
}
break;
case DWG_TYPE_LTYPE:
error = dwg_decode_LTYPE (dat, obj);
break;
case DWG_TYPE_VIEW_CONTROL:
error = dwg_decode_VIEW_CONTROL (dat, obj);
if (!error && obj->tio.object->tio.VIEW_CONTROL)
{
obj->tio.object->tio.VIEW_CONTROL->objid = num;
dwg->view_control = *obj->tio.object->tio.VIEW_CONTROL;
}
break;
case DWG_TYPE_VIEW:
error = dwg_decode_VIEW (dat, obj);
break;
case DWG_TYPE_UCS_CONTROL:
error = dwg_decode_UCS_CONTROL (dat, obj);
if (!error && obj->tio.object->tio.UCS_CONTROL)
{
obj->tio.object->tio.UCS_CONTROL->objid = num;
dwg->ucs_control = *obj->tio.object->tio.UCS_CONTROL;
}
break;
case DWG_TYPE_UCS:
error = dwg_decode_UCS (dat, obj);
break;
case DWG_TYPE_VPORT_CONTROL:
error = dwg_decode_VPORT_CONTROL (dat, obj);
if (!error && obj->tio.object->tio.VPORT_CONTROL)
{
obj->tio.object->tio.VPORT_CONTROL->objid = num;
dwg->vport_control = *obj->tio.object->tio.VPORT_CONTROL;
}
break;
case DWG_TYPE_VPORT:
error = dwg_decode_VPORT (dat, obj);
break;
case DWG_TYPE_APPID_CONTROL:
error = dwg_decode_APPID_CONTROL (dat, obj);
if (!error && obj->tio.object->tio.APPID_CONTROL)
{
obj->tio.object->tio.APPID_CONTROL->objid = num;
dwg->appid_control = *obj->tio.object->tio.APPID_CONTROL;
}
break;
case DWG_TYPE_APPID:
error = dwg_decode_APPID (dat, obj);
break;
case DWG_TYPE_DIMSTYLE_CONTROL:
error = dwg_decode_DIMSTYLE_CONTROL (dat, obj);
if (!error && obj->tio.object->tio.DIMSTYLE_CONTROL)
{
obj->tio.object->tio.DIMSTYLE_CONTROL->objid = num;
dwg->dimstyle_control = *obj->tio.object->tio.DIMSTYLE_CONTROL;
}
break;
case DWG_TYPE_DIMSTYLE:
error = dwg_decode_DIMSTYLE (dat, obj);
break;
case DWG_TYPE_VX_CONTROL:
error = dwg_decode_VX_CONTROL (dat, obj);
if (!error && obj->tio.object->tio.VX_CONTROL)
{
obj->tio.object->tio.VX_CONTROL->objid = num;
dwg->vx_control
= *obj->tio.object->tio.VX_CONTROL;
}
break;
case DWG_TYPE_VX_TABLE_RECORD:
error = dwg_decode_VX_TABLE_RECORD (dat, obj);
break;
case DWG_TYPE_GROUP:
error = dwg_decode_GROUP (dat, obj);
break;
case DWG_TYPE_MLINESTYLE:
error = dwg_decode_MLINESTYLE (dat, obj);
break;
case DWG_TYPE_OLE2FRAME:
error = dwg_decode_OLE2FRAME (dat, obj);
break;
case DWG_TYPE_DUMMY:
error = dwg_decode_DUMMY (dat, obj);
break;
case DWG_TYPE_LONG_TRANSACTION:
error = dwg_decode_LONG_TRANSACTION (dat, obj);
break;
case DWG_TYPE_LWPOLYLINE:
error = dwg_decode_LWPOLYLINE (dat, obj);
break;
case DWG_TYPE_HATCH:
error = dwg_decode_HATCH (dat, obj);
break;
case DWG_TYPE_XRECORD:
error = dwg_decode_XRECORD (dat, obj);
break;
case DWG_TYPE_PLACEHOLDER:
error = dwg_decode_PLACEHOLDER (dat, obj);
break;
case DWG_TYPE_OLEFRAME:
error = dwg_decode_OLEFRAME (dat, obj);
break;
case DWG_TYPE_VBA_PROJECT:
LOG_ERROR (""Unhandled Object VBA_PROJECT. Has its own section"");
error = DWG_ERR_UNHANDLEDCLASS;
break;
case DWG_TYPE_LAYOUT:
error = dwg_decode_LAYOUT (dat, obj);
break;
case DWG_TYPE_PROXY_ENTITY:
error = dwg_decode_PROXY_ENTITY (dat, obj);
break;
case DWG_TYPE_PROXY_OBJECT:
error = dwg_decode_PROXY_OBJECT (dat, obj);
break;
default:
if (obj->type == dwg->layout_type)
error = dwg_decode_LAYOUT (dat, obj);
else if ((error = dwg_decode_variable_type (dwg, dat, hdl_dat, obj))
& DWG_ERR_UNHANDLEDCLASS)
{
int is_entity = 0;
int i = obj->type - 500;
Dwg_Class *klass = NULL;
bit_set_position (dat, restartpos);
if (i >= 0 && i < (int)dwg->num_classes)
{
klass = &dwg->dwg_class[i];
is_entity = dwg_class_is_entity (klass);
}
else
{
if (i < 0)
LOG_ERROR (""Invalid class index %d < 0"", i)
else
LOG_ERROR (""Invalid class index %d >= %d"", i,
(int)dwg->num_classes)
obj->type = 0;
*dat = abs_dat;
return error | DWG_ERR_VALUEOUTOFBOUNDS;
}
if (is_entity)
error |= dwg_decode_UNKNOWN_ENT (dat, obj);
else
error |= dwg_decode_UNKNOWN_OBJ (dat, obj);
if (!dat)
return error;
if (error >= DWG_ERR_CRITICAL)
*dat = abs_dat;
}
}
if (obj->handle.value)
{       LOG_HANDLE ("" object_map{%lX} = %lu\n"", obj->handle.value,
(unsigned long)num);
hash_set (dwg->object_map, obj->handle.value, (uint32_t)num);
}
if (dat->byte > 8 * dat->size)
{
LOG_ERROR (""Invalid object address (overflow): %lu > %lu"", dat->byte,
8 * dat->size);
*dat = abs_dat;
return error | DWG_ERR_INVALIDDWG;
}
restartpos = bit_position (dat);
*dat = abs_dat;
bit_set_position (dat, objpos + restartpos);
if (dat->bit)
{
unsigned char r = 8 - dat->bit;
LOG_HANDLE ("" padding: %X/%X (%d bits)\n"", dat->chain[dat->byte],
dat->chain[dat->byte] & ((1 << r) - 1), r);
bit_advance_position (dat, r);
}
bit_set_position (dat, (obj->address + obj->size) * 8 - 2);
if (!bit_check_CRC (dat, address, 0xC0C1))
error |= DWG_ERR_WRONGCRC;
*dat = abs_dat;
return realloced ? -1 : error; }","int
dwg_decode_add_object (Dwg_Data *restrict VAR_0, Bit_Chain *VAR_1,
Bit_Chain *VAR_2, long unsigned int VAR_3)
{
long unsigned int VAR_4, VAR_5;
Bit_Chain VAR_6 = { NULL };
unsigned char VAR_7;
Dwg_Object *restrict VAR_8;
BITCODE_BL VAR_9 = VAR_0->num_objects;
int VAR_10 = 0;
int VAR_11 = 0;
VAR_6 = *VAR_1;
VAR_1->byte = VAR_3;
VAR_1->bit = 0;
VAR_11 = dwg_add_object (VAR_0);
if (VAR_11 > 0)
{
*VAR_1 = VAR_6;
return VAR_11; 
}
VAR_8 = &VAR_0->object[VAR_9];
LOG_INFO (""==========================================\n""
""Object number: %lu/%lX"",
(unsigned long)VAR_9, (unsigned long)VAR_9)
VAR_8->size = bit_read_MS (VAR_1);
LOG_INFO ("", Size: %d [MS]"", VAR_8->size)
SINCE (VAR_12)
{
VAR_8->handlestream_size = bit_read_UMC (VAR_1);
LOG_INFO ("", Hdlsize: "" VAR_13 "" [UMC] "", VAR_8->handlestream_size);
VAR_8->bitsize = VAR_8->size * 8 - VAR_8->handlestream_size;
}
VAR_4 = bit_position (VAR_1); 
VAR_8->address = VAR_1->byte;
bit_reset_chain (VAR_1);
if (VAR_8->size > VAR_1->size || VAR_1->chain + VAR_1->size > VAR_6.chain + VAR_6.size)
{
LOG_TRACE (""\n"");
LOG_WARN (""Invalid object size %u > %ld. Would overflow"", VAR_8->size,
VAR_1->size);
VAR_10 |= VAR_14;
#if 0
VAR_8->size = VAR_1->size - 1;
#else
*VAR_1 = VAR_6;
return VAR_10;
#endif
}
VAR_1->size = VAR_8->size;
SINCE (VAR_12) { VAR_8->type = bit_read_BOT (VAR_1); }
else { VAR_8->type = bit_read_BS (VAR_1); }
LOG_INFO ("", Type: %d [%s], Address: %lu\n"", VAR_8->type,
VAR_1->from_version >= VAR_12 ? ""BOT"" : ""BS"", VAR_8->address);
VAR_5 = bit_position (VAR_1); 
switch (VAR_8->type)
{
case VAR_15:
VAR_10 = dwg_decode_TEXT (VAR_1, VAR_8);
break;
case VAR_16:
VAR_10 = dwg_decode_ATTRIB (VAR_1, VAR_8);
break;
case VAR_17:
VAR_10 = dwg_decode_ATTDEF (VAR_1, VAR_8);
break;
case VAR_18:
VAR_10 = dwg_decode_BLOCK (VAR_1, VAR_8);
break;
case VAR_19:
VAR_10 = dwg_decode_ENDBLK (VAR_1, VAR_8);
break;
case VAR_20:
VAR_10 = dwg_decode_SEQEND (VAR_1, VAR_8);
if (VAR_1->from_version >= VAR_21 && VAR_8->tio.entity->ownerhandle)
{
Dwg_Object *restrict VAR_22 = dwg_resolve_handle (
VAR_0, VAR_8->tio.entity->ownerhandle->absolute_ref);
if (!VAR_22)
{
LOG_WARN (""no SEQEND.ownerhandle"")
}
else if (VAR_22->fixedtype == VAR_23
|| VAR_22->fixedtype == VAR_24)
{
hash_set (VAR_0->object_map, VAR_8->handle.value, (uint32_t)VAR_9);
(void)dwg_validate_INSERT (VAR_22);
}
else if (VAR_22->fixedtype == VAR_25
|| VAR_22->fixedtype == VAR_26
|| VAR_22->fixedtype == VAR_27
|| VAR_22->fixedtype == VAR_28)
{
Dwg_Entity_POLYLINE_2D *restrict VAR_29
= VAR_22->tio.entity->tio.POLYLINE_2D;
if (!VAR_29->seqend)
hash_set (VAR_0->object_map, VAR_8->handle.value, (uint32_t)VAR_9);
(void)dwg_validate_POLYLINE (VAR_22);
}
}
break;
case VAR_23:
VAR_10 = dwg_decode_INSERT (VAR_1, VAR_8);
break;
case VAR_24:
VAR_10 = dwg_decode_MINSERT (VAR_1, VAR_8);
break;
case VAR_30:
VAR_10 = dwg_decode_VERTEX_2D (VAR_1, VAR_8);
break;
case VAR_31:
VAR_10 = dwg_decode_VERTEX_3D (VAR_1, VAR_8);
break;
case VAR_32:
VAR_10 = dwg_decode_VERTEX_MESH (VAR_1, VAR_8);
break;
case VAR_33:
VAR_10 = dwg_decode_VERTEX_PFACE (VAR_1, VAR_8);
break;
case VAR_34:
VAR_10 = dwg_decode_VERTEX_PFACE_FACE (VAR_1, VAR_8);
break;
case VAR_25:
VAR_10 = dwg_decode_POLYLINE_2D (VAR_1, VAR_8);
if (VAR_1->from_version >= VAR_12)
check_POLYLINE_handles (VAR_8);
break;
case VAR_26:
VAR_10 = dwg_decode_POLYLINE_3D (VAR_1, VAR_8);
if (VAR_1->from_version >= VAR_12)
check_POLYLINE_handles (VAR_8);
break;
case VAR_35:
VAR_10 = dwg_decode_ARC (VAR_1, VAR_8);
break;
case VAR_36:
VAR_10 = dwg_decode_CIRCLE (VAR_1, VAR_8);
break;
case VAR_37:
VAR_10 = dwg_decode_LINE (VAR_1, VAR_8);
break;
case VAR_38:
VAR_10 = dwg_decode_DIMENSION_ORDINATE (VAR_1, VAR_8);
break;
case VAR_39:
VAR_10 = dwg_decode_DIMENSION_LINEAR (VAR_1, VAR_8);
break;
case VAR_40:
VAR_10 = dwg_decode_DIMENSION_ALIGNED (VAR_1, VAR_8);
break;
case VAR_41:
VAR_10 = dwg_decode_DIMENSION_ANG3PT (VAR_1, VAR_8);
break;
case VAR_42:
VAR_10 = dwg_decode_DIMENSION_ANG2LN (VAR_1, VAR_8);
break;
case VAR_43:
VAR_10 = dwg_decode_DIMENSION_RADIUS (VAR_1, VAR_8);
break;
case VAR_44:
VAR_10 = dwg_decode_DIMENSION_DIAMETER (VAR_1, VAR_8);
break;
case VAR_45:
VAR_10 = dwg_decode_POINT (VAR_1, VAR_8);
break;
case VAR_46:
VAR_10 = dwg_decode__3DFACE (VAR_1, VAR_8);
break;
case VAR_27:
VAR_10 = dwg_decode_POLYLINE_PFACE (VAR_1, VAR_8);
if (VAR_1->from_version >= VAR_12)
check_POLYLINE_handles (VAR_8);
break;
case VAR_28:
VAR_10 = dwg_decode_POLYLINE_MESH (VAR_1, VAR_8);
if (VAR_1->from_version >= VAR_12)
check_POLYLINE_handles (VAR_8);
break;
case VAR_47:
VAR_10 = dwg_decode_SOLID (VAR_1, VAR_8);
break;
case VAR_48:
VAR_10 = dwg_decode_TRACE (VAR_1, VAR_8);
break;
case VAR_49:
VAR_10 = dwg_decode_SHAPE (VAR_1, VAR_8);
break;
case VAR_50:
VAR_10 = dwg_decode_VIEWPORT (VAR_1, VAR_8);
break;
case VAR_51:
VAR_10 = dwg_decode_ELLIPSE (VAR_1, VAR_8);
break;
case VAR_52:
VAR_10 = dwg_decode_SPLINE (VAR_1, VAR_8);
break;
case VAR_53:
VAR_10 = dwg_decode_REGION (VAR_1, VAR_8);
break;
case VAR_54:
VAR_10 = dwg_decode__3DSOLID (VAR_1, VAR_8);
break;
case VAR_55:
VAR_10 = dwg_decode_BODY (VAR_1, VAR_8);
break;
case VAR_56:
VAR_10 = dwg_decode_RAY (VAR_1, VAR_8);
break;
case VAR_57:
VAR_10 = dwg_decode_XLINE (VAR_1, VAR_8);
break;
case VAR_58:
VAR_10 = dwg_decode_DICTIONARY (VAR_1, VAR_8);
break;
case VAR_59:
VAR_10 = dwg_decode_MTEXT (VAR_1, VAR_8);
break;
case VAR_60:
VAR_10 = dwg_decode_LEADER (VAR_1, VAR_8);
break;
case VAR_61:
VAR_10 = dwg_decode_TOLERANCE (VAR_1, VAR_8);
break;
case VAR_62:
VAR_10 = dwg_decode_MLINE (VAR_1, VAR_8);
break;
case VAR_63:
VAR_10 = dwg_decode_BLOCK_CONTROL (VAR_1, VAR_8);
if (!VAR_10 && VAR_8->tio.object->tio.BLOCK_CONTROL)
{
VAR_8->tio.object->tio.BLOCK_CONTROL->objid = VAR_9;
if (!VAR_0->block_control.parent) 
VAR_0->block_control = *VAR_8->tio.object->tio.BLOCK_CONTROL;
else
LOG_WARN (""Second BLOCK_CONTROL object ignored"");
}
break;
case VAR_64:
VAR_10 = dwg_decode_BLOCK_HEADER (VAR_1, VAR_8);
break;
case VAR_65:
VAR_10 = dwg_decode_LAYER_CONTROL (VAR_1, VAR_8);
if (!VAR_10 && VAR_8->tio.object->tio.LAYER_CONTROL)
{
VAR_8->tio.object->tio.LAYER_CONTROL->objid = VAR_9;
VAR_0->layer_control = *VAR_8->tio.object->tio.LAYER_CONTROL;
}
break;
case VAR_66:
VAR_10 = dwg_decode_LAYER (VAR_1, VAR_8);
break;
case VAR_67:
VAR_10 = dwg_decode_STYLE_CONTROL (VAR_1, VAR_8);
if (!VAR_10 && VAR_8->tio.object->tio.STYLE_CONTROL)
{
VAR_8->tio.object->tio.STYLE_CONTROL->objid = VAR_9;
VAR_0->style_control = *VAR_8->tio.object->tio.STYLE_CONTROL;
}
break;
case VAR_68:
VAR_10 = dwg_decode_STYLE (VAR_1, VAR_8);
break;
case VAR_69:
VAR_10 = dwg_decode_LTYPE_CONTROL (VAR_1, VAR_8);
if (!VAR_10 && VAR_8->tio.object->tio.LTYPE_CONTROL)
{
VAR_8->tio.object->tio.LTYPE_CONTROL->objid = VAR_9;
VAR_0->ltype_control = *VAR_8->tio.object->tio.LTYPE_CONTROL;
}
break;
case VAR_70:
VAR_10 = dwg_decode_LTYPE (VAR_1, VAR_8);
break;
case VAR_71:
VAR_10 = dwg_decode_VIEW_CONTROL (VAR_1, VAR_8);
if (!VAR_10 && VAR_8->tio.object->tio.VIEW_CONTROL)
{
VAR_8->tio.object->tio.VIEW_CONTROL->objid = VAR_9;
VAR_0->view_control = *VAR_8->tio.object->tio.VIEW_CONTROL;
}
break;
case VAR_72:
VAR_10 = dwg_decode_VIEW (VAR_1, VAR_8);
break;
case VAR_73:
VAR_10 = dwg_decode_UCS_CONTROL (VAR_1, VAR_8);
if (!VAR_10 && VAR_8->tio.object->tio.UCS_CONTROL)
{
VAR_8->tio.object->tio.UCS_CONTROL->objid = VAR_9;
VAR_0->ucs_control = *VAR_8->tio.object->tio.UCS_CONTROL;
}
break;
case VAR_74:
VAR_10 = dwg_decode_UCS (VAR_1, VAR_8);
break;
case VAR_75:
VAR_10 = dwg_decode_VPORT_CONTROL (VAR_1, VAR_8);
if (!VAR_10 && VAR_8->tio.object->tio.VPORT_CONTROL)
{
VAR_8->tio.object->tio.VPORT_CONTROL->objid = VAR_9;
VAR_0->vport_control = *VAR_8->tio.object->tio.VPORT_CONTROL;
}
break;
case VAR_76:
VAR_10 = dwg_decode_VPORT (VAR_1, VAR_8);
break;
case VAR_77:
VAR_10 = dwg_decode_APPID_CONTROL (VAR_1, VAR_8);
if (!VAR_10 && VAR_8->tio.object->tio.APPID_CONTROL)
{
VAR_8->tio.object->tio.APPID_CONTROL->objid = VAR_9;
VAR_0->appid_control = *VAR_8->tio.object->tio.APPID_CONTROL;
}
break;
case VAR_78:
VAR_10 = dwg_decode_APPID (VAR_1, VAR_8);
break;
case VAR_79:
VAR_10 = dwg_decode_DIMSTYLE_CONTROL (VAR_1, VAR_8);
if (!VAR_10 && VAR_8->tio.object->tio.DIMSTYLE_CONTROL)
{
VAR_8->tio.object->tio.DIMSTYLE_CONTROL->objid = VAR_9;
VAR_0->dimstyle_control = *VAR_8->tio.object->tio.DIMSTYLE_CONTROL;
}
break;
case VAR_80:
VAR_10 = dwg_decode_DIMSTYLE (VAR_1, VAR_8);
break;
case VAR_81:
VAR_10 = dwg_decode_VX_CONTROL (VAR_1, VAR_8);
if (!VAR_10 && VAR_8->tio.object->tio.VX_CONTROL)
{
VAR_8->tio.object->tio.VX_CONTROL->objid = VAR_9;
VAR_0->vx_control
= *VAR_8->tio.object->tio.VX_CONTROL;
}
break;
case VAR_82:
VAR_10 = dwg_decode_VX_TABLE_RECORD (VAR_1, VAR_8);
break;
case VAR_83:
VAR_10 = dwg_decode_GROUP (VAR_1, VAR_8);
break;
case VAR_84:
VAR_10 = dwg_decode_MLINESTYLE (VAR_1, VAR_8);
break;
case VAR_85:
VAR_10 = dwg_decode_OLE2FRAME (VAR_1, VAR_8);
break;
case VAR_86:
VAR_10 = dwg_decode_DUMMY (VAR_1, VAR_8);
break;
case VAR_87:
VAR_10 = dwg_decode_LONG_TRANSACTION (VAR_1, VAR_8);
break;
case VAR_88:
VAR_10 = dwg_decode_LWPOLYLINE (VAR_1, VAR_8);
break;
case VAR_89:
VAR_10 = dwg_decode_HATCH (VAR_1, VAR_8);
break;
case VAR_90:
VAR_10 = dwg_decode_XRECORD (VAR_1, VAR_8);
break;
case VAR_91:
VAR_10 = dwg_decode_PLACEHOLDER (VAR_1, VAR_8);
break;
case VAR_92:
VAR_10 = dwg_decode_OLEFRAME (VAR_1, VAR_8);
break;
case VAR_93:
LOG_ERROR (""Unhandled Object VBA_PROJECT. Has its own section"");
VAR_10 = VAR_94;
break;
case VAR_95:
VAR_10 = dwg_decode_LAYOUT (VAR_1, VAR_8);
break;
case VAR_96:
VAR_10 = dwg_decode_PROXY_ENTITY (VAR_1, VAR_8);
break;
case VAR_97:
VAR_10 = dwg_decode_PROXY_OBJECT (VAR_1, VAR_8);
break;
default:
if (VAR_8->type == VAR_0->layout_type)
VAR_10 = dwg_decode_LAYOUT (VAR_1, VAR_8);
else if ((VAR_10 = dwg_decode_variable_type (VAR_0, VAR_1, VAR_2, VAR_8))
& VAR_94)
{
int VAR_98 = 0;
int VAR_99 = VAR_8->type - 500;
Dwg_Class *VAR_100 = NULL;
bit_set_position (VAR_1, VAR_5);
if (VAR_99 >= 0 && VAR_99 < (int)VAR_0->num_classes)
{
VAR_100 = &VAR_0->dwg_class[VAR_99];
VAR_98 = dwg_class_is_entity (VAR_100);
}
else
{
if (VAR_99 < 0)
LOG_ERROR (""Invalid class index %d < 0"", VAR_99)
else
VAR_101 (""Invalid class index %d >= %d"", VAR_99,
(int)VAR_0->num_classes)
VAR_8->type = 0;
*VAR_1 = VAR_6;
return VAR_10 | VAR_14;
}
if (VAR_98)
VAR_10 |= dwg_decode_UNKNOWN_ENT (VAR_1, VAR_8);
else
VAR_10 |= dwg_decode_UNKNOWN_OBJ (VAR_1, VAR_8);
if (!VAR_1)
return VAR_10;
if (VAR_10 >= VAR_102)
*VAR_1 = VAR_6;
}
}
if (VAR_8->handle.value)
{ 
LOG_HANDLE ("" object_map{%lX} = %lu\n"", VAR_8->handle.value,
(unsigned long)VAR_9);
hash_set (VAR_0->object_map, VAR_8->handle.value, (uint32_t)VAR_9);
}
if (VAR_1->byte > 8 * VAR_1->size)
{
VAR_101 (""Invalid object address (overflow): %lu > %lu"", VAR_1->byte,
8 * VAR_1->size);
*VAR_1 = VAR_6;
return VAR_10 | VAR_103;
}
VAR_5 = bit_position (VAR_1);
*VAR_1 = VAR_6;
bit_set_position (VAR_1, VAR_4 + VAR_5);
if (VAR_1->bit)
{
unsigned char VAR_104 = 8 - VAR_1->bit;
LOG_HANDLE ("" padding: %X/%X (%d bits)\n"", VAR_1->chain[VAR_1->byte],
VAR_1->chain[VAR_1->byte] & ((1 << VAR_104) - 1), VAR_104);
bit_advance_position (VAR_1, VAR_104);
}
bit_set_position (VAR_1, (VAR_8->address + VAR_8->size) * 8 - 2);
if (!bit_check_CRC (VAR_1, VAR_3, 0xC0C1))
VAR_10 |= VAR_105;
*VAR_1 = VAR_6;
return VAR_11 ? -1 : VAR_10; 
}",LibreDWG/libredwg/8ebc76a03390197745a94b4e2d374aee636b84a7/decode.c/vul/before/1.json,"int
dwg_decode_add_object (Dwg_Data *restrict dwg, Bit_Chain *dat,
                       Bit_Chain *hdl_dat, long unsigned int address)
{
  long unsigned int objpos, restartpos;
  Bit_Chain abs_dat = { NULL };
  unsigned char previous_bit;
  Dwg_Object *restrict obj;
  BITCODE_BL num = dwg->num_objects;
  int error = 0;
  int realloced = 0;

  /* Keep the previous full chain  */
  abs_dat = *dat;

  /* Use the indicated address for the object
   */
  dat->byte = address;
  dat->bit = 0;

  // DEBUG_HERE;
  /*
   * Reserve memory space for objects. A realloc violates all internal
   * pointers.
   */
  realloced = dwg_add_object (dwg);
  if (realloced > 0)
    {
      *dat = abs_dat;
      return realloced; // i.e. DWG_ERR_OUTOFMEM
    }
  obj = &dwg->object[num];
  LOG_INFO (""==========================================\n""
            ""Object number: %lu/%lX"",
            (unsigned long)num, (unsigned long)num)

  obj->size = bit_read_MS (dat);
  LOG_INFO ("", Size: %d [MS]"", obj->size)
  SINCE (R_2010)
  {
    /* This is not counted in the object size */
    obj->handlestream_size = bit_read_UMC (dat);
    LOG_INFO ("", Hdlsize: "" FORMAT_UMC "" [UMC] "", obj->handlestream_size);
    obj->bitsize = obj->size * 8 - obj->handlestream_size;
    // TODO boundscheck
  }

  objpos = bit_position (dat); // absolute
  obj->address = dat->byte;

  /* Until here dat is absolute. now restrict it */
  bit_reset_chain (dat);
  if (obj->size > dat->size || dat->chain + dat->size > abs_dat.chain + abs_dat.size)
    {
      LOG_TRACE (""\n"");
      LOG_WARN (""Invalid object size %u > %ld. Would overflow"", obj->size,
                 dat->size);
      error |= DWG_ERR_VALUEOUTOFBOUNDS;
#if 0
      obj->size = dat->size - 1;
#else
      *dat = abs_dat;
      return error;
#endif
    }
  dat->size = obj->size;

  SINCE (R_2010) { obj->type = bit_read_BOT (dat); }
  else { obj->type = bit_read_BS (dat); }
  LOG_INFO ("", Type: %d [%s], Address: %lu\n"", obj->type,
            dat->from_version >= R_2010 ? ""BOT"" : ""BS"", obj->address);
  restartpos = bit_position (dat); // relative

  /* Check the type of the object
   */
  switch (obj->type)
    {
    case DWG_TYPE_TEXT:
      error = dwg_decode_TEXT (dat, obj);
      break;
    case DWG_TYPE_ATTRIB:
      error = dwg_decode_ATTRIB (dat, obj);
      break;
    case DWG_TYPE_ATTDEF:
      error = dwg_decode_ATTDEF (dat, obj);
      break;
    case DWG_TYPE_BLOCK:
      error = dwg_decode_BLOCK (dat, obj);
      break;
    case DWG_TYPE_ENDBLK:
      error = dwg_decode_ENDBLK (dat, obj);
      break;
    case DWG_TYPE_SEQEND:
      error = dwg_decode_SEQEND (dat, obj);
      if (dat->from_version >= R_13 && obj->tio.entity->ownerhandle)
        {
          Dwg_Object *restrict owner = dwg_resolve_handle (
              dwg, obj->tio.entity->ownerhandle->absolute_ref);
          if (!owner)
            {
              LOG_WARN (""no SEQEND.ownerhandle"")
            }
          else if (owner->fixedtype == DWG_TYPE_INSERT
                   || owner->fixedtype == DWG_TYPE_MINSERT)
            {
              /* SEQEND handle for the owner needed in validate_INSERT */
              hash_set (dwg->object_map, obj->handle.value, (uint32_t)num);
              (void)dwg_validate_INSERT (owner);
            }
          else if (owner->fixedtype == DWG_TYPE_POLYLINE_2D
                   || owner->fixedtype == DWG_TYPE_POLYLINE_3D
                   || owner->fixedtype == DWG_TYPE_POLYLINE_PFACE
                   || owner->fixedtype == DWG_TYPE_POLYLINE_MESH)
            {
              Dwg_Entity_POLYLINE_2D *restrict _obj
                  = owner->tio.entity->tio.POLYLINE_2D;
              if (!_obj->seqend)
                /* SEQEND handle for the owner needed in validate_POLYLINE */
                hash_set (dwg->object_map, obj->handle.value, (uint32_t)num);
              (void)dwg_validate_POLYLINE (owner);
            }
        }
      break;
    case DWG_TYPE_INSERT:
      error = dwg_decode_INSERT (dat, obj);
      break;
    case DWG_TYPE_MINSERT:
      error = dwg_decode_MINSERT (dat, obj);
      break;
    case DWG_TYPE_VERTEX_2D:
      error = dwg_decode_VERTEX_2D (dat, obj);
      break;
    case DWG_TYPE_VERTEX_3D:
      error = dwg_decode_VERTEX_3D (dat, obj);
      break;
    case DWG_TYPE_VERTEX_MESH:
      error = dwg_decode_VERTEX_MESH (dat, obj);
      break;
    case DWG_TYPE_VERTEX_PFACE:
      error = dwg_decode_VERTEX_PFACE (dat, obj);
      break;
    case DWG_TYPE_VERTEX_PFACE_FACE:
      error = dwg_decode_VERTEX_PFACE_FACE (dat, obj);
      break;
    case DWG_TYPE_POLYLINE_2D:
      error = dwg_decode_POLYLINE_2D (dat, obj);
      if (dat->from_version >= R_2010 && error < DWG_ERR_CRITICAL)
        check_POLYLINE_handles (obj);
      break;
    case DWG_TYPE_POLYLINE_3D:
      error = dwg_decode_POLYLINE_3D (dat, obj);
      if (dat->from_version >= R_2010 && error < DWG_ERR_CRITICAL)
        check_POLYLINE_handles (obj);
      break;
    case DWG_TYPE_ARC:
      error = dwg_decode_ARC (dat, obj);
      break;
    case DWG_TYPE_CIRCLE:
      error = dwg_decode_CIRCLE (dat, obj);
      break;
    case DWG_TYPE_LINE:
      error = dwg_decode_LINE (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_ORDINATE:
      error = dwg_decode_DIMENSION_ORDINATE (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_LINEAR:
      error = dwg_decode_DIMENSION_LINEAR (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_ALIGNED:
      error = dwg_decode_DIMENSION_ALIGNED (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_ANG3PT:
      error = dwg_decode_DIMENSION_ANG3PT (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_ANG2LN:
      error = dwg_decode_DIMENSION_ANG2LN (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_RADIUS:
      error = dwg_decode_DIMENSION_RADIUS (dat, obj);
      break;
    case DWG_TYPE_DIMENSION_DIAMETER:
      error = dwg_decode_DIMENSION_DIAMETER (dat, obj);
      break;
    case DWG_TYPE_POINT:
      error = dwg_decode_POINT (dat, obj);
      break;
    case DWG_TYPE__3DFACE:
      error = dwg_decode__3DFACE (dat, obj);
      break;
    case DWG_TYPE_POLYLINE_PFACE:
      error = dwg_decode_POLYLINE_PFACE (dat, obj);
      if (dat->from_version >= R_2010 && error < DWG_ERR_CRITICAL)
        check_POLYLINE_handles (obj);
      break;
    case DWG_TYPE_POLYLINE_MESH:
      error = dwg_decode_POLYLINE_MESH (dat, obj);
      if (dat->from_version >= R_2010)
        check_POLYLINE_handles (obj);
      break;
    case DWG_TYPE_SOLID:
      error = dwg_decode_SOLID (dat, obj);
      break;
    case DWG_TYPE_TRACE:
      error = dwg_decode_TRACE (dat, obj);
      break;
    case DWG_TYPE_SHAPE:
      error = dwg_decode_SHAPE (dat, obj);
      break;
    case DWG_TYPE_VIEWPORT:
      error = dwg_decode_VIEWPORT (dat, obj);
      break;
    case DWG_TYPE_ELLIPSE:
      error = dwg_decode_ELLIPSE (dat, obj);
      break;
    case DWG_TYPE_SPLINE:
      error = dwg_decode_SPLINE (dat, obj);
      break;
    case DWG_TYPE_REGION:
      error = dwg_decode_REGION (dat, obj);
      break;
    case DWG_TYPE__3DSOLID:
      error = dwg_decode__3DSOLID (dat, obj);
      break;
    case DWG_TYPE_BODY:
      error = dwg_decode_BODY (dat, obj);
      break;
    case DWG_TYPE_RAY:
      error = dwg_decode_RAY (dat, obj);
      break;
    case DWG_TYPE_XLINE:
      error = dwg_decode_XLINE (dat, obj);
      break;
    case DWG_TYPE_DICTIONARY:
      error = dwg_decode_DICTIONARY (dat, obj);
      break;
    case DWG_TYPE_MTEXT:
      error = dwg_decode_MTEXT (dat, obj);
      break;
    case DWG_TYPE_LEADER:
      error = dwg_decode_LEADER (dat, obj);
      break;
    case DWG_TYPE_TOLERANCE:
      error = dwg_decode_TOLERANCE (dat, obj);
      break;
    case DWG_TYPE_MLINE:
      error = dwg_decode_MLINE (dat, obj);
      break;
    case DWG_TYPE_BLOCK_CONTROL:
      error = dwg_decode_BLOCK_CONTROL (dat, obj);
      if (!error && obj->tio.object->tio.BLOCK_CONTROL)
        {
          obj->tio.object->tio.BLOCK_CONTROL->objid = num;
          if (!dwg->block_control.parent) // only once
            dwg->block_control = *obj->tio.object->tio.BLOCK_CONTROL;
          else
            LOG_WARN (""Second BLOCK_CONTROL object ignored"");
        }
      break;
    case DWG_TYPE_BLOCK_HEADER:
      error = dwg_decode_BLOCK_HEADER (dat, obj);
      /*
       * We cannot cache dwg->*space_block here as dwg->objects might get
       * realloc'ed. See dwg_model_space_object() and dwg_paper_space_object()
       * instead.
       */
      break;
    case DWG_TYPE_LAYER_CONTROL:
      error = dwg_decode_LAYER_CONTROL (dat, obj);
      if (!error && obj->tio.object->tio.LAYER_CONTROL)
        {
          obj->tio.object->tio.LAYER_CONTROL->objid = num;
          dwg->layer_control = *obj->tio.object->tio.LAYER_CONTROL;
        }
      break;
    case DWG_TYPE_LAYER:
      error = dwg_decode_LAYER (dat, obj);
      break;
    case DWG_TYPE_STYLE_CONTROL:
      error = dwg_decode_STYLE_CONTROL (dat, obj);
      if (!error && obj->tio.object->tio.STYLE_CONTROL)
        {
          obj->tio.object->tio.STYLE_CONTROL->objid = num;
          dwg->style_control = *obj->tio.object->tio.STYLE_CONTROL;
        }
      break;
    case DWG_TYPE_STYLE:
      error = dwg_decode_STYLE (dat, obj);
      break;
    case DWG_TYPE_LTYPE_CONTROL:
      error = dwg_decode_LTYPE_CONTROL (dat, obj);
      if (!error && obj->tio.object->tio.LTYPE_CONTROL)
        {
          obj->tio.object->tio.LTYPE_CONTROL->objid = num;
          dwg->ltype_control = *obj->tio.object->tio.LTYPE_CONTROL;
        }
      break;
    case DWG_TYPE_LTYPE:
      error = dwg_decode_LTYPE (dat, obj);
      break;
    case DWG_TYPE_VIEW_CONTROL:
      error = dwg_decode_VIEW_CONTROL (dat, obj);
      if (!error && obj->tio.object->tio.VIEW_CONTROL)
        {
          obj->tio.object->tio.VIEW_CONTROL->objid = num;
          dwg->view_control = *obj->tio.object->tio.VIEW_CONTROL;
        }
      break;
    case DWG_TYPE_VIEW:
      error = dwg_decode_VIEW (dat, obj);
      break;
    case DWG_TYPE_UCS_CONTROL:
      error = dwg_decode_UCS_CONTROL (dat, obj);
      if (!error && obj->tio.object->tio.UCS_CONTROL)
        {
          obj->tio.object->tio.UCS_CONTROL->objid = num;
          dwg->ucs_control = *obj->tio.object->tio.UCS_CONTROL;
        }
      break;
    case DWG_TYPE_UCS:
      error = dwg_decode_UCS (dat, obj);
      break;
    case DWG_TYPE_VPORT_CONTROL:
      error = dwg_decode_VPORT_CONTROL (dat, obj);
      if (!error && obj->tio.object->tio.VPORT_CONTROL)
        {
          obj->tio.object->tio.VPORT_CONTROL->objid = num;
          dwg->vport_control = *obj->tio.object->tio.VPORT_CONTROL;
        }
      break;
    case DWG_TYPE_VPORT:
      error = dwg_decode_VPORT (dat, obj);
      break;
    case DWG_TYPE_APPID_CONTROL:
      error = dwg_decode_APPID_CONTROL (dat, obj);
      if (!error && obj->tio.object->tio.APPID_CONTROL)
        {
          obj->tio.object->tio.APPID_CONTROL->objid = num;
          dwg->appid_control = *obj->tio.object->tio.APPID_CONTROL;
        }
      break;
    case DWG_TYPE_APPID:
      error = dwg_decode_APPID (dat, obj);
      break;
    case DWG_TYPE_DIMSTYLE_CONTROL:
      error = dwg_decode_DIMSTYLE_CONTROL (dat, obj);
      if (!error && obj->tio.object->tio.DIMSTYLE_CONTROL)
        {
          obj->tio.object->tio.DIMSTYLE_CONTROL->objid = num;
          dwg->dimstyle_control = *obj->tio.object->tio.DIMSTYLE_CONTROL;
        }
      break;
    case DWG_TYPE_DIMSTYLE:
      error = dwg_decode_DIMSTYLE (dat, obj);
      break;
    case DWG_TYPE_VX_CONTROL:
      error = dwg_decode_VX_CONTROL (dat, obj);
      if (!error && obj->tio.object->tio.VX_CONTROL)
        {
          obj->tio.object->tio.VX_CONTROL->objid = num;
          dwg->vx_control
              = *obj->tio.object->tio.VX_CONTROL;
        }
      break;
    case DWG_TYPE_VX_TABLE_RECORD:
      error = dwg_decode_VX_TABLE_RECORD (dat, obj);
      break;
    case DWG_TYPE_GROUP:
      error = dwg_decode_GROUP (dat, obj);
      break;
    case DWG_TYPE_MLINESTYLE:
      error = dwg_decode_MLINESTYLE (dat, obj);
      break;
    case DWG_TYPE_OLE2FRAME:
      error = dwg_decode_OLE2FRAME (dat, obj);
      break;
    case DWG_TYPE_DUMMY:
      error = dwg_decode_DUMMY (dat, obj);
      break;
    case DWG_TYPE_LONG_TRANSACTION:
      error = dwg_decode_LONG_TRANSACTION (dat, obj);
      break;
    case DWG_TYPE_LWPOLYLINE:
      error = dwg_decode_LWPOLYLINE (dat, obj);
      break;
    case DWG_TYPE_HATCH:
      error = dwg_decode_HATCH (dat, obj);
      break;
    case DWG_TYPE_XRECORD:
      error = dwg_decode_XRECORD (dat, obj);
      break;
    case DWG_TYPE_PLACEHOLDER:
      error = dwg_decode_PLACEHOLDER (dat, obj);
      break;
    case DWG_TYPE_OLEFRAME:
      error = dwg_decode_OLEFRAME (dat, obj);
      break;
    case DWG_TYPE_VBA_PROJECT:
      LOG_ERROR (""Unhandled Object VBA_PROJECT. Has its own section"");
      // dwg_decode_VBA_PROJECT(dat, obj);
      error = DWG_ERR_UNHANDLEDCLASS;
      break;
    case DWG_TYPE_LAYOUT:
      error = dwg_decode_LAYOUT (dat, obj);
      break;
    case DWG_TYPE_PROXY_ENTITY:
      error = dwg_decode_PROXY_ENTITY (dat, obj);
      break;
    case DWG_TYPE_PROXY_OBJECT:
      error = dwg_decode_PROXY_OBJECT (dat, obj);
      break;
    default:
      if (obj->type == dwg->layout_type)
        error = dwg_decode_LAYOUT (dat, obj);
      /* > 500 */
      else if ((error = dwg_decode_variable_type (dwg, dat, hdl_dat, obj))
               & DWG_ERR_UNHANDLEDCLASS)
        {
          int is_entity = 0;
          int i = obj->type - 500;
          Dwg_Class *klass = NULL;

          /* restart and read into the UNKNOWN_OBJ object */
          /* the relative offset from type after common_entity_data */
          // obj->common_size = bit_position(dat) - restartpos;
          // LOG_HANDLE(""common_size: %lu\n"", obj->common_size); // needed for
          // unknown
          bit_set_position (dat, restartpos);

          if (i >= 0 && i < (int)dwg->num_classes)
            {
              klass = &dwg->dwg_class[i];
              is_entity = dwg_class_is_entity (klass);
            }
          else
            {
              if (i < 0)
                LOG_ERROR (""Invalid class index %d < 0"", i)
              else
                LOG_ERROR (""Invalid class index %d >= %d"", i,
                           (int)dwg->num_classes)
              obj->type = 0;
              *dat = abs_dat;
              return error | DWG_ERR_VALUEOUTOFBOUNDS;
            }

          // properly dwg_decode_object/_entity for eed, reactors, xdic
          if (is_entity)
              error |= dwg_decode_UNKNOWN_ENT (dat, obj);
          else
              error |= dwg_decode_UNKNOWN_OBJ (dat, obj);

          if (!dat)
            return error;
          if (error >= DWG_ERR_CRITICAL)
            *dat = abs_dat;
        }
    }

  if (obj->handle.value)
    { // empty only with UNKNOWN
      LOG_HANDLE ("" object_map{%lX} = %lu\n"", obj->handle.value,
                  (unsigned long)num);
      hash_set (dwg->object_map, obj->handle.value, (uint32_t)num);
    }

  if (dat->byte > 8 * dat->size)
    {
      LOG_ERROR (""Invalid object address (overflow): %lu > %lu"", dat->byte,
                 8 * dat->size);
      *dat = abs_dat;
      return error | DWG_ERR_INVALIDDWG;
    }

  /* Restore the old absolute chain.
     CRC needs to be calculated from address, which is before our 0 position.
   */
  restartpos = bit_position (dat);
  *dat = abs_dat;
  bit_set_position (dat, objpos + restartpos);

  /* Now 1 padding bits until next byte, and then a RS CRC */
  if (dat->bit)
    {
      unsigned char r = 8 - dat->bit;
      LOG_HANDLE ("" padding: %X/%X (%d bits)\n"", dat->chain[dat->byte],
                  dat->chain[dat->byte] & ((1 << r) - 1), r);
      bit_advance_position (dat, r);
    }
  bit_set_position (dat, (obj->address + obj->size) * 8 - 2);
  if (!bit_check_CRC (dat, address, 0xC0C1))
    error |= DWG_ERR_WRONGCRC;

  /* Reset to previous addresses for return */
  *dat = abs_dat;

  return realloced ? -1 : error; // re-alloced or not
}","int
dwg_decode_add_object (Dwg_Data *restrict VAR_0, Bit_Chain *VAR_1,
                       Bit_Chain *VAR_2, long unsigned int VAR_3)
{
  long unsigned int VAR_4, VAR_5;
  Bit_Chain VAR_6 = { NULL };
  unsigned char VAR_7;
  Dwg_Object *restrict VAR_8;
  BITCODE_BL VAR_9 = VAR_0->num_objects;
  int VAR_10 = 0;
  int VAR_11 = 0;

  /* COMMENT_0 */
  VAR_6 = *VAR_1;

  /* COMMENT_1 */
     
  VAR_1->byte = VAR_3;
  VAR_1->bit = 0;

  /* COMMENT_3 */
  /* COMMENT_4 */
                                                                      
              
     
  VAR_11 = dwg_add_object (VAR_0);
  if (VAR_11 > 0)
    {
      *VAR_1 = VAR_6;
      return VAR_11; /* COMMENT_8 */
    }
  VAR_8 = &VAR_0->object[VAR_9];
  LOG_INFO (""==========================================\n""
            ""Object number: %lu/%lX"",
            (unsigned long)VAR_9, (unsigned long)VAR_9)

  VAR_8->size = bit_read_MS (VAR_1);
  LOG_INFO ("", Size: %d [MS]"", VAR_8->size)
  SINCE (VAR_12)
  {
    /* COMMENT_9 */
    VAR_8->handlestream_size = bit_read_UMC (VAR_1);
    LOG_INFO ("", Hdlsize: "" VAR_13 "" [UMC] "", VAR_8->handlestream_size);
    VAR_8->bitsize = VAR_8->size * 8 - VAR_8->handlestream_size;
    /* COMMENT_10 */
  }

  VAR_4 = bit_position (VAR_1); /* COMMENT_11 */
  VAR_8->address = VAR_1->byte;

  /* COMMENT_12 */
  bit_reset_chain (VAR_1);
  if (VAR_8->size > VAR_1->size || VAR_1->chain + VAR_1->size > VAR_6.chain + VAR_6.size)
    {
      LOG_TRACE (""\n"");
      LOG_WARN (""Invalid object size %u > %ld. Would overflow"", VAR_8->size,
                 VAR_1->size);
      VAR_10 |= VAR_14;
#if 0
      VAR_8->size = VAR_1->size - 1;
#else
      *VAR_1 = VAR_6;
      return VAR_10;
#endif
    }
  VAR_1->size = VAR_8->size;

  SINCE (VAR_12) { VAR_8->type = bit_read_BOT (VAR_1); }
  else { VAR_8->type = bit_read_BS (VAR_1); }
  LOG_INFO ("", Type: %d [%s], Address: %lu\n"", VAR_8->type,
            VAR_1->from_version >= VAR_12 ? ""BOT"" : ""BS"", VAR_8->address);
  VAR_5 = bit_position (VAR_1); /* COMMENT_13 */

  /* COMMENT_14 */
     
  switch (VAR_8->type)
    {
    case VAR_15:
      VAR_10 = dwg_decode_TEXT (VAR_1, VAR_8);
      break;
    case VAR_16:
      VAR_10 = dwg_decode_ATTRIB (VAR_1, VAR_8);
      break;
    case VAR_17:
      VAR_10 = dwg_decode_ATTDEF (VAR_1, VAR_8);
      break;
    case VAR_18:
      VAR_10 = dwg_decode_BLOCK (VAR_1, VAR_8);
      break;
    case VAR_19:
      VAR_10 = dwg_decode_ENDBLK (VAR_1, VAR_8);
      break;
    case VAR_20:
      VAR_10 = dwg_decode_SEQEND (VAR_1, VAR_8);
      if (VAR_1->from_version >= VAR_21 && VAR_8->tio.entity->ownerhandle)
        {
          Dwg_Object *restrict VAR_22 = dwg_resolve_handle (
              VAR_0, VAR_8->tio.entity->ownerhandle->absolute_ref);
          if (!VAR_22)
            {
              LOG_WARN (""no SEQEND.ownerhandle"")
            }
          else if (VAR_22->fixedtype == VAR_23
                   || VAR_22->fixedtype == VAR_24)
            {
              /* COMMENT_16 */
              hash_set (VAR_0->object_map, VAR_8->handle.value, (uint32_t)VAR_9);
              (void)dwg_validate_INSERT (VAR_22);
            }
          else if (VAR_22->fixedtype == VAR_25
                   || VAR_22->fixedtype == VAR_26
                   || VAR_22->fixedtype == VAR_27
                   || VAR_22->fixedtype == VAR_28)
            {
              Dwg_Entity_POLYLINE_2D *restrict VAR_29
                  = VAR_22->tio.entity->tio.POLYLINE_2D;
              if (!VAR_29->seqend)
                /* COMMENT_17 */
                hash_set (VAR_0->object_map, VAR_8->handle.value, (uint32_t)VAR_9);
              (void)dwg_validate_POLYLINE (VAR_22);
            }
        }
      break;
    case VAR_23:
      VAR_10 = dwg_decode_INSERT (VAR_1, VAR_8);
      break;
    case VAR_24:
      VAR_10 = dwg_decode_MINSERT (VAR_1, VAR_8);
      break;
    case VAR_30:
      VAR_10 = dwg_decode_VERTEX_2D (VAR_1, VAR_8);
      break;
    case VAR_31:
      VAR_10 = dwg_decode_VERTEX_3D (VAR_1, VAR_8);
      break;
    case VAR_32:
      VAR_10 = dwg_decode_VERTEX_MESH (VAR_1, VAR_8);
      break;
    case VAR_33:
      VAR_10 = dwg_decode_VERTEX_PFACE (VAR_1, VAR_8);
      break;
    case VAR_34:
      VAR_10 = dwg_decode_VERTEX_PFACE_FACE (VAR_1, VAR_8);
      break;
    case VAR_25:
      VAR_10 = dwg_decode_POLYLINE_2D (VAR_1, VAR_8);
      if (VAR_1->from_version >= VAR_12 && VAR_10 < VAR_35)
        check_POLYLINE_handles (VAR_8);
      break;
    case VAR_26:
      VAR_10 = dwg_decode_POLYLINE_3D (VAR_1, VAR_8);
      if (VAR_1->from_version >= VAR_12 && VAR_10 < VAR_35)
        check_POLYLINE_handles (VAR_8);
      break;
    case VAR_36:
      VAR_10 = dwg_decode_ARC (VAR_1, VAR_8);
      break;
    case VAR_37:
      VAR_10 = dwg_decode_CIRCLE (VAR_1, VAR_8);
      break;
    case VAR_38:
      VAR_10 = dwg_decode_LINE (VAR_1, VAR_8);
      break;
    case VAR_39:
      VAR_10 = dwg_decode_DIMENSION_ORDINATE (VAR_1, VAR_8);
      break;
    case VAR_40:
      VAR_10 = dwg_decode_DIMENSION_LINEAR (VAR_1, VAR_8);
      break;
    case VAR_41:
      VAR_10 = dwg_decode_DIMENSION_ALIGNED (VAR_1, VAR_8);
      break;
    case VAR_42:
      VAR_10 = dwg_decode_DIMENSION_ANG3PT (VAR_1, VAR_8);
      break;
    case VAR_43:
      VAR_10 = dwg_decode_DIMENSION_ANG2LN (VAR_1, VAR_8);
      break;
    case VAR_44:
      VAR_10 = dwg_decode_DIMENSION_RADIUS (VAR_1, VAR_8);
      break;
    case VAR_45:
      VAR_10 = dwg_decode_DIMENSION_DIAMETER (VAR_1, VAR_8);
      break;
    case VAR_46:
      VAR_10 = dwg_decode_POINT (VAR_1, VAR_8);
      break;
    case VAR_47:
      VAR_10 = dwg_decode__3DFACE (VAR_1, VAR_8);
      break;
    case VAR_27:
      VAR_10 = dwg_decode_POLYLINE_PFACE (VAR_1, VAR_8);
      if (VAR_1->from_version >= VAR_12 && VAR_10 < VAR_35)
        check_POLYLINE_handles (VAR_8);
      break;
    case VAR_28:
      VAR_10 = dwg_decode_POLYLINE_MESH (VAR_1, VAR_8);
      if (VAR_1->from_version >= VAR_12)
        check_POLYLINE_handles (VAR_8);
      break;
    case VAR_48:
      VAR_10 = dwg_decode_SOLID (VAR_1, VAR_8);
      break;
    case VAR_49:
      VAR_10 = dwg_decode_TRACE (VAR_1, VAR_8);
      break;
    case VAR_50:
      VAR_10 = dwg_decode_SHAPE (VAR_1, VAR_8);
      break;
    case VAR_51:
      VAR_10 = dwg_decode_VIEWPORT (VAR_1, VAR_8);
      break;
    case VAR_52:
      VAR_10 = dwg_decode_ELLIPSE (VAR_1, VAR_8);
      break;
    case VAR_53:
      VAR_10 = dwg_decode_SPLINE (VAR_1, VAR_8);
      break;
    case VAR_54:
      VAR_10 = dwg_decode_REGION (VAR_1, VAR_8);
      break;
    case VAR_55:
      VAR_10 = dwg_decode__3DSOLID (VAR_1, VAR_8);
      break;
    case VAR_56:
      VAR_10 = dwg_decode_BODY (VAR_1, VAR_8);
      break;
    case VAR_57:
      VAR_10 = dwg_decode_RAY (VAR_1, VAR_8);
      break;
    case VAR_58:
      VAR_10 = dwg_decode_XLINE (VAR_1, VAR_8);
      break;
    case VAR_59:
      VAR_10 = dwg_decode_DICTIONARY (VAR_1, VAR_8);
      break;
    case VAR_60:
      VAR_10 = dwg_decode_MTEXT (VAR_1, VAR_8);
      break;
    case VAR_61:
      VAR_10 = dwg_decode_LEADER (VAR_1, VAR_8);
      break;
    case VAR_62:
      VAR_10 = dwg_decode_TOLERANCE (VAR_1, VAR_8);
      break;
    case VAR_63:
      VAR_10 = dwg_decode_MLINE (VAR_1, VAR_8);
      break;
    case VAR_64:
      VAR_10 = dwg_decode_BLOCK_CONTROL (VAR_1, VAR_8);
      if (!VAR_10 && VAR_8->tio.object->tio.BLOCK_CONTROL)
        {
          VAR_8->tio.object->tio.BLOCK_CONTROL->objid = VAR_9;
          if (!VAR_0->block_control.parent) /* COMMENT_18 */
            VAR_0->block_control = *VAR_8->tio.object->tio.BLOCK_CONTROL;
          else
            LOG_WARN (""Second BLOCK_CONTROL object ignored"");
        }
      break;
    case VAR_65:
      VAR_10 = dwg_decode_BLOCK_HEADER (VAR_1, VAR_8);
      /* COMMENT_19 */
                                                                         
                                                                              
                 
         
      break;
    case VAR_66:
      VAR_10 = dwg_decode_LAYER_CONTROL (VAR_1, VAR_8);
      if (!VAR_10 && VAR_8->tio.object->tio.LAYER_CONTROL)
        {
          VAR_8->tio.object->tio.LAYER_CONTROL->objid = VAR_9;
          VAR_0->layer_control = *VAR_8->tio.object->tio.LAYER_CONTROL;
        }
      break;
    case VAR_67:
      VAR_10 = dwg_decode_LAYER (VAR_1, VAR_8);
      break;
    case VAR_68:
      VAR_10 = dwg_decode_STYLE_CONTROL (VAR_1, VAR_8);
      if (!VAR_10 && VAR_8->tio.object->tio.STYLE_CONTROL)
        {
          VAR_8->tio.object->tio.STYLE_CONTROL->objid = VAR_9;
          VAR_0->style_control = *VAR_8->tio.object->tio.STYLE_CONTROL;
        }
      break;
    case VAR_69:
      VAR_10 = dwg_decode_STYLE (VAR_1, VAR_8);
      break;
    case VAR_70:
      VAR_10 = dwg_decode_LTYPE_CONTROL (VAR_1, VAR_8);
      if (!VAR_10 && VAR_8->tio.object->tio.LTYPE_CONTROL)
        {
          VAR_8->tio.object->tio.LTYPE_CONTROL->objid = VAR_9;
          VAR_0->ltype_control = *VAR_8->tio.object->tio.LTYPE_CONTROL;
        }
      break;
    case VAR_71:
      VAR_10 = dwg_decode_LTYPE (VAR_1, VAR_8);
      break;
    case VAR_72:
      VAR_10 = dwg_decode_VIEW_CONTROL (VAR_1, VAR_8);
      if (!VAR_10 && VAR_8->tio.object->tio.VIEW_CONTROL)
        {
          VAR_8->tio.object->tio.VIEW_CONTROL->objid = VAR_9;
          VAR_0->view_control = *VAR_8->tio.object->tio.VIEW_CONTROL;
        }
      break;
    case VAR_73:
      VAR_10 = dwg_decode_VIEW (VAR_1, VAR_8);
      break;
    case VAR_74:
      VAR_10 = dwg_decode_UCS_CONTROL (VAR_1, VAR_8);
      if (!VAR_10 && VAR_8->tio.object->tio.UCS_CONTROL)
        {
          VAR_8->tio.object->tio.UCS_CONTROL->objid = VAR_9;
          VAR_0->ucs_control = *VAR_8->tio.object->tio.UCS_CONTROL;
        }
      break;
    case VAR_75:
      VAR_10 = dwg_decode_UCS (VAR_1, VAR_8);
      break;
    case VAR_76:
      VAR_10 = dwg_decode_VPORT_CONTROL (VAR_1, VAR_8);
      if (!VAR_10 && VAR_8->tio.object->tio.VPORT_CONTROL)
        {
          VAR_8->tio.object->tio.VPORT_CONTROL->objid = VAR_9;
          VAR_0->vport_control = *VAR_8->tio.object->tio.VPORT_CONTROL;
        }
      break;
    case VAR_77:
      VAR_10 = dwg_decode_VPORT (VAR_1, VAR_8);
      break;
    case VAR_78:
      VAR_10 = dwg_decode_APPID_CONTROL (VAR_1, VAR_8);
      if (!VAR_10 && VAR_8->tio.object->tio.APPID_CONTROL)
        {
          VAR_8->tio.object->tio.APPID_CONTROL->objid = VAR_9;
          VAR_0->appid_control = *VAR_8->tio.object->tio.APPID_CONTROL;
        }
      break;
    case VAR_79:
      VAR_10 = dwg_decode_APPID (VAR_1, VAR_8);
      break;
    case VAR_80:
      VAR_10 = dwg_decode_DIMSTYLE_CONTROL (VAR_1, VAR_8);
      if (!VAR_10 && VAR_8->tio.object->tio.DIMSTYLE_CONTROL)
        {
          VAR_8->tio.object->tio.DIMSTYLE_CONTROL->objid = VAR_9;
          VAR_0->dimstyle_control = *VAR_8->tio.object->tio.DIMSTYLE_CONTROL;
        }
      break;
    case VAR_81:
      VAR_10 = dwg_decode_DIMSTYLE (VAR_1, VAR_8);
      break;
    case VAR_82:
      VAR_10 = dwg_decode_VX_CONTROL (VAR_1, VAR_8);
      if (!VAR_10 && VAR_8->tio.object->tio.VX_CONTROL)
        {
          VAR_8->tio.object->tio.VX_CONTROL->objid = VAR_9;
          VAR_0->vx_control
              = *VAR_8->tio.object->tio.VX_CONTROL;
        }
      break;
    case VAR_83:
      VAR_10 = dwg_decode_VX_TABLE_RECORD (VAR_1, VAR_8);
      break;
    case VAR_84:
      VAR_10 = dwg_decode_GROUP (VAR_1, VAR_8);
      break;
    case VAR_85:
      VAR_10 = dwg_decode_MLINESTYLE (VAR_1, VAR_8);
      break;
    case VAR_86:
      VAR_10 = dwg_decode_OLE2FRAME (VAR_1, VAR_8);
      break;
    case VAR_87:
      VAR_10 = dwg_decode_DUMMY (VAR_1, VAR_8);
      break;
    case VAR_88:
      VAR_10 = dwg_decode_LONG_TRANSACTION (VAR_1, VAR_8);
      break;
    case VAR_89:
      VAR_10 = dwg_decode_LWPOLYLINE (VAR_1, VAR_8);
      break;
    case VAR_90:
      VAR_10 = dwg_decode_HATCH (VAR_1, VAR_8);
      break;
    case VAR_91:
      VAR_10 = dwg_decode_XRECORD (VAR_1, VAR_8);
      break;
    case VAR_92:
      VAR_10 = dwg_decode_PLACEHOLDER (VAR_1, VAR_8);
      break;
    case VAR_93:
      VAR_10 = dwg_decode_OLEFRAME (VAR_1, VAR_8);
      break;
    case VAR_94:
      LOG_ERROR (""Unhandled Object VBA_PROJECT. Has its own section"");
      /* COMMENT_24 */
      VAR_10 = VAR_95;
      break;
    case VAR_96:
      VAR_10 = dwg_decode_LAYOUT (VAR_1, VAR_8);
      break;
    case VAR_97:
      VAR_10 = dwg_decode_PROXY_ENTITY (VAR_1, VAR_8);
      break;
    case VAR_98:
      VAR_10 = dwg_decode_PROXY_OBJECT (VAR_1, VAR_8);
      break;
    default:
      if (VAR_8->type == VAR_0->layout_type)
        VAR_10 = dwg_decode_LAYOUT (VAR_1, VAR_8);
      /* COMMENT_25 */
      else if ((VAR_10 = dwg_decode_variable_type (VAR_0, VAR_1, VAR_2, VAR_8))
               & VAR_95)
        {
          int VAR_99 = 0;
          int VAR_100 = VAR_8->type - 500;
          Dwg_Class *VAR_101 = NULL;

          /* COMMENT_26 */
          /* COMMENT_27 */
          /* COMMENT_28 */
          /* COMMENT_29 */
          /* COMMENT_30 */
          bit_set_position (VAR_1, VAR_5);

          if (VAR_100 >= 0 && VAR_100 < (int)VAR_0->num_classes)
            {
              VAR_101 = &VAR_0->dwg_class[VAR_100];
              VAR_99 = dwg_class_is_entity (VAR_101);
            }
          else
            {
              if (VAR_100 < 0)
                LOG_ERROR (""Invalid class index %d < 0"", VAR_100)
              else
                VAR_102 (""Invalid class index %d >= %d"", VAR_100,
                           (int)VAR_0->num_classes)
              VAR_8->type = 0;
              *VAR_1 = VAR_6;
              return VAR_10 | VAR_14;
            }

          /* COMMENT_31 */
          if (VAR_99)
              VAR_10 |= dwg_decode_UNKNOWN_ENT (VAR_1, VAR_8);
          else
              VAR_10 |= dwg_decode_UNKNOWN_OBJ (VAR_1, VAR_8);

          if (!VAR_1)
            return VAR_10;
          if (VAR_10 >= VAR_35)
            *VAR_1 = VAR_6;
        }
    }

  if (VAR_8->handle.value)
    { /* COMMENT_32 */
      LOG_HANDLE ("" object_map{%lX} = %lu\n"", VAR_8->handle.value,
                  (unsigned long)VAR_9);
      hash_set (VAR_0->object_map, VAR_8->handle.value, (uint32_t)VAR_9);
    }

  if (VAR_1->byte > 8 * VAR_1->size)
    {
      VAR_102 (""Invalid object address (overflow): %lu > %lu"", VAR_1->byte,
                 8 * VAR_1->size);
      *VAR_1 = VAR_6;
      return VAR_10 | VAR_103;
    }

  /* COMMENT_33 */
                                                                             
     
  VAR_5 = bit_position (VAR_1);
  *VAR_1 = VAR_6;
  bit_set_position (VAR_1, VAR_4 + VAR_5);

  /* COMMENT_36 */
  if (VAR_1->bit)
    {
      unsigned char VAR_104 = 8 - VAR_1->bit;
      LOG_HANDLE ("" padding: %X/%X (%d bits)\n"", VAR_1->chain[VAR_1->byte],
                  VAR_1->chain[VAR_1->byte] & ((1 << VAR_104) - 1), VAR_104);
      bit_advance_position (VAR_1, VAR_104);
    }
  bit_set_position (VAR_1, (VAR_8->address + VAR_8->size) * 8 - 2);
  if (!bit_check_CRC (VAR_1, VAR_3, 0xC0C1))
    VAR_10 |= VAR_105;

  /* COMMENT_37 */
  *VAR_1 = VAR_6;

  return VAR_11 ? -1 : VAR_10; /* COMMENT_38 */
}",LibreDWG/libredwg/8ebc76a03390197745a94b4e2d374aee636b84a7/decode.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -144,12 +144,12 @@
       break;
     case DWG_TYPE_POLYLINE_2D:
       error = dwg_decode_POLYLINE_2D (dat, obj);
-      if (dat->from_version >= R_2010)
+      if (dat->from_version >= R_2010 && error < DWG_ERR_CRITICAL)
         check_POLYLINE_handles (obj);
       break;
     case DWG_TYPE_POLYLINE_3D:
       error = dwg_decode_POLYLINE_3D (dat, obj);
-      if (dat->from_version >= R_2010)
+      if (dat->from_version >= R_2010 && error < DWG_ERR_CRITICAL)
         check_POLYLINE_handles (obj);
       break;
     case DWG_TYPE_ARC:
@@ -190,7 +190,7 @@
       break;
     case DWG_TYPE_POLYLINE_PFACE:
       error = dwg_decode_POLYLINE_PFACE (dat, obj);
-      if (dat->from_version >= R_2010)
+      if (dat->from_version >= R_2010 && error < DWG_ERR_CRITICAL)
         check_POLYLINE_handles (obj);
       break;
     case DWG_TYPE_POLYLINE_MESH:","{'deleted_lines': ['      if (dat->from_version >= R_2010)', '      if (dat->from_version >= R_2010)', '      if (dat->from_version >= R_2010)'], 'added_lines': ['      if (dat->from_version >= R_2010 && error < DWG_ERR_CRITICAL)', '      if (dat->from_version >= R_2010 && error < DWG_ERR_CRITICAL)', '      if (dat->from_version >= R_2010 && error < DWG_ERR_CRITICAL)']}",True,An issue was discovered in libredwg through v0.10.1.3751. A NULL pointer dereference exists in the function check_POLYLINE_handles() located in decode.c. It allows an attacker to cause Denial of Service.,6.5,MEDIUM,1,test,2020-07-31T15:51:25Z,3
CVE-2021-39523,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,LibreDWG/libredwg,"decode: fix check_POLYLINE_handles NULL deref

detected by @seviezhou via fuzzing. Fixes GH #251",8ebc76a03390197745a94b4e2d374aee636b84a7,https://github.com/LibreDWG/libredwg/commit/8ebc76a03390197745a94b4e2d374aee636b84a7,src/decode.c,check_POLYLINE_handles,"static void
check_POLYLINE_handles (Dwg_Object *obj)
{
Dwg_Entity_POLYLINE_2D *_obj = obj->tio.entity->tio.POLYLINE_2D;
Dwg_Data *dwg = obj->parent;
if (dwg->header.version >= R_2004)
{
BITCODE_BL i = 0;
Dwg_Object_Ref *layer = obj->tio.entity->layer;
Dwg_Object_Ref *seqend = _obj->seqend;
if (layer && !layer->obj)
layer->obj = dwg_ref_object_relative (dwg, layer, obj);
if (!layer || !layer->obj)
{           LOG_WARN (""Wrong POLYLINE.layer %lX"",
layer ? layer->handleref.value : 0L);
if (_obj->num_owned > 0 && _obj->vertex)
{
Dwg_Object_Ref *vertex = _obj->vertex[0];
if (vertex && !vertex->obj)
vertex->obj = dwg_ref_object_relative (dwg, vertex, obj);
if (vertex && vertex->obj 
&& vertex->obj->fixedtype == DWG_TYPE_LAYER)
{
Dwg_Object *seq;
obj->tio.entity->layer = layer = vertex;
LOG_WARN (
""POLYLINE.layer is vertex[0] %lX, shift em, NULL seqend"",
layer->handleref.value);
for (i = 0; i < _obj->num_owned - 1; i++)
{
_obj->vertex[i] = _obj->vertex[i + 1];
}
_obj->vertex[_obj->num_owned - 1] = seqend;
_obj->seqend = NULL;
seq = dwg_next_object (obj);
if (seq && seq->type == DWG_TYPE_SEQEND)
{
LOG_WARN (""POLYLINE.seqend = POLYLINE+1 %lX"",
seq->handle.value);
seqend = _obj->seqend = dwg_find_objectref (dwg, seq);
}
else
{
seq = dwg_next_object (seqend->obj);
if (seq && seq->type == DWG_TYPE_SEQEND)
{
LOG_WARN (""POLYLINE.seqend = VERTEX+1 %lX"",
seq->handle.value);
seqend = _obj->seqend
= dwg_find_objectref (dwg, seq);
}
}
}
}
}
else if (layer->obj->fixedtype != DWG_TYPE_LAYER
&& layer->obj->fixedtype != DWG_TYPE_DICTIONARY)
{           LOG_WARN (""Wrong POLYLINE.layer %s"", layer->obj->dxfname)
}
if (!seqend || !seqend->handleref.value)
{
LOG_WARN (""Empty POLYLINE.seqend"")
}
else if (seqend->obj && seqend->obj->fixedtype != DWG_TYPE_SEQEND)
{           LOG_WARN (""Wrong POLYLINE.seqend %s"", seqend->obj->dxfname)
}
if (!_obj->vertex)
return;
for (; i < _obj->num_owned; i++)
{
Dwg_Object_Ref *v = _obj->vertex[i];
if (!v || !v->handleref.value)
{
LOG_WARN (""Empty POLYLINE.vertex[%d]"", i);
}
else if (v->obj && v->obj->fixedtype != DWG_TYPE_VERTEX_2D
&& v->obj->fixedtype != DWG_TYPE_VERTEX_3D
&& v->obj->fixedtype != DWG_TYPE_VERTEX_MESH
&& v->obj->fixedtype != DWG_TYPE_VERTEX_PFACE
&& v->obj->fixedtype != DWG_TYPE_VERTEX_PFACE_FACE)
{
LOG_WARN (""Wrong POLYLINE.vertex[%d] %lX %s"", i,
v->handleref.value, v->obj->dxfname)
}
}
}
}","static void
check_POLYLINE_handles (Dwg_Object *VAR_0)
{
Dwg_Entity_POLYLINE_2D *VAR_1 = VAR_0->tio.entity->tio.POLYLINE_2D;
Dwg_Data *VAR_2 = VAR_0->parent;
if (VAR_2->header.version >= VAR_3)
{
BITCODE_BL VAR_4 = 0;
Dwg_Object_Ref *VAR_5 = VAR_0->tio.entity->layer;
Dwg_Object_Ref *VAR_6 = VAR_1->seqend;
if (VAR_5 && !VAR_5->obj)
VAR_5->obj = dwg_ref_object_relative (VAR_2, VAR_5, VAR_0);
if (!VAR_5 || !VAR_5->obj)
{ 
LOG_WARN (""Wrong POLYLINE.layer %lX"",
VAR_5 ? VAR_5->handleref.value : 0L);
if (VAR_1->num_owned > 0 && VAR_1->vertex)
{
Dwg_Object_Ref *VAR_7 = VAR_1->vertex[0];
if (VAR_7 && !VAR_7->obj)
VAR_7->obj = dwg_ref_object_relative (VAR_2, VAR_7, VAR_0);
if (VAR_7 && VAR_7->obj 
&& VAR_7->obj->fixedtype == VAR_8)
{
Dwg_Object *VAR_9;
VAR_0->tio.entity->layer = VAR_5 = VAR_7;
LOG_WARN (
""POLYLINE.layer is vertex[0] %lX, shift em, NULL seqend"",
VAR_5->handleref.value);
for (VAR_4 = 0; VAR_4 < VAR_1->num_owned - 1; VAR_4++)
{
VAR_1->vertex[VAR_4] = VAR_1->vertex[VAR_4 + 1];
}
VAR_1->vertex[VAR_1->num_owned - 1] = VAR_6;
VAR_1->seqend = NULL;
VAR_9 = dwg_next_object (VAR_0);
if (VAR_9 && VAR_9->type == VAR_10)
{
LOG_WARN (""POLYLINE.seqend = POLYLINE+1 %lX"",
VAR_9->handle.value);
VAR_6 = VAR_1->seqend = dwg_find_objectref (VAR_2, VAR_9);
}
else
{
VAR_9 = dwg_next_object (VAR_6->obj);
if (VAR_9 && VAR_9->type == VAR_10)
{
LOG_WARN (""POLYLINE.seqend = VERTEX+1 %lX"",
VAR_9->handle.value);
VAR_6 = VAR_1->seqend
= dwg_find_objectref (VAR_2, VAR_9);
}
}
}
}
}
else if (VAR_5->obj->fixedtype != VAR_8
&& VAR_5->obj->fixedtype != VAR_11)
{ 
LOG_WARN (""Wrong POLYLINE.layer %s"", VAR_5->obj->dxfname)
}
if (!VAR_6 || !VAR_6->handleref.value)
{
LOG_WARN (""Empty POLYLINE.seqend"")
}
else if (VAR_6->obj && VAR_6->obj->fixedtype != VAR_10)
{ 
LOG_WARN (""Wrong POLYLINE.seqend %s"", VAR_6->obj->dxfname)
}
if (!VAR_1->vertex)
return;
for (; VAR_4 < VAR_1->num_owned; VAR_4++)
{
Dwg_Object_Ref *VAR_12 = VAR_1->vertex[VAR_4];
if (!VAR_12 || !VAR_12->handleref.value)
{
LOG_WARN (""Empty POLYLINE.vertex[%d]"", VAR_4);
}
else if (VAR_12->obj && VAR_12->obj->fixedtype != VAR_13
&& VAR_12->obj->fixedtype != VAR_14
&& VAR_12->obj->fixedtype != VAR_15
&& VAR_12->obj->fixedtype != VAR_16
&& VAR_12->obj->fixedtype != VAR_17)
{
LOG_WARN (""Wrong POLYLINE.vertex[%d] %lX %s"", VAR_4,
VAR_12->handleref.value, VAR_12->obj->dxfname)
}
}
}
}",LibreDWG/libredwg/8ebc76a03390197745a94b4e2d374aee636b84a7/decode.c/vul/before/0.json,"static void
check_POLYLINE_handles (Dwg_Object *obj)
{
  /* We ensured the common fields structure is shared with all 4 types */
  Dwg_Entity_POLYLINE_2D *_obj = obj->tio.entity->tio.POLYLINE_2D;
  Dwg_Data *dwg = obj->parent;

  if (dwg->header.version >= R_2004)
    {
      BITCODE_BL i = 0;
      Dwg_Object_Ref *layer = obj->tio.entity->layer;
      Dwg_Object_Ref *seqend = _obj->seqend;

      // resolve prev. object
      if (layer && !layer->obj)
        layer->obj = dwg_ref_object_relative (dwg, layer, obj);
      if (!layer || !layer->obj)
        { // maybe a reactor pointing forwards or vertex
          LOG_WARN (""Wrong POLYLINE.layer %lX"",
                    layer ? layer->handleref.value : 0L);
          if (_obj->num_owned > 0 && _obj->vertex)
            {
              Dwg_Object_Ref *vertex = _obj->vertex[0];
              if (vertex && !vertex->obj)
                vertex->obj = dwg_ref_object_relative (dwg, vertex, obj);
              if (vertex && vertex->obj /* pointing backwards */
                  && vertex->obj->fixedtype == DWG_TYPE_LAYER)
                {
                  Dwg_Object *seq;
                  obj->tio.entity->layer = layer = vertex;
                  LOG_WARN (
                      ""POLYLINE.layer is vertex[0] %lX, shift em, NULL seqend"",
                      layer->handleref.value);
                  /* shift vertices one back */
                  for (i = 0; i < _obj->num_owned - 1; i++)
                    {
                      _obj->vertex[i] = _obj->vertex[i + 1];
                    }
                  _obj->vertex[_obj->num_owned - 1] = seqend;
                  _obj->seqend = NULL;
                  /* now just seqend is empty.
                     either 1+ last_vertex, or one before the first.
                     Here the next object might not be read yet. */
                  seq = dwg_next_object (obj);
                  if (seq && seq->type == DWG_TYPE_SEQEND)
                    {
                      LOG_WARN (""POLYLINE.seqend = POLYLINE+1 %lX"",
                                seq->handle.value);
                      seqend = _obj->seqend = dwg_find_objectref (dwg, seq);
                    }
                  else
                    {
                      seq = seqend ? dwg_next_object (seqend->obj) : NULL;
                      if (seq && seq->type == DWG_TYPE_SEQEND)
                        {
                          LOG_WARN (""POLYLINE.seqend = VERTEX+1 %lX"",
                                    seq->handle.value);
                          seqend = _obj->seqend
                              = dwg_find_objectref (dwg, seq);
                        }
                    }
                }
            }
        }
      else if (layer->obj->fixedtype != DWG_TYPE_LAYER
               && layer->obj->fixedtype != DWG_TYPE_DICTIONARY)
        { // a vertex would be after, a reactor before
          LOG_WARN (""Wrong POLYLINE.layer %s"", layer->obj->dxfname)
        }
      // a SEQEND is always after the polyline, so it cannot be resolved yet
      if (!seqend || !seqend->handleref.value)
        {
          LOG_WARN (""Empty POLYLINE.seqend"")
        }
      else if (seqend->obj && seqend->obj->fixedtype != DWG_TYPE_SEQEND)
        { // most likely a vertex, off by one
          LOG_WARN (""Wrong POLYLINE.seqend %s"", seqend->obj->dxfname)
        }
      if (!_obj->vertex)
        return;
      for (; i < _obj->num_owned; i++)
        {
          Dwg_Object_Ref *v = _obj->vertex[i];
          if (!v || !v->handleref.value)
            {
              LOG_WARN (""Empty POLYLINE.vertex[%d]"", i);
            }
          else if (v->obj && v->obj->fixedtype != DWG_TYPE_VERTEX_2D
                   && v->obj->fixedtype != DWG_TYPE_VERTEX_3D
                   && v->obj->fixedtype != DWG_TYPE_VERTEX_MESH
                   && v->obj->fixedtype != DWG_TYPE_VERTEX_PFACE
                   && v->obj->fixedtype != DWG_TYPE_VERTEX_PFACE_FACE)
            {
              LOG_WARN (""Wrong POLYLINE.vertex[%d] %lX %s"", i,
                        v->handleref.value, v->obj->dxfname)
            }
        }
    }
}","static void
check_POLYLINE_handles (Dwg_Object *VAR_0)
{
  /* COMMENT_0 */
  Dwg_Entity_POLYLINE_2D *VAR_1 = VAR_0->tio.entity->tio.POLYLINE_2D;
  Dwg_Data *VAR_2 = VAR_0->parent;

  if (VAR_2->header.version >= VAR_3)
    {
      BITCODE_BL VAR_4 = 0;
      Dwg_Object_Ref *VAR_5 = VAR_0->tio.entity->layer;
      Dwg_Object_Ref *VAR_6 = VAR_1->seqend;

      /* COMMENT_1 */
      if (VAR_5 && !VAR_5->obj)
        VAR_5->obj = dwg_ref_object_relative (VAR_2, VAR_5, VAR_0);
      if (!VAR_5 || !VAR_5->obj)
        { /* COMMENT_2 */
          LOG_WARN (""Wrong POLYLINE.layer %lX"",
                    VAR_5 ? VAR_5->handleref.value : 0L);
          if (VAR_1->num_owned > 0 && VAR_1->vertex)
            {
              Dwg_Object_Ref *VAR_7 = VAR_1->vertex[0];
              if (VAR_7 && !VAR_7->obj)
                VAR_7->obj = dwg_ref_object_relative (VAR_2, VAR_7, VAR_0);
              if (VAR_7 && VAR_7->obj /* COMMENT_3 */
                  && VAR_7->obj->fixedtype == VAR_8)
                {
                  Dwg_Object *VAR_9;
                  VAR_0->tio.entity->layer = VAR_5 = VAR_7;
                  LOG_WARN (
                      ""POLYLINE.layer is vertex[0] %lX, shift em, NULL seqend"",
                      VAR_5->handleref.value);
                  /* COMMENT_4 */
                  for (VAR_4 = 0; VAR_4 < VAR_1->num_owned - 1; VAR_4++)
                    {
                      VAR_1->vertex[VAR_4] = VAR_1->vertex[VAR_4 + 1];
                    }
                  VAR_1->vertex[VAR_1->num_owned - 1] = VAR_6;
                  VAR_1->seqend = NULL;
                  /* COMMENT_5 */
                                                                    
                                                                   
                  VAR_9 = dwg_next_object (VAR_0);
                  if (VAR_9 && VAR_9->type == VAR_10)
                    {
                      LOG_WARN (""POLYLINE.seqend = POLYLINE+1 %lX"",
                                VAR_9->handle.value);
                      VAR_6 = VAR_1->seqend = dwg_find_objectref (VAR_2, VAR_9);
                    }
                  else
                    {
                      VAR_9 = VAR_6 ? dwg_next_object (VAR_6->obj) : NULL;
                      if (VAR_9 && VAR_9->type == VAR_10)
                        {
                          LOG_WARN (""POLYLINE.seqend = VERTEX+1 %lX"",
                                    VAR_9->handle.value);
                          VAR_6 = VAR_1->seqend
                              = dwg_find_objectref (VAR_2, VAR_9);
                        }
                    }
                }
            }
        }
      else if (VAR_5->obj->fixedtype != VAR_8
               && VAR_5->obj->fixedtype != VAR_11)
        { /* COMMENT_8 */
          LOG_WARN (""Wrong POLYLINE.layer %s"", VAR_5->obj->dxfname)
        }
      /* COMMENT_9 */
      if (!VAR_6 || !VAR_6->handleref.value)
        {
          LOG_WARN (""Empty POLYLINE.seqend"")
        }
      else if (VAR_6->obj && VAR_6->obj->fixedtype != VAR_10)
        { /* COMMENT_10 */
          LOG_WARN (""Wrong POLYLINE.seqend %s"", VAR_6->obj->dxfname)
        }
      if (!VAR_1->vertex)
        return;
      for (; VAR_4 < VAR_1->num_owned; VAR_4++)
        {
          Dwg_Object_Ref *VAR_12 = VAR_1->vertex[VAR_4];
          if (!VAR_12 || !VAR_12->handleref.value)
            {
              LOG_WARN (""Empty POLYLINE.vertex[%d]"", VAR_4);
            }
          else if (VAR_12->obj && VAR_12->obj->fixedtype != VAR_13
                   && VAR_12->obj->fixedtype != VAR_14
                   && VAR_12->obj->fixedtype != VAR_15
                   && VAR_12->obj->fixedtype != VAR_16
                   && VAR_12->obj->fixedtype != VAR_17)
            {
              LOG_WARN (""Wrong POLYLINE.vertex[%d] %lX %s"", VAR_4,
                        VAR_12->handleref.value, VAR_12->obj->dxfname)
            }
        }
    }
}",LibreDWG/libredwg/8ebc76a03390197745a94b4e2d374aee636b84a7/decode.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -50,7 +50,7 @@
                     }
                   else
                     {
-                      seq = dwg_next_object (seqend->obj);
+                      seq = seqend ? dwg_next_object (seqend->obj) : NULL;
                       if (seq && seq->type == DWG_TYPE_SEQEND)
                         {
                           LOG_WARN (""POLYLINE.seqend = VERTEX+1 %lX"",","{'deleted_lines': ['                      seq = dwg_next_object (seqend->obj);'], 'added_lines': ['                      seq = seqend ? dwg_next_object (seqend->obj) : NULL;']}",True,An issue was discovered in libredwg through v0.10.1.3751. A NULL pointer dereference exists in the function check_POLYLINE_handles() located in decode.c. It allows an attacker to cause Denial of Service.,6.5,MEDIUM,1,test,2020-07-31T15:51:25Z,3
CVE-2020-23928,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,gpac,fixed #1568,8e05648d6b4459facbc783025c5c42d301fef5c3,https://github.com/gpac/gpac/commit/8e05648d6b4459facbc783025c5c42d301fef5c3,src/isomedia/box_code_adobe.c,abst_box_read,"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)
{
GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;
int i;
u32 tmp_strsize;
char *tmp_str;
GF_Err e;
ISOM_DECREASE_SIZE(ptr, 25)
ptr->bootstrapinfo_version = gf_bs_read_u32(bs);
ptr->profile = gf_bs_read_int(bs, 2);
ptr->live = gf_bs_read_int(bs, 1);
ptr->update = gf_bs_read_int(bs, 1);
ptr->reserved = gf_bs_read_int(bs, 4);
ptr->time_scale = gf_bs_read_u32(bs);
ptr->current_media_time = gf_bs_read_u64(bs);
ptr->smpte_time_code_offset = gf_bs_read_u64(bs);
i=0;
if (ptr->size<8) return GF_ISOM_INVALID_FILE;
tmp_strsize =(u32)ptr->size-8;
tmp_str = gf_malloc(sizeof(char)*tmp_strsize);
if (!tmp_str) return GF_OUT_OF_MEM;
memset(tmp_str, 0, sizeof(char)*tmp_strsize);
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->movie_identifier = gf_strdup(tmp_str);
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->server_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->server_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}
if (j) {
gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);
}
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->quality_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->quality_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}
if (j) {
gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);
}
}
i=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->drm_data = gf_strdup(tmp_str);
}
i=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->meta_data = gf_strdup(tmp_str);
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->segment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->segment_run_table_count; i++) {
GF_AdobeSegmentRunTableBox *asrt = NULL;
e = gf_isom_box_parse((GF_Box **)&asrt, bs);
if (e) {
if (asrt) gf_isom_box_del((GF_Box*)asrt);
gf_free(tmp_str);
return e;
}
gf_list_add(ptr->segment_run_table_entries, asrt);
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->fragment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->fragment_run_table_count; i++) {
GF_AdobeFragmentRunTableBox *afrt = NULL;
e = gf_isom_box_parse((GF_Box **)&afrt, bs);
if (e) {
if (afrt) gf_isom_box_del((GF_Box*)afrt);
gf_free(tmp_str);
return e;
}
gf_list_add(ptr->fragment_run_table_entries, afrt);
}
gf_free(tmp_str);
return GF_OK;
}","GF_Err abst_box_read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
GF_AdobeBootstrapInfoBox *VAR_2 = (GF_AdobeBootstrapInfoBox *)VAR_0;
int VAR_3;
u32 VAR_4;
char *VAR_5;
GF_Err VAR_6;
ISOM_DECREASE_SIZE(VAR_2, 25)
VAR_2->bootstrapinfo_version = gf_bs_read_u32(VAR_1);
VAR_2->profile = gf_bs_read_int(VAR_1, 2);
VAR_2->live = gf_bs_read_int(VAR_1, 1);
VAR_2->update = gf_bs_read_int(VAR_1, 1);
VAR_2->reserved = gf_bs_read_int(VAR_1, 4);
VAR_2->time_scale = gf_bs_read_u32(VAR_1);
VAR_2->current_media_time = gf_bs_read_u64(VAR_1);
VAR_2->smpte_time_code_offset = gf_bs_read_u64(VAR_1);
VAR_3=0;
if (VAR_2->size<8) return VAR_7;
VAR_4 =(u32)VAR_2->size-8;
VAR_5 = gf_malloc(sizeof(char)*VAR_4);
if (!VAR_5) return VAR_8;
memset(VAR_5, 0, sizeof(char)*VAR_4);
while (VAR_4) {
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_3])
break;
VAR_3++;
}
if (VAR_3) {
VAR_2->movie_identifier = gf_strdup(VAR_5);
}
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_2->server_entry_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->server_entry_count; VAR_3++) {
int VAR_9=0;
VAR_4=(u32)VAR_2->size;
while (VAR_4) {
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_5[VAR_9] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_9])
break;
VAR_9++;
}
if (VAR_9) {
gf_list_insert(VAR_2->server_entry_table, gf_strdup(VAR_5), VAR_3);
}
}
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_2->quality_entry_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->quality_entry_count; VAR_3++) {
int VAR_9=0;
VAR_4=(u32)VAR_2->size;
while (VAR_4) {
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_5[VAR_9] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_9])
break;
VAR_9++;
}
if (VAR_9) {
gf_list_insert(VAR_2->quality_entry_table, gf_strdup(VAR_5), VAR_3);
}
}
VAR_3=0;
VAR_4=(u32)VAR_2->size;
while (VAR_4) {
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_3])
break;
VAR_3++;
}
if (VAR_3) {
VAR_2->drm_data = gf_strdup(VAR_5);
}
VAR_3=0;
VAR_4=(u32)VAR_2->size;
while (VAR_4) {
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_3])
break;
VAR_3++;
}
if (VAR_3) {
VAR_2->meta_data = gf_strdup(VAR_5);
}
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_2->segment_run_table_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->segment_run_table_count; VAR_3++) {
GF_AdobeSegmentRunTableBox *VAR_10 = NULL;
VAR_6 = gf_isom_box_parse((GF_Box **)&VAR_10, VAR_1);
if (VAR_6) {
if (VAR_10) gf_isom_box_del((GF_Box*)VAR_10);
gf_free(VAR_5);
return VAR_6;
}
gf_list_add(VAR_2->segment_run_table_entries, VAR_10);
}
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_2->fragment_run_table_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->fragment_run_table_count; VAR_3++) {
GF_AdobeFragmentRunTableBox *VAR_11 = NULL;
VAR_6 = gf_isom_box_parse((GF_Box **)&VAR_11, VAR_1);
if (VAR_6) {
if (VAR_11) gf_isom_box_del((GF_Box*)VAR_11);
gf_free(VAR_5);
return VAR_6;
}
gf_list_add(VAR_2->fragment_run_table_entries, VAR_11);
}
gf_free(VAR_5);
return VAR_12;
}",gpac/8e05648d6b4459facbc783025c5c42d301fef5c3/box_code_adobe.c/vul/before/0.json,"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;
	int i;
	u32 tmp_strsize;
	char *tmp_str;
	GF_Err e;

	ISOM_DECREASE_SIZE(ptr, 25)
	ptr->bootstrapinfo_version = gf_bs_read_u32(bs);
	ptr->profile = gf_bs_read_int(bs, 2);
	ptr->live = gf_bs_read_int(bs, 1);
	ptr->update = gf_bs_read_int(bs, 1);
	ptr->reserved = gf_bs_read_int(bs, 4);
	ptr->time_scale = gf_bs_read_u32(bs);
	ptr->current_media_time = gf_bs_read_u64(bs);
	ptr->smpte_time_code_offset = gf_bs_read_u64(bs);

	i=0;
	if (ptr->size<8) return GF_ISOM_INVALID_FILE;
	tmp_strsize =(u32)ptr->size;
	tmp_str = gf_malloc(sizeof(char)*tmp_strsize);
	if (!tmp_str) return GF_OUT_OF_MEM;
	memset(tmp_str, 0, sizeof(char)*tmp_strsize);

	while (tmp_strsize) {
		ISOM_DECREASE_SIZE(ptr, 1)
		tmp_str[i] = gf_bs_read_u8(bs);
		tmp_strsize--;
		if (!tmp_str[i])
			break;
		i++;
	}
	if (i) {
		ptr->movie_identifier = gf_strdup(tmp_str);
	}

	ISOM_DECREASE_SIZE(ptr, 1)
	ptr->server_entry_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->server_entry_count; i++) {
		int j=0;
		tmp_strsize=(u32)ptr->size;
		while (tmp_strsize) {
			ISOM_DECREASE_SIZE(ptr, 1)
			tmp_str[j] = gf_bs_read_u8(bs);
			tmp_strsize--;
			if (!tmp_str[j])
				break;
			j++;
		}
		if (j) {
			gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);
		}
	}

	ISOM_DECREASE_SIZE(ptr, 1)
	ptr->quality_entry_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->quality_entry_count; i++) {
		int j=0;
		tmp_strsize=(u32)ptr->size;
		while (tmp_strsize) {
			ISOM_DECREASE_SIZE(ptr, 1)
			tmp_str[j] = gf_bs_read_u8(bs);
			tmp_strsize--;
			if (!tmp_str[j])
				break;
			j++;
		}

		if (j) {
			gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);
		}
	}

	i=0;
	tmp_strsize=(u32)ptr->size;
	while (tmp_strsize) {
		ISOM_DECREASE_SIZE(ptr, 1)
		tmp_str[i] = gf_bs_read_u8(bs);
		tmp_strsize--;
		if (!tmp_str[i])
			break;
		i++;
	}
	if (i) {
		ptr->drm_data = gf_strdup(tmp_str);
	}

	i=0;
	tmp_strsize=(u32)ptr->size;
	while (tmp_strsize) {
		ISOM_DECREASE_SIZE(ptr, 1)
		tmp_str[i] = gf_bs_read_u8(bs);
		tmp_strsize--;
		if (!tmp_str[i])
			break;
		i++;
	}
	if (i) {
		ptr->meta_data = gf_strdup(tmp_str);
	}

	ISOM_DECREASE_SIZE(ptr, 1)
	ptr->segment_run_table_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->segment_run_table_count; i++) {
		GF_AdobeSegmentRunTableBox *asrt = NULL;
		e = gf_isom_box_parse((GF_Box **)&asrt, bs);
		if (e) {
			if (asrt) gf_isom_box_del((GF_Box*)asrt);
			gf_free(tmp_str);
			return e;
		}
		gf_list_add(ptr->segment_run_table_entries, asrt);
	}

	ISOM_DECREASE_SIZE(ptr, 1)
	ptr->fragment_run_table_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->fragment_run_table_count; i++) {
		GF_AdobeFragmentRunTableBox *afrt = NULL;
		e = gf_isom_box_parse((GF_Box **)&afrt, bs);
		if (e) {
			if (afrt) gf_isom_box_del((GF_Box*)afrt);
			gf_free(tmp_str);
			return e;
		}
		gf_list_add(ptr->fragment_run_table_entries, afrt);
	}

	gf_free(tmp_str);

	return GF_OK;
}","GF_Err abst_box_read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
	GF_AdobeBootstrapInfoBox *VAR_2 = (GF_AdobeBootstrapInfoBox *)VAR_0;
	int VAR_3;
	u32 VAR_4;
	char *VAR_5;
	GF_Err VAR_6;

	ISOM_DECREASE_SIZE(VAR_2, 25)
	VAR_2->bootstrapinfo_version = gf_bs_read_u32(VAR_1);
	VAR_2->profile = gf_bs_read_int(VAR_1, 2);
	VAR_2->live = gf_bs_read_int(VAR_1, 1);
	VAR_2->update = gf_bs_read_int(VAR_1, 1);
	VAR_2->reserved = gf_bs_read_int(VAR_1, 4);
	VAR_2->time_scale = gf_bs_read_u32(VAR_1);
	VAR_2->current_media_time = gf_bs_read_u64(VAR_1);
	VAR_2->smpte_time_code_offset = gf_bs_read_u64(VAR_1);

	VAR_3=0;
	if (VAR_2->size<8) return VAR_7;
	VAR_4 =(u32)VAR_2->size;
	VAR_5 = gf_malloc(sizeof(char)*VAR_4);
	if (!VAR_5) return VAR_8;
	memset(VAR_5, 0, sizeof(char)*VAR_4);

	while (VAR_4) {
		ISOM_DECREASE_SIZE(VAR_2, 1)
		VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
		VAR_4--;
		if (!VAR_5[VAR_3])
			break;
		VAR_3++;
	}
	if (VAR_3) {
		VAR_2->movie_identifier = gf_strdup(VAR_5);
	}

	ISOM_DECREASE_SIZE(VAR_2, 1)
	VAR_2->server_entry_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->server_entry_count; VAR_3++) {
		int VAR_9=0;
		VAR_4=(u32)VAR_2->size;
		while (VAR_4) {
			ISOM_DECREASE_SIZE(VAR_2, 1)
			VAR_5[VAR_9] = gf_bs_read_u8(VAR_1);
			VAR_4--;
			if (!VAR_5[VAR_9])
				break;
			VAR_9++;
		}
		if (VAR_9) {
			gf_list_insert(VAR_2->server_entry_table, gf_strdup(VAR_5), VAR_3);
		}
	}

	ISOM_DECREASE_SIZE(VAR_2, 1)
	VAR_2->quality_entry_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->quality_entry_count; VAR_3++) {
		int VAR_9=0;
		VAR_4=(u32)VAR_2->size;
		while (VAR_4) {
			ISOM_DECREASE_SIZE(VAR_2, 1)
			VAR_5[VAR_9] = gf_bs_read_u8(VAR_1);
			VAR_4--;
			if (!VAR_5[VAR_9])
				break;
			VAR_9++;
		}

		if (VAR_9) {
			gf_list_insert(VAR_2->quality_entry_table, gf_strdup(VAR_5), VAR_3);
		}
	}

	VAR_3=0;
	VAR_4=(u32)VAR_2->size;
	while (VAR_4) {
		ISOM_DECREASE_SIZE(VAR_2, 1)
		VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
		VAR_4--;
		if (!VAR_5[VAR_3])
			break;
		VAR_3++;
	}
	if (VAR_3) {
		VAR_2->drm_data = gf_strdup(VAR_5);
	}

	VAR_3=0;
	VAR_4=(u32)VAR_2->size;
	while (VAR_4) {
		ISOM_DECREASE_SIZE(VAR_2, 1)
		VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
		VAR_4--;
		if (!VAR_5[VAR_3])
			break;
		VAR_3++;
	}
	if (VAR_3) {
		VAR_2->meta_data = gf_strdup(VAR_5);
	}

	ISOM_DECREASE_SIZE(VAR_2, 1)
	VAR_2->segment_run_table_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->segment_run_table_count; VAR_3++) {
		GF_AdobeSegmentRunTableBox *VAR_10 = NULL;
		VAR_6 = gf_isom_box_parse((GF_Box **)&VAR_10, VAR_1);
		if (VAR_6) {
			if (VAR_10) gf_isom_box_del((GF_Box*)VAR_10);
			gf_free(VAR_5);
			return VAR_6;
		}
		gf_list_add(VAR_2->segment_run_table_entries, VAR_10);
	}

	ISOM_DECREASE_SIZE(VAR_2, 1)
	VAR_2->fragment_run_table_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->fragment_run_table_count; VAR_3++) {
		GF_AdobeFragmentRunTableBox *VAR_11 = NULL;
		VAR_6 = gf_isom_box_parse((GF_Box **)&VAR_11, VAR_1);
		if (VAR_6) {
			if (VAR_11) gf_isom_box_del((GF_Box*)VAR_11);
			gf_free(VAR_5);
			return VAR_6;
		}
		gf_list_add(VAR_2->fragment_run_table_entries, VAR_11);
	}

	gf_free(VAR_5);

	return VAR_12;
}",gpac/8e05648d6b4459facbc783025c5c42d301fef5c3/box_code_adobe.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,7 +18,7 @@
 
 	i=0;
 	if (ptr->size<8) return GF_ISOM_INVALID_FILE;
-	tmp_strsize =(u32)ptr->size-8;
+	tmp_strsize =(u32)ptr->size;
 	tmp_str = gf_malloc(sizeof(char)*tmp_strsize);
 	if (!tmp_str) return GF_OUT_OF_MEM;
 	memset(tmp_str, 0, sizeof(char)*tmp_strsize);","{'deleted_lines': ['\ttmp_strsize =(u32)ptr->size-8;'], 'added_lines': ['\ttmp_strsize =(u32)ptr->size;']}",True,An issue was discovered in gpac before 1.0.1. The abst_box_read function in box_code_adobe.c has a heap-based buffer over-read.,7.1,HIGH,2,test,2020-09-01T15:10:13Z,3
CVE-2020-25463,['CWE-Other'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,Moddable-OpenSource/moddable,XS: #440,404c84d1c8041b776f337e686249fa3afe1fc078,https://github.com/Moddable-OpenSource/moddable/commit/404c84d1c8041b776f337e686249fa3afe1fc078,xs/sources/xsArguments.c,fxArgumentsSloppyDefineOwnProperty,"txBoolean fxArgumentsSloppyDefineOwnProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* descriptor, txFlag mask) 
{
if (!id) {
txSlot* property = fxGetIndexProperty(the, instance->next, index);
if (property && (property->kind == XS_CLOSURE_KIND)) {
txSlot* closure = property->value.closure;
if (mask & XS_ACCESSOR_FLAG) {
property->flag = closure->flag;
property->kind = closure->kind;
property->value = closure->value;
}
else if ((descriptor->flag & XS_DONT_SET_FLAG) && (mask & XS_DONT_SET_FLAG)) {
property->flag = closure->flag;
property->kind = closure->kind;
property->value = closure->value;
if (descriptor->kind != XS_UNINITIALIZED_KIND)
closure->value = descriptor->value;
}
}
}
return fxOrdinaryDefineOwnProperty(the, instance, id, index, descriptor, mask);
}","txBoolean fxArgumentsSloppyDefineOwnProperty(txMachine* VAR_0, txSlot* VAR_1, txID VAR_2, txIndex VAR_3, txSlot* VAR_4, txFlag VAR_5) 
{
if (!VAR_2) {
txSlot* VAR_6 = fxGetIndexProperty(VAR_0, VAR_1->next, VAR_3);
if (VAR_6 && (VAR_6->kind == VAR_7)) {
txSlot* VAR_8 = VAR_6->value.closure;
if (VAR_5 & VAR_9) {
VAR_6->flag = VAR_8->flag;
VAR_6->kind = VAR_8->kind;
VAR_6->value = VAR_8->value;
}
else if ((VAR_4->flag & VAR_10) && (VAR_5 & VAR_10)) {
VAR_6->flag = VAR_8->flag;
VAR_6->kind = VAR_8->kind;
VAR_6->value = VAR_8->value;
if (VAR_4->kind != VAR_11)
VAR_8->value = VAR_4->value;
}
}
}
return fxOrdinaryDefineOwnProperty(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5);
}",Moddable-OpenSource/moddable/404c84d1c8041b776f337e686249fa3afe1fc078/xsArguments.c/vul/before/0.json,"txBoolean fxArgumentsSloppyDefineOwnProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* descriptor, txFlag mask) 
{
	if (!id) {
		txSlot* property = fxGetIndexProperty(the, instance->next, index);
		if (property && (property->kind == XS_CLOSURE_KIND)) {
			txSlot* closure = property->value.closure;
			if (mask & XS_ACCESSOR_FLAG) {
				property->flag = closure->flag;
				property->kind = closure->kind;
				property->value = closure->value;
			}
			else if ((descriptor->flag & XS_DONT_SET_FLAG) && (mask & XS_DONT_SET_FLAG)) {
				property->flag = closure->flag;
				property->kind = closure->kind;
				property->value = closure->value;
				if (descriptor->kind != XS_UNINITIALIZED_KIND) {
					closure->kind = descriptor->kind;
					closure->value = descriptor->value;
				}
			}
		}
	}
	return fxOrdinaryDefineOwnProperty(the, instance, id, index, descriptor, mask);
}","txBoolean fxArgumentsSloppyDefineOwnProperty(txMachine* VAR_0, txSlot* VAR_1, txID VAR_2, txIndex VAR_3, txSlot* VAR_4, txFlag VAR_5) 
{
	if (!VAR_2) {
		txSlot* VAR_6 = fxGetIndexProperty(VAR_0, VAR_1->next, VAR_3);
		if (VAR_6 && (VAR_6->kind == VAR_7)) {
			txSlot* VAR_8 = VAR_6->value.closure;
			if (VAR_5 & VAR_9) {
				VAR_6->flag = VAR_8->flag;
				VAR_6->kind = VAR_8->kind;
				VAR_6->value = VAR_8->value;
			}
			else if ((VAR_4->flag & VAR_10) && (VAR_5 & VAR_10)) {
				VAR_6->flag = VAR_8->flag;
				VAR_6->kind = VAR_8->kind;
				VAR_6->value = VAR_8->value;
				if (VAR_4->kind != VAR_11) {
					VAR_8->kind = VAR_4->kind;
					VAR_8->value = VAR_4->value;
				}
			}
		}
	}
	return fxOrdinaryDefineOwnProperty(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5);
}",Moddable-OpenSource/moddable/404c84d1c8041b776f337e686249fa3afe1fc078/xsArguments.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,8 +13,10 @@
 				property->flag = closure->flag;
 				property->kind = closure->kind;
 				property->value = closure->value;
-				if (descriptor->kind != XS_UNINITIALIZED_KIND)
+				if (descriptor->kind != XS_UNINITIALIZED_KIND) {
+					closure->kind = descriptor->kind;
 					closure->value = descriptor->value;
+				}
 			}
 		}
 	}","{'deleted_lines': ['\t\t\t\tif (descriptor->kind != XS_UNINITIALIZED_KIND)'], 'added_lines': ['\t\t\t\tif (descriptor->kind != XS_UNINITIALIZED_KIND) {', '\t\t\t\t\tclosure->kind = descriptor->kind;', '\t\t\t\t}']}",True,Invalid Memory Access in fxUTF8Decode at moddable/xs/sources/xsCommon.c:916 in Moddable SDK before OS200908 causes a denial of service (SEGV).,7.5,HIGH,2,test,2020-09-08T03:45:17Z,3
CVE-2020-15207,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,tensorflow,"[tflite] Ensure `ResolveAxis` properly handles negative inputs.

In Python, a list `l` of length `n` allows indexing with negative indices, `l[i]`. The only constraint is that `n + i` becomes positive. Code in `ResolveAxis` assumes the constraints and only checks it using a `DCHECK`. But the macro is a no-op in non-debug builds and that can result in reading from negative offsets (buffer underflows).

PiperOrigin-RevId: 332530683
Change-Id: I464e073fee618054ae3719a3679739007bb3f3bc",2d88f470dea2671b430884260f3626b1fe99830a,https://github.com/tensorflow/tensorflow/commit/2d88f470dea2671b430884260f3626b1fe99830a,tensorflow/lite/kernels/internal/reference/reduce.h,ResolveAxis,"inline bool ResolveAxis(const int num_dims, const int* axis,
const int64_t num_axis, int* out_axis,
int* out_num_axis) {
*out_num_axis = 0;      if (num_dims == 0) {
return true;
}
for (int64_t idx = 0; idx < num_axis; ++idx) {
int current = axis[idx] < 0 ? (axis[idx] + num_dims) : axis[idx];
TFLITE_DCHECK(current >= 0 && current < num_dims);
bool is_dup = false;
for (int j = 0; j < *out_num_axis; ++j) {
if (out_axis[j] == current) {
is_dup = true;
break;
}
}
if (!is_dup) {
out_axis[*out_num_axis] = current;
*out_num_axis += 1;
}
}
return true;
}","inline bool ResolveAxis(const int VAR_0, const int* VAR_1,
const int64_t VAR_2, int* VAR_3,
int* VAR_4) {
*VAR_4 = 0;  
if (VAR_0 == 0) {
return true;
}
for (int64_t VAR_5 = 0; VAR_5 < VAR_2; ++VAR_5) {
int VAR_6 = VAR_1[VAR_5] < 0 ? (VAR_1[VAR_5] + VAR_0) : VAR_1[VAR_5];
TFLITE_DCHECK(VAR_6 >= 0 && VAR_6 < VAR_0);
bool VAR_7 = false;
for (int VAR_8 = 0; VAR_8 < *VAR_4; ++VAR_8) {
if (VAR_3[VAR_8] == VAR_6) {
VAR_7 = true;
break;
}
}
if (!VAR_7) {
VAR_3[*VAR_4] = VAR_6;
*VAR_4 += 1;
}
}
return true;
}",tensorflow/2d88f470dea2671b430884260f3626b1fe99830a/reduce.h/vul/before/0.json,"inline bool ResolveAxis(const int num_dims, const int* axis,
                        const int64_t num_axis, int* out_axis,
                        int* out_num_axis) {
  *out_num_axis = 0;  // Just in case.
  // Short-circuit axis resolution for scalars; the axis will go unused.
  if (num_dims == 0) {
    return true;
  }
  // o(n^2) is fine since out_num_axis should be really small, mostly <= 4
  for (int64_t idx = 0; idx < num_axis; ++idx) {
    // Handle negative index. A positive index 'p_idx' can be represented as a
    // negative index 'n_idx' as: n_idx = p_idx-num_dims
    // eg: For num_dims=3, [0, 1, 2] is the same as [-3, -2, -1]  */
    int current = axis[idx] < 0 ? (axis[idx] + num_dims) : axis[idx];
    TFLITE_DCHECK(current >= 0 && current < num_dims);
    if (current < 0 || current >= num_dims) {
      return false;
    }
    bool is_dup = false;
    for (int j = 0; j < *out_num_axis; ++j) {
      if (out_axis[j] == current) {
        is_dup = true;
        break;
      }
    }
    if (!is_dup) {
      out_axis[*out_num_axis] = current;
      *out_num_axis += 1;
    }
  }
  return true;
}","inline bool ResolveAxis(const int VAR_0, const int* VAR_1,
                        const int64_t VAR_2, int* VAR_3,
                        int* VAR_4) {
  *VAR_4 = 0;  /* COMMENT_0 */
  /* COMMENT_1 */
  if (VAR_0 == 0) {
    return true;
  }
  /* COMMENT_2 */
  for (int64_t VAR_5 = 0; VAR_5 < VAR_2; ++VAR_5) {
    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_5 */
    int VAR_6 = VAR_1[VAR_5] < 0 ? (VAR_1[VAR_5] + VAR_0) : VAR_1[VAR_5];
    TFLITE_DCHECK(VAR_6 >= 0 && VAR_6 < VAR_0);
    if (VAR_6 < 0 || VAR_6 >= VAR_0) {
      return false;
    }
    bool VAR_7 = false;
    for (int VAR_8 = 0; VAR_8 < *VAR_4; ++VAR_8) {
      if (VAR_3[VAR_8] == VAR_6) {
        VAR_7 = true;
        break;
      }
    }
    if (!VAR_7) {
      VAR_3[*VAR_4] = VAR_6;
      *VAR_4 += 1;
    }
  }
  return true;
}",tensorflow/2d88f470dea2671b430884260f3626b1fe99830a/reduce.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,6 +13,9 @@
     // eg: For num_dims=3, [0, 1, 2] is the same as [-3, -2, -1]  */
     int current = axis[idx] < 0 ? (axis[idx] + num_dims) : axis[idx];
     TFLITE_DCHECK(current >= 0 && current < num_dims);
+    if (current < 0 || current >= num_dims) {
+      return false;
+    }
     bool is_dup = false;
     for (int j = 0; j < *out_num_axis; ++j) {
       if (out_axis[j] == current) {","{'deleted_lines': [], 'added_lines': ['    if (current < 0 || current >= num_dims) {', '      return false;', '    }']}",True,"In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, to mimic Python's indexing with negative values, TFLite uses `ResolveAxis` to convert negative values to positive indices. However, the only check that the converted index is now valid is only present in debug builds. If the `DCHECK` does not trigger, then code execution moves ahead with a negative index. This, in turn, results in accessing data out of bounds which results in segfaults and/or data corruption. The issue is patched in commit 2d88f470dea2671b430884260f3626b1fe99830a, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",8.7,HIGH,2,test,2020-09-18T21:43:00Z,3
CVE-2021-20299,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,AcademySoftwareFoundation/openexr,"add sanity check for reading multipart files with no parts (#840)

Signed-off-by: Peter Hillman <peterh@wetafx.co.nz>",25e9515b06a6bc293d871622b8cafaee7af84e0f,https://github.com/AcademySoftwareFoundation/openexr/commit/25e9515b06a6bc293d871622b8cafaee7af84e0f,OpenEXR/IlmImf/ImfMultiPartInputFile.cpp,MultiPartInputFile::initialize,"void
MultiPartInputFile::initialize()
{
readMagicNumberAndVersionField(*_data->is, _data->version);
bool multipart = isMultiPart(_data->version);
bool tiled = isTiled(_data->version);
if (tiled && multipart)
throw IEX_NAMESPACE::InputExc (""Multipart files cannot have the tiled bit set"");
int pos = 0;
while (true)
{
Header header;
header.readFrom(*_data->is, _data->version);
if (header.readsNothing())
{
pos++;
break;
}
_data->_headers.push_back(header);
if(multipart == false)
break;
}
for (size_t i = 0; i < _data->_headers.size(); i++)
{
if( _data->_headers[i].hasType() == false )
{
if(multipart)
throw IEX_NAMESPACE::ArgExc (""Every header in a multipart file should have a type"");
_data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);
}
else
{
if(!multipart && !isNonImage(_data->version))
{
_data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);
}
}
if( _data->_headers[i].hasName() == false )
{
if(multipart)
throw IEX_NAMESPACE::ArgExc (""Every header in a multipart file should have a name"");
}
if (isTiled(_data->_headers[i].type()))
_data->_headers[i].sanityCheck(true, multipart);
else
_data->_headers[i].sanityCheck(false, multipart);
}
if (multipart)
{
set<string> names;
for (size_t i = 0; i < _data->_headers.size(); i++)
{
if (names.find(_data->_headers[i].name()) != names.end())
{
throw IEX_NAMESPACE::InputExc (""Header name "" + _data->_headers[i].name() +
"" is not a unique name."");
}
names.insert(_data->_headers[i].name());
}
}
if (multipart && strictSharedAttribute)
{
for (size_t i = 1; i < _data->_headers.size(); i++)
{
vector <string> attrs;
if (_data->checkSharedAttributesValues (_data->_headers[0], _data->_headers[i], attrs))
{
string attrNames;
for (size_t j=0; j<attrs.size(); j++)
attrNames += "" "" + attrs[j];
throw IEX_NAMESPACE::InputExc (""Header name "" + _data->_headers[i].name() +
"" has non-conforming shared attributes: ""+
attrNames);
}
}
}
for (size_t i = 0; i < _data->_headers.size(); i++)
_data->parts.push_back(
new InputPartData(_data, _data->_headers[i], i, _data->numThreads, _data->version));
_data->readChunkOffsetTables(_data->reconstructChunkOffsetTable);
}","void
MultiPartInputFile::initialize()
{
readMagicNumberAndVersionField(*VAR_0->is, VAR_0->version);
bool VAR_1 = isMultiPart(VAR_0->version);
bool VAR_2 = isTiled(VAR_0->version);
if (VAR_2 && VAR_1)
throw IEX_NAMESPACE::InputExc (""Multipart files cannot have the tiled bit set"");
int VAR_3 = 0;
while (true)
{
Header VAR_4;
VAR_4.readFrom(*VAR_0->is, VAR_0->version);
if (VAR_4.readsNothing())
{
VAR_3++;
break;
}
VAR_0->_headers.push_back(VAR_4);
if(VAR_1 == false)
break;
}
for (size_t VAR_5 = 0; VAR_5 < VAR_0->_headers.size(); VAR_5++)
{
if( VAR_0->_headers[VAR_5].hasType() == false )
{
if(VAR_1)
throw IEX_NAMESPACE::ArgExc (""Every header in a multipart file should have a type"");
VAR_0->_headers[VAR_5].setType(VAR_2 ? VAR_6 : VAR_7);
}
else
{
if(!VAR_1 && !isNonImage(VAR_0->version))
{
VAR_0->_headers[VAR_5].setType(VAR_2 ? VAR_6 : VAR_7);
}
}
if( VAR_0->_headers[VAR_5].hasName() == false )
{
if(VAR_1)
throw IEX_NAMESPACE::ArgExc (""Every header in a multipart file should have a name"");
}
if (isTiled(VAR_0->_headers[VAR_5].type()))
VAR_0->_headers[VAR_5].sanityCheck(true, VAR_1);
else
VAR_0->_headers[VAR_5].sanityCheck(false, VAR_1);
}
if (VAR_1)
{
set<string> VAR_8;
for (size_t VAR_5 = 0; VAR_5 < VAR_0->_headers.size(); VAR_5++)
{
if (VAR_8.find(VAR_0->_headers[VAR_5].name()) != VAR_8.end())
{
throw IEX_NAMESPACE::InputExc (""Header name "" + VAR_0->_headers[VAR_5].name() +
"" is not a unique name."");
}
VAR_8.insert(VAR_0->_headers[VAR_5].name());
}
}
if (VAR_1 && VAR_9)
{
for (size_t VAR_5 = 1; VAR_5 < VAR_0->_headers.size(); VAR_5++)
{
vector <string> VAR_10;
if (VAR_0->checkSharedAttributesValues (VAR_0->_headers[0], VAR_0->_headers[VAR_5], VAR_10))
{
string VAR_11;
for (size_t VAR_12=0; VAR_12<VAR_10.size(); VAR_12++)
VAR_11 += "" "" + VAR_10[VAR_12];
throw IEX_NAMESPACE::InputExc (""Header name "" + VAR_0->_headers[VAR_5].name() +
"" has non-conforming shared attributes: ""+
VAR_11);
}
}
}
for (size_t VAR_5 = 0; VAR_5 < VAR_0->_headers.size(); VAR_5++)
VAR_0->parts.push_back(
new InputPartData(VAR_0, VAR_0->_headers[VAR_5], VAR_5, VAR_0->numThreads, VAR_0->version));
VAR_0->readChunkOffsetTables(VAR_0->reconstructChunkOffsetTable);
}",AcademySoftwareFoundation/openexr/25e9515b06a6bc293d871622b8cafaee7af84e0f/ImfMultiPartInputFile.cpp/vul/before/0.json,"void
MultiPartInputFile::initialize()
{
    readMagicNumberAndVersionField(*_data->is, _data->version);
    
    bool multipart = isMultiPart(_data->version);
    bool tiled = isTiled(_data->version);

    //
    // Multipart files don't have and shouldn't have the tiled bit set.
    //

    if (tiled && multipart)
        throw IEX_NAMESPACE::InputExc (""Multipart files cannot have the tiled bit set"");

    
    int pos = 0;
    while (true)
    {
        Header header;
        header.readFrom(*_data->is, _data->version);

        //
        // If we read nothing then we stop reading.
        //

        if (header.readsNothing())
        {
            pos++;
            break;
        }

        _data->_headers.push_back(header);
        
        if(multipart == false)
          break;
    }

    //
    // Perform usual check on headers.
    //

    if ( _data->_headers.size() == 0)
    {
        throw IEX_NAMESPACE::ArgExc (""Files must contain at least one header"");
    }

    for (size_t i = 0; i < _data->_headers.size(); i++)
    {
        //
        // Silently invent a type if the file is a single part regular image.
        //

        if( _data->_headers[i].hasType() == false )
        {
            if(multipart)

                throw IEX_NAMESPACE::ArgExc (""Every header in a multipart file should have a type"");
          
            _data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);
        }
        else
        {
            
            //
            // Silently fix the header type if it's wrong
            // (happens when a regular Image file written by EXR_2.0 is rewritten by an older library,
            //  so doesn't effect deep image types)
            //

            if(!multipart && !isNonImage(_data->version))
            {
                _data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);
            }
        }
         

        
        if( _data->_headers[i].hasName() == false )
        {
            if(multipart)
                throw IEX_NAMESPACE::ArgExc (""Every header in a multipart file should have a name"");
        }
        
        if (isTiled(_data->_headers[i].type()))
            _data->_headers[i].sanityCheck(true, multipart);
        else
            _data->_headers[i].sanityCheck(false, multipart);
    }

    //
    // Check name uniqueness.
    //

    if (multipart)
    {
        set<string> names;
        for (size_t i = 0; i < _data->_headers.size(); i++)
        {
        
            if (names.find(_data->_headers[i].name()) != names.end())
            {
                throw IEX_NAMESPACE::InputExc (""Header name "" + _data->_headers[i].name() +
                                   "" is not a unique name."");
            }
            names.insert(_data->_headers[i].name());
        }
    }
    
    //
    // Check shared attributes compliance.
    //

    if (multipart && strictSharedAttribute)
    {
        for (size_t i = 1; i < _data->_headers.size(); i++)
        {
            vector <string> attrs;
            if (_data->checkSharedAttributesValues (_data->_headers[0], _data->_headers[i], attrs))
            {
                string attrNames;
                for (size_t j=0; j<attrs.size(); j++)
                    attrNames += "" "" + attrs[j];
                throw IEX_NAMESPACE::InputExc (""Header name "" + _data->_headers[i].name() +
                                     "" has non-conforming shared attributes: ""+
                                     attrNames);
            }
        }
    }

    //
    // Create InputParts and read chunk offset tables.
    //
        
    for (size_t i = 0; i < _data->_headers.size(); i++)
        _data->parts.push_back(
                new InputPartData(_data, _data->_headers[i], i, _data->numThreads, _data->version));

    _data->readChunkOffsetTables(_data->reconstructChunkOffsetTable);
}","void
MultiPartInputFile::initialize()
{
    readMagicNumberAndVersionField(*VAR_0->is, VAR_0->version);
    
    bool VAR_1 = isMultiPart(VAR_0->version);
    bool VAR_2 = isTiled(VAR_0->version);

    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_0 */

    if (VAR_2 && VAR_1)
        throw IEX_NAMESPACE::InputExc (""Multipart files cannot have the tiled bit set"");

    
    int VAR_3 = 0;
    while (true)
    {
        Header VAR_4;
        VAR_4.readFrom(*VAR_0->is, VAR_0->version);

        /* COMMENT_0 */
        /* COMMENT_2 */
        /* COMMENT_0 */

        if (VAR_4.readsNothing())
        {
            VAR_3++;
            break;
        }

        VAR_0->_headers.push_back(VAR_4);
        
        if(VAR_1 == false)
          break;
    }

    /* COMMENT_0 */
    /* COMMENT_3 */
    /* COMMENT_0 */

    if ( VAR_0->_headers.size() == 0)
    {
        throw IEX_NAMESPACE::ArgExc (""Files must contain at least one header"");
    }

    for (size_t VAR_5 = 0; VAR_5 < VAR_0->_headers.size(); VAR_5++)
    {
        /* COMMENT_0 */
        /* COMMENT_4 */
        /* COMMENT_0 */

        if( VAR_0->_headers[VAR_5].hasType() == false )
        {
            if(VAR_1)

                throw IEX_NAMESPACE::ArgExc (""Every header in a multipart file should have a type"");
          
            VAR_0->_headers[VAR_5].setType(VAR_2 ? VAR_6 : VAR_7);
        }
        else
        {
            
            /* COMMENT_0 */
            /* COMMENT_5 */
            /* COMMENT_6 */
            /* COMMENT_7 */
            /* COMMENT_0 */

            if(!VAR_1 && !isNonImage(VAR_0->version))
            {
                VAR_0->_headers[VAR_5].setType(VAR_2 ? VAR_6 : VAR_7);
            }
        }
         

        
        if( VAR_0->_headers[VAR_5].hasName() == false )
        {
            if(VAR_1)
                throw IEX_NAMESPACE::ArgExc (""Every header in a multipart file should have a name"");
        }
        
        if (isTiled(VAR_0->_headers[VAR_5].type()))
            VAR_0->_headers[VAR_5].sanityCheck(true, VAR_1);
        else
            VAR_0->_headers[VAR_5].sanityCheck(false, VAR_1);
    }

    /* COMMENT_0 */
    /* COMMENT_8 */
    /* COMMENT_0 */

    if (VAR_1)
    {
        set<string> VAR_8;
        for (size_t VAR_5 = 0; VAR_5 < VAR_0->_headers.size(); VAR_5++)
        {
        
            if (VAR_8.find(VAR_0->_headers[VAR_5].name()) != VAR_8.end())
            {
                throw IEX_NAMESPACE::InputExc (""Header name "" + VAR_0->_headers[VAR_5].name() +
                                   "" is not a unique name."");
            }
            VAR_8.insert(VAR_0->_headers[VAR_5].name());
        }
    }
    
    /* COMMENT_0 */
    /* COMMENT_9 */
    /* COMMENT_0 */

    if (VAR_1 && VAR_9)
    {
        for (size_t VAR_5 = 1; VAR_5 < VAR_0->_headers.size(); VAR_5++)
        {
            vector <string> VAR_10;
            if (VAR_0->checkSharedAttributesValues (VAR_0->_headers[0], VAR_0->_headers[VAR_5], VAR_10))
            {
                string VAR_11;
                for (size_t VAR_12=0; VAR_12<VAR_10.size(); VAR_12++)
                    VAR_11 += "" "" + VAR_10[VAR_12];
                throw IEX_NAMESPACE::InputExc (""Header name "" + VAR_0->_headers[VAR_5].name() +
                                     "" has non-conforming shared attributes: ""+
                                     VAR_11);
            }
        }
    }

    /* COMMENT_0 */
    /* COMMENT_10 */
    /* COMMENT_0 */
        
    for (size_t VAR_5 = 0; VAR_5 < VAR_0->_headers.size(); VAR_5++)
        VAR_0->parts.push_back(
                new InputPartData(VAR_0, VAR_0->_headers[VAR_5], VAR_5, VAR_0->numThreads, VAR_0->version));

    VAR_0->readChunkOffsetTables(VAR_0->reconstructChunkOffsetTable);
}",AcademySoftwareFoundation/openexr/25e9515b06a6bc293d871622b8cafaee7af84e0f/ImfMultiPartInputFile.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -39,6 +39,11 @@
     //
     // Perform usual check on headers.
     //
+
+    if ( _data->_headers.size() == 0)
+    {
+        throw IEX_NAMESPACE::ArgExc (""Files must contain at least one header"");
+    }
 
     for (size_t i = 0; i < _data->_headers.size(); i++)
     {","{'deleted_lines': [], 'added_lines': ['', '    if ( _data->_headers.size() == 0)', '    {', '        throw IEX_NAMESPACE::ArgExc (""Files must contain at least one header"");', '    }']}",True,A flaw was found in OpenEXR's Multipart input file functionality. A crafted multi-part input file with no actual parts can trigger a NULL pointer dereference. The highest threat from this vulnerability is to system availability.,7.5,HIGH,2,test,2020-09-22T06:52:57Z,3
CVE-2020-26519,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ArtifexSoftware/mupdf,"Bug 702857: Detect/avoid overflow when calculating sizes of pixmaps.

Throw an error when trying to allocate an overly large pixmap.",af1e390a2c7abceb32676ec684cd1dbb92907ce8,https://github.com/ArtifexSoftware/mupdf/commit/af1e390a2c7abceb32676ec684cd1dbb92907ce8,source/fitz/pixmap.c,fz_new_pixmap_with_data,"fz_pixmap *
fz_new_pixmap_with_data(fz_context *ctx, fz_colorspace *colorspace, int w, int h, fz_separations *seps, int alpha, int stride, unsigned char *samples)
{
fz_pixmap *pix;
int s = fz_count_active_separations(ctx, seps);
int n;
if (w < 0 || h < 0)
fz_throw(ctx, FZ_ERROR_GENERIC, ""Illegal dimensions for pixmap %d %d"", w, h);
n = alpha + s + fz_colorspace_n(ctx, colorspace);
if (stride < n*w && stride > -n*w)
fz_throw(ctx, FZ_ERROR_GENERIC, ""Illegal stride for pixmap (n=%d w=%d, stride=%d)"", n, w, stride);
if (samples == NULL && stride < n*w)
fz_throw(ctx, FZ_ERROR_GENERIC, ""Illegal -ve stride for pixmap without data"");
if (n > FZ_MAX_COLORS)
fz_throw(ctx, FZ_ERROR_GENERIC, ""Illegal number of colorants"");
pix = fz_malloc_struct(ctx, fz_pixmap);
FZ_INIT_STORABLE(pix, 1, fz_drop_pixmap_imp);
pix->x = 0;
pix->y = 0;
pix->w = w;
pix->h = h;
pix->alpha = alpha = !!alpha;
pix->flags = FZ_PIXMAP_FLAG_INTERPOLATE;
pix->xres = 96;
pix->yres = 96;
pix->colorspace = NULL;
pix->n = n;
pix->s = s;
pix->seps = fz_keep_separations(ctx, seps);
pix->stride = stride;
if (colorspace)
{
pix->colorspace = fz_keep_colorspace(ctx, colorspace);
}
else
{
assert(alpha || s);
}
pix->samples = samples;
if (!samples)
{
fz_try(ctx)
{
if (pix->stride - 1 > INT_MAX / pix->n)
fz_throw(ctx, FZ_ERROR_GENERIC, ""overly wide image"");
pix->samples = Memento_label(fz_malloc(ctx, pix->h * pix->stride), ""pixmap_data"");
}
fz_catch(ctx)
{
fz_drop_separations(ctx, pix->seps);
fz_drop_colorspace(ctx, pix->colorspace);
fz_free(ctx, pix);
fz_rethrow(ctx);
}
pix->flags |= FZ_PIXMAP_FLAG_FREE_SAMPLES;
}
return pix;
}","fz_pixmap *
fz_new_pixmap_with_data(fz_context *VAR_0, fz_colorspace *VAR_1, int VAR_2, int VAR_3, fz_separations *VAR_4, int VAR_5, int VAR_6, unsigned char *VAR_7)
{
fz_pixmap *VAR_8;
int VAR_9 = fz_count_active_separations(VAR_0, VAR_4);
int VAR_10;
if (VAR_2 < 0 || VAR_3 < 0)
fz_throw(VAR_0, VAR_11, ""Illegal dimensions for pixmap %d %d"", VAR_2, VAR_3);
VAR_10 = VAR_5 + VAR_9 + fz_colorspace_n(VAR_0, VAR_1);
if (VAR_6 < VAR_10*VAR_2 && VAR_6 > -VAR_10*VAR_2)
fz_throw(VAR_0, VAR_11, ""Illegal stride for pixmap (n=%d w=%d, stride=%d)"", VAR_10, VAR_2, VAR_6);
if (VAR_7 == NULL && VAR_6 < VAR_10*VAR_2)
fz_throw(VAR_0, VAR_11, ""Illegal -ve stride for pixmap without data"");
if (VAR_10 > VAR_12)
fz_throw(VAR_0, VAR_11, ""Illegal number of colorants"");
VAR_8 = fz_malloc_struct(VAR_0, fz_pixmap);
FZ_INIT_STORABLE(VAR_8, 1, VAR_13);
VAR_8->x = 0;
VAR_8->y = 0;
VAR_8->w = VAR_2;
VAR_8->h = VAR_3;
VAR_8->alpha = VAR_5 = !!VAR_5;
VAR_8->flags = VAR_14;
VAR_8->xres = 96;
VAR_8->yres = 96;
VAR_8->colorspace = NULL;
VAR_8->n = VAR_10;
VAR_8->s = VAR_9;
VAR_8->seps = fz_keep_separations(VAR_0, VAR_4);
VAR_8->stride = VAR_6;
if (VAR_1)
{
VAR_8->colorspace = fz_keep_colorspace(VAR_0, VAR_1);
}
else
{
assert(VAR_5 || VAR_9);
}
VAR_8->samples = VAR_7;
if (!VAR_7)
{
fz_try(VAR_0)
{
if (VAR_8->stride - 1 > VAR_15 / VAR_8->n)
fz_throw(VAR_0, VAR_11, ""overly wide image"");
VAR_8->samples = Memento_label(fz_malloc(VAR_0, VAR_8->h * VAR_8->stride), ""pixmap_data"");
}
fz_catch(VAR_0)
{
fz_drop_separations(VAR_0, VAR_8->seps);
fz_drop_colorspace(VAR_0, VAR_8->colorspace);
fz_free(VAR_0, VAR_8);
fz_rethrow(VAR_0);
}
VAR_8->flags |= VAR_16;
}
return VAR_8;
}",ArtifexSoftware/mupdf/af1e390a2c7abceb32676ec684cd1dbb92907ce8/pixmap.c/vul/before/0.json,"fz_pixmap *
fz_new_pixmap_with_data(fz_context *ctx, fz_colorspace *colorspace, int w, int h, fz_separations *seps, int alpha, int stride, unsigned char *samples)
{
	fz_pixmap *pix;
	int s = fz_count_active_separations(ctx, seps);
	int n;

	if (w < 0 || h < 0)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""Illegal dimensions for pixmap %d %d"", w, h);

	n = alpha + s + fz_colorspace_n(ctx, colorspace);
	if (stride < n*w && stride > -n*w)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""Illegal stride for pixmap (n=%d w=%d, stride=%d)"", n, w, stride);
	if (samples == NULL && stride < n*w)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""Illegal -ve stride for pixmap without data"");
	if (n > FZ_MAX_COLORS)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""Illegal number of colorants"");

	pix = fz_malloc_struct(ctx, fz_pixmap);
	FZ_INIT_STORABLE(pix, 1, fz_drop_pixmap_imp);
	pix->x = 0;
	pix->y = 0;
	pix->w = w;
	pix->h = h;
	pix->alpha = alpha = !!alpha;
	pix->flags = FZ_PIXMAP_FLAG_INTERPOLATE;
	pix->xres = 96;
	pix->yres = 96;
	pix->colorspace = NULL;
	pix->n = n;
	pix->s = s;
	pix->seps = fz_keep_separations(ctx, seps);
	pix->stride = stride;

	if (colorspace)
	{
		pix->colorspace = fz_keep_colorspace(ctx, colorspace);
	}
	else
	{
		assert(alpha || s);
	}

	pix->samples = samples;
	if (!samples && pix->h > 0 && pix->w > 0)
	{
		fz_try(ctx)
		{
			if (pix->stride > INT_MAX / pix->h)
				fz_throw(ctx, FZ_ERROR_GENERIC, ""Overly large image"");
			pix->samples = Memento_label(fz_malloc(ctx, pix->h * pix->stride), ""pixmap_data"");
		}
		fz_catch(ctx)
		{
			fz_drop_separations(ctx, pix->seps);
			fz_drop_colorspace(ctx, pix->colorspace);
			fz_free(ctx, pix);
			fz_rethrow(ctx);
		}
		pix->flags |= FZ_PIXMAP_FLAG_FREE_SAMPLES;
	}

	return pix;
}","fz_pixmap *
fz_new_pixmap_with_data(fz_context *VAR_0, fz_colorspace *VAR_1, int VAR_2, int VAR_3, fz_separations *VAR_4, int VAR_5, int VAR_6, unsigned char *VAR_7)
{
	fz_pixmap *VAR_8;
	int VAR_9 = fz_count_active_separations(VAR_0, VAR_4);
	int VAR_10;

	if (VAR_2 < 0 || VAR_3 < 0)
		fz_throw(VAR_0, VAR_11, ""Illegal dimensions for pixmap %d %d"", VAR_2, VAR_3);

	VAR_10 = VAR_5 + VAR_9 + fz_colorspace_n(VAR_0, VAR_1);
	if (VAR_6 < VAR_10*VAR_2 && VAR_6 > -VAR_10*VAR_2)
		fz_throw(VAR_0, VAR_11, ""Illegal stride for pixmap (n=%d w=%d, stride=%d)"", VAR_10, VAR_2, VAR_6);
	if (VAR_7 == NULL && VAR_6 < VAR_10*VAR_2)
		fz_throw(VAR_0, VAR_11, ""Illegal -ve stride for pixmap without data"");
	if (VAR_10 > VAR_12)
		fz_throw(VAR_0, VAR_11, ""Illegal number of colorants"");

	VAR_8 = fz_malloc_struct(VAR_0, fz_pixmap);
	FZ_INIT_STORABLE(VAR_8, 1, VAR_13);
	VAR_8->x = 0;
	VAR_8->y = 0;
	VAR_8->w = VAR_2;
	VAR_8->h = VAR_3;
	VAR_8->alpha = VAR_5 = !!VAR_5;
	VAR_8->flags = VAR_14;
	VAR_8->xres = 96;
	VAR_8->yres = 96;
	VAR_8->colorspace = NULL;
	VAR_8->n = VAR_10;
	VAR_8->s = VAR_9;
	VAR_8->seps = fz_keep_separations(VAR_0, VAR_4);
	VAR_8->stride = VAR_6;

	if (VAR_1)
	{
		VAR_8->colorspace = fz_keep_colorspace(VAR_0, VAR_1);
	}
	else
	{
		assert(VAR_5 || VAR_9);
	}

	VAR_8->samples = VAR_7;
	if (!VAR_7 && VAR_8->h > 0 && VAR_8->w > 0)
	{
		fz_try(VAR_0)
		{
			if (VAR_8->stride > VAR_15 / VAR_8->h)
				fz_throw(VAR_0, VAR_11, ""Overly large image"");
			VAR_8->samples = Memento_label(fz_malloc(VAR_0, VAR_8->h * VAR_8->stride), ""pixmap_data"");
		}
		fz_catch(VAR_0)
		{
			fz_drop_separations(VAR_0, VAR_8->seps);
			fz_drop_colorspace(VAR_0, VAR_8->colorspace);
			fz_free(VAR_0, VAR_8);
			fz_rethrow(VAR_0);
		}
		VAR_8->flags |= VAR_16;
	}

	return VAR_8;
}",ArtifexSoftware/mupdf/af1e390a2c7abceb32676ec684cd1dbb92907ce8/pixmap.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -42,12 +42,12 @@
 	}
 
 	pix->samples = samples;
-	if (!samples)
+	if (!samples && pix->h > 0 && pix->w > 0)
 	{
 		fz_try(ctx)
 		{
-			if (pix->stride - 1 > INT_MAX / pix->n)
-				fz_throw(ctx, FZ_ERROR_GENERIC, ""overly wide image"");
+			if (pix->stride > INT_MAX / pix->h)
+				fz_throw(ctx, FZ_ERROR_GENERIC, ""Overly large image"");
 			pix->samples = Memento_label(fz_malloc(ctx, pix->h * pix->stride), ""pixmap_data"");
 		}
 		fz_catch(ctx)","{'deleted_lines': ['\tif (!samples)', '\t\t\tif (pix->stride - 1 > INT_MAX / pix->n)', '\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, ""overly wide image"");'], 'added_lines': ['\tif (!samples && pix->h > 0 && pix->w > 0)', '\t\t\tif (pix->stride > INT_MAX / pix->h)', '\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, ""Overly large image"");']}",True,Artifex MuPDF before 1.18.0 has a heap based buffer over-write when parsing JBIG2 files allowing attackers to cause a denial of service.,5.5,MEDIUM,1,test,2020-09-25T12:19:48Z,3
CVE-2020-26519,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ArtifexSoftware/mupdf,"Bug 702857: Detect/avoid overflow when calculating sizes of pixmaps.

Throw an error when trying to allocate an overly large pixmap.",af1e390a2c7abceb32676ec684cd1dbb92907ce8,https://github.com/ArtifexSoftware/mupdf/commit/af1e390a2c7abceb32676ec684cd1dbb92907ce8,source/fitz/pixmap.c,fz_new_pixmap,"fz_pixmap *
fz_new_pixmap(fz_context *ctx, fz_colorspace *colorspace, int w, int h, fz_separations *seps, int alpha)
{
int stride;
int s = fz_count_active_separations(ctx, seps);
if (!colorspace && s == 0) alpha = 1;
stride = (fz_colorspace_n(ctx, colorspace) + s + alpha) * w;
return fz_new_pixmap_with_data(ctx, colorspace, w, h, seps, alpha, stride, NULL);
}","fz_pixmap *
fz_new_pixmap(fz_context *VAR_0, fz_colorspace *VAR_1, int VAR_2, int VAR_3, fz_separations *VAR_4, int VAR_5)
{
int VAR_6;
int VAR_7 = fz_count_active_separations(VAR_0, VAR_4);
if (!VAR_1 && VAR_7 == 0) VAR_5 = 1;
VAR_6 = (fz_colorspace_n(VAR_0, VAR_1) + VAR_7 + VAR_5) * VAR_2;
return fz_new_pixmap_with_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6, NULL);
}",ArtifexSoftware/mupdf/af1e390a2c7abceb32676ec684cd1dbb92907ce8/pixmap.c/vul/before/1.json,"fz_pixmap *
fz_new_pixmap(fz_context *ctx, fz_colorspace *colorspace, int w, int h, fz_separations *seps, int alpha)
{
	int stride;
	int s = fz_count_active_separations(ctx, seps);
	int n;
	if (!colorspace && s == 0) alpha = 1;
	n = fz_colorspace_n(ctx, colorspace) + s + alpha;
	if (w > INT_MAX / n)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""Overly wide image"");
	stride = n * w;
	return fz_new_pixmap_with_data(ctx, colorspace, w, h, seps, alpha, stride, NULL);
}","fz_pixmap *
fz_new_pixmap(fz_context *VAR_0, fz_colorspace *VAR_1, int VAR_2, int VAR_3, fz_separations *VAR_4, int VAR_5)
{
	int VAR_6;
	int VAR_7 = fz_count_active_separations(VAR_0, VAR_4);
	int VAR_8;
	if (!VAR_1 && VAR_7 == 0) VAR_5 = 1;
	VAR_8 = fz_colorspace_n(VAR_0, VAR_1) + VAR_7 + VAR_5;
	if (VAR_2 > VAR_9 / VAR_8)
		fz_throw(VAR_0, VAR_10, ""Overly wide image"");
	VAR_6 = VAR_8 * VAR_2;
	return fz_new_pixmap_with_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6, NULL);
}",ArtifexSoftware/mupdf/af1e390a2c7abceb32676ec684cd1dbb92907ce8/pixmap.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -3,7 +3,11 @@
 {
 	int stride;
 	int s = fz_count_active_separations(ctx, seps);
+	int n;
 	if (!colorspace && s == 0) alpha = 1;
-	stride = (fz_colorspace_n(ctx, colorspace) + s + alpha) * w;
+	n = fz_colorspace_n(ctx, colorspace) + s + alpha;
+	if (w > INT_MAX / n)
+		fz_throw(ctx, FZ_ERROR_GENERIC, ""Overly wide image"");
+	stride = n * w;
 	return fz_new_pixmap_with_data(ctx, colorspace, w, h, seps, alpha, stride, NULL);
 }","{'deleted_lines': ['\tstride = (fz_colorspace_n(ctx, colorspace) + s + alpha) * w;'], 'added_lines': ['\tint n;', '\tn = fz_colorspace_n(ctx, colorspace) + s + alpha;', '\tif (w > INT_MAX / n)', '\t\tfz_throw(ctx, FZ_ERROR_GENERIC, ""Overly wide image"");', '\tstride = n * w;']}",True,Artifex MuPDF before 1.18.0 has a heap based buffer over-write when parsing JBIG2 files allowing attackers to cause a denial of service.,5.5,MEDIUM,1,test,2020-09-25T12:19:48Z,3
CVE-2021-32278,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,knik0/faad2,"Check return value of ltp_data.

Fixes #62.",e19a5e491354e0e4664d02b796dacee28fb2521e,https://github.com/knik0/faad2/commit/e19a5e491354e0e4664d02b796dacee28fb2521e,libfaad/syntax.c,ics_info,"static uint8_t ics_info(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld,
uint8_t common_window)
{
uint8_t retval = 0;
uint8_t ics_reserved_bit;
ics_reserved_bit = faad_get1bit(ld
DEBUGVAR(1,43,""ics_info(): ics_reserved_bit""));
if (ics_reserved_bit != 0)
return 32;
ics->window_sequence = (uint8_t)faad_getbits(ld, 2
DEBUGVAR(1,44,""ics_info(): window_sequence""));
ics->window_shape = faad_get1bit(ld
DEBUGVAR(1,45,""ics_info(): window_shape""));
#ifdef LD_DEC
if ((hDecoder->object_type == LD) && (ics->window_sequence != ONLY_LONG_SEQUENCE))
return 32;
#endif
if (ics->window_sequence == EIGHT_SHORT_SEQUENCE)
{
ics->max_sfb = (uint8_t)faad_getbits(ld, 4
DEBUGVAR(1,46,""ics_info(): max_sfb (short)""));
ics->scale_factor_grouping = (uint8_t)faad_getbits(ld, 7
DEBUGVAR(1,47,""ics_info(): scale_factor_grouping""));
} else {
ics->max_sfb = (uint8_t)faad_getbits(ld, 6
DEBUGVAR(1,48,""ics_info(): max_sfb (long)""));
}
if ((retval = window_grouping_info(hDecoder, ics)) > 0)
return retval;
if (ics->max_sfb > ics->num_swb)
return 16;
if (ics->window_sequence != EIGHT_SHORT_SEQUENCE)
{
if ((ics->predictor_data_present = faad_get1bit(ld
DEBUGVAR(1,49,""ics_info(): predictor_data_present""))) & 1)
{
if (hDecoder->object_type == MAIN) 
{
uint8_t sfb;
uint8_t limit = min(ics->max_sfb, max_pred_sfb(hDecoder->sf_index));
#ifdef MAIN_DEC
ics->pred.limit = limit;
#endif
if ((
#ifdef MAIN_DEC
ics->pred.predictor_reset =
#endif
faad_get1bit(ld DEBUGVAR(1,53,""ics_info(): pred.predictor_reset""))) & 1)
{
#ifdef MAIN_DEC
ics->pred.predictor_reset_group_number =
#endif
(uint8_t)faad_getbits(ld, 5 DEBUGVAR(1,54,""ics_info(): pred.predictor_reset_group_number""));
}
for (sfb = 0; sfb < limit; sfb++)
{
#ifdef MAIN_DEC
ics->pred.prediction_used[sfb] =
#endif
faad_get1bit(ld DEBUGVAR(1,55,""ics_info(): pred.prediction_used""));
}
}
#ifdef LTP_DEC
else { 
if (hDecoder->object_type < ER_OBJECT_START)
{
if ((ics->ltp.data_present = faad_get1bit(ld
DEBUGVAR(1,50,""ics_info(): ltp.data_present""))) & 1)
{
if ((retval = ltp_data(hDecoder, ics, &(ics->ltp), ld)) > 0)
{
return retval;
}
}
if (common_window)
{
if ((ics->ltp2.data_present = faad_get1bit(ld
DEBUGVAR(1,51,""ics_info(): ltp2.data_present""))) & 1)
{
if ((retval = ltp_data(hDecoder, ics, &(ics->ltp2), ld)) > 0)
{
return retval;
}
}
}
}
#ifdef ERROR_RESILIENCE
if (!common_window && (hDecoder->object_type >= ER_OBJECT_START))
{
if ((ics->ltp.data_present = faad_get1bit(ld
DEBUGVAR(1,50,""ics_info(): ltp.data_present""))) & 1)
{
ltp_data(hDecoder, ics, &(ics->ltp), ld);
}
}
#endif
}
#endif
}
}
return retval;
}","static uint8_t ics_info(NeAACDecStruct *VAR_0, ic_stream *VAR_1, bitfile *VAR_2,
uint8_t VAR_3)
{
uint8_t VAR_4 = 0;
uint8_t VAR_5;
VAR_5 = faad_get1bit(VAR_2
DEBUGVAR(1,43,""ics_info(): ics_reserved_bit""));
if (VAR_5 != 0)
return 32;
VAR_1->window_sequence = (uint8_t)faad_getbits(VAR_2, 2
DEBUGVAR(1,44,""ics_info(): window_sequence""));
VAR_1->window_shape = faad_get1bit(VAR_2
DEBUGVAR(1,45,""ics_info(): window_shape""));
#ifdef VAR_6
if ((VAR_0->object_type == VAR_7) && (VAR_1->window_sequence != VAR_8))
return 32;
#endif
if (VAR_1->window_sequence == VAR_9)
{
VAR_1->max_sfb = (uint8_t)faad_getbits(VAR_2, 4
DEBUGVAR(1,46,""ics_info(): max_sfb (short)""));
VAR_1->scale_factor_grouping = (uint8_t)faad_getbits(VAR_2, 7
DEBUGVAR(1,47,""ics_info(): scale_factor_grouping""));
} else {
VAR_1->max_sfb = (uint8_t)faad_getbits(VAR_2, 6
DEBUGVAR(1,48,""ics_info(): max_sfb (long)""));
}
if ((VAR_4 = window_grouping_info(VAR_0, VAR_1)) > 0)
return VAR_4;
if (VAR_1->max_sfb > VAR_1->num_swb)
return 16;
if (VAR_1->window_sequence != VAR_9)
{
if ((VAR_1->predictor_data_present = faad_get1bit(VAR_2
DEBUGVAR(1,49,""ics_info(): predictor_data_present""))) & 1)
{
if (VAR_0->object_type == VAR_10) 
{
uint8_t VAR_11;
uint8_t VAR_12 = min(VAR_1->max_sfb, max_pred_sfb(VAR_0->sf_index));
#ifdef VAR_13
VAR_1->pred.limit = VAR_12;
#endif
if ((
#ifdef VAR_13
VAR_1->pred.predictor_reset =
#endif
faad_get1bit(VAR_2 DEBUGVAR(1,53,""ics_info(): pred.predictor_reset""))) & 1)
{
#ifdef VAR_13
VAR_1->pred.predictor_reset_group_number =
#endif
(uint8_t)faad_getbits(VAR_2, 5 DEBUGVAR(1,54,""ics_info(): pred.predictor_reset_group_number""));
}
for (VAR_11 = 0; VAR_11 < VAR_12; VAR_11++)
{
#ifdef VAR_13
VAR_1->pred.prediction_used[VAR_11] =
#endif
faad_get1bit(VAR_2 DEBUGVAR(1,55,""ics_info(): pred.prediction_used""));
}
}
#ifdef VAR_14
else { 
if (VAR_0->object_type < VAR_15)
{
if ((VAR_1->ltp.data_present = faad_get1bit(VAR_2
DEBUGVAR(1,50,""ics_info(): ltp.data_present""))) & 1)
{
if ((VAR_4 = ltp_data(VAR_0, VAR_1, &(VAR_1->ltp), VAR_2)) > 0)
{
return VAR_4;
}
}
if (VAR_3)
{
if ((VAR_1->ltp2.data_present = faad_get1bit(VAR_2
DEBUGVAR(1,51,""ics_info(): ltp2.data_present""))) & 1)
{
if ((VAR_4 = ltp_data(VAR_0, VAR_1, &(VAR_1->ltp2), VAR_2)) > 0)
{
return VAR_4;
}
}
}
}
#ifdef VAR_16
if (!VAR_3 && (VAR_0->object_type >= VAR_15))
{
if ((VAR_1->ltp.data_present = faad_get1bit(VAR_2
DEBUGVAR(1,50,""ics_info(): ltp.data_present""))) & 1)
{
ltp_data(VAR_0, VAR_1, &(VAR_1->ltp), VAR_2);
}
}
#endif
}
#endif
}
}
return VAR_4;
}",knik0/faad2/e19a5e491354e0e4664d02b796dacee28fb2521e/syntax.c/vul/before/0.json,"static uint8_t ics_info(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld,
                        uint8_t common_window)
{
    uint8_t retval = 0;
    uint8_t ics_reserved_bit;

    ics_reserved_bit = faad_get1bit(ld
        DEBUGVAR(1,43,""ics_info(): ics_reserved_bit""));
    if (ics_reserved_bit != 0)
        return 32;
    ics->window_sequence = (uint8_t)faad_getbits(ld, 2
        DEBUGVAR(1,44,""ics_info(): window_sequence""));
    ics->window_shape = faad_get1bit(ld
        DEBUGVAR(1,45,""ics_info(): window_shape""));

#ifdef LD_DEC
    /* No block switching in LD */
    if ((hDecoder->object_type == LD) && (ics->window_sequence != ONLY_LONG_SEQUENCE))
        return 32;
#endif

    if (ics->window_sequence == EIGHT_SHORT_SEQUENCE)
    {
        ics->max_sfb = (uint8_t)faad_getbits(ld, 4
            DEBUGVAR(1,46,""ics_info(): max_sfb (short)""));
        ics->scale_factor_grouping = (uint8_t)faad_getbits(ld, 7
            DEBUGVAR(1,47,""ics_info(): scale_factor_grouping""));
    } else {
        ics->max_sfb = (uint8_t)faad_getbits(ld, 6
            DEBUGVAR(1,48,""ics_info(): max_sfb (long)""));
    }

    /* get the grouping information */
    if ((retval = window_grouping_info(hDecoder, ics)) > 0)
        return retval;


    /* should be an error */
    /* check the range of max_sfb */
    if (ics->max_sfb > ics->num_swb)
        return 16;

    if (ics->window_sequence != EIGHT_SHORT_SEQUENCE)
    {
        if ((ics->predictor_data_present = faad_get1bit(ld
            DEBUGVAR(1,49,""ics_info(): predictor_data_present""))) & 1)
        {
            if (hDecoder->object_type == MAIN) /* MPEG2 style AAC predictor */
            {
                uint8_t sfb;

                uint8_t limit = min(ics->max_sfb, max_pred_sfb(hDecoder->sf_index));
#ifdef MAIN_DEC
                ics->pred.limit = limit;
#endif

                if ((
#ifdef MAIN_DEC
                    ics->pred.predictor_reset =
#endif
                    faad_get1bit(ld DEBUGVAR(1,53,""ics_info(): pred.predictor_reset""))) & 1)
                {
#ifdef MAIN_DEC
                    ics->pred.predictor_reset_group_number =
#endif
                        (uint8_t)faad_getbits(ld, 5 DEBUGVAR(1,54,""ics_info(): pred.predictor_reset_group_number""));
                }

                for (sfb = 0; sfb < limit; sfb++)
                {
#ifdef MAIN_DEC
                    ics->pred.prediction_used[sfb] =
#endif
                        faad_get1bit(ld DEBUGVAR(1,55,""ics_info(): pred.prediction_used""));
                }
            }
#ifdef LTP_DEC
            else { /* Long Term Prediction */
                if (hDecoder->object_type < ER_OBJECT_START)
                {
                    if ((ics->ltp.data_present = faad_get1bit(ld
                        DEBUGVAR(1,50,""ics_info(): ltp.data_present""))) & 1)
                    {
                        if ((retval = ltp_data(hDecoder, ics, &(ics->ltp), ld)) > 0)
                        {
                            return retval;
                        }
                    }
                    if (common_window)
                    {
                        if ((ics->ltp2.data_present = faad_get1bit(ld
                            DEBUGVAR(1,51,""ics_info(): ltp2.data_present""))) & 1)
                        {
                            if ((retval = ltp_data(hDecoder, ics, &(ics->ltp2), ld)) > 0)
                            {
                                return retval;
                            }
                        }
                    }
                }
#ifdef ERROR_RESILIENCE
                if (!common_window && (hDecoder->object_type >= ER_OBJECT_START))
                {
                    if ((ics->ltp.data_present = faad_get1bit(ld
                        DEBUGVAR(1,50,""ics_info(): ltp.data_present""))) & 1)
                    {
                        if ((retval = ltp_data(hDecoder, ics, &(ics->ltp), ld)) > 0)
                        {
                            return retval;
                        }
                    }
                }
#endif
            }
#endif
        }
    }

    return retval;
}","static uint8_t ics_info(NeAACDecStruct *VAR_0, ic_stream *VAR_1, bitfile *VAR_2,
                        uint8_t VAR_3)
{
    uint8_t VAR_4 = 0;
    uint8_t VAR_5;

    VAR_5 = faad_get1bit(VAR_2
        DEBUGVAR(1,43,""ics_info(): ics_reserved_bit""));
    if (VAR_5 != 0)
        return 32;
    VAR_1->window_sequence = (uint8_t)faad_getbits(VAR_2, 2
        DEBUGVAR(1,44,""ics_info(): window_sequence""));
    VAR_1->window_shape = faad_get1bit(VAR_2
        DEBUGVAR(1,45,""ics_info(): window_shape""));

#ifdef VAR_6
    /* COMMENT_0 */
    if ((VAR_0->object_type == VAR_7) && (VAR_1->window_sequence != VAR_8))
        return 32;
#endif

    if (VAR_1->window_sequence == VAR_9)
    {
        VAR_1->max_sfb = (uint8_t)faad_getbits(VAR_2, 4
            DEBUGVAR(1,46,""ics_info(): max_sfb (short)""));
        VAR_1->scale_factor_grouping = (uint8_t)faad_getbits(VAR_2, 7
            DEBUGVAR(1,47,""ics_info(): scale_factor_grouping""));
    } else {
        VAR_1->max_sfb = (uint8_t)faad_getbits(VAR_2, 6
            DEBUGVAR(1,48,""ics_info(): max_sfb (long)""));
    }

    /* COMMENT_1 */
    if ((VAR_4 = window_grouping_info(VAR_0, VAR_1)) > 0)
        return VAR_4;


    /* COMMENT_2 */
    /* COMMENT_3 */
    if (VAR_1->max_sfb > VAR_1->num_swb)
        return 16;

    if (VAR_1->window_sequence != VAR_9)
    {
        if ((VAR_1->predictor_data_present = faad_get1bit(VAR_2
            DEBUGVAR(1,49,""ics_info(): predictor_data_present""))) & 1)
        {
            if (VAR_0->object_type == VAR_10) /* COMMENT_4 */
            {
                uint8_t VAR_11;

                uint8_t VAR_12 = min(VAR_1->max_sfb, max_pred_sfb(VAR_0->sf_index));
#ifdef VAR_13
                VAR_1->pred.limit = VAR_12;
#endif

                if ((
#ifdef VAR_13
                    VAR_1->pred.predictor_reset =
#endif
                    faad_get1bit(VAR_2 DEBUGVAR(1,53,""ics_info(): pred.predictor_reset""))) & 1)
                {
#ifdef VAR_13
                    VAR_1->pred.predictor_reset_group_number =
#endif
                        (uint8_t)faad_getbits(VAR_2, 5 DEBUGVAR(1,54,""ics_info(): pred.predictor_reset_group_number""));
                }

                for (VAR_11 = 0; VAR_11 < VAR_12; VAR_11++)
                {
#ifdef VAR_13
                    VAR_1->pred.prediction_used[VAR_11] =
#endif
                        faad_get1bit(VAR_2 DEBUGVAR(1,55,""ics_info(): pred.prediction_used""));
                }
            }
#ifdef VAR_14
            else { /* COMMENT_5 */
                if (VAR_0->object_type < VAR_15)
                {
                    if ((VAR_1->ltp.data_present = faad_get1bit(VAR_2
                        DEBUGVAR(1,50,""ics_info(): ltp.data_present""))) & 1)
                    {
                        if ((VAR_4 = ltp_data(VAR_0, VAR_1, &(VAR_1->ltp), VAR_2)) > 0)
                        {
                            return VAR_4;
                        }
                    }
                    if (VAR_3)
                    {
                        if ((VAR_1->ltp2.data_present = faad_get1bit(VAR_2
                            DEBUGVAR(1,51,""ics_info(): ltp2.data_present""))) & 1)
                        {
                            if ((VAR_4 = ltp_data(VAR_0, VAR_1, &(VAR_1->ltp2), VAR_2)) > 0)
                            {
                                return VAR_4;
                            }
                        }
                    }
                }
#ifdef VAR_16
                if (!VAR_3 && (VAR_0->object_type >= VAR_15))
                {
                    if ((VAR_1->ltp.data_present = faad_get1bit(VAR_2
                        DEBUGVAR(1,50,""ics_info(): ltp.data_present""))) & 1)
                    {
                        if ((VAR_4 = ltp_data(VAR_0, VAR_1, &(VAR_1->ltp), VAR_2)) > 0)
                        {
                            return VAR_4;
                        }
                    }
                }
#endif
            }
#endif
        }
    }

    return VAR_4;
}",knik0/faad2/e19a5e491354e0e4664d02b796dacee28fb2521e/syntax.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -104,7 +104,10 @@
                     if ((ics->ltp.data_present = faad_get1bit(ld
                         DEBUGVAR(1,50,""ics_info(): ltp.data_present""))) & 1)
                     {
-                        ltp_data(hDecoder, ics, &(ics->ltp), ld);
+                        if ((retval = ltp_data(hDecoder, ics, &(ics->ltp), ld)) > 0)
+                        {
+                            return retval;
+                        }
                     }
                 }
 #endif","{'deleted_lines': ['                        ltp_data(hDecoder, ics, &(ics->ltp), ld);'], 'added_lines': ['                        if ((retval = ltp_data(hDecoder, ics, &(ics->ltp), ld)) > 0)', '                        {', '                            return retval;', '                        }']}",True,An issue was discovered in faad2 through 2.10.0. A heap-buffer-overflow exists in the function lt_prediction located in lt_predict.c. It allows an attacker to cause code Execution.,7.8,HIGH,2,test,2020-10-05T05:33:44Z,3
CVE-2022-48571,['CWE-400'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,memcached,"udp: crash fix when receiving multi-packet uploads

multi-packet sets aren't supported in UDP. It was trying to write an
error message in response, but no mc_resp object was initialized at the
time, leading to a null reference crash.

Instead drop the packet quietly since that's a pretty fatal bug anyway
and keeps the parser simplified.

For credits see accompanying release notes.",6b319c8c7a29e9c353dec83dc92f01905f6c8966,https://github.com/memcached/memcached/commit/6b319c8c7a29e9c353dec83dc92f01905f6c8966,memcached.c,out_string,"void out_string(conn *c, const char *str) {
size_t len;
mc_resp *resp = c->resp;
assert(c != NULL);
resp_reset(resp);
if (c->noreply) {
resp->skip = true;
if (settings.verbose > 1)
fprintf(stderr, "">%d NOREPLY %s\n"", c->sfd, str);
conn_set_state(c, conn_new_cmd);
return;
}
if (settings.verbose > 1)
fprintf(stderr, "">%d %s\n"", c->sfd, str);
len = strlen(str);
if ((len + 2) > WRITE_BUFFER_SIZE) {
str = ""SERVER_ERROR output line too long"";
len = strlen(str);
}
memcpy(resp->wbuf, str, len);
memcpy(resp->wbuf + len, ""\r\n"", 2);
resp_add_iov(resp, resp->wbuf, len + 2);
conn_set_state(c, conn_new_cmd);
return;
}","void out_string(conn *VAR_0, const char *VAR_1) {
size_t VAR_2;
mc_resp *VAR_3 = VAR_0->resp;
assert(VAR_0 != NULL);
resp_reset(VAR_3);
if (VAR_0->noreply) {
VAR_3->skip = true;
if (VAR_4.verbose > 1)
fprintf(VAR_5, "">%d NOREPLY %s\n"", VAR_0->sfd, VAR_1);
conn_set_state(VAR_0, VAR_6);
return;
}
if (VAR_4.verbose > 1)
fprintf(VAR_5, "">%d %s\n"", VAR_0->sfd, VAR_1);
VAR_2 = strlen(VAR_1);
if ((VAR_2 + 2) > VAR_7) {
VAR_1 = ""SERVER_ERROR output line too long"";
VAR_2 = strlen(VAR_1);
}
memcpy(VAR_3->wbuf, VAR_1, VAR_2);
memcpy(VAR_3->wbuf + VAR_2, ""\r\n"", 2);
resp_add_iov(VAR_3, VAR_3->wbuf, VAR_2 + 2);
conn_set_state(VAR_0, VAR_6);
return;
}",memcached/6b319c8c7a29e9c353dec83dc92f01905f6c8966/memcached.c/vul/before/1.json,"void out_string(conn *c, const char *str) {
    size_t len;
    assert(c != NULL);
    mc_resp *resp = c->resp;

    // if response was original filled with something, but we're now writing
    // out an error or similar, have to reset the object first.
    // TODO: since this is often redundant with allocation, how many callers
    // are actually requiring it be reset? Can we fast test by just looking at
    // tosend and reset if nonzero?
    resp_reset(resp);

    if (c->noreply) {
        // TODO: just invalidate the response since nothing's been attempted
        // to send yet?
        resp->skip = true;
        if (settings.verbose > 1)
            fprintf(stderr, "">%d NOREPLY %s\n"", c->sfd, str);
        conn_set_state(c, conn_new_cmd);
        return;
    }

    if (settings.verbose > 1)
        fprintf(stderr, "">%d %s\n"", c->sfd, str);

    // Fill response object with static string.

    len = strlen(str);
    if ((len + 2) > WRITE_BUFFER_SIZE) {
        /* ought to be always enough. just fail for simplicity */
        str = ""SERVER_ERROR output line too long"";
        len = strlen(str);
    }

    memcpy(resp->wbuf, str, len);
    memcpy(resp->wbuf + len, ""\r\n"", 2);
    resp_add_iov(resp, resp->wbuf, len + 2);

    conn_set_state(c, conn_new_cmd);
    return;
}","void out_string(conn *VAR_0, const char *VAR_1) {
    size_t VAR_2;
    assert(VAR_0 != NULL);
    mc_resp *VAR_3 = VAR_0->resp;

    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    resp_reset(VAR_3);

    if (VAR_0->noreply) {
        /* COMMENT_5 */
        /* COMMENT_6 */
        VAR_3->skip = true;
        if (VAR_4.verbose > 1)
            fprintf(VAR_5, "">%d NOREPLY %s\n"", VAR_0->sfd, VAR_1);
        conn_set_state(VAR_0, VAR_6);
        return;
    }

    if (VAR_4.verbose > 1)
        fprintf(VAR_5, "">%d %s\n"", VAR_0->sfd, VAR_1);

    /* COMMENT_7 */

    VAR_2 = strlen(VAR_1);
    if ((VAR_2 + 2) > VAR_7) {
        /* COMMENT_8 */
        VAR_1 = ""SERVER_ERROR output line too long"";
        VAR_2 = strlen(VAR_1);
    }

    memcpy(VAR_3->wbuf, VAR_1, VAR_2);
    memcpy(VAR_3->wbuf + VAR_2, ""\r\n"", 2);
    resp_add_iov(VAR_3, VAR_3->wbuf, VAR_2 + 2);

    conn_set_state(VAR_0, VAR_6);
    return;
}",memcached/6b319c8c7a29e9c353dec83dc92f01905f6c8966/memcached.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,8 +1,8 @@
 void out_string(conn *c, const char *str) {
     size_t len;
+    assert(c != NULL);
     mc_resp *resp = c->resp;
 
-    assert(c != NULL);
     // if response was original filled with something, but we're now writing
     // out an error or similar, have to reset the object first.
     // TODO: since this is often redundant with allocation, how many callers","{'deleted_lines': ['    assert(c != NULL);'], 'added_lines': ['    assert(c != NULL);']}",True,memcached 1.6.7 allows a Denial of Service via multi-packet uploads in UDP.,7.5,HIGH,2,test,2020-10-26T23:29:07Z,3
CVE-2022-48571,['CWE-400'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,memcached,"udp: crash fix when receiving multi-packet uploads

multi-packet sets aren't supported in UDP. It was trying to write an
error message in response, but no mc_resp object was initialized at the
time, leading to a null reference crash.

Instead drop the packet quietly since that's a pretty fatal bug anyway
and keeps the parser simplified.

For credits see accompanying release notes.",6b319c8c7a29e9c353dec83dc92f01905f6c8966,https://github.com/memcached/memcached/commit/6b319c8c7a29e9c353dec83dc92f01905f6c8966,memcached.c,try_read_udp,"static enum try_read_result try_read_udp(conn *c) {
int res;
assert(c != NULL);
c->request_addr_size = sizeof(c->request_addr);
res = recvfrom(c->sfd, c->rbuf, c->rsize,
0, (struct sockaddr *)&c->request_addr,
&c->request_addr_size);
if (res > 8) {
unsigned char *buf = (unsigned char *)c->rbuf;
pthread_mutex_lock(&c->thread->stats.mutex);
c->thread->stats.bytes_read += res;
pthread_mutex_unlock(&c->thread->stats.mutex);
c->request_id = buf[0] * 256 + buf[1];
if (buf[4] != 0 || buf[5] != 1) {
out_string(c, ""SERVER_ERROR multi-packet request not supported"");
return READ_NO_DATA_RECEIVED;
}
res -= 8;
memmove(c->rbuf, c->rbuf + 8, res);
c->rbytes = res;
c->rcurr = c->rbuf;
return READ_DATA_RECEIVED;
}
return READ_NO_DATA_RECEIVED;
}","static enum try_read_result try_read_udp(conn *VAR_0) {
int VAR_1;
assert(VAR_0 != NULL);
VAR_0->request_addr_size = sizeof(VAR_0->request_addr);
VAR_1 = recvfrom(VAR_0->sfd, VAR_0->rbuf, VAR_0->rsize,
0, (struct sockaddr *)&VAR_0->request_addr,
&VAR_0->request_addr_size);
if (VAR_1 > 8) {
unsigned char *VAR_2 = (unsigned char *)VAR_0->rbuf;
pthread_mutex_lock(&VAR_0->thread->stats.mutex);
VAR_0->thread->stats.bytes_read += VAR_1;
pthread_mutex_unlock(&VAR_0->thread->stats.mutex);
VAR_0->request_id = VAR_2[0] * 256 + VAR_2[1];
if (VAR_2[4] != 0 || VAR_2[5] != 1) {
out_string(VAR_0, ""SERVER_ERROR multi-packet request not supported"");
return VAR_3;
}
VAR_1 -= 8;
memmove(VAR_0->rbuf, VAR_0->rbuf + 8, VAR_1);
VAR_0->rbytes = VAR_1;
VAR_0->rcurr = VAR_0->rbuf;
return VAR_4;
}
return VAR_3;
}",memcached/6b319c8c7a29e9c353dec83dc92f01905f6c8966/memcached.c/vul/before/0.json,"static enum try_read_result try_read_udp(conn *c) {
    int res;

    assert(c != NULL);

    c->request_addr_size = sizeof(c->request_addr);
    res = recvfrom(c->sfd, c->rbuf, c->rsize,
                   0, (struct sockaddr *)&c->request_addr,
                   &c->request_addr_size);
    if (res > 8) {
        unsigned char *buf = (unsigned char *)c->rbuf;
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.bytes_read += res;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        /* Beginning of UDP packet is the request ID; save it. */
        c->request_id = buf[0] * 256 + buf[1];

        /* If this is a multi-packet request, drop it. */
        if (buf[4] != 0 || buf[5] != 1) {
            return READ_NO_DATA_RECEIVED;
        }

        /* Don't care about any of the rest of the header. */
        res -= 8;
        memmove(c->rbuf, c->rbuf + 8, res);

        c->rbytes = res;
        c->rcurr = c->rbuf;
        return READ_DATA_RECEIVED;
    }
    return READ_NO_DATA_RECEIVED;
}","static enum try_read_result try_read_udp(conn *VAR_0) {
    int VAR_1;

    assert(VAR_0 != NULL);

    VAR_0->request_addr_size = sizeof(VAR_0->request_addr);
    VAR_1 = recvfrom(VAR_0->sfd, VAR_0->rbuf, VAR_0->rsize,
                   0, (struct sockaddr *)&VAR_0->request_addr,
                   &VAR_0->request_addr_size);
    if (VAR_1 > 8) {
        unsigned char *VAR_2 = (unsigned char *)VAR_0->rbuf;
        pthread_mutex_lock(&VAR_0->thread->stats.mutex);
        VAR_0->thread->stats.bytes_read += VAR_1;
        pthread_mutex_unlock(&VAR_0->thread->stats.mutex);

        /* COMMENT_0 */
        VAR_0->request_id = VAR_2[0] * 256 + VAR_2[1];

        /* COMMENT_1 */
        if (VAR_2[4] != 0 || VAR_2[5] != 1) {
            return VAR_3;
        }

        /* COMMENT_2 */
        VAR_1 -= 8;
        memmove(VAR_0->rbuf, VAR_0->rbuf + 8, VAR_1);

        VAR_0->rbytes = VAR_1;
        VAR_0->rcurr = VAR_0->rbuf;
        return VAR_4;
    }
    return VAR_3;
}",memcached/6b319c8c7a29e9c353dec83dc92f01905f6c8966/memcached.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,7 +18,6 @@
 
         /* If this is a multi-packet request, drop it. */
         if (buf[4] != 0 || buf[5] != 1) {
-            out_string(c, ""SERVER_ERROR multi-packet request not supported"");
             return READ_NO_DATA_RECEIVED;
         }
 ","{'deleted_lines': ['            out_string(c, ""SERVER_ERROR multi-packet request not supported"");'], 'added_lines': []}",True,memcached 1.6.7 allows a Denial of Service via multi-packet uploads in UDP.,7.5,HIGH,2,test,2020-10-26T23:29:07Z,3
CVE-2020-29260,['CWE-400'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,LibVNC/libvncserver,"libvncclient: free vncRec memory in rfbClientCleanup()

Otherwise we leak memory. Spotted by Ramin Farajpour Cami
<ramin.blackhat@gmail.com>, thanks!",bef41f6ec4097a8ee094f90a1b34a708fbd757ec,https://github.com/LibVNC/libvncserver/commit/bef41f6ec4097a8ee094f90a1b34a708fbd757ec,libvncclient/vncviewer.c,rfbClientCleanup,"void rfbClientCleanup(rfbClient* client) {
#ifdef LIBVNCSERVER_HAVE_LIBZ
int i;
for ( i = 0; i < 4; i++ ) {
if (client->zlibStreamActive[i] == TRUE ) {
if (inflateEnd (&client->zlibStream[i]) != Z_OK &&
client->zlibStream[i].msg != NULL)
rfbClientLog(""inflateEnd: %s\n"", client->zlibStream[i].msg);
}
}
if ( client->decompStreamInited == TRUE ) {
if (inflateEnd (&client->decompStream) != Z_OK &&
client->decompStream.msg != NULL)
rfbClientLog(""inflateEnd: %s\n"", client->decompStream.msg );
}
#endif
if (client->ultra_buffer)
free(client->ultra_buffer);
if (client->raw_buffer)
free(client->raw_buffer);
FreeTLS(client);
while (client->clientData) {
rfbClientData* next = client->clientData->next;
free(client->clientData);
client->clientData = next;
}
if (client->sock != RFB_INVALID_SOCKET)
rfbCloseSocket(client->sock);
if (client->listenSock != RFB_INVALID_SOCKET)
rfbCloseSocket(client->listenSock);
free(client->desktopName);
free(client->serverHost);
if (client->destHost)
free(client->destHost);
if (client->clientAuthSchemes)
free(client->clientAuthSchemes);
#ifdef LIBVNCSERVER_HAVE_SASL
if (client->saslSecret)
free(client->saslSecret);
#endif 
#ifdef WIN32
if(WSACleanup() != 0) {
errno=WSAGetLastError();
rfbClientErr(""Could not terminate Windows Sockets: %s\n"", strerror(errno));
}
#endif
free(client);
}","void rfbClientCleanup(rfbClient* VAR_0) {
#ifdef VAR_1
int VAR_2;
for ( VAR_2 = 0; VAR_2 < 4; VAR_2++ ) {
if (VAR_0->zlibStreamActive[VAR_2] == TRUE ) {
if (inflateEnd (&VAR_0->zlibStream[VAR_2]) != VAR_3 &&
VAR_0->zlibStream[VAR_2].msg != NULL)
rfbClientLog(""inflateEnd: %s\n"", VAR_0->zlibStream[VAR_2].msg);
}
}
if ( VAR_0->decompStreamInited == TRUE ) {
if (inflateEnd (&VAR_0->decompStream) != VAR_3 &&
VAR_0->decompStream.msg != NULL)
rfbClientLog(""inflateEnd: %s\n"", VAR_0->decompStream.msg );
}
#endif
if (VAR_0->ultra_buffer)
free(VAR_0->ultra_buffer);
if (VAR_0->raw_buffer)
free(VAR_0->raw_buffer);
FreeTLS(VAR_0);
while (VAR_0->clientData) {
rfbClientData* VAR_4 = VAR_0->clientData->next;
free(VAR_0->clientData);
VAR_0->clientData = VAR_4;
}
if (VAR_0->sock != VAR_5)
rfbCloseSocket(VAR_0->sock);
if (VAR_0->listenSock != VAR_5)
rfbCloseSocket(VAR_0->listenSock);
free(VAR_0->desktopName);
free(VAR_0->serverHost);
if (VAR_0->destHost)
free(VAR_0->destHost);
if (VAR_0->clientAuthSchemes)
free(VAR_0->clientAuthSchemes);
#ifdef VAR_6
if (VAR_0->saslSecret)
free(VAR_0->saslSecret);
#endif 
#ifdef VAR_7
if(WSACleanup() != 0) {
VAR_8=WSAGetLastError();
rfbClientErr(""Could not terminate Windows Sockets: %s\n"", strerror(VAR_8));
}
#endif
free(VAR_0);
}",LibVNC/libvncserver/bef41f6ec4097a8ee094f90a1b34a708fbd757ec/vncviewer.c/vul/before/0.json,"void rfbClientCleanup(rfbClient* client) {
#ifdef LIBVNCSERVER_HAVE_LIBZ
  int i;

  for ( i = 0; i < 4; i++ ) {
    if (client->zlibStreamActive[i] == TRUE ) {
      if (inflateEnd (&client->zlibStream[i]) != Z_OK &&
	  client->zlibStream[i].msg != NULL)
	rfbClientLog(""inflateEnd: %s\n"", client->zlibStream[i].msg);
    }
  }

  if ( client->decompStreamInited == TRUE ) {
    if (inflateEnd (&client->decompStream) != Z_OK &&
	client->decompStream.msg != NULL)
      rfbClientLog(""inflateEnd: %s\n"", client->decompStream.msg );
  }
#endif

  if (client->ultra_buffer)
    free(client->ultra_buffer);

  if (client->raw_buffer)
    free(client->raw_buffer);

  FreeTLS(client);

  while (client->clientData) {
    rfbClientData* next = client->clientData->next;
    free(client->clientData);
    client->clientData = next;
  }

  free(client->vncRec);

  if (client->sock != RFB_INVALID_SOCKET)
    rfbCloseSocket(client->sock);
  if (client->listenSock != RFB_INVALID_SOCKET)
    rfbCloseSocket(client->listenSock);
  free(client->desktopName);
  free(client->serverHost);
  if (client->destHost)
    free(client->destHost);
  if (client->clientAuthSchemes)
    free(client->clientAuthSchemes);

#ifdef LIBVNCSERVER_HAVE_SASL
  if (client->saslSecret)
    free(client->saslSecret);
#endif /* LIBVNCSERVER_HAVE_SASL */

#ifdef WIN32
  if(WSACleanup() != 0) {
      errno=WSAGetLastError();
      rfbClientErr(""Could not terminate Windows Sockets: %s\n"", strerror(errno));
  }
#endif

  free(client);
}","void rfbClientCleanup(rfbClient* VAR_0) {
#ifdef VAR_1
  int VAR_2;

  for ( VAR_2 = 0; VAR_2 < 4; VAR_2++ ) {
    if (VAR_0->zlibStreamActive[VAR_2] == TRUE ) {
      if (inflateEnd (&VAR_0->zlibStream[VAR_2]) != VAR_3 &&
	  VAR_0->zlibStream[VAR_2].msg != NULL)
	rfbClientLog(""inflateEnd: %s\n"", VAR_0->zlibStream[VAR_2].msg);
    }
  }

  if ( VAR_0->decompStreamInited == TRUE ) {
    if (inflateEnd (&VAR_0->decompStream) != VAR_3 &&
	VAR_0->decompStream.msg != NULL)
      rfbClientLog(""inflateEnd: %s\n"", VAR_0->decompStream.msg );
  }
#endif

  if (VAR_0->ultra_buffer)
    free(VAR_0->ultra_buffer);

  if (VAR_0->raw_buffer)
    free(VAR_0->raw_buffer);

  FreeTLS(VAR_0);

  while (VAR_0->clientData) {
    rfbClientData* VAR_4 = VAR_0->clientData->next;
    free(VAR_0->clientData);
    VAR_0->clientData = VAR_4;
  }

  free(VAR_0->vncRec);

  if (VAR_0->sock != VAR_5)
    rfbCloseSocket(VAR_0->sock);
  if (VAR_0->listenSock != VAR_5)
    rfbCloseSocket(VAR_0->listenSock);
  free(VAR_0->desktopName);
  free(VAR_0->serverHost);
  if (VAR_0->destHost)
    free(VAR_0->destHost);
  if (VAR_0->clientAuthSchemes)
    free(VAR_0->clientAuthSchemes);

#ifdef VAR_6
  if (VAR_0->saslSecret)
    free(VAR_0->saslSecret);
#endif /* COMMENT_0 */

#ifdef VAR_7
  if(WSACleanup() != 0) {
      VAR_8=WSAGetLastError();
      rfbClientErr(""Could not terminate Windows Sockets: %s\n"", strerror(VAR_8));
  }
#endif

  free(VAR_0);
}",LibVNC/libvncserver/bef41f6ec4097a8ee094f90a1b34a708fbd757ec/vncviewer.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -31,6 +31,8 @@
     client->clientData = next;
   }
 
+  free(client->vncRec);
+
   if (client->sock != RFB_INVALID_SOCKET)
     rfbCloseSocket(client->sock);
   if (client->listenSock != RFB_INVALID_SOCKET)","{'deleted_lines': [], 'added_lines': ['  free(client->vncRec);', '']}",True,libvncclient v0.9.13 was discovered to contain a memory leak via the function rfbClientCleanup().,7.5,HIGH,2,test,2020-11-21T11:52:31Z,3
CVE-2020-29394,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,COVESA/dlt-daemon,"dlt_common: Fix buffer overflow in dlt_filter_load

A buffer overflow in the dlt_filter_load function in dlt_common.c in dlt-daemon allows arbitrary code execution via an unsafe usage of fscanf, because it does not limit the number of characters to be read in a format argument.

Fixed: #274

Signed-off-by: GwanYeong Kim <gy741.kim@gmail.com>",7f5cd5404a03fa330e192084f6bdafb2dc9bdcb7,https://github.com/COVESA/dlt-daemon/commit/7f5cd5404a03fa330e192084f6bdafb2dc9bdcb7,src/shared/dlt_common.c,dlt_filter_load,"DltReturnValue dlt_filter_load(DltFilter *filter, const char *filename, int verbose)
{
if ((filter == NULL) || (filename == NULL))
return DLT_RETURN_WRONG_PARAMETER;
FILE *handle;
char str1[DLT_COMMON_BUFFER_LENGTH];
char apid[DLT_ID_SIZE], ctid[DLT_ID_SIZE];
PRINT_FUNCTION_VERBOSE(verbose);
handle = fopen(filename, ""r"");
if (handle == NULL) {
dlt_vlog(LOG_WARNING, ""Filter file %s cannot be opened!\n"", filename);
return DLT_RETURN_ERROR;
}
filter->counter = 0;
while (!feof(handle)) {
str1[0] = 0;
if (fscanf(handle, ""%s"", str1) != 1)
break;
if (str1[0] == 0)
break;
printf("" %s"", str1);
if (strcmp(str1, ""----"") == 0)
dlt_set_id(apid, """");
else
dlt_set_id(apid, str1);
str1[0] = 0;
if (fscanf(handle, ""%s"", str1) != 1)
break;
if (str1[0] == 0)
break;
printf("" %s\r\n"", str1);
if (strcmp(str1, ""----"") == 0)
dlt_set_id(ctid, """");
else
dlt_set_id(ctid, str1);
if (filter->counter < DLT_FILTER_MAX) {
dlt_filter_add(filter, apid, ctid, verbose);
}
else {
dlt_vlog(LOG_WARNING,
""Maximum number (%d) of allowed filters reached, ignoring rest of filters!\n"",
DLT_FILTER_MAX);
}
}
fclose(handle);
return DLT_RETURN_OK;
}","DltReturnValue dlt_filter_load(DltFilter *VAR_0, const char *VAR_1, int VAR_2)
{
if ((VAR_0 == NULL) || (VAR_1 == NULL))
return VAR_3;
FILE *VAR_4;
char VAR_5[VAR_6];
char VAR_7[VAR_8], VAR_9[VAR_8];
PRINT_FUNCTION_VERBOSE(VAR_2);
VAR_4 = fopen(VAR_1, ""r"");
if (VAR_4 == NULL) {
dlt_vlog(VAR_10, ""Filter file %s cannot be opened!\n"", VAR_1);
return VAR_11;
}
VAR_0->counter = 0;
while (!feof(VAR_4)) {
VAR_5[0] = 0;
if (fscanf(VAR_4, ""%s"", VAR_5) != 1)
break;
if (VAR_5[0] == 0)
break;
printf("" %s"", VAR_5);
if (strcmp(VAR_5, ""----"") == 0)
dlt_set_id(VAR_7, """");
else
dlt_set_id(VAR_7, VAR_5);
VAR_5[0] = 0;
if (fscanf(VAR_4, ""%s"", VAR_5) != 1)
break;
if (VAR_5[0] == 0)
break;
printf("" %s\r\n"", VAR_5);
if (strcmp(VAR_5, ""----"") == 0)
dlt_set_id(VAR_9, """");
else
dlt_set_id(VAR_9, VAR_5);
if (VAR_0->counter < VAR_12) {
dlt_filter_add(VAR_0, VAR_7, VAR_9, VAR_2);
}
else {
dlt_vlog(VAR_10,
""Maximum number (%d) of allowed filters reached, ignoring rest of filters!\n"",
VAR_12);
}
}
fclose(VAR_4);
return VAR_13;
}",COVESA/dlt-daemon/7f5cd5404a03fa330e192084f6bdafb2dc9bdcb7/dlt_common.c/vul/before/0.json,"DltReturnValue dlt_filter_load(DltFilter *filter, const char *filename, int verbose)
{
    if ((filter == NULL) || (filename == NULL))
        return DLT_RETURN_WRONG_PARAMETER;

    FILE *handle;
    char str1[DLT_COMMON_BUFFER_LENGTH];
    char apid[DLT_ID_SIZE], ctid[DLT_ID_SIZE];

    PRINT_FUNCTION_VERBOSE(verbose);

    handle = fopen(filename, ""r"");

    if (handle == NULL) {
        dlt_vlog(LOG_WARNING, ""Filter file %s cannot be opened!\n"", filename);
        return DLT_RETURN_ERROR;
    }

    /* Reset filters */
    filter->counter = 0;

    while (!feof(handle)) {
        str1[0] = 0;

        if (fscanf(handle, ""%254s"", str1) != 1)
            break;

        if (str1[0] == 0)
            break;

        printf("" %s"", str1);

        if (strcmp(str1, ""----"") == 0)
            dlt_set_id(apid, """");
        else
            dlt_set_id(apid, str1);

        str1[0] = 0;

        if (fscanf(handle, ""%254s"", str1) != 1)
            break;

        if (str1[0] == 0)
            break;

        printf("" %s\r\n"", str1);

        if (strcmp(str1, ""----"") == 0)
            dlt_set_id(ctid, """");
        else
            dlt_set_id(ctid, str1);

        if (filter->counter < DLT_FILTER_MAX) {
            dlt_filter_add(filter, apid, ctid, verbose);
        }
        else {
            dlt_vlog(LOG_WARNING,
                     ""Maximum number (%d) of allowed filters reached, ignoring rest of filters!\n"",
                     DLT_FILTER_MAX);
        }
    }

    fclose(handle);

    return DLT_RETURN_OK;
}","DltReturnValue dlt_filter_load(DltFilter *VAR_0, const char *VAR_1, int VAR_2)
{
    if ((VAR_0 == NULL) || (VAR_1 == NULL))
        return VAR_3;

    FILE *VAR_4;
    char VAR_5[VAR_6];
    char VAR_7[VAR_8], VAR_9[VAR_8];

    PRINT_FUNCTION_VERBOSE(VAR_2);

    VAR_4 = fopen(VAR_1, ""r"");

    if (VAR_4 == NULL) {
        dlt_vlog(VAR_10, ""Filter file %s cannot be opened!\n"", VAR_1);
        return VAR_11;
    }

    /* COMMENT_0 */
    VAR_0->counter = 0;

    while (!feof(VAR_4)) {
        VAR_5[0] = 0;

        if (fscanf(VAR_4, ""%254s"", VAR_5) != 1)
            break;

        if (VAR_5[0] == 0)
            break;

        printf("" %s"", VAR_5);

        if (strcmp(VAR_5, ""----"") == 0)
            dlt_set_id(VAR_7, """");
        else
            dlt_set_id(VAR_7, VAR_5);

        VAR_5[0] = 0;

        if (fscanf(VAR_4, ""%254s"", VAR_5) != 1)
            break;

        if (VAR_5[0] == 0)
            break;

        printf("" %s\r\n"", VAR_5);

        if (strcmp(VAR_5, ""----"") == 0)
            dlt_set_id(VAR_9, """");
        else
            dlt_set_id(VAR_9, VAR_5);

        if (VAR_0->counter < VAR_12) {
            dlt_filter_add(VAR_0, VAR_7, VAR_9, VAR_2);
        }
        else {
            dlt_vlog(VAR_10,
                     ""Maximum number (%d) of allowed filters reached, ignoring rest of filters!\n"",
                     VAR_12);
        }
    }

    fclose(VAR_4);

    return VAR_13;
}",COVESA/dlt-daemon/7f5cd5404a03fa330e192084f6bdafb2dc9bdcb7/dlt_common.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,7 +22,7 @@
     while (!feof(handle)) {
         str1[0] = 0;
 
-        if (fscanf(handle, ""%s"", str1) != 1)
+        if (fscanf(handle, ""%254s"", str1) != 1)
             break;
 
         if (str1[0] == 0)
@@ -37,7 +37,7 @@
 
         str1[0] = 0;
 
-        if (fscanf(handle, ""%s"", str1) != 1)
+        if (fscanf(handle, ""%254s"", str1) != 1)
             break;
 
         if (str1[0] == 0)","{'deleted_lines': ['        if (fscanf(handle, ""%s"", str1) != 1)', '        if (fscanf(handle, ""%s"", str1) != 1)'], 'added_lines': ['        if (fscanf(handle, ""%254s"", str1) != 1)', '        if (fscanf(handle, ""%254s"", str1) != 1)']}",True,A buffer overflow in the dlt_filter_load function in dlt_common.c from dlt-daemon through 2.18.5 (GENIVI Diagnostic Log and Trace) allows arbitrary code execution because fscanf is misused (no limit on the number of characters to be read in the format argument).,7.8,HIGH,2,test,2020-11-28T03:24:46Z,3
CVE-2021-20224,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,ImageMagick,"outside the range of representable values of type 'unsigned char' (#3083)

Co-authored-by: Zhang Xiaohui <ruc_zhangxiaohui@163.com>",5af1dffa4b6ab984b5f13d1e91c95760d75f12a6,https://github.com/ImageMagick/ImageMagick/commit/5af1dffa4b6ab984b5f13d1e91c95760d75f12a6,MagickCore/quantum-export.c,ExportIndexQuantum,"static void ExportIndexQuantum(const Image *image,QuantumInfo *quantum_info,
const MagickSizeType number_pixels,const Quantum *magick_restrict p,
unsigned char *magick_restrict q,ExceptionInfo *exception)
{
ssize_t
x;
ssize_t
bit;
if (image->storage_class != PseudoClass)
{
(void) ThrowMagickException(exception,GetMagickModule(),ImageError,
""ColormappedImageRequired"",""`%s'"",image->filename);
return;
}
switch (quantum_info->depth)
{
case 1:
{
unsigned char
pixel;
for (x=((ssize_t) number_pixels-7); x > 0; x-=8)
{
pixel=(unsigned char) GetPixelIndex(image,p);
*q=((pixel & 0x01) << 7);
p+=GetPixelChannels(image);
pixel=(unsigned char) GetPixelIndex(image,p);
*q|=((pixel & 0x01) << 6);
p+=GetPixelChannels(image);
pixel=(unsigned char) GetPixelIndex(image,p);
*q|=((pixel & 0x01) << 5);
p+=GetPixelChannels(image);
pixel=(unsigned char) GetPixelIndex(image,p);
*q|=((pixel & 0x01) << 4);
p+=GetPixelChannels(image);
pixel=(unsigned char) GetPixelIndex(image,p);
*q|=((pixel & 0x01) << 3);
p+=GetPixelChannels(image);
pixel=(unsigned char) GetPixelIndex(image,p);
*q|=((pixel & 0x01) << 2);
p+=GetPixelChannels(image);
pixel=(unsigned char) GetPixelIndex(image,p);
*q|=((pixel & 0x01) << 1);
p+=GetPixelChannels(image);
pixel=(unsigned char) GetPixelIndex(image,p);
*q|=((pixel & 0x01) << 0);
p+=GetPixelChannels(image);
q++;
}
if ((number_pixels % 8) != 0)
{
*q='\0';
for (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)
{
pixel=(unsigned char) GetPixelIndex(image,p);
*q|=((pixel & 0x01) << (unsigned char) bit);
p+=GetPixelChannels(image);
}
q++;
}
break;
}
case 4:
{
unsigned char
pixel;
for (x=0; x < (ssize_t) (number_pixels-1) ; x+=2)
{
pixel=(unsigned char) GetPixelIndex(image,p);
*q=((pixel & 0xf) << 4);
p+=GetPixelChannels(image);
pixel=(unsigned char) GetPixelIndex(image,p);
*q|=((pixel & 0xf) << 0);
p+=GetPixelChannels(image);
q++;
}
if ((number_pixels % 2) != 0)
{
pixel=(unsigned char) GetPixelIndex(image,p);
*q=((pixel & 0xf) << 4);
p+=GetPixelChannels(image);
q++;
}
break;
}
case 8:
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopCharPixel((unsigned char) GetPixelIndex(image,p),q);
p+=GetPixelChannels(image);
q+=quantum_info->pad;
}
break;
}
case 16:
{
if (quantum_info->format == FloatingPointQuantumFormat)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopShortPixel(quantum_info->endian,SinglePrecisionToHalf(
QuantumScale*GetPixelIndex(image,p)),q);
p+=GetPixelChannels(image);
q+=quantum_info->pad;
}
break;
}
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopShortPixel(quantum_info->endian,(unsigned short)
GetPixelIndex(image,p),q);
p+=GetPixelChannels(image);
q+=quantum_info->pad;
}
break;
}
case 32:
{
if (quantum_info->format == FloatingPointQuantumFormat)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopFloatPixel(quantum_info,(float) GetPixelIndex(image,p),q);
p+=GetPixelChannels(image);
q+=quantum_info->pad;
}
break;
}
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopLongPixel(quantum_info->endian,(unsigned int)
GetPixelIndex(image,p),q);
p+=GetPixelChannels(image);
q+=quantum_info->pad;
}
break;
}
case 64:
{
if (quantum_info->format == FloatingPointQuantumFormat)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopDoublePixel(quantum_info,(double) GetPixelIndex(image,p),q);
p+=GetPixelChannels(image);
q+=quantum_info->pad;
}
break;
}
}
default:
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopQuantumPixel(quantum_info,GetPixelIndex(image,p),q);
p+=GetPixelChannels(image);
q+=quantum_info->pad;
}
break;
}
}
}","static void ExportIndexQuantum(const Image *VAR_0,QuantumInfo *VAR_1,
const MagickSizeType VAR_2,const Quantum *magick_restrict VAR_3,
unsigned char *magick_restrict VAR_4,ExceptionInfo *VAR_5)
{
ssize_t
VAR_6;
ssize_t
VAR_7;
if (VAR_0->storage_class != VAR_8)
{
(void) ThrowMagickException(VAR_5,GetMagickModule(),VAR_9,
""ColormappedImageRequired"",""`%s'"",VAR_0->filename);
return;
}
switch (VAR_1->depth)
{
case 1:
{
unsigned char
VAR_10;
for (VAR_6=((ssize_t) VAR_2-7); VAR_6 > 0; VAR_6-=8)
{
VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);
*VAR_4=((VAR_10 & 0x01) << 7);
VAR_3+=GetPixelChannels(VAR_0);
VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);
*VAR_4|=((VAR_10 & 0x01) << 6);
VAR_3+=GetPixelChannels(VAR_0);
VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);
*VAR_4|=((VAR_10 & 0x01) << 5);
VAR_3+=GetPixelChannels(VAR_0);
VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);
*VAR_4|=((VAR_10 & 0x01) << 4);
VAR_3+=GetPixelChannels(VAR_0);
VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);
*VAR_4|=((VAR_10 & 0x01) << 3);
VAR_3+=GetPixelChannels(VAR_0);
VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);
*VAR_4|=((VAR_10 & 0x01) << 2);
VAR_3+=GetPixelChannels(VAR_0);
VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);
*VAR_4|=((VAR_10 & 0x01) << 1);
VAR_3+=GetPixelChannels(VAR_0);
VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);
*VAR_4|=((VAR_10 & 0x01) << 0);
VAR_3+=GetPixelChannels(VAR_0);
VAR_4++;
}
if ((VAR_2 % 8) != 0)
{
*VAR_4='\0';
for (VAR_7=7; VAR_7 >= (ssize_t) (8-(VAR_2 % 8)); VAR_7--)
{
VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);
*VAR_4|=((VAR_10 & 0x01) << (unsigned char) VAR_7);
VAR_3+=GetPixelChannels(VAR_0);
}
VAR_4++;
}
break;
}
case 4:
{
unsigned char
VAR_10;
for (VAR_6=0; VAR_6 < (ssize_t) (VAR_2-1) ; VAR_6+=2)
{
VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);
*VAR_4=((VAR_10 & 0xf) << 4);
VAR_3+=GetPixelChannels(VAR_0);
VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);
*VAR_4|=((VAR_10 & 0xf) << 0);
VAR_3+=GetPixelChannels(VAR_0);
VAR_4++;
}
if ((VAR_2 % 2) != 0)
{
VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);
*VAR_4=((VAR_10 & 0xf) << 4);
VAR_3+=GetPixelChannels(VAR_0);
VAR_4++;
}
break;
}
case 8:
{
for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)
{
VAR_4=PopCharPixel((unsigned char) GetPixelIndex(VAR_0,VAR_3),VAR_4);
VAR_3+=GetPixelChannels(VAR_0);
VAR_4+=VAR_1->pad;
}
break;
}
case 16:
{
if (VAR_1->format == VAR_11)
{
for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)
{
VAR_4=PopShortPixel(VAR_1->endian,SinglePrecisionToHalf(
VAR_12*GetPixelIndex(VAR_0,VAR_3)),VAR_4);
VAR_3+=GetPixelChannels(VAR_0);
VAR_4+=VAR_1->pad;
}
break;
}
for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)
{
VAR_4=PopShortPixel(VAR_1->endian,(unsigned short)
GetPixelIndex(VAR_0,VAR_3),VAR_4);
VAR_3+=GetPixelChannels(VAR_0);
VAR_4+=VAR_1->pad;
}
break;
}
case 32:
{
if (VAR_1->format == VAR_11)
{
for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)
{
VAR_4=PopFloatPixel(VAR_1,(float) GetPixelIndex(VAR_0,VAR_3),VAR_4);
VAR_3+=GetPixelChannels(VAR_0);
VAR_4+=VAR_1->pad;
}
break;
}
for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)
{
VAR_4=PopLongPixel(VAR_1->endian,(unsigned int)
GetPixelIndex(VAR_0,VAR_3),VAR_4);
VAR_3+=GetPixelChannels(VAR_0);
VAR_4+=VAR_1->pad;
}
break;
}
case 64:
{
if (VAR_1->format == VAR_11)
{
for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)
{
VAR_4=PopDoublePixel(VAR_1,(double) GetPixelIndex(VAR_0,VAR_3),VAR_4);
VAR_3+=GetPixelChannels(VAR_0);
VAR_4+=VAR_1->pad;
}
break;
}
}
default:
{
for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)
{
VAR_4=PopQuantumPixel(VAR_1,GetPixelIndex(VAR_0,VAR_3),VAR_4);
VAR_3+=GetPixelChannels(VAR_0);
VAR_4+=VAR_1->pad;
}
break;
}
}
}",,"static void ExportIndexQuantum(const Image *image,QuantumInfo *quantum_info,
  const MagickSizeType number_pixels,const Quantum *magick_restrict p,
  unsigned char *magick_restrict q,ExceptionInfo *exception)
{
  ssize_t
    x;

  ssize_t
    bit;

  if (image->storage_class != PseudoClass)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,
        ""ColormappedImageRequired"",""`%s'"",image->filename);
      return;
    }
  switch (quantum_info->depth)
  {
    case 1:
    {
      unsigned char
        pixel;

      for (x=((ssize_t) number_pixels-7); x > 0; x-=8)
      {
        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
        *q=((pixel & 0x01) << 7);
        p+=GetPixelChannels(image);
        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
        *q|=((pixel & 0x01) << 6);
        p+=GetPixelChannels(image);
        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
        *q|=((pixel & 0x01) << 5);
        p+=GetPixelChannels(image);
        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
        *q|=((pixel & 0x01) << 4);
        p+=GetPixelChannels(image);
        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
        *q|=((pixel & 0x01) << 3);
        p+=GetPixelChannels(image);
        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
        *q|=((pixel & 0x01) << 2);
        p+=GetPixelChannels(image);
        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
        *q|=((pixel & 0x01) << 1);
        p+=GetPixelChannels(image);
        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
        *q|=((pixel & 0x01) << 0);
        p+=GetPixelChannels(image);
        q++;
      }
      if ((number_pixels % 8) != 0)
        {
          *q='\0';
          for (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)
          {
            pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
            *q|=((pixel & 0x01) << (unsigned char) bit);
            p+=GetPixelChannels(image);
          }
          q++;
        }
      break;
    }
    case 4:
    {
      unsigned char
        pixel;

      for (x=0; x < (ssize_t) (number_pixels-1) ; x+=2)
      {
        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
        *q=((pixel & 0xf) << 4);
        p+=GetPixelChannels(image);
        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
        *q|=((pixel & 0xf) << 0);
        p+=GetPixelChannels(image);
        q++;
      }
      if ((number_pixels % 2) != 0)
        {
          pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
          *q=((pixel & 0xf) << 4);
          p+=GetPixelChannels(image);
          q++;
        }
      break;
    }
    case 8:
    {
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        q=PopCharPixel((unsigned char) ((ssize_t) GetPixelIndex(image,p)),q);
        p+=GetPixelChannels(image);
        q+=quantum_info->pad;
      }
      break;
    }
    case 16:
    {
      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            q=PopShortPixel(quantum_info->endian,SinglePrecisionToHalf(
              QuantumScale*GetPixelIndex(image,p)),q);
            p+=GetPixelChannels(image);
            q+=quantum_info->pad;
          }
          break;
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        q=PopShortPixel(quantum_info->endian,(unsigned short)
          GetPixelIndex(image,p),q);
        p+=GetPixelChannels(image);
        q+=quantum_info->pad;
      }
      break;
    }
    case 32:
    {
      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            q=PopFloatPixel(quantum_info,(float) GetPixelIndex(image,p),q);
            p+=GetPixelChannels(image);
            q+=quantum_info->pad;
          }
          break;
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        q=PopLongPixel(quantum_info->endian,(unsigned int)
          GetPixelIndex(image,p),q);
        p+=GetPixelChannels(image);
        q+=quantum_info->pad;
      }
      break;
    }
    case 64:
    {
      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            q=PopDoublePixel(quantum_info,(double) GetPixelIndex(image,p),q);
            p+=GetPixelChannels(image);
            q+=quantum_info->pad;
          }
          break;
        }
    }
    default:
    {
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        q=PopQuantumPixel(quantum_info,GetPixelIndex(image,p),q);
        p+=GetPixelChannels(image);
        q+=quantum_info->pad;
      }
      break;
    }
  }
}","static void ExportIndexQuantum(const Image *VAR_0,QuantumInfo *VAR_1,
  const MagickSizeType VAR_2,const Quantum *magick_restrict VAR_3,
  unsigned char *magick_restrict VAR_4,ExceptionInfo *VAR_5)
{
  ssize_t
    VAR_6;

  ssize_t
    VAR_7;

  if (VAR_0->storage_class != VAR_8)
    {
      (void) ThrowMagickException(VAR_5,GetMagickModule(),VAR_9,
        ""ColormappedImageRequired"",""`%s'"",VAR_0->filename);
      return;
    }
  switch (VAR_1->depth)
  {
    case 1:
    {
      unsigned char
        VAR_10;

      for (VAR_6=((ssize_t) VAR_2-7); VAR_6 > 0; VAR_6-=8)
      {
        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));
        *VAR_4=((VAR_10 & 0x01) << 7);
        VAR_3+=GetPixelChannels(VAR_0);
        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));
        *VAR_4|=((VAR_10 & 0x01) << 6);
        VAR_3+=GetPixelChannels(VAR_0);
        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));
        *VAR_4|=((VAR_10 & 0x01) << 5);
        VAR_3+=GetPixelChannels(VAR_0);
        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));
        *VAR_4|=((VAR_10 & 0x01) << 4);
        VAR_3+=GetPixelChannels(VAR_0);
        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));
        *VAR_4|=((VAR_10 & 0x01) << 3);
        VAR_3+=GetPixelChannels(VAR_0);
        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));
        *VAR_4|=((VAR_10 & 0x01) << 2);
        VAR_3+=GetPixelChannels(VAR_0);
        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));
        *VAR_4|=((VAR_10 & 0x01) << 1);
        VAR_3+=GetPixelChannels(VAR_0);
        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));
        *VAR_4|=((VAR_10 & 0x01) << 0);
        VAR_3+=GetPixelChannels(VAR_0);
        VAR_4++;
      }
      if ((VAR_2 % 8) != 0)
        {
          *VAR_4='\0';
          for (VAR_7=7; VAR_7 >= (ssize_t) (8-(VAR_2 % 8)); VAR_7--)
          {
            VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));
            *VAR_4|=((VAR_10 & 0x01) << (unsigned char) VAR_7);
            VAR_3+=GetPixelChannels(VAR_0);
          }
          VAR_4++;
        }
      break;
    }
    case 4:
    {
      unsigned char
        VAR_10;

      for (VAR_6=0; VAR_6 < (ssize_t) (VAR_2-1) ; VAR_6+=2)
      {
        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));
        *VAR_4=((VAR_10 & 0xf) << 4);
        VAR_3+=GetPixelChannels(VAR_0);
        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));
        *VAR_4|=((VAR_10 & 0xf) << 0);
        VAR_3+=GetPixelChannels(VAR_0);
        VAR_4++;
      }
      if ((VAR_2 % 2) != 0)
        {
          VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));
          *VAR_4=((VAR_10 & 0xf) << 4);
          VAR_3+=GetPixelChannels(VAR_0);
          VAR_4++;
        }
      break;
    }
    case 8:
    {
      for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)
      {
        VAR_4=PopCharPixel((unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3)),VAR_4);
        VAR_3+=GetPixelChannels(VAR_0);
        VAR_4+=VAR_1->pad;
      }
      break;
    }
    case 16:
    {
      if (VAR_1->format == VAR_11)
        {
          for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)
          {
            VAR_4=PopShortPixel(VAR_1->endian,SinglePrecisionToHalf(
              VAR_12*GetPixelIndex(VAR_0,VAR_3)),VAR_4);
            VAR_3+=GetPixelChannels(VAR_0);
            VAR_4+=VAR_1->pad;
          }
          break;
        }
      for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)
      {
        VAR_4=PopShortPixel(VAR_1->endian,(unsigned short)
          GetPixelIndex(VAR_0,VAR_3),VAR_4);
        VAR_3+=GetPixelChannels(VAR_0);
        VAR_4+=VAR_1->pad;
      }
      break;
    }
    case 32:
    {
      if (VAR_1->format == VAR_11)
        {
          for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)
          {
            VAR_4=PopFloatPixel(VAR_1,(float) GetPixelIndex(VAR_0,VAR_3),VAR_4);
            VAR_3+=GetPixelChannels(VAR_0);
            VAR_4+=VAR_1->pad;
          }
          break;
        }
      for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)
      {
        VAR_4=PopLongPixel(VAR_1->endian,(unsigned int)
          GetPixelIndex(VAR_0,VAR_3),VAR_4);
        VAR_3+=GetPixelChannels(VAR_0);
        VAR_4+=VAR_1->pad;
      }
      break;
    }
    case 64:
    {
      if (VAR_1->format == VAR_11)
        {
          for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)
          {
            VAR_4=PopDoublePixel(VAR_1,(double) GetPixelIndex(VAR_0,VAR_3),VAR_4);
            VAR_3+=GetPixelChannels(VAR_0);
            VAR_4+=VAR_1->pad;
          }
          break;
        }
    }
    default:
    {
      for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)
      {
        VAR_4=PopQuantumPixel(VAR_1,GetPixelIndex(VAR_0,VAR_3),VAR_4);
        VAR_3+=GetPixelChannels(VAR_0);
        VAR_4+=VAR_1->pad;
      }
      break;
    }
  }
}",,"--- func_before
+++ func_after
@@ -23,28 +23,28 @@
 
       for (x=((ssize_t) number_pixels-7); x > 0; x-=8)
       {
-        pixel=(unsigned char) GetPixelIndex(image,p);
+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
         *q=((pixel & 0x01) << 7);
         p+=GetPixelChannels(image);
-        pixel=(unsigned char) GetPixelIndex(image,p);
+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
         *q|=((pixel & 0x01) << 6);
         p+=GetPixelChannels(image);
-        pixel=(unsigned char) GetPixelIndex(image,p);
+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
         *q|=((pixel & 0x01) << 5);
         p+=GetPixelChannels(image);
-        pixel=(unsigned char) GetPixelIndex(image,p);
+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
         *q|=((pixel & 0x01) << 4);
         p+=GetPixelChannels(image);
-        pixel=(unsigned char) GetPixelIndex(image,p);
+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
         *q|=((pixel & 0x01) << 3);
         p+=GetPixelChannels(image);
-        pixel=(unsigned char) GetPixelIndex(image,p);
+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
         *q|=((pixel & 0x01) << 2);
         p+=GetPixelChannels(image);
-        pixel=(unsigned char) GetPixelIndex(image,p);
+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
         *q|=((pixel & 0x01) << 1);
         p+=GetPixelChannels(image);
-        pixel=(unsigned char) GetPixelIndex(image,p);
+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
         *q|=((pixel & 0x01) << 0);
         p+=GetPixelChannels(image);
         q++;
@@ -54,7 +54,7 @@
           *q='\0';
           for (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)
           {
-            pixel=(unsigned char) GetPixelIndex(image,p);
+            pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
             *q|=((pixel & 0x01) << (unsigned char) bit);
             p+=GetPixelChannels(image);
           }
@@ -69,17 +69,17 @@
 
       for (x=0; x < (ssize_t) (number_pixels-1) ; x+=2)
       {
-        pixel=(unsigned char) GetPixelIndex(image,p);
+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
         *q=((pixel & 0xf) << 4);
         p+=GetPixelChannels(image);
-        pixel=(unsigned char) GetPixelIndex(image,p);
+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
         *q|=((pixel & 0xf) << 0);
         p+=GetPixelChannels(image);
         q++;
       }
       if ((number_pixels % 2) != 0)
         {
-          pixel=(unsigned char) GetPixelIndex(image,p);
+          pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));
           *q=((pixel & 0xf) << 4);
           p+=GetPixelChannels(image);
           q++;
@@ -90,7 +90,7 @@
     {
       for (x=0; x < (ssize_t) number_pixels; x++)
       {
-        q=PopCharPixel((unsigned char) GetPixelIndex(image,p),q);
+        q=PopCharPixel((unsigned char) ((ssize_t) GetPixelIndex(image,p)),q);
         p+=GetPixelChannels(image);
         q+=quantum_info->pad;
       }","{'deleted_lines': ['        pixel=(unsigned char) GetPixelIndex(image,p);', '        pixel=(unsigned char) GetPixelIndex(image,p);', '        pixel=(unsigned char) GetPixelIndex(image,p);', '        pixel=(unsigned char) GetPixelIndex(image,p);', '        pixel=(unsigned char) GetPixelIndex(image,p);', '        pixel=(unsigned char) GetPixelIndex(image,p);', '        pixel=(unsigned char) GetPixelIndex(image,p);', '        pixel=(unsigned char) GetPixelIndex(image,p);', '            pixel=(unsigned char) GetPixelIndex(image,p);', '        pixel=(unsigned char) GetPixelIndex(image,p);', '        pixel=(unsigned char) GetPixelIndex(image,p);', '          pixel=(unsigned char) GetPixelIndex(image,p);', '        q=PopCharPixel((unsigned char) GetPixelIndex(image,p),q);'], 'added_lines': ['        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));', '        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));', '        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));', '        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));', '        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));', '        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));', '        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));', '        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));', '            pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));', '        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));', '        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));', '          pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));', '        q=PopCharPixel((unsigned char) ((ssize_t) GetPixelIndex(image,p)),q);']}",True,"An integer overflow issue was discovered in ImageMagick's ExportIndexQuantum() function in MagickCore/quantum-export.c. Function calls to GetPixelIndex() could result in values outside the range of representable for the 'unsigned char'. When ImageMagick processes a crafted pdf file, this could lead to an undefined behaviour or a crash.",5.5,MEDIUM,1,test,2021-01-06T23:15:12Z,3
CVE-2021-20224,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,ImageMagick/ImageMagick6,https://github.com/ImageMagick/ImageMagick/pull/3083,553054c1cb1e4e05ec86237afef76a32cd7c464d,https://github.com/ImageMagick/ImageMagick6/commit/553054c1cb1e4e05ec86237afef76a32cd7c464d,magick/quantum-export.c,ExportIndexQuantum,"static void ExportIndexQuantum(const Image *image,QuantumInfo *quantum_info,
const MagickSizeType number_pixels,const PixelPacket *magick_restrict p,
const IndexPacket *magick_restrict indexes,unsigned char *magick_restrict q,
ExceptionInfo *exception)
{
ssize_t
x;
ssize_t
bit;
if (image->storage_class != PseudoClass)
{
(void) ThrowMagickException(exception,GetMagickModule(),ImageError,
""ColormappedImageRequired"",""`%s'"",image->filename);
return;
}
switch (quantum_info->depth)
{
case 1:
{
unsigned char
pixel;
for (x=((ssize_t) number_pixels-7); x > 0; x-=8)
{
pixel=(unsigned char) *indexes++;
*q=((pixel & 0x01) << 7);
pixel=(unsigned char) *indexes++;
*q|=((pixel & 0x01) << 6);
pixel=(unsigned char) *indexes++;
*q|=((pixel & 0x01) << 5);
pixel=(unsigned char) *indexes++;
*q|=((pixel & 0x01) << 4);
pixel=(unsigned char) *indexes++;
*q|=((pixel & 0x01) << 3);
pixel=(unsigned char) *indexes++;
*q|=((pixel & 0x01) << 2);
pixel=(unsigned char) *indexes++;
*q|=((pixel & 0x01) << 1);
pixel=(unsigned char) *indexes++;
*q|=((pixel & 0x01) << 0);
q++;
}
if ((number_pixels % 8) != 0)
{
*q='\0';
for (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)
{
pixel=(unsigned char) *indexes++;
*q|=((pixel & 0x01) << (unsigned char) bit);
}
q++;
}
break;
}
case 4:
{
unsigned char
pixel;
for (x=0; x < (ssize_t) (number_pixels-1) ; x+=2)
{
pixel=(unsigned char) *indexes++;
*q=((pixel & 0xf) << 4);
pixel=(unsigned char) *indexes++;
*q|=((pixel & 0xf) << 0);
q++;
}
if ((number_pixels % 2) != 0)
{
pixel=(unsigned char) *indexes++;
*q=((pixel & 0xf) << 4);
q++;
}
break;
}
case 8:
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopCharPixel((unsigned char) GetPixelIndex(indexes+x),q);
q+=quantum_info->pad;
}
break;
}
case 16:
{
if (quantum_info->format == FloatingPointQuantumFormat)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopShortPixel(quantum_info->endian,SinglePrecisionToHalf(QuantumScale*
GetPixelIndex(indexes+x)),q);
q+=quantum_info->pad;
}
break;
}
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopShortPixel(quantum_info->endian,(unsigned short) GetPixelIndex(indexes+x),q);
q+=quantum_info->pad;
}
break;
}
case 32:
{
if (quantum_info->format == FloatingPointQuantumFormat)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopFloatPixel(quantum_info,(float) GetPixelIndex(indexes+x),q);
p++;
q+=quantum_info->pad;
}
break;
}
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopLongPixel(quantum_info->endian,(unsigned int) GetPixelIndex(indexes+x),q);
q+=quantum_info->pad;
}
break;
}
case 64:
{
if (quantum_info->format == FloatingPointQuantumFormat)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopDoublePixel(quantum_info,(double) GetPixelIndex(indexes+x),
q);
p++;
q+=quantum_info->pad;
}
break;
}
}
default:
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopQuantumPixel(quantum_info,
GetPixelIndex(indexes+x),q);
p++;
q+=quantum_info->pad;
}
break;
}
}
}","static void ExportIndexQuantum(const Image *VAR_0,QuantumInfo *VAR_1,
const MagickSizeType VAR_2,const PixelPacket *magick_restrict VAR_3,
const IndexPacket *magick_restrict VAR_4,unsigned char *magick_restrict VAR_5,
ExceptionInfo *VAR_6)
{
ssize_t
VAR_7;
ssize_t
VAR_8;
if (VAR_0->storage_class != VAR_9)
{
(void) ThrowMagickException(VAR_6,GetMagickModule(),VAR_10,
""ColormappedImageRequired"",""`%s'"",VAR_0->filename);
return;
}
switch (VAR_1->depth)
{
case 1:
{
unsigned char
VAR_11;
for (VAR_7=((ssize_t) VAR_2-7); VAR_7 > 0; VAR_7-=8)
{
VAR_11=(unsigned char) *VAR_4++;
*VAR_5=((VAR_11 & 0x01) << 7);
VAR_11=(unsigned char) *VAR_4++;
*VAR_5|=((VAR_11 & 0x01) << 6);
VAR_11=(unsigned char) *VAR_4++;
*VAR_5|=((VAR_11 & 0x01) << 5);
VAR_11=(unsigned char) *VAR_4++;
*VAR_5|=((VAR_11 & 0x01) << 4);
VAR_11=(unsigned char) *VAR_4++;
*VAR_5|=((VAR_11 & 0x01) << 3);
VAR_11=(unsigned char) *VAR_4++;
*VAR_5|=((VAR_11 & 0x01) << 2);
VAR_11=(unsigned char) *VAR_4++;
*VAR_5|=((VAR_11 & 0x01) << 1);
VAR_11=(unsigned char) *VAR_4++;
*VAR_5|=((VAR_11 & 0x01) << 0);
VAR_5++;
}
if ((VAR_2 % 8) != 0)
{
*VAR_5='\0';
for (VAR_8=7; VAR_8 >= (ssize_t) (8-(VAR_2 % 8)); VAR_8--)
{
VAR_11=(unsigned char) *VAR_4++;
*VAR_5|=((VAR_11 & 0x01) << (unsigned char) VAR_8);
}
VAR_5++;
}
break;
}
case 4:
{
unsigned char
VAR_11;
for (VAR_7=0; VAR_7 < (ssize_t) (VAR_2-1) ; VAR_7+=2)
{
VAR_11=(unsigned char) *VAR_4++;
*VAR_5=((VAR_11 & 0xf) << 4);
VAR_11=(unsigned char) *VAR_4++;
*VAR_5|=((VAR_11 & 0xf) << 0);
VAR_5++;
}
if ((VAR_2 % 2) != 0)
{
VAR_11=(unsigned char) *VAR_4++;
*VAR_5=((VAR_11 & 0xf) << 4);
VAR_5++;
}
break;
}
case 8:
{
for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
{
VAR_5=PopCharPixel((unsigned char) GetPixelIndex(VAR_4+VAR_7),VAR_5);
VAR_5+=VAR_1->pad;
}
break;
}
case 16:
{
if (VAR_1->format == VAR_12)
{
for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
{
VAR_5=PopShortPixel(VAR_1->endian,SinglePrecisionToHalf(VAR_13*
GetPixelIndex(VAR_4+VAR_7)),VAR_5);
VAR_5+=VAR_1->pad;
}
break;
}
for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
{
VAR_5=PopShortPixel(VAR_1->endian,(unsigned short) GetPixelIndex(VAR_4+VAR_7),VAR_5);
VAR_5+=VAR_1->pad;
}
break;
}
case 32:
{
if (VAR_1->format == VAR_12)
{
for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
{
VAR_5=PopFloatPixel(VAR_1,(float) GetPixelIndex(VAR_4+VAR_7),VAR_5);
VAR_3++;
VAR_5+=VAR_1->pad;
}
break;
}
for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
{
VAR_5=PopLongPixel(VAR_1->endian,(unsigned int) GetPixelIndex(VAR_4+VAR_7),VAR_5);
VAR_5+=VAR_1->pad;
}
break;
}
case 64:
{
if (VAR_1->format == VAR_12)
{
for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
{
VAR_5=PopDoublePixel(VAR_1,(double) GetPixelIndex(VAR_4+VAR_7),
VAR_5);
VAR_3++;
VAR_5+=VAR_1->pad;
}
break;
}
}
default:
{
for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
{
VAR_5=PopQuantumPixel(VAR_1,
GetPixelIndex(VAR_4+VAR_7),VAR_5);
VAR_3++;
VAR_5+=VAR_1->pad;
}
break;
}
}
}",,"static void ExportIndexQuantum(const Image *image,QuantumInfo *quantum_info,
  const MagickSizeType number_pixels,const PixelPacket *magick_restrict p,
  const IndexPacket *magick_restrict indexes,unsigned char *magick_restrict q,
  ExceptionInfo *exception)
{
  ssize_t
    x;

  ssize_t
    bit;

  if (image->storage_class != PseudoClass)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,
        ""ColormappedImageRequired"",""`%s'"",image->filename);
      return;
    }
  switch (quantum_info->depth)
  {
    case 1:
    {
      unsigned char
        pixel;

      for (x=((ssize_t) number_pixels-7); x > 0; x-=8)
      {
        pixel=(unsigned char) ((ssize_t) *indexes++);
        *q=((pixel & 0x01) << 7);
        pixel=(unsigned char) ((ssize_t) *indexes++);
        *q|=((pixel & 0x01) << 6);
        pixel=(unsigned char) ((ssize_t) *indexes++);
        *q|=((pixel & 0x01) << 5);
        pixel=(unsigned char) ((ssize_t) *indexes++);
        *q|=((pixel & 0x01) << 4);
        pixel=(unsigned char) ((ssize_t) *indexes++);
        *q|=((pixel & 0x01) << 3);
        pixel=(unsigned char) ((ssize_t) *indexes++);
        *q|=((pixel & 0x01) << 2);
        pixel=(unsigned char) ((ssize_t) *indexes++);
        *q|=((pixel & 0x01) << 1);
        pixel=(unsigned char) ((ssize_t) *indexes++);
        *q|=((pixel & 0x01) << 0);
        q++;
      }
      if ((number_pixels % 8) != 0)
        {
          *q='\0';
          for (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)
          {
            pixel=(unsigned char) ((ssize_t) *indexes++);
            *q|=((pixel & 0x01) << (unsigned char) bit);
          }
          q++;
        }
      break;
    }
    case 4:
    {
      unsigned char
        pixel;

      for (x=0; x < (ssize_t) (number_pixels-1) ; x+=2)
      {
        pixel=(unsigned char) ((ssize_t) *indexes++);
        *q=((pixel & 0xf) << 4);
        pixel=(unsigned char) ((ssize_t) *indexes++);
        *q|=((pixel & 0xf) << 0);
        q++;
      }
      if ((number_pixels % 2) != 0)
        {
          pixel=(unsigned char) ((ssize_t) *indexes++);
          *q=((pixel & 0xf) << 4);
          q++;
        }
      break;
    }
    case 8:
    {
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        q=PopCharPixel((unsigned char) GetPixelIndex(indexes+x),q);
        q+=quantum_info->pad;
      }
      break;
    }
    case 16:
    {
      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            q=PopShortPixel(quantum_info->endian,SinglePrecisionToHalf(QuantumScale*
              GetPixelIndex(indexes+x)),q);
            q+=quantum_info->pad;
          }
          break;
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        q=PopShortPixel(quantum_info->endian,(unsigned short) GetPixelIndex(indexes+x),q);
        q+=quantum_info->pad;
      }
      break;
    }
    case 32:
    {
      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            q=PopFloatPixel(quantum_info,(float) GetPixelIndex(indexes+x),q);
            p++;
            q+=quantum_info->pad;
          }
          break;
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        q=PopLongPixel(quantum_info->endian,(unsigned int) GetPixelIndex(indexes+x),q);
        q+=quantum_info->pad;
      }
      break;
    }
    case 64:
    {
      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            q=PopDoublePixel(quantum_info,(double) GetPixelIndex(indexes+x),
              q);
            p++;
            q+=quantum_info->pad;
          }
          break;
        }
    }
    default:
    {
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        q=PopQuantumPixel(quantum_info,
          GetPixelIndex(indexes+x),q);
        p++;
        q+=quantum_info->pad;
      }
      break;
    }
  }
}","static void ExportIndexQuantum(const Image *VAR_0,QuantumInfo *VAR_1,
  const MagickSizeType VAR_2,const PixelPacket *magick_restrict VAR_3,
  const IndexPacket *magick_restrict VAR_4,unsigned char *magick_restrict VAR_5,
  ExceptionInfo *VAR_6)
{
  ssize_t
    VAR_7;

  ssize_t
    VAR_8;

  if (VAR_0->storage_class != VAR_9)
    {
      (void) ThrowMagickException(VAR_6,GetMagickModule(),VAR_10,
        ""ColormappedImageRequired"",""`%s'"",VAR_0->filename);
      return;
    }
  switch (VAR_1->depth)
  {
    case 1:
    {
      unsigned char
        VAR_11;

      for (VAR_7=((ssize_t) VAR_2-7); VAR_7 > 0; VAR_7-=8)
      {
        VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
        *VAR_5=((VAR_11 & 0x01) << 7);
        VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
        *VAR_5|=((VAR_11 & 0x01) << 6);
        VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
        *VAR_5|=((VAR_11 & 0x01) << 5);
        VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
        *VAR_5|=((VAR_11 & 0x01) << 4);
        VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
        *VAR_5|=((VAR_11 & 0x01) << 3);
        VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
        *VAR_5|=((VAR_11 & 0x01) << 2);
        VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
        *VAR_5|=((VAR_11 & 0x01) << 1);
        VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
        *VAR_5|=((VAR_11 & 0x01) << 0);
        VAR_5++;
      }
      if ((VAR_2 % 8) != 0)
        {
          *VAR_5='\0';
          for (VAR_8=7; VAR_8 >= (ssize_t) (8-(VAR_2 % 8)); VAR_8--)
          {
            VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
            *VAR_5|=((VAR_11 & 0x01) << (unsigned char) VAR_8);
          }
          VAR_5++;
        }
      break;
    }
    case 4:
    {
      unsigned char
        VAR_11;

      for (VAR_7=0; VAR_7 < (ssize_t) (VAR_2-1) ; VAR_7+=2)
      {
        VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
        *VAR_5=((VAR_11 & 0xf) << 4);
        VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
        *VAR_5|=((VAR_11 & 0xf) << 0);
        VAR_5++;
      }
      if ((VAR_2 % 2) != 0)
        {
          VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
          *VAR_5=((VAR_11 & 0xf) << 4);
          VAR_5++;
        }
      break;
    }
    case 8:
    {
      for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
      {
        VAR_5=PopCharPixel((unsigned char) GetPixelIndex(VAR_4+VAR_7),VAR_5);
        VAR_5+=VAR_1->pad;
      }
      break;
    }
    case 16:
    {
      if (VAR_1->format == VAR_12)
        {
          for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
          {
            VAR_5=PopShortPixel(VAR_1->endian,SinglePrecisionToHalf(VAR_13*
              GetPixelIndex(VAR_4+VAR_7)),VAR_5);
            VAR_5+=VAR_1->pad;
          }
          break;
        }
      for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
      {
        VAR_5=PopShortPixel(VAR_1->endian,(unsigned short) GetPixelIndex(VAR_4+VAR_7),VAR_5);
        VAR_5+=VAR_1->pad;
      }
      break;
    }
    case 32:
    {
      if (VAR_1->format == VAR_12)
        {
          for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
          {
            VAR_5=PopFloatPixel(VAR_1,(float) GetPixelIndex(VAR_4+VAR_7),VAR_5);
            VAR_3++;
            VAR_5+=VAR_1->pad;
          }
          break;
        }
      for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
      {
        VAR_5=PopLongPixel(VAR_1->endian,(unsigned int) GetPixelIndex(VAR_4+VAR_7),VAR_5);
        VAR_5+=VAR_1->pad;
      }
      break;
    }
    case 64:
    {
      if (VAR_1->format == VAR_12)
        {
          for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
          {
            VAR_5=PopDoublePixel(VAR_1,(double) GetPixelIndex(VAR_4+VAR_7),
              VAR_5);
            VAR_3++;
            VAR_5+=VAR_1->pad;
          }
          break;
        }
    }
    default:
    {
      for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
      {
        VAR_5=PopQuantumPixel(VAR_1,
          GetPixelIndex(VAR_4+VAR_7),VAR_5);
        VAR_3++;
        VAR_5+=VAR_1->pad;
      }
      break;
    }
  }
}",,"--- func_before
+++ func_after
@@ -24,21 +24,21 @@
 
       for (x=((ssize_t) number_pixels-7); x > 0; x-=8)
       {
-        pixel=(unsigned char) *indexes++;
+        pixel=(unsigned char) ((ssize_t) *indexes++);
         *q=((pixel & 0x01) << 7);
-        pixel=(unsigned char) *indexes++;
+        pixel=(unsigned char) ((ssize_t) *indexes++);
         *q|=((pixel & 0x01) << 6);
-        pixel=(unsigned char) *indexes++;
+        pixel=(unsigned char) ((ssize_t) *indexes++);
         *q|=((pixel & 0x01) << 5);
-        pixel=(unsigned char) *indexes++;
+        pixel=(unsigned char) ((ssize_t) *indexes++);
         *q|=((pixel & 0x01) << 4);
-        pixel=(unsigned char) *indexes++;
+        pixel=(unsigned char) ((ssize_t) *indexes++);
         *q|=((pixel & 0x01) << 3);
-        pixel=(unsigned char) *indexes++;
+        pixel=(unsigned char) ((ssize_t) *indexes++);
         *q|=((pixel & 0x01) << 2);
-        pixel=(unsigned char) *indexes++;
+        pixel=(unsigned char) ((ssize_t) *indexes++);
         *q|=((pixel & 0x01) << 1);
-        pixel=(unsigned char) *indexes++;
+        pixel=(unsigned char) ((ssize_t) *indexes++);
         *q|=((pixel & 0x01) << 0);
         q++;
       }
@@ -47,7 +47,7 @@
           *q='\0';
           for (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)
           {
-            pixel=(unsigned char) *indexes++;
+            pixel=(unsigned char) ((ssize_t) *indexes++);
             *q|=((pixel & 0x01) << (unsigned char) bit);
           }
           q++;
@@ -61,15 +61,15 @@
 
       for (x=0; x < (ssize_t) (number_pixels-1) ; x+=2)
       {
-        pixel=(unsigned char) *indexes++;
+        pixel=(unsigned char) ((ssize_t) *indexes++);
         *q=((pixel & 0xf) << 4);
-        pixel=(unsigned char) *indexes++;
+        pixel=(unsigned char) ((ssize_t) *indexes++);
         *q|=((pixel & 0xf) << 0);
         q++;
       }
       if ((number_pixels % 2) != 0)
         {
-          pixel=(unsigned char) *indexes++;
+          pixel=(unsigned char) ((ssize_t) *indexes++);
           *q=((pixel & 0xf) << 4);
           q++;
         }","{'deleted_lines': ['        pixel=(unsigned char) *indexes++;', '        pixel=(unsigned char) *indexes++;', '        pixel=(unsigned char) *indexes++;', '        pixel=(unsigned char) *indexes++;', '        pixel=(unsigned char) *indexes++;', '        pixel=(unsigned char) *indexes++;', '        pixel=(unsigned char) *indexes++;', '        pixel=(unsigned char) *indexes++;', '            pixel=(unsigned char) *indexes++;', '        pixel=(unsigned char) *indexes++;', '        pixel=(unsigned char) *indexes++;', '          pixel=(unsigned char) *indexes++;'], 'added_lines': ['        pixel=(unsigned char) ((ssize_t) *indexes++);', '        pixel=(unsigned char) ((ssize_t) *indexes++);', '        pixel=(unsigned char) ((ssize_t) *indexes++);', '        pixel=(unsigned char) ((ssize_t) *indexes++);', '        pixel=(unsigned char) ((ssize_t) *indexes++);', '        pixel=(unsigned char) ((ssize_t) *indexes++);', '        pixel=(unsigned char) ((ssize_t) *indexes++);', '        pixel=(unsigned char) ((ssize_t) *indexes++);', '            pixel=(unsigned char) ((ssize_t) *indexes++);', '        pixel=(unsigned char) ((ssize_t) *indexes++);', '        pixel=(unsigned char) ((ssize_t) *indexes++);', '          pixel=(unsigned char) ((ssize_t) *indexes++);']}",True,"An integer overflow issue was discovered in ImageMagick's ExportIndexQuantum() function in MagickCore/quantum-export.c. Function calls to GetPixelIndex() could result in values outside the range of representable for the 'unsigned char'. When ImageMagick processes a crafted pdf file, this could lead to an undefined behaviour or a crash.",5.5,MEDIUM,1,test,2021-01-06T23:34:31Z,3
CVE-2021-20224,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,ImageMagick/ImageMagick6,https://github.com/ImageMagick/ImageMagick/pull/3083,553054c1cb1e4e05ec86237afef76a32cd7c464d,https://github.com/ImageMagick/ImageMagick6/commit/553054c1cb1e4e05ec86237afef76a32cd7c464d,magick/quantum-export.c,ExportRGBQuantum,"static void ExportRGBQuantum(QuantumInfo *quantum_info,
const MagickSizeType number_pixels,const PixelPacket *magick_restrict p,
unsigned char *magick_restrict q)
{
QuantumAny
range;
ssize_t
x;
ssize_t
bit;
switch (quantum_info->depth)
{
case 8:
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopCharPixel(ScaleQuantumToChar(GetPixelRed(p)),q);
q=PopCharPixel(ScaleQuantumToChar(GetPixelGreen(p)),q);
q=PopCharPixel(ScaleQuantumToChar(GetPixelBlue(p)),q);
p++;
q+=quantum_info->pad;
}
break;
}
case 10:
{
unsigned int
pixel;
range=GetQuantumRange(quantum_info->depth);
if (quantum_info->pack == MagickFalse)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
pixel=(unsigned int) (
ScaleQuantumToAny(GetPixelRed(p),range) << 22 |
ScaleQuantumToAny(GetPixelGreen(p),range) << 12 |
ScaleQuantumToAny(GetPixelBlue(p),range) << 2);
q=PopLongPixel(quantum_info->endian,pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
if (quantum_info->quantum == 32UL)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range);
q=PopQuantumLongPixel(quantum_info,pixel,q);
pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range);
q=PopQuantumLongPixel(quantum_info,pixel,q);
pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range);
q=PopQuantumLongPixel(quantum_info,pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
for (x=0; x < (ssize_t) number_pixels; x++)
{
pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range);
q=PopQuantumPixel(quantum_info,pixel,q);
pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range);
q=PopQuantumPixel(quantum_info,pixel,q);
pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range);
q=PopQuantumPixel(quantum_info,pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
case 12:
{
unsigned int
pixel;
range=GetQuantumRange(quantum_info->depth);
if (quantum_info->pack == MagickFalse)
{
for (x=0; x < (ssize_t) (3*number_pixels-1); x+=2)
{
switch (x % 3)
{
default:
case 0:
{
pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range);
break;
}
case 1:
{
pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range);
break;
}
case 2:
{
pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range);
p++;
break;
}
}
q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),q);
switch ((x+1) % 3)
{
default:
case 0:
{
pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range);
break;
}
case 1:
{
pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range);
break;
}
case 2:
{
pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range);
p++;
break;
}
}
q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),q);
q+=quantum_info->pad;
}
for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++)
{
switch ((x+bit) % 3)
{
default:
case 0:
{
pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range);
break;
}
case 1:
{
pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range);
break;
}
case 2:
{
pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range);
p++;
break;
}
}
q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),q);
q+=quantum_info->pad;
}
if (bit != 0)
p++;
break;
}
if (quantum_info->quantum == 32UL)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range);
q=PopQuantumLongPixel(quantum_info,pixel,q);
pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range);
q=PopQuantumLongPixel(quantum_info,pixel,q);
pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range);
q=PopQuantumLongPixel(quantum_info,pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
for (x=0; x < (ssize_t) number_pixels; x++)
{
pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range);
q=PopQuantumPixel(quantum_info,pixel,q);
pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range);
q=PopQuantumPixel(quantum_info,pixel,q);
pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range);
q=PopQuantumPixel(quantum_info,pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
case 16:
{
unsigned short
pixel;
if (quantum_info->format == FloatingPointQuantumFormat)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(p));
q=PopShortPixel(quantum_info->endian,pixel,q);
pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(p));
q=PopShortPixel(quantum_info->endian,pixel,q);
pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(p));
q=PopShortPixel(quantum_info->endian,pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
for (x=0; x < (ssize_t) number_pixels; x++)
{
pixel=ScaleQuantumToShort(GetPixelRed(p));
q=PopShortPixel(quantum_info->endian,pixel,q);
pixel=ScaleQuantumToShort(GetPixelGreen(p));
q=PopShortPixel(quantum_info->endian,pixel,q);
pixel=ScaleQuantumToShort(GetPixelBlue(p));
q=PopShortPixel(quantum_info->endian,pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
case 32:
{
unsigned int
pixel;
if (quantum_info->format == FloatingPointQuantumFormat)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopFloatPixel(quantum_info,(float) GetPixelRed(p),q);
q=PopFloatPixel(quantum_info,(float) GetPixelGreen(p),q);
q=PopFloatPixel(quantum_info,(float) GetPixelBlue(p),q);
p++;
q+=quantum_info->pad;
}
break;
}
for (x=0; x < (ssize_t) number_pixels; x++)
{
pixel=ScaleQuantumToLong(GetPixelRed(p));
q=PopLongPixel(quantum_info->endian,pixel,q);
pixel=ScaleQuantumToLong(GetPixelGreen(p));
q=PopLongPixel(quantum_info->endian,pixel,q);
pixel=ScaleQuantumToLong(GetPixelBlue(p));
q=PopLongPixel(quantum_info->endian,pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
case 64:
{
if (quantum_info->format == FloatingPointQuantumFormat)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopDoublePixel(quantum_info,(double) GetPixelRed(p),q);
q=PopDoublePixel(quantum_info,(double) GetPixelGreen(p),q);
q=PopDoublePixel(quantum_info,(double) GetPixelBlue(p),q);
p++;
q+=quantum_info->pad;
}
break;
}
}
default:
{
range=GetQuantumRange(quantum_info->depth);
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopQuantumPixel(quantum_info,
ScaleQuantumToAny(GetPixelRed(p),range),q);
q=PopQuantumPixel(quantum_info,
ScaleQuantumToAny(GetPixelGreen(p),range),q);
q=PopQuantumPixel(quantum_info,
ScaleQuantumToAny(GetPixelBlue(p),range),q);
p++;
q+=quantum_info->pad;
}
break;
}
}
}","static void ExportRGBQuantum(QuantumInfo *VAR_0,
const MagickSizeType VAR_1,const PixelPacket *magick_restrict VAR_2,
unsigned char *magick_restrict VAR_3)
{
QuantumAny
VAR_4;
ssize_t
VAR_5;
ssize_t
VAR_6;
switch (VAR_0->depth)
{
case 8:
{
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_3=PopCharPixel(ScaleQuantumToChar(GetPixelRed(VAR_2)),VAR_3);
VAR_3=PopCharPixel(ScaleQuantumToChar(GetPixelGreen(VAR_2)),VAR_3);
VAR_3=PopCharPixel(ScaleQuantumToChar(GetPixelBlue(VAR_2)),VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
case 10:
{
unsigned int
VAR_7;
VAR_4=GetQuantumRange(VAR_0->depth);
if (VAR_0->pack == VAR_8)
{
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_7=(unsigned int) (
ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4) << 22 |
ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4) << 12 |
ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4) << 2);
VAR_3=PopLongPixel(VAR_0->endian,VAR_7,VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
if (VAR_0->quantum == 32UL)
{
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4);
VAR_3=PopQuantumLongPixel(VAR_0,VAR_7,VAR_3);
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4);
VAR_3=PopQuantumLongPixel(VAR_0,VAR_7,VAR_3);
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4);
VAR_3=PopQuantumLongPixel(VAR_0,VAR_7,VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4);
VAR_3=PopQuantumPixel(VAR_0,VAR_7,VAR_3);
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4);
VAR_3=PopQuantumPixel(VAR_0,VAR_7,VAR_3);
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4);
VAR_3=PopQuantumPixel(VAR_0,VAR_7,VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
case 12:
{
unsigned int
VAR_7;
VAR_4=GetQuantumRange(VAR_0->depth);
if (VAR_0->pack == VAR_8)
{
for (VAR_5=0; VAR_5 < (ssize_t) (3*VAR_1-1); VAR_5+=2)
{
switch (VAR_5 % 3)
{
default:
case 0:
{
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4);
break;
}
case 1:
{
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4);
break;
}
case 2:
{
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4);
VAR_2++;
break;
}
}
VAR_3=PopShortPixel(VAR_0->endian,(unsigned short) (VAR_7 << 4),VAR_3);
switch ((VAR_5+1) % 3)
{
default:
case 0:
{
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4);
break;
}
case 1:
{
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4);
break;
}
case 2:
{
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4);
VAR_2++;
break;
}
}
VAR_3=PopShortPixel(VAR_0->endian,(unsigned short) (VAR_7 << 4),VAR_3);
VAR_3+=VAR_0->pad;
}
for (VAR_6=0; VAR_6 < (ssize_t) (3*VAR_1 % 2); VAR_6++)
{
switch ((VAR_5+VAR_6) % 3)
{
default:
case 0:
{
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4);
break;
}
case 1:
{
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4);
break;
}
case 2:
{
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4);
VAR_2++;
break;
}
}
VAR_3=PopShortPixel(VAR_0->endian,(unsigned short) (VAR_7 << 4),VAR_3);
VAR_3+=VAR_0->pad;
}
if (VAR_6 != 0)
VAR_2++;
break;
}
if (VAR_0->quantum == 32UL)
{
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4);
VAR_3=PopQuantumLongPixel(VAR_0,VAR_7,VAR_3);
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4);
VAR_3=PopQuantumLongPixel(VAR_0,VAR_7,VAR_3);
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4);
VAR_3=PopQuantumLongPixel(VAR_0,VAR_7,VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4);
VAR_3=PopQuantumPixel(VAR_0,VAR_7,VAR_3);
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4);
VAR_3=PopQuantumPixel(VAR_0,VAR_7,VAR_3);
VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4);
VAR_3=PopQuantumPixel(VAR_0,VAR_7,VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
case 16:
{
unsigned short
VAR_7;
if (VAR_0->format == VAR_9)
{
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_7=SinglePrecisionToHalf(VAR_10*GetPixelRed(VAR_2));
VAR_3=PopShortPixel(VAR_0->endian,VAR_7,VAR_3);
VAR_7=SinglePrecisionToHalf(VAR_10*GetPixelGreen(VAR_2));
VAR_3=PopShortPixel(VAR_0->endian,VAR_7,VAR_3);
VAR_7=SinglePrecisionToHalf(VAR_10*GetPixelBlue(VAR_2));
VAR_3=PopShortPixel(VAR_0->endian,VAR_7,VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_7=ScaleQuantumToShort(GetPixelRed(VAR_2));
VAR_3=PopShortPixel(VAR_0->endian,VAR_7,VAR_3);
VAR_7=ScaleQuantumToShort(GetPixelGreen(VAR_2));
VAR_3=PopShortPixel(VAR_0->endian,VAR_7,VAR_3);
VAR_7=ScaleQuantumToShort(GetPixelBlue(VAR_2));
VAR_3=PopShortPixel(VAR_0->endian,VAR_7,VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
case 32:
{
unsigned int
VAR_7;
if (VAR_0->format == VAR_9)
{
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_3=PopFloatPixel(VAR_0,(float) GetPixelRed(VAR_2),VAR_3);
VAR_3=PopFloatPixel(VAR_0,(float) GetPixelGreen(VAR_2),VAR_3);
VAR_3=PopFloatPixel(VAR_0,(float) GetPixelBlue(VAR_2),VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_7=ScaleQuantumToLong(GetPixelRed(VAR_2));
VAR_3=PopLongPixel(VAR_0->endian,VAR_7,VAR_3);
VAR_7=ScaleQuantumToLong(GetPixelGreen(VAR_2));
VAR_3=PopLongPixel(VAR_0->endian,VAR_7,VAR_3);
VAR_7=ScaleQuantumToLong(GetPixelBlue(VAR_2));
VAR_3=PopLongPixel(VAR_0->endian,VAR_7,VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
case 64:
{
if (VAR_0->format == VAR_9)
{
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_3=PopDoublePixel(VAR_0,(double) GetPixelRed(VAR_2),VAR_3);
VAR_3=PopDoublePixel(VAR_0,(double) GetPixelGreen(VAR_2),VAR_3);
VAR_3=PopDoublePixel(VAR_0,(double) GetPixelBlue(VAR_2),VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
}
default:
{
VAR_4=GetQuantumRange(VAR_0->depth);
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_3=PopQuantumPixel(VAR_0,
ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4),VAR_3);
VAR_3=PopQuantumPixel(VAR_0,
ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4),VAR_3);
VAR_3=PopQuantumPixel(VAR_0,
ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4),VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
}
}",,"static void ExportRGBQuantum(QuantumInfo *quantum_info,
  const MagickSizeType number_pixels,const PixelPacket *magick_restrict p,
  unsigned char *magick_restrict q)
{
  QuantumAny
    range;

  ssize_t
    x;

  ssize_t
    bit;

  switch (quantum_info->depth)
  {
    case 8:
    {
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        q=PopCharPixel(ScaleQuantumToChar(GetPixelRed(p)),q);
        q=PopCharPixel(ScaleQuantumToChar(GetPixelGreen(p)),q);
        q=PopCharPixel(ScaleQuantumToChar(GetPixelBlue(p)),q);
        p++;
        q+=quantum_info->pad;
      }
      break;
    }
    case 10:
    {
      unsigned int
        pixel;

      range=GetQuantumRange(quantum_info->depth);
      if (quantum_info->pack == MagickFalse)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            pixel=(unsigned int) (
              ScaleQuantumToAny(GetPixelRed(p),range) << 22 |
              ScaleQuantumToAny(GetPixelGreen(p),range) << 12 |
              ScaleQuantumToAny(GetPixelBlue(p),range) << 2);
            q=PopLongPixel(quantum_info->endian,pixel,q);
            p++;
            q+=quantum_info->pad;
          }
          break;
        }
      if (quantum_info->quantum == 32UL)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range);
            q=PopQuantumLongPixel(quantum_info,pixel,q);
            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range);
            q=PopQuantumLongPixel(quantum_info,pixel,q);
            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range);
            q=PopQuantumLongPixel(quantum_info,pixel,q);
            p++;
            q+=quantum_info->pad;
          }
          break;
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range);
        q=PopQuantumPixel(quantum_info,pixel,q);
        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range);
        q=PopQuantumPixel(quantum_info,pixel,q);
        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range);
        q=PopQuantumPixel(quantum_info,pixel,q);
        p++;
        q+=quantum_info->pad;
      }
      break;
    }
    case 12:
    {
      unsigned int
        pixel;

      range=GetQuantumRange(quantum_info->depth);
      if (quantum_info->pack == MagickFalse)
        {
          for (x=0; x < (ssize_t) (3*number_pixels-1); x+=2)
          {
            switch (x % 3)
            {
              default:
              case 0:
              {
                pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range);
                break;
              }
              case 1:
              {
                pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range);
                break;
              }
              case 2:
              {
                pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range);
                p++;
                break;
              }
            }
            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),
              q);
            switch ((x+1) % 3)
            {
              default:
              case 0:
              {
                pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range);
                break;
              }
              case 1:
              {
                pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range);
                break;
              }
              case 2:
              {
                pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range);
                p++;
                break;
              }
            }
            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),
              q);
            q+=quantum_info->pad;
          }
          for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++)
          {
            switch ((x+bit) % 3)
            {
              default:
              case 0:
              {
                pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range);
                break;
              }
              case 1:
              {
                pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range);
                break;
              }
              case 2:
              {
                pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range);
                p++;
                break;
              }
            }
            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),
              q);
            q+=quantum_info->pad;
          }
          if (bit != 0)
            p++;
          break;
        }
      if (quantum_info->quantum == 32UL)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range);
            q=PopQuantumLongPixel(quantum_info,pixel,q);
            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range);
            q=PopQuantumLongPixel(quantum_info,pixel,q);
            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range);
            q=PopQuantumLongPixel(quantum_info,pixel,q);
            p++;
            q+=quantum_info->pad;
          }
          break;
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range);
        q=PopQuantumPixel(quantum_info,pixel,q);
        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range);
        q=PopQuantumPixel(quantum_info,pixel,q);
        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range);
        q=PopQuantumPixel(quantum_info,pixel,q);
        p++;
        q+=quantum_info->pad;
      }
      break;
    }
    case 16:
    {
      unsigned short
        pixel;

      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(p));
            q=PopShortPixel(quantum_info->endian,pixel,q);
            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(p));
            q=PopShortPixel(quantum_info->endian,pixel,q);
            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(p));
            q=PopShortPixel(quantum_info->endian,pixel,q);
            p++;
            q+=quantum_info->pad;
          }
          break;
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        pixel=ScaleQuantumToShort(GetPixelRed(p));
        q=PopShortPixel(quantum_info->endian,pixel,q);
        pixel=ScaleQuantumToShort(GetPixelGreen(p));
        q=PopShortPixel(quantum_info->endian,pixel,q);
        pixel=ScaleQuantumToShort(GetPixelBlue(p));
        q=PopShortPixel(quantum_info->endian,pixel,q);
        p++;
        q+=quantum_info->pad;
      }
      break;
    }
    case 32:
    {
      unsigned int
        pixel;

      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            q=PopFloatPixel(quantum_info,(float) GetPixelRed(p),q);
            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(p),q);
            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(p),q);
            p++;
            q+=quantum_info->pad;
          }
          break;
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        pixel=ScaleQuantumToLong(GetPixelRed(p));
        q=PopLongPixel(quantum_info->endian,pixel,q);
        pixel=ScaleQuantumToLong(GetPixelGreen(p));
        q=PopLongPixel(quantum_info->endian,pixel,q);
        pixel=ScaleQuantumToLong(GetPixelBlue(p));
        q=PopLongPixel(quantum_info->endian,pixel,q);
        p++;
        q+=quantum_info->pad;
      }
      break;
    }
    case 64:
    {
      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            q=PopDoublePixel(quantum_info,(double) GetPixelRed(p),q);
            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(p),q);
            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(p),q);
            p++;
            q+=quantum_info->pad;
          }
          break;
        }
    }
    default:
    {
      range=GetQuantumRange(quantum_info->depth);
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        q=PopQuantumPixel(quantum_info,
          ScaleQuantumToAny(GetPixelRed(p),range),q);
        q=PopQuantumPixel(quantum_info,
          ScaleQuantumToAny(GetPixelGreen(p),range),q);
        q=PopQuantumPixel(quantum_info,
          ScaleQuantumToAny(GetPixelBlue(p),range),q);
        p++;
        q+=quantum_info->pad;
      }
      break;
    }
  }
}","static void ExportRGBQuantum(QuantumInfo *VAR_0,
  const MagickSizeType VAR_1,const PixelPacket *magick_restrict VAR_2,
  unsigned char *magick_restrict VAR_3)
{
  QuantumAny
    VAR_4;

  ssize_t
    VAR_5;

  ssize_t
    VAR_6;

  switch (VAR_0->depth)
  {
    case 8:
    {
      for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
      {
        VAR_3=PopCharPixel(ScaleQuantumToChar(GetPixelRed(VAR_2)),VAR_3);
        VAR_3=PopCharPixel(ScaleQuantumToChar(GetPixelGreen(VAR_2)),VAR_3);
        VAR_3=PopCharPixel(ScaleQuantumToChar(GetPixelBlue(VAR_2)),VAR_3);
        VAR_2++;
        VAR_3+=VAR_0->pad;
      }
      break;
    }
    case 10:
    {
      unsigned int
        VAR_7;

      VAR_4=GetQuantumRange(VAR_0->depth);
      if (VAR_0->pack == VAR_8)
        {
          for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
          {
            VAR_7=(unsigned int) (
              ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4) << 22 |
              ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4) << 12 |
              ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4) << 2);
            VAR_3=PopLongPixel(VAR_0->endian,VAR_7,VAR_3);
            VAR_2++;
            VAR_3+=VAR_0->pad;
          }
          break;
        }
      if (VAR_0->quantum == 32UL)
        {
          for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
          {
            VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4);
            VAR_3=PopQuantumLongPixel(VAR_0,VAR_7,VAR_3);
            VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4);
            VAR_3=PopQuantumLongPixel(VAR_0,VAR_7,VAR_3);
            VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4);
            VAR_3=PopQuantumLongPixel(VAR_0,VAR_7,VAR_3);
            VAR_2++;
            VAR_3+=VAR_0->pad;
          }
          break;
        }
      for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
      {
        VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4);
        VAR_3=PopQuantumPixel(VAR_0,VAR_7,VAR_3);
        VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4);
        VAR_3=PopQuantumPixel(VAR_0,VAR_7,VAR_3);
        VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4);
        VAR_3=PopQuantumPixel(VAR_0,VAR_7,VAR_3);
        VAR_2++;
        VAR_3+=VAR_0->pad;
      }
      break;
    }
    case 12:
    {
      unsigned int
        VAR_7;

      VAR_4=GetQuantumRange(VAR_0->depth);
      if (VAR_0->pack == VAR_8)
        {
          for (VAR_5=0; VAR_5 < (ssize_t) (3*VAR_1-1); VAR_5+=2)
          {
            switch (VAR_5 % 3)
            {
              default:
              case 0:
              {
                VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4);
                break;
              }
              case 1:
              {
                VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4);
                break;
              }
              case 2:
              {
                VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4);
                VAR_2++;
                break;
              }
            }
            VAR_3=PopShortPixel(VAR_0->endian,(unsigned short) (VAR_7 << 4),
              VAR_3);
            switch ((VAR_5+1) % 3)
            {
              default:
              case 0:
              {
                VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4);
                break;
              }
              case 1:
              {
                VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4);
                break;
              }
              case 2:
              {
                VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4);
                VAR_2++;
                break;
              }
            }
            VAR_3=PopShortPixel(VAR_0->endian,(unsigned short) (VAR_7 << 4),
              VAR_3);
            VAR_3+=VAR_0->pad;
          }
          for (VAR_6=0; VAR_6 < (ssize_t) (3*VAR_1 % 2); VAR_6++)
          {
            switch ((VAR_5+VAR_6) % 3)
            {
              default:
              case 0:
              {
                VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4);
                break;
              }
              case 1:
              {
                VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4);
                break;
              }
              case 2:
              {
                VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4);
                VAR_2++;
                break;
              }
            }
            VAR_3=PopShortPixel(VAR_0->endian,(unsigned short) (VAR_7 << 4),
              VAR_3);
            VAR_3+=VAR_0->pad;
          }
          if (VAR_6 != 0)
            VAR_2++;
          break;
        }
      if (VAR_0->quantum == 32UL)
        {
          for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
          {
            VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4);
            VAR_3=PopQuantumLongPixel(VAR_0,VAR_7,VAR_3);
            VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4);
            VAR_3=PopQuantumLongPixel(VAR_0,VAR_7,VAR_3);
            VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4);
            VAR_3=PopQuantumLongPixel(VAR_0,VAR_7,VAR_3);
            VAR_2++;
            VAR_3+=VAR_0->pad;
          }
          break;
        }
      for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
      {
        VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4);
        VAR_3=PopQuantumPixel(VAR_0,VAR_7,VAR_3);
        VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4);
        VAR_3=PopQuantumPixel(VAR_0,VAR_7,VAR_3);
        VAR_7=(unsigned int) ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4);
        VAR_3=PopQuantumPixel(VAR_0,VAR_7,VAR_3);
        VAR_2++;
        VAR_3+=VAR_0->pad;
      }
      break;
    }
    case 16:
    {
      unsigned short
        VAR_7;

      if (VAR_0->format == VAR_9)
        {
          for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
          {
            VAR_7=SinglePrecisionToHalf(VAR_10*GetPixelRed(VAR_2));
            VAR_3=PopShortPixel(VAR_0->endian,VAR_7,VAR_3);
            VAR_7=SinglePrecisionToHalf(VAR_10*GetPixelGreen(VAR_2));
            VAR_3=PopShortPixel(VAR_0->endian,VAR_7,VAR_3);
            VAR_7=SinglePrecisionToHalf(VAR_10*GetPixelBlue(VAR_2));
            VAR_3=PopShortPixel(VAR_0->endian,VAR_7,VAR_3);
            VAR_2++;
            VAR_3+=VAR_0->pad;
          }
          break;
        }
      for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
      {
        VAR_7=ScaleQuantumToShort(GetPixelRed(VAR_2));
        VAR_3=PopShortPixel(VAR_0->endian,VAR_7,VAR_3);
        VAR_7=ScaleQuantumToShort(GetPixelGreen(VAR_2));
        VAR_3=PopShortPixel(VAR_0->endian,VAR_7,VAR_3);
        VAR_7=ScaleQuantumToShort(GetPixelBlue(VAR_2));
        VAR_3=PopShortPixel(VAR_0->endian,VAR_7,VAR_3);
        VAR_2++;
        VAR_3+=VAR_0->pad;
      }
      break;
    }
    case 32:
    {
      unsigned int
        VAR_7;

      if (VAR_0->format == VAR_9)
        {
          for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
          {
            VAR_3=PopFloatPixel(VAR_0,(float) GetPixelRed(VAR_2),VAR_3);
            VAR_3=PopFloatPixel(VAR_0,(float) GetPixelGreen(VAR_2),VAR_3);
            VAR_3=PopFloatPixel(VAR_0,(float) GetPixelBlue(VAR_2),VAR_3);
            VAR_2++;
            VAR_3+=VAR_0->pad;
          }
          break;
        }
      for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
      {
        VAR_7=ScaleQuantumToLong(GetPixelRed(VAR_2));
        VAR_3=PopLongPixel(VAR_0->endian,VAR_7,VAR_3);
        VAR_7=ScaleQuantumToLong(GetPixelGreen(VAR_2));
        VAR_3=PopLongPixel(VAR_0->endian,VAR_7,VAR_3);
        VAR_7=ScaleQuantumToLong(GetPixelBlue(VAR_2));
        VAR_3=PopLongPixel(VAR_0->endian,VAR_7,VAR_3);
        VAR_2++;
        VAR_3+=VAR_0->pad;
      }
      break;
    }
    case 64:
    {
      if (VAR_0->format == VAR_9)
        {
          for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
          {
            VAR_3=PopDoublePixel(VAR_0,(double) GetPixelRed(VAR_2),VAR_3);
            VAR_3=PopDoublePixel(VAR_0,(double) GetPixelGreen(VAR_2),VAR_3);
            VAR_3=PopDoublePixel(VAR_0,(double) GetPixelBlue(VAR_2),VAR_3);
            VAR_2++;
            VAR_3+=VAR_0->pad;
          }
          break;
        }
    }
    default:
    {
      VAR_4=GetQuantumRange(VAR_0->depth);
      for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
      {
        VAR_3=PopQuantumPixel(VAR_0,
          ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4),VAR_3);
        VAR_3=PopQuantumPixel(VAR_0,
          ScaleQuantumToAny(GetPixelGreen(VAR_2),VAR_4),VAR_3);
        VAR_3=PopQuantumPixel(VAR_0,
          ScaleQuantumToAny(GetPixelBlue(VAR_2),VAR_4),VAR_3);
        VAR_2++;
        VAR_3+=VAR_0->pad;
      }
      break;
    }
  }
}",,"--- func_before
+++ func_after
@@ -103,7 +103,8 @@
                 break;
               }
             }
-            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),q);
+            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),
+              q);
             switch ((x+1) % 3)
             {
               default:
@@ -124,7 +125,8 @@
                 break;
               }
             }
-            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),q);
+            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),
+              q);
             q+=quantum_info->pad;
           }
           for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++)
@@ -149,7 +151,8 @@
                 break;
               }
             }
-            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),q);
+            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),
+              q);
             q+=quantum_info->pad;
           }
           if (bit != 0)","{'deleted_lines': ['            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),q);', '            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),q);', '            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),q);'], 'added_lines': ['            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),', '              q);', '            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),', '              q);', '            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),', '              q);']}",True,"An integer overflow issue was discovered in ImageMagick's ExportIndexQuantum() function in MagickCore/quantum-export.c. Function calls to GetPixelIndex() could result in values outside the range of representable for the 'unsigned char'. When ImageMagick processes a crafted pdf file, this could lead to an undefined behaviour or a crash.",5.5,MEDIUM,1,test,2021-01-06T23:34:31Z,3
CVE-2021-20224,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,ImageMagick/ImageMagick6,https://github.com/ImageMagick/ImageMagick/pull/3083,553054c1cb1e4e05ec86237afef76a32cd7c464d,https://github.com/ImageMagick/ImageMagick6/commit/553054c1cb1e4e05ec86237afef76a32cd7c464d,magick/quantum-export.c,ExportIndexAlphaQuantum,"static void ExportIndexAlphaQuantum(const Image *image,
QuantumInfo *quantum_info,const MagickSizeType number_pixels,
const PixelPacket *magick_restrict p,
const IndexPacket *magick_restrict indexes,unsigned char *magick_restrict q,
ExceptionInfo *exception)
{
ssize_t
x;
ssize_t
bit;
if (image->storage_class != PseudoClass)
{
(void) ThrowMagickException(exception,GetMagickModule(),ImageError,
""ColormappedImageRequired"",""`%s'"",image->filename);
return;
}
switch (quantum_info->depth)
{
case 1:
{
unsigned char
pixel;
for (x=((ssize_t) number_pixels-3); x > 0; x-=4)
{
pixel=(unsigned char) *indexes++;
*q=((pixel & 0x01) << 7);
pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)
TransparentOpacity ? 1 : 0);
*q|=((pixel & 0x01) << 6);
p++;
pixel=(unsigned char) *indexes++;
*q|=((pixel & 0x01) << 5);
pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)
TransparentOpacity ? 1 : 0);
*q|=((pixel & 0x01) << 4);
p++;
pixel=(unsigned char) *indexes++;
*q|=((pixel & 0x01) << 3);
pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)
TransparentOpacity ? 1 : 0);
*q|=((pixel & 0x01) << 2);
p++;
pixel=(unsigned char) *indexes++;
*q|=((pixel & 0x01) << 1);
pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)
TransparentOpacity ? 1 : 0);
*q|=((pixel & 0x01) << 0);
p++;
q++;
}
if ((number_pixels % 4) != 0)
{
*q='\0';
for (bit=3; bit >= (ssize_t) (4-(number_pixels % 4)); bit-=2)
{
pixel=(unsigned char) *indexes++;
*q|=((pixel & 0x01) << (unsigned char) (bit+4));
pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)
TransparentOpacity ? 1 : 0);
*q|=((pixel & 0x01) << (unsigned char) (bit+4-1));
p++;
}
q++;
}
break;
}
case 4:
{
unsigned char
pixel;
for (x=0; x < (ssize_t) number_pixels ; x++)
{
pixel=(unsigned char) *indexes++;
*q=((pixel & 0xf) << 4);
pixel=(unsigned char) (16*QuantumScale*((Quantum) (QuantumRange-
GetPixelOpacity(p)))+0.5);
*q|=((pixel & 0xf) << 0);
p++;
q++;
}
break;
}
case 8:
{
unsigned char
pixel;
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopCharPixel((unsigned char) GetPixelIndex(indexes+x),q);
pixel=ScaleQuantumToChar((Quantum) (QuantumRange-GetPixelOpacity(p)));
q=PopCharPixel(pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
case 16:
{
unsigned short
pixel;
if (quantum_info->format == FloatingPointQuantumFormat)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopShortPixel(quantum_info->endian,(unsigned short) GetPixelIndex(indexes+x),q);
pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(p));
q=PopShortPixel(quantum_info->endian,pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopShortPixel(quantum_info->endian,(unsigned short) GetPixelIndex(indexes+x),q);
pixel=ScaleQuantumToShort((Quantum) (QuantumRange-GetPixelOpacity(p)));
q=PopShortPixel(quantum_info->endian,pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
case 32:
{
unsigned int
pixel;
if (quantum_info->format == FloatingPointQuantumFormat)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
float
pixel;
q=PopFloatPixel(quantum_info,(float) GetPixelIndex(indexes+x),q);
pixel=(float)  (GetPixelAlpha(p));
q=PopFloatPixel(quantum_info,pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopLongPixel(quantum_info->endian,(unsigned int) GetPixelIndex(indexes+x),q);
pixel=ScaleQuantumToLong((Quantum) (QuantumRange-GetPixelOpacity(p)));
q=PopLongPixel(quantum_info->endian,pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
case 64:
{
if (quantum_info->format == FloatingPointQuantumFormat)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
double
pixel;
q=PopDoublePixel(quantum_info,(double) GetPixelIndex(indexes+x),
q);
pixel=(double) (GetPixelAlpha(p));
q=PopDoublePixel(quantum_info,pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
}
default:
{
QuantumAny
range;
range=GetQuantumRange(quantum_info->depth);
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopQuantumPixel(quantum_info,
GetPixelIndex(indexes+x),q);
q=PopQuantumPixel(quantum_info,
ScaleQuantumToAny((Quantum) (GetPixelAlpha(p)),range),q);
p++;
q+=quantum_info->pad;
}
break;
}
}
}","static void ExportIndexAlphaQuantum(const Image *VAR_0,
QuantumInfo *VAR_1,const MagickSizeType VAR_2,
const PixelPacket *magick_restrict VAR_3,
const IndexPacket *magick_restrict VAR_4,unsigned char *magick_restrict VAR_5,
ExceptionInfo *VAR_6)
{
ssize_t
VAR_7;
ssize_t
VAR_8;
if (VAR_0->storage_class != VAR_9)
{
(void) ThrowMagickException(VAR_6,GetMagickModule(),VAR_10,
""ColormappedImageRequired"",""`%s'"",VAR_0->filename);
return;
}
switch (VAR_1->depth)
{
case 1:
{
unsigned char
VAR_11;
for (VAR_7=((ssize_t) VAR_2-3); VAR_7 > 0; VAR_7-=4)
{
VAR_11=(unsigned char) *VAR_4++;
*VAR_5=((VAR_11 & 0x01) << 7);
VAR_11=(unsigned char) (GetPixelOpacity(VAR_3) == (Quantum)
VAR_12 ? 1 : 0);
*VAR_5|=((VAR_11 & 0x01) << 6);
VAR_3++;
VAR_11=(unsigned char) *VAR_4++;
*VAR_5|=((VAR_11 & 0x01) << 5);
VAR_11=(unsigned char) (GetPixelOpacity(VAR_3) == (Quantum)
VAR_12 ? 1 : 0);
*VAR_5|=((VAR_11 & 0x01) << 4);
VAR_3++;
VAR_11=(unsigned char) *VAR_4++;
*VAR_5|=((VAR_11 & 0x01) << 3);
VAR_11=(unsigned char) (GetPixelOpacity(VAR_3) == (Quantum)
VAR_12 ? 1 : 0);
*VAR_5|=((VAR_11 & 0x01) << 2);
VAR_3++;
VAR_11=(unsigned char) *VAR_4++;
*VAR_5|=((VAR_11 & 0x01) << 1);
VAR_11=(unsigned char) (GetPixelOpacity(VAR_3) == (Quantum)
VAR_12 ? 1 : 0);
*VAR_5|=((VAR_11 & 0x01) << 0);
VAR_3++;
VAR_5++;
}
if ((VAR_2 % 4) != 0)
{
*VAR_5='\0';
for (VAR_8=3; VAR_8 >= (ssize_t) (4-(VAR_2 % 4)); VAR_8-=2)
{
VAR_11=(unsigned char) *VAR_4++;
*VAR_5|=((VAR_11 & 0x01) << (unsigned char) (VAR_8+4));
VAR_11=(unsigned char) (GetPixelOpacity(VAR_3) == (Quantum)
VAR_12 ? 1 : 0);
*VAR_5|=((VAR_11 & 0x01) << (unsigned char) (VAR_8+4-1));
VAR_3++;
}
VAR_5++;
}
break;
}
case 4:
{
unsigned char
VAR_11;
for (VAR_7=0; VAR_7 < (ssize_t) VAR_2 ; VAR_7++)
{
VAR_11=(unsigned char) *VAR_4++;
*VAR_5=((VAR_11 & 0xf) << 4);
VAR_11=(unsigned char) (16*VAR_13*((Quantum) (VAR_14-
GetPixelOpacity(VAR_3)))+0.5);
*VAR_5|=((VAR_11 & 0xf) << 0);
VAR_3++;
VAR_5++;
}
break;
}
case 8:
{
unsigned char
VAR_11;
for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
{
VAR_5=PopCharPixel((unsigned char) GetPixelIndex(VAR_4+VAR_7),VAR_5);
VAR_11=ScaleQuantumToChar((Quantum) (VAR_14-GetPixelOpacity(VAR_3)));
VAR_5=PopCharPixel(VAR_11,VAR_5);
VAR_3++;
VAR_5+=VAR_1->pad;
}
break;
}
case 16:
{
unsigned short
VAR_11;
if (VAR_1->format == VAR_15)
{
for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
{
VAR_5=PopShortPixel(VAR_1->endian,(unsigned short) GetPixelIndex(VAR_4+VAR_7),VAR_5);
VAR_11=SinglePrecisionToHalf(VAR_13*GetPixelAlpha(VAR_3));
VAR_5=PopShortPixel(VAR_1->endian,VAR_11,VAR_5);
VAR_3++;
VAR_5+=VAR_1->pad;
}
break;
}
for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
{
VAR_5=PopShortPixel(VAR_1->endian,(unsigned short) GetPixelIndex(VAR_4+VAR_7),VAR_5);
VAR_11=ScaleQuantumToShort((Quantum) (VAR_14-GetPixelOpacity(VAR_3)));
VAR_5=PopShortPixel(VAR_1->endian,VAR_11,VAR_5);
VAR_3++;
VAR_5+=VAR_1->pad;
}
break;
}
case 32:
{
unsigned int
VAR_11;
if (VAR_1->format == VAR_15)
{
for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
{
float
VAR_11;
VAR_5=PopFloatPixel(VAR_1,(float) GetPixelIndex(VAR_4+VAR_7),VAR_5);
VAR_11=(float)  (GetPixelAlpha(VAR_3));
VAR_5=PopFloatPixel(VAR_1,VAR_11,VAR_5);
VAR_3++;
VAR_5+=VAR_1->pad;
}
break;
}
for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
{
VAR_5=PopLongPixel(VAR_1->endian,(unsigned int) GetPixelIndex(VAR_4+VAR_7),VAR_5);
VAR_11=ScaleQuantumToLong((Quantum) (VAR_14-GetPixelOpacity(VAR_3)));
VAR_5=PopLongPixel(VAR_1->endian,VAR_11,VAR_5);
VAR_3++;
VAR_5+=VAR_1->pad;
}
break;
}
case 64:
{
if (VAR_1->format == VAR_15)
{
for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
{
double
VAR_11;
VAR_5=PopDoublePixel(VAR_1,(double) GetPixelIndex(VAR_4+VAR_7),
VAR_5);
VAR_11=(double) (GetPixelAlpha(VAR_3));
VAR_5=PopDoublePixel(VAR_1,VAR_11,VAR_5);
VAR_3++;
VAR_5+=VAR_1->pad;
}
break;
}
}
default:
{
QuantumAny
VAR_16;
VAR_16=GetQuantumRange(VAR_1->depth);
for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
{
VAR_5=PopQuantumPixel(VAR_1,
GetPixelIndex(VAR_4+VAR_7),VAR_5);
VAR_5=PopQuantumPixel(VAR_1,
ScaleQuantumToAny((Quantum) (GetPixelAlpha(VAR_3)),VAR_16),VAR_5);
VAR_3++;
VAR_5+=VAR_1->pad;
}
break;
}
}
}",,"static void ExportIndexAlphaQuantum(const Image *image,
  QuantumInfo *quantum_info,const MagickSizeType number_pixels,
  const PixelPacket *magick_restrict p,
  const IndexPacket *magick_restrict indexes,unsigned char *magick_restrict q,
  ExceptionInfo *exception)
{
  ssize_t
    x;

  ssize_t
    bit;

  if (image->storage_class != PseudoClass)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,
        ""ColormappedImageRequired"",""`%s'"",image->filename);
      return;
    }
  switch (quantum_info->depth)
  {
    case 1:
    {
      unsigned char
        pixel;

      for (x=((ssize_t) number_pixels-3); x > 0; x-=4)
      {
        pixel=(unsigned char) ((ssize_t) *indexes++);
        *q=((pixel & 0x01) << 7);
        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)
          TransparentOpacity ? 1 : 0);
        *q|=((pixel & 0x01) << 6);
        p++;
        pixel=(unsigned char) ((ssize_t) *indexes++);
        *q|=((pixel & 0x01) << 5);
        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)
          TransparentOpacity ? 1 : 0);
        *q|=((pixel & 0x01) << 4);
        p++;
        pixel=(unsigned char) ((ssize_t) *indexes++);
        *q|=((pixel & 0x01) << 3);
        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)
          TransparentOpacity ? 1 : 0);
        *q|=((pixel & 0x01) << 2);
        p++;
        pixel=(unsigned char) ((ssize_t) *indexes++);
        *q|=((pixel & 0x01) << 1);
        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)
          TransparentOpacity ? 1 : 0);
        *q|=((pixel & 0x01) << 0);
        p++;
        q++;
      }
      if ((number_pixels % 4) != 0)
        {
          *q='\0';
          for (bit=3; bit >= (ssize_t) (4-(number_pixels % 4)); bit-=2)
          {
            pixel=(unsigned char) ((ssize_t) *indexes++);
            *q|=((pixel & 0x01) << (unsigned char) (bit+4));
            pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)
              TransparentOpacity ? 1 : 0);
            *q|=((pixel & 0x01) << (unsigned char) (bit+4-1));
            p++;
          }
          q++;
        }
      break;
    }
    case 4:
    {
      unsigned char
        pixel;

      for (x=0; x < (ssize_t) number_pixels ; x++)
      {
        pixel=(unsigned char) ((ssize_t) *indexes++);
        *q=((pixel & 0xf) << 4);
        pixel=(unsigned char) ((ssize_t) (16*QuantumScale*((Quantum)
          (QuantumRange-GetPixelOpacity(p)))+0.5));
        *q|=((pixel & 0xf) << 0);
        p++;
        q++;
      }
      break;
    }
    case 8:
    {
      unsigned char
        pixel;

      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        q=PopCharPixel((unsigned char) GetPixelIndex(indexes+x),q);
        pixel=ScaleQuantumToChar((Quantum) (QuantumRange-GetPixelOpacity(p)));
        q=PopCharPixel(pixel,q);
        p++;
        q+=quantum_info->pad;
      }
      break;
    }
    case 16:
    {
      unsigned short
        pixel;

      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            q=PopShortPixel(quantum_info->endian,(unsigned short)
              ((ssize_t) GetPixelIndex(indexes+x)),q);
            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(p));
            q=PopShortPixel(quantum_info->endian,pixel,q);
            p++;
            q+=quantum_info->pad;
          }
          break;
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        q=PopShortPixel(quantum_info->endian,(unsigned short)
          ((ssize_t) GetPixelIndex(indexes+x)),q);
        pixel=ScaleQuantumToShort((Quantum) (QuantumRange-GetPixelOpacity(p)));
        q=PopShortPixel(quantum_info->endian,pixel,q);
        p++;
        q+=quantum_info->pad;
      }
      break;
    }
    case 32:
    {
      unsigned int
        pixel;

      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            float
              pixel;

            q=PopFloatPixel(quantum_info,(float) GetPixelIndex(indexes+x),q);
            pixel=(float)  (GetPixelAlpha(p));
            q=PopFloatPixel(quantum_info,pixel,q);
            p++;
            q+=quantum_info->pad;
          }
          break;
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        q=PopLongPixel(quantum_info->endian,(unsigned int)
          GetPixelIndex(indexes+x),q);
        pixel=ScaleQuantumToLong((Quantum) (QuantumRange-GetPixelOpacity(p)));
        q=PopLongPixel(quantum_info->endian,pixel,q);
        p++;
        q+=quantum_info->pad;
      }
      break;
    }
    case 64:
    {
      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            double
              pixel;

            q=PopDoublePixel(quantum_info,(double) GetPixelIndex(indexes+x),
              q);
            pixel=(double) (GetPixelAlpha(p));
            q=PopDoublePixel(quantum_info,pixel,q);
            p++;
            q+=quantum_info->pad;
          }
          break;
        }
    }
    default:
    {
      QuantumAny
        range;

      range=GetQuantumRange(quantum_info->depth);
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        q=PopQuantumPixel(quantum_info,GetPixelIndex(indexes+x),q);
        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny((Quantum)
          (GetPixelAlpha(p)),range),q);
        p++;
        q+=quantum_info->pad;
      }
      break;
    }
  }
}","static void ExportIndexAlphaQuantum(const Image *VAR_0,
  QuantumInfo *VAR_1,const MagickSizeType VAR_2,
  const PixelPacket *magick_restrict VAR_3,
  const IndexPacket *magick_restrict VAR_4,unsigned char *magick_restrict VAR_5,
  ExceptionInfo *VAR_6)
{
  ssize_t
    VAR_7;

  ssize_t
    VAR_8;

  if (VAR_0->storage_class != VAR_9)
    {
      (void) ThrowMagickException(VAR_6,GetMagickModule(),VAR_10,
        ""ColormappedImageRequired"",""`%s'"",VAR_0->filename);
      return;
    }
  switch (VAR_1->depth)
  {
    case 1:
    {
      unsigned char
        VAR_11;

      for (VAR_7=((ssize_t) VAR_2-3); VAR_7 > 0; VAR_7-=4)
      {
        VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
        *VAR_5=((VAR_11 & 0x01) << 7);
        VAR_11=(unsigned char) (GetPixelOpacity(VAR_3) == (Quantum)
          VAR_12 ? 1 : 0);
        *VAR_5|=((VAR_11 & 0x01) << 6);
        VAR_3++;
        VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
        *VAR_5|=((VAR_11 & 0x01) << 5);
        VAR_11=(unsigned char) (GetPixelOpacity(VAR_3) == (Quantum)
          VAR_12 ? 1 : 0);
        *VAR_5|=((VAR_11 & 0x01) << 4);
        VAR_3++;
        VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
        *VAR_5|=((VAR_11 & 0x01) << 3);
        VAR_11=(unsigned char) (GetPixelOpacity(VAR_3) == (Quantum)
          VAR_12 ? 1 : 0);
        *VAR_5|=((VAR_11 & 0x01) << 2);
        VAR_3++;
        VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
        *VAR_5|=((VAR_11 & 0x01) << 1);
        VAR_11=(unsigned char) (GetPixelOpacity(VAR_3) == (Quantum)
          VAR_12 ? 1 : 0);
        *VAR_5|=((VAR_11 & 0x01) << 0);
        VAR_3++;
        VAR_5++;
      }
      if ((VAR_2 % 4) != 0)
        {
          *VAR_5='\0';
          for (VAR_8=3; VAR_8 >= (ssize_t) (4-(VAR_2 % 4)); VAR_8-=2)
          {
            VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
            *VAR_5|=((VAR_11 & 0x01) << (unsigned char) (VAR_8+4));
            VAR_11=(unsigned char) (GetPixelOpacity(VAR_3) == (Quantum)
              VAR_12 ? 1 : 0);
            *VAR_5|=((VAR_11 & 0x01) << (unsigned char) (VAR_8+4-1));
            VAR_3++;
          }
          VAR_5++;
        }
      break;
    }
    case 4:
    {
      unsigned char
        VAR_11;

      for (VAR_7=0; VAR_7 < (ssize_t) VAR_2 ; VAR_7++)
      {
        VAR_11=(unsigned char) ((ssize_t) *VAR_4++);
        *VAR_5=((VAR_11 & 0xf) << 4);
        VAR_11=(unsigned char) ((ssize_t) (16*VAR_13*((Quantum)
          (VAR_14-GetPixelOpacity(VAR_3)))+0.5));
        *VAR_5|=((VAR_11 & 0xf) << 0);
        VAR_3++;
        VAR_5++;
      }
      break;
    }
    case 8:
    {
      unsigned char
        VAR_11;

      for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
      {
        VAR_5=PopCharPixel((unsigned char) GetPixelIndex(VAR_4+VAR_7),VAR_5);
        VAR_11=ScaleQuantumToChar((Quantum) (VAR_14-GetPixelOpacity(VAR_3)));
        VAR_5=PopCharPixel(VAR_11,VAR_5);
        VAR_3++;
        VAR_5+=VAR_1->pad;
      }
      break;
    }
    case 16:
    {
      unsigned short
        VAR_11;

      if (VAR_1->format == VAR_15)
        {
          for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
          {
            VAR_5=PopShortPixel(VAR_1->endian,(unsigned short)
              ((ssize_t) GetPixelIndex(VAR_4+VAR_7)),VAR_5);
            VAR_11=SinglePrecisionToHalf(VAR_13*GetPixelAlpha(VAR_3));
            VAR_5=PopShortPixel(VAR_1->endian,VAR_11,VAR_5);
            VAR_3++;
            VAR_5+=VAR_1->pad;
          }
          break;
        }
      for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
      {
        VAR_5=PopShortPixel(VAR_1->endian,(unsigned short)
          ((ssize_t) GetPixelIndex(VAR_4+VAR_7)),VAR_5);
        VAR_11=ScaleQuantumToShort((Quantum) (VAR_14-GetPixelOpacity(VAR_3)));
        VAR_5=PopShortPixel(VAR_1->endian,VAR_11,VAR_5);
        VAR_3++;
        VAR_5+=VAR_1->pad;
      }
      break;
    }
    case 32:
    {
      unsigned int
        VAR_11;

      if (VAR_1->format == VAR_15)
        {
          for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
          {
            float
              VAR_11;

            VAR_5=PopFloatPixel(VAR_1,(float) GetPixelIndex(VAR_4+VAR_7),VAR_5);
            VAR_11=(float)  (GetPixelAlpha(VAR_3));
            VAR_5=PopFloatPixel(VAR_1,VAR_11,VAR_5);
            VAR_3++;
            VAR_5+=VAR_1->pad;
          }
          break;
        }
      for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
      {
        VAR_5=PopLongPixel(VAR_1->endian,(unsigned int)
          GetPixelIndex(VAR_4+VAR_7),VAR_5);
        VAR_11=ScaleQuantumToLong((Quantum) (VAR_14-GetPixelOpacity(VAR_3)));
        VAR_5=PopLongPixel(VAR_1->endian,VAR_11,VAR_5);
        VAR_3++;
        VAR_5+=VAR_1->pad;
      }
      break;
    }
    case 64:
    {
      if (VAR_1->format == VAR_15)
        {
          for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
          {
            double
              VAR_11;

            VAR_5=PopDoublePixel(VAR_1,(double) GetPixelIndex(VAR_4+VAR_7),
              VAR_5);
            VAR_11=(double) (GetPixelAlpha(VAR_3));
            VAR_5=PopDoublePixel(VAR_1,VAR_11,VAR_5);
            VAR_3++;
            VAR_5+=VAR_1->pad;
          }
          break;
        }
    }
    default:
    {
      QuantumAny
        VAR_16;

      VAR_16=GetQuantumRange(VAR_1->depth);
      for (VAR_7=0; VAR_7 < (ssize_t) VAR_2; VAR_7++)
      {
        VAR_5=PopQuantumPixel(VAR_1,GetPixelIndex(VAR_4+VAR_7),VAR_5);
        VAR_5=PopQuantumPixel(VAR_1,ScaleQuantumToAny((Quantum)
          (GetPixelAlpha(VAR_3)),VAR_16),VAR_5);
        VAR_3++;
        VAR_5+=VAR_1->pad;
      }
      break;
    }
  }
}",,"--- func_before
+++ func_after
@@ -25,25 +25,25 @@
 
       for (x=((ssize_t) number_pixels-3); x > 0; x-=4)
       {
-        pixel=(unsigned char) *indexes++;
+        pixel=(unsigned char) ((ssize_t) *indexes++);
         *q=((pixel & 0x01) << 7);
         pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)
           TransparentOpacity ? 1 : 0);
         *q|=((pixel & 0x01) << 6);
         p++;
-        pixel=(unsigned char) *indexes++;
+        pixel=(unsigned char) ((ssize_t) *indexes++);
         *q|=((pixel & 0x01) << 5);
         pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)
           TransparentOpacity ? 1 : 0);
         *q|=((pixel & 0x01) << 4);
         p++;
-        pixel=(unsigned char) *indexes++;
+        pixel=(unsigned char) ((ssize_t) *indexes++);
         *q|=((pixel & 0x01) << 3);
         pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)
           TransparentOpacity ? 1 : 0);
         *q|=((pixel & 0x01) << 2);
         p++;
-        pixel=(unsigned char) *indexes++;
+        pixel=(unsigned char) ((ssize_t) *indexes++);
         *q|=((pixel & 0x01) << 1);
         pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)
           TransparentOpacity ? 1 : 0);
@@ -56,7 +56,7 @@
           *q='\0';
           for (bit=3; bit >= (ssize_t) (4-(number_pixels % 4)); bit-=2)
           {
-            pixel=(unsigned char) *indexes++;
+            pixel=(unsigned char) ((ssize_t) *indexes++);
             *q|=((pixel & 0x01) << (unsigned char) (bit+4));
             pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)
               TransparentOpacity ? 1 : 0);
@@ -74,10 +74,10 @@
 
       for (x=0; x < (ssize_t) number_pixels ; x++)
       {
-        pixel=(unsigned char) *indexes++;
+        pixel=(unsigned char) ((ssize_t) *indexes++);
         *q=((pixel & 0xf) << 4);
-        pixel=(unsigned char) (16*QuantumScale*((Quantum) (QuantumRange-
-          GetPixelOpacity(p)))+0.5);
+        pixel=(unsigned char) ((ssize_t) (16*QuantumScale*((Quantum)
+          (QuantumRange-GetPixelOpacity(p)))+0.5));
         *q|=((pixel & 0xf) << 0);
         p++;
         q++;
@@ -108,7 +108,8 @@
         {
           for (x=0; x < (ssize_t) number_pixels; x++)
           {
-            q=PopShortPixel(quantum_info->endian,(unsigned short) GetPixelIndex(indexes+x),q);
+            q=PopShortPixel(quantum_info->endian,(unsigned short)
+              ((ssize_t) GetPixelIndex(indexes+x)),q);
             pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(p));
             q=PopShortPixel(quantum_info->endian,pixel,q);
             p++;
@@ -118,7 +119,8 @@
         }
       for (x=0; x < (ssize_t) number_pixels; x++)
       {
-        q=PopShortPixel(quantum_info->endian,(unsigned short) GetPixelIndex(indexes+x),q);
+        q=PopShortPixel(quantum_info->endian,(unsigned short)
+          ((ssize_t) GetPixelIndex(indexes+x)),q);
         pixel=ScaleQuantumToShort((Quantum) (QuantumRange-GetPixelOpacity(p)));
         q=PopShortPixel(quantum_info->endian,pixel,q);
         p++;
@@ -148,7 +150,8 @@
         }
       for (x=0; x < (ssize_t) number_pixels; x++)
       {
-        q=PopLongPixel(quantum_info->endian,(unsigned int) GetPixelIndex(indexes+x),q);
+        q=PopLongPixel(quantum_info->endian,(unsigned int)
+          GetPixelIndex(indexes+x),q);
         pixel=ScaleQuantumToLong((Quantum) (QuantumRange-GetPixelOpacity(p)));
         q=PopLongPixel(quantum_info->endian,pixel,q);
         p++;
@@ -183,10 +186,9 @@
       range=GetQuantumRange(quantum_info->depth);
       for (x=0; x < (ssize_t) number_pixels; x++)
       {
-        q=PopQuantumPixel(quantum_info,
-          GetPixelIndex(indexes+x),q);
-        q=PopQuantumPixel(quantum_info,
-          ScaleQuantumToAny((Quantum) (GetPixelAlpha(p)),range),q);
+        q=PopQuantumPixel(quantum_info,GetPixelIndex(indexes+x),q);
+        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny((Quantum)
+          (GetPixelAlpha(p)),range),q);
         p++;
         q+=quantum_info->pad;
       }","{'deleted_lines': ['        pixel=(unsigned char) *indexes++;', '        pixel=(unsigned char) *indexes++;', '        pixel=(unsigned char) *indexes++;', '        pixel=(unsigned char) *indexes++;', '            pixel=(unsigned char) *indexes++;', '        pixel=(unsigned char) *indexes++;', '        pixel=(unsigned char) (16*QuantumScale*((Quantum) (QuantumRange-', '          GetPixelOpacity(p)))+0.5);', '            q=PopShortPixel(quantum_info->endian,(unsigned short) GetPixelIndex(indexes+x),q);', '        q=PopShortPixel(quantum_info->endian,(unsigned short) GetPixelIndex(indexes+x),q);', '        q=PopLongPixel(quantum_info->endian,(unsigned int) GetPixelIndex(indexes+x),q);', '        q=PopQuantumPixel(quantum_info,', '          GetPixelIndex(indexes+x),q);', '        q=PopQuantumPixel(quantum_info,', '          ScaleQuantumToAny((Quantum) (GetPixelAlpha(p)),range),q);'], 'added_lines': ['        pixel=(unsigned char) ((ssize_t) *indexes++);', '        pixel=(unsigned char) ((ssize_t) *indexes++);', '        pixel=(unsigned char) ((ssize_t) *indexes++);', '        pixel=(unsigned char) ((ssize_t) *indexes++);', '            pixel=(unsigned char) ((ssize_t) *indexes++);', '        pixel=(unsigned char) ((ssize_t) *indexes++);', '        pixel=(unsigned char) ((ssize_t) (16*QuantumScale*((Quantum)', '          (QuantumRange-GetPixelOpacity(p)))+0.5));', '            q=PopShortPixel(quantum_info->endian,(unsigned short)', '              ((ssize_t) GetPixelIndex(indexes+x)),q);', '        q=PopShortPixel(quantum_info->endian,(unsigned short)', '          ((ssize_t) GetPixelIndex(indexes+x)),q);', '        q=PopLongPixel(quantum_info->endian,(unsigned int)', '          GetPixelIndex(indexes+x),q);', '        q=PopQuantumPixel(quantum_info,GetPixelIndex(indexes+x),q);', '        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny((Quantum)', '          (GetPixelAlpha(p)),range),q);']}",True,"An integer overflow issue was discovered in ImageMagick's ExportIndexQuantum() function in MagickCore/quantum-export.c. Function calls to GetPixelIndex() could result in values outside the range of representable for the 'unsigned char'. When ImageMagick processes a crafted pdf file, this could lead to an undefined behaviour or a crash.",5.5,MEDIUM,1,test,2021-01-06T23:34:31Z,3
CVE-2021-20224,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,ImageMagick/ImageMagick6,https://github.com/ImageMagick/ImageMagick/pull/3083,553054c1cb1e4e05ec86237afef76a32cd7c464d,https://github.com/ImageMagick/ImageMagick6/commit/553054c1cb1e4e05ec86237afef76a32cd7c464d,magick/quantum-export.c,ExportRedQuantum,"static void ExportRedQuantum(QuantumInfo *quantum_info,
const MagickSizeType number_pixels,const PixelPacket *magick_restrict p,
unsigned char *magick_restrict q)
{
QuantumAny
range;
ssize_t
x;
switch (quantum_info->depth)
{
case 8:
{
unsigned char
pixel;
for (x=0; x < (ssize_t) number_pixels; x++)
{
pixel=ScaleQuantumToChar(GetPixelRed(p));
q=PopCharPixel(pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
case 16:
{
unsigned short
pixel;
if (quantum_info->format == FloatingPointQuantumFormat)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(p));
q=PopShortPixel(quantum_info->endian,pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
for (x=0; x < (ssize_t) number_pixels; x++)
{
pixel=ScaleQuantumToShort(GetPixelRed(p));
q=PopShortPixel(quantum_info->endian,pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
case 32:
{
unsigned int
pixel;
if (quantum_info->format == FloatingPointQuantumFormat)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopFloatPixel(quantum_info,(float) GetPixelRed(p),q);
p++;
q+=quantum_info->pad;
}
break;
}
for (x=0; x < (ssize_t) number_pixels; x++)
{
pixel=ScaleQuantumToLong(GetPixelRed(p));
q=PopLongPixel(quantum_info->endian,pixel,q);
p++;
q+=quantum_info->pad;
}
break;
}
case 64:
{
if (quantum_info->format == FloatingPointQuantumFormat)
{
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopDoublePixel(quantum_info,(double) GetPixelRed(p),q);
p++;
q+=quantum_info->pad;
}
break;
}
}
default:
{
range=GetQuantumRange(quantum_info->depth);
for (x=0; x < (ssize_t) number_pixels; x++)
{
q=PopQuantumPixel(quantum_info,
ScaleQuantumToAny(GetPixelRed(p),range),q);
p++;
q+=quantum_info->pad;
}
break;
}
}
}","static void ExportRedQuantum(QuantumInfo *VAR_0,
const MagickSizeType VAR_1,const PixelPacket *magick_restrict VAR_2,
unsigned char *magick_restrict VAR_3)
{
QuantumAny
VAR_4;
ssize_t
VAR_5;
switch (VAR_0->depth)
{
case 8:
{
unsigned char
VAR_6;
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_6=ScaleQuantumToChar(GetPixelRed(VAR_2));
VAR_3=PopCharPixel(VAR_6,VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
case 16:
{
unsigned short
VAR_6;
if (VAR_0->format == VAR_7)
{
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_6=SinglePrecisionToHalf(VAR_8*GetPixelRed(VAR_2));
VAR_3=PopShortPixel(VAR_0->endian,VAR_6,VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_6=ScaleQuantumToShort(GetPixelRed(VAR_2));
VAR_3=PopShortPixel(VAR_0->endian,VAR_6,VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
case 32:
{
unsigned int
VAR_6;
if (VAR_0->format == VAR_7)
{
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_3=PopFloatPixel(VAR_0,(float) GetPixelRed(VAR_2),VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_6=ScaleQuantumToLong(GetPixelRed(VAR_2));
VAR_3=PopLongPixel(VAR_0->endian,VAR_6,VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
case 64:
{
if (VAR_0->format == VAR_7)
{
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_3=PopDoublePixel(VAR_0,(double) GetPixelRed(VAR_2),VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
}
default:
{
VAR_4=GetQuantumRange(VAR_0->depth);
for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
{
VAR_3=PopQuantumPixel(VAR_0,
ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4),VAR_3);
VAR_2++;
VAR_3+=VAR_0->pad;
}
break;
}
}
}",,"static void ExportRedQuantum(QuantumInfo *quantum_info,
  const MagickSizeType number_pixels,const PixelPacket *magick_restrict p,
  unsigned char *magick_restrict q)
{
  QuantumAny
    range;

  ssize_t
    x;

  switch (quantum_info->depth)
  {
    case 8:
    {
      unsigned char
        pixel;

      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        pixel=ScaleQuantumToChar(GetPixelRed(p));
        q=PopCharPixel(pixel,q);
        p++;
        q+=quantum_info->pad;
      }
      break;
    }
    case 16:
    {
      unsigned short
        pixel;

      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(p));
            q=PopShortPixel(quantum_info->endian,pixel,q);
            p++;
            q+=quantum_info->pad;
          }
          break;
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        pixel=ScaleQuantumToShort(GetPixelRed(p));
        q=PopShortPixel(quantum_info->endian,pixel,q);
        p++;
        q+=quantum_info->pad;
      }
      break;
    }
    case 32:
    {
      unsigned int
        pixel;

      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            q=PopFloatPixel(quantum_info,(float) GetPixelRed(p),q);
            p++;
            q+=quantum_info->pad;
          }
          break;
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        pixel=ScaleQuantumToLong(GetPixelRed(p));
        q=PopLongPixel(quantum_info->endian,pixel,q);
        p++;
        q+=quantum_info->pad;
      }
      break;
    }
    case 64:
    {
      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            q=PopDoublePixel(quantum_info,(double) GetPixelRed(p),q);
            p++;
            q+=quantum_info->pad;
          }
          break;
        }
    }
    default:
    {
      range=GetQuantumRange(quantum_info->depth);
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(p),range),
          q);
        p++;
        q+=quantum_info->pad;
      }
      break;
    }
  }
}","static void ExportRedQuantum(QuantumInfo *VAR_0,
  const MagickSizeType VAR_1,const PixelPacket *magick_restrict VAR_2,
  unsigned char *magick_restrict VAR_3)
{
  QuantumAny
    VAR_4;

  ssize_t
    VAR_5;

  switch (VAR_0->depth)
  {
    case 8:
    {
      unsigned char
        VAR_6;

      for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
      {
        VAR_6=ScaleQuantumToChar(GetPixelRed(VAR_2));
        VAR_3=PopCharPixel(VAR_6,VAR_3);
        VAR_2++;
        VAR_3+=VAR_0->pad;
      }
      break;
    }
    case 16:
    {
      unsigned short
        VAR_6;

      if (VAR_0->format == VAR_7)
        {
          for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
          {
            VAR_6=SinglePrecisionToHalf(VAR_8*GetPixelRed(VAR_2));
            VAR_3=PopShortPixel(VAR_0->endian,VAR_6,VAR_3);
            VAR_2++;
            VAR_3+=VAR_0->pad;
          }
          break;
        }
      for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
      {
        VAR_6=ScaleQuantumToShort(GetPixelRed(VAR_2));
        VAR_3=PopShortPixel(VAR_0->endian,VAR_6,VAR_3);
        VAR_2++;
        VAR_3+=VAR_0->pad;
      }
      break;
    }
    case 32:
    {
      unsigned int
        VAR_6;

      if (VAR_0->format == VAR_7)
        {
          for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
          {
            VAR_3=PopFloatPixel(VAR_0,(float) GetPixelRed(VAR_2),VAR_3);
            VAR_2++;
            VAR_3+=VAR_0->pad;
          }
          break;
        }
      for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
      {
        VAR_6=ScaleQuantumToLong(GetPixelRed(VAR_2));
        VAR_3=PopLongPixel(VAR_0->endian,VAR_6,VAR_3);
        VAR_2++;
        VAR_3+=VAR_0->pad;
      }
      break;
    }
    case 64:
    {
      if (VAR_0->format == VAR_7)
        {
          for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
          {
            VAR_3=PopDoublePixel(VAR_0,(double) GetPixelRed(VAR_2),VAR_3);
            VAR_2++;
            VAR_3+=VAR_0->pad;
          }
          break;
        }
    }
    default:
    {
      VAR_4=GetQuantumRange(VAR_0->depth);
      for (VAR_5=0; VAR_5 < (ssize_t) VAR_1; VAR_5++)
      {
        VAR_3=PopQuantumPixel(VAR_0,ScaleQuantumToAny(GetPixelRed(VAR_2),VAR_4),
          VAR_3);
        VAR_2++;
        VAR_3+=VAR_0->pad;
      }
      break;
    }
  }
}",,"--- func_before
+++ func_after
@@ -91,8 +91,8 @@
       range=GetQuantumRange(quantum_info->depth);
       for (x=0; x < (ssize_t) number_pixels; x++)
       {
-        q=PopQuantumPixel(quantum_info,
-          ScaleQuantumToAny(GetPixelRed(p),range),q);
+        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(p),range),
+          q);
         p++;
         q+=quantum_info->pad;
       }","{'deleted_lines': ['        q=PopQuantumPixel(quantum_info,', '          ScaleQuantumToAny(GetPixelRed(p),range),q);'], 'added_lines': ['        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(p),range),', '          q);']}",True,"An integer overflow issue was discovered in ImageMagick's ExportIndexQuantum() function in MagickCore/quantum-export.c. Function calls to GetPixelIndex() could result in values outside the range of representable for the 'unsigned char'. When ImageMagick processes a crafted pdf file, this could lead to an undefined behaviour or a crash.",5.5,MEDIUM,1,test,2021-01-06T23:34:31Z,3
CVE-2020-29394,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,COVESA/dlt-daemon,"fscanf() uses dynamic formatting to prevent buffer overflow

CVE: CVE-2020-29394

Signed-off-by: KHANH LUONG HONG DUY <khanh.luonghongduy@vn.bosch.com>",25703a5cdbf3067ca4d4e75a0229762855548ecc,https://github.com/COVESA/dlt-daemon/commit/25703a5cdbf3067ca4d4e75a0229762855548ecc,src/shared/dlt_common.c,dlt_filter_load,"DltReturnValue dlt_filter_load(DltFilter *filter, const char *filename, int verbose)
{
if ((filter == NULL) || (filename == NULL))
return DLT_RETURN_WRONG_PARAMETER;
FILE *handle;
char str1[DLT_COMMON_BUFFER_LENGTH];
char apid[DLT_ID_SIZE], ctid[DLT_ID_SIZE];
PRINT_FUNCTION_VERBOSE(verbose);
handle = fopen(filename, ""r"");
if (handle == NULL) {
dlt_vlog(LOG_WARNING, ""Filter file %s cannot be opened!\n"", filename);
return DLT_RETURN_ERROR;
}
filter->counter = 0;
while (!feof(handle)) {
str1[0] = 0;
if (fscanf(handle, ""%254s"", str1) != 1)
break;
if (str1[0] == 0)
break;
printf("" %s"", str1);
if (strcmp(str1, ""----"") == 0)
dlt_set_id(apid, """");
else
dlt_set_id(apid, str1);
str1[0] = 0;
if (fscanf(handle, ""%254s"", str1) != 1)
break;
if (str1[0] == 0)
break;
printf("" %s\r\n"", str1);
if (strcmp(str1, ""----"") == 0)
dlt_set_id(ctid, """");
else
dlt_set_id(ctid, str1);
if (filter->counter < DLT_FILTER_MAX) {
dlt_filter_add(filter, apid, ctid, verbose);
}
else {
dlt_vlog(LOG_WARNING,
""Maximum number (%d) of allowed filters reached, ignoring rest of filters!\n"",
DLT_FILTER_MAX);
}
}
fclose(handle);
return DLT_RETURN_OK;
}","DltReturnValue dlt_filter_load(DltFilter *VAR_0, const char *VAR_1, int VAR_2)
{
if ((VAR_0 == NULL) || (VAR_1 == NULL))
return VAR_3;
FILE *VAR_4;
char VAR_5[VAR_6];
char VAR_7[VAR_8], VAR_9[VAR_8];
PRINT_FUNCTION_VERBOSE(VAR_2);
VAR_4 = fopen(VAR_1, ""r"");
if (VAR_4 == NULL) {
dlt_vlog(VAR_10, ""Filter file %s cannot be opened!\n"", VAR_1);
return VAR_11;
}
VAR_0->counter = 0;
while (!feof(VAR_4)) {
VAR_5[0] = 0;
if (fscanf(VAR_4, ""%254s"", VAR_5) != 1)
break;
if (VAR_5[0] == 0)
break;
printf("" %s"", VAR_5);
if (strcmp(VAR_5, ""----"") == 0)
dlt_set_id(VAR_7, """");
else
dlt_set_id(VAR_7, VAR_5);
VAR_5[0] = 0;
if (fscanf(VAR_4, ""%254s"", VAR_5) != 1)
break;
if (VAR_5[0] == 0)
break;
printf("" %s\r\n"", VAR_5);
if (strcmp(VAR_5, ""----"") == 0)
dlt_set_id(VAR_9, """");
else
dlt_set_id(VAR_9, VAR_5);
if (VAR_0->counter < VAR_12) {
dlt_filter_add(VAR_0, VAR_7, VAR_9, VAR_2);
}
else {
dlt_vlog(VAR_10,
""Maximum number (%d) of allowed filters reached, ignoring rest of filters!\n"",
VAR_12);
}
}
fclose(VAR_4);
return VAR_13;
}",COVESA/dlt-daemon/25703a5cdbf3067ca4d4e75a0229762855548ecc/dlt_common.c/vul/before/0.json,"DltReturnValue dlt_filter_load(DltFilter *filter, const char *filename, int verbose)
{
    if ((filter == NULL) || (filename == NULL))
        return DLT_RETURN_WRONG_PARAMETER;

    FILE *handle;
    char str1[DLT_COMMON_BUFFER_LENGTH];
    char apid[DLT_ID_SIZE], ctid[DLT_ID_SIZE];
    char format[10];

    PRINT_FUNCTION_VERBOSE(verbose);

    handle = fopen(filename, ""r"");

    if (handle == NULL) {
        dlt_vlog(LOG_WARNING, ""Filter file %s cannot be opened!\n"", filename);
        return DLT_RETURN_ERROR;
    }

    sprintf(format, ""%c%ds"", '%', DLT_COMMON_BUFFER_LENGTH-1);

    /* Reset filters */
    filter->counter = 0;

    while (!feof(handle)) {
        str1[0] = 0;

        if (fscanf(handle, format, str1) != 1)
            break;

        if (str1[0] == 0)
            break;

        printf("" %s"", str1);

        if (strcmp(str1, ""----"") == 0)
            dlt_set_id(apid, """");
        else
            dlt_set_id(apid, str1);

        str1[0] = 0;

        if (fscanf(handle, format, str1) != 1)
            break;

        if (str1[0] == 0)
            break;

        printf("" %s\r\n"", str1);

        if (strcmp(str1, ""----"") == 0)
            dlt_set_id(ctid, """");
        else
            dlt_set_id(ctid, str1);

        if (filter->counter < DLT_FILTER_MAX) {
            dlt_filter_add(filter, apid, ctid, verbose);
        }
        else {
            dlt_vlog(LOG_WARNING,
                     ""Maximum number (%d) of allowed filters reached, ignoring rest of filters!\n"",
                     DLT_FILTER_MAX);
        }
    }

    fclose(handle);

    return DLT_RETURN_OK;
}","DltReturnValue dlt_filter_load(DltFilter *VAR_0, const char *VAR_1, int VAR_2)
{
    if ((VAR_0 == NULL) || (VAR_1 == NULL))
        return VAR_3;

    FILE *VAR_4;
    char VAR_5[VAR_6];
    char VAR_7[VAR_8], VAR_9[VAR_8];
    char VAR_10[10];

    PRINT_FUNCTION_VERBOSE(VAR_2);

    VAR_4 = fopen(VAR_1, ""r"");

    if (VAR_4 == NULL) {
        dlt_vlog(VAR_11, ""Filter file %s cannot be opened!\n"", VAR_1);
        return VAR_12;
    }

    sprintf(VAR_10, ""%c%ds"", '%', VAR_6-1);

    /* COMMENT_0 */
    VAR_0->counter = 0;

    while (!feof(VAR_4)) {
        VAR_5[0] = 0;

        if (fscanf(VAR_4, VAR_10, VAR_5) != 1)
            break;

        if (VAR_5[0] == 0)
            break;

        printf("" %s"", VAR_5);

        if (strcmp(VAR_5, ""----"") == 0)
            dlt_set_id(VAR_7, """");
        else
            dlt_set_id(VAR_7, VAR_5);

        VAR_5[0] = 0;

        if (fscanf(VAR_4, VAR_10, VAR_5) != 1)
            break;

        if (VAR_5[0] == 0)
            break;

        printf("" %s\r\n"", VAR_5);

        if (strcmp(VAR_5, ""----"") == 0)
            dlt_set_id(VAR_9, """");
        else
            dlt_set_id(VAR_9, VAR_5);

        if (VAR_0->counter < VAR_13) {
            dlt_filter_add(VAR_0, VAR_7, VAR_9, VAR_2);
        }
        else {
            dlt_vlog(VAR_11,
                     ""Maximum number (%d) of allowed filters reached, ignoring rest of filters!\n"",
                     VAR_13);
        }
    }

    fclose(VAR_4);

    return VAR_14;
}",COVESA/dlt-daemon/25703a5cdbf3067ca4d4e75a0229762855548ecc/dlt_common.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,7 @@
     FILE *handle;
     char str1[DLT_COMMON_BUFFER_LENGTH];
     char apid[DLT_ID_SIZE], ctid[DLT_ID_SIZE];
+    char format[10];
 
     PRINT_FUNCTION_VERBOSE(verbose);
 
@@ -16,13 +17,15 @@
         return DLT_RETURN_ERROR;
     }
 
+    sprintf(format, ""%c%ds"", '%', DLT_COMMON_BUFFER_LENGTH-1);
+
     /* Reset filters */
     filter->counter = 0;
 
     while (!feof(handle)) {
         str1[0] = 0;
 
-        if (fscanf(handle, ""%254s"", str1) != 1)
+        if (fscanf(handle, format, str1) != 1)
             break;
 
         if (str1[0] == 0)
@@ -37,7 +40,7 @@
 
         str1[0] = 0;
 
-        if (fscanf(handle, ""%254s"", str1) != 1)
+        if (fscanf(handle, format, str1) != 1)
             break;
 
         if (str1[0] == 0)","{'deleted_lines': ['        if (fscanf(handle, ""%254s"", str1) != 1)', '        if (fscanf(handle, ""%254s"", str1) != 1)'], 'added_lines': ['    char format[10];', '    sprintf(format, ""%c%ds"", \'%\', DLT_COMMON_BUFFER_LENGTH-1);', '', '        if (fscanf(handle, format, str1) != 1)', '        if (fscanf(handle, format, str1) != 1)']}",True,A buffer overflow in the dlt_filter_load function in dlt_common.c from dlt-daemon through 2.18.5 (GENIVI Diagnostic Log and Trace) allows arbitrary code execution because fscanf is misused (no limit on the number of characters to be read in the format argument).,7.8,HIGH,2,test,2021-01-22T03:44:59Z,3
CVE-2019-25016,"['CWE-459', 'CWE-909']",AV:N/AC:L/Au:S/C:P/I:P/A:P,0,Duncaen/OpenDoas,"correctly reset path for rules without specific command

This is a fixup for commit 01c658f8c45cb92a343be5f32aa6da70b2032168
where the behaviour was changed to not inherit the PATH variable
by default.",d5acd52e2a15c36a8e06f9103d35622933aa422d,https://github.com/Duncaen/OpenDoas/commit/d5acd52e2a15c36a8e06f9103d35622933aa422d,doas.c,main,"int
main(int argc, char **argv)
{
const char *safepath = ""/bin:/sbin:/usr/bin:/usr/sbin:""
""/usr/local/bin:/usr/local/sbin"";
const char *confpath = NULL;
char *shargv[] = { NULL, NULL };
char *sh;
const char *p;
const char *cmd;
char cmdline[LINE_MAX];
struct passwd mypwstore, targpwstore;
struct passwd *mypw, *targpw;
const struct rule *rule;
uid_t uid;
uid_t target = 0;
gid_t groups[NGROUPS_MAX + 1];
int ngroups;
int i, ch, rv;
int sflag = 0;
int nflag = 0;
char cwdpath[PATH_MAX];
const char *cwd;
char **envp;
setprogname(""doas"");
closefrom(STDERR_FILENO + 1);
uid = getuid();
while ((ch = getopt(argc, argv, ""+C:Lnsu:"")) != -1) {
switch (ch) {
case 'C':
confpath = optarg;
break;
case 'L':
#if defined(USE_TIMESTAMP)
exit(timestamp_clear() == -1);
#else
exit(0);
#endif
case 'u':
if (parseuid(optarg, &target) != 0)
errx(1, ""unknown user"");
break;
case 'n':
nflag = 1;
break;
case 's':
sflag = 1;
break;
default:
usage();
break;
}
}
argv += optind;
argc -= optind;
if (confpath) {
if (sflag)
usage();
} else if ((!sflag && !argc) || (sflag && argc))
usage();
rv = mygetpwuid_r(uid, &mypwstore, &mypw);
if (rv != 0)
err(1, ""getpwuid_r failed"");
if (mypw == NULL)
errx(1, ""no passwd entry for self"");
ngroups = getgroups(NGROUPS_MAX, groups);
if (ngroups == -1)
err(1, ""can't get groups"");
groups[ngroups++] = getgid();
if (sflag) {
sh = getenv(""SHELL"");
if (sh == NULL || *sh == '\0') {
shargv[0] = mypw->pw_shell;
} else
shargv[0] = sh;
argv = shargv;
argc = 1;
}
if (confpath) {
checkconfig(confpath, argc, argv, uid, groups, ngroups,
target);
exit(1);
}
if (geteuid())
errx(1, ""not installed setuid"");
parseconfig(DOAS_CONF, 1);
(void)strlcpy(cmdline, argv[0], sizeof(cmdline));
for (i = 1; i < argc; i++) {
if (strlcat(cmdline, "" "", sizeof(cmdline)) >= sizeof(cmdline))
break;
if (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))
break;
}
cmd = argv[0];
if (!permit(uid, groups, ngroups, &rule, target, cmd,
(const char **)argv + 1)) {
syslog(LOG_AUTHPRIV | LOG_NOTICE,
""command not permitted for %s: %s"", mypw->pw_name, cmdline);
errc(1, EPERM, NULL);
}
#if defined(USE_SHADOW)
if (!(rule->options & NOPASS)) {
if (nflag)
errx(1, ""Authorization required"");
shadowauth(mypw->pw_name, rule->options & PERSIST);
}
#elif !defined(USE_PAM)
(void) nflag;
if (!(rule->options & NOPASS))
errx(1, ""Authorization required"");
#endif
if ((p = getenv(""PATH"")) != NULL)
formerpath = strdup(p);
if (formerpath == NULL)
formerpath = """";
if (rule->cmd) {
if (setenv(""PATH"", safepath, 1) == -1)
err(1, ""failed to set PATH '%s'"", safepath);
}
rv = mygetpwuid_r(target, &targpwstore, &targpw);
if (rv != 0)
err(1, ""getpwuid_r failed"");
if (targpw == NULL)
errx(1, ""no passwd entry for target"");
#if defined(USE_PAM)
pamauth(targpw->pw_name, mypw->pw_name, !nflag, rule->options & NOPASS,
rule->options & PERSIST);
#endif
#ifdef HAVE_LOGIN_CAP_H
if (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |
LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |
LOGIN_SETUSER) != 0)
errx(1, ""failed to set user context for target"");
#else
if (setresgid(targpw->pw_gid, targpw->pw_gid, targpw->pw_gid) != 0)
err(1, ""setresgid"");
if (initgroups(targpw->pw_name, targpw->pw_gid) != 0)
err(1, ""initgroups"");
if (setresuid(target, target, target) != 0)
err(1, ""setresuid"");
#endif
if (getcwd(cwdpath, sizeof(cwdpath)) == NULL)
cwd = ""(failed)"";
else
cwd = cwdpath;
if (!(rule->options & NOLOG)) {
syslog(LOG_AUTHPRIV | LOG_INFO,
""%s ran command %s as %s from %s"",
mypw->pw_name, cmdline, targpw->pw_name, cwd);
}
envp = prepenv(rule, mypw, targpw);
if (rule->cmd) {
if (setenv(""PATH"", safepath, 1) == -1)
err(1, ""failed to set PATH '%s'"", safepath);
} else {
if (setenv(""PATH"", formerpath, 1) == -1)
err(1, ""failed to set PATH '%s'"", formerpath);
}
execvpe(cmd, argv, envp);
if (errno == ENOENT)
errx(1, ""%s: command not found"", cmd);
err(1, ""%s"", cmd);
}","int
main(int VAR_0, char **VAR_1)
{
const char *VAR_2 = ""/bin:/sbin:/usr/bin:/usr/sbin:""
""/usr/local/bin:/usr/local/sbin"";
const char *VAR_3 = NULL;
char *VAR_4[] = { NULL, NULL };
char *VAR_5;
const char *VAR_6;
const char *VAR_7;
char VAR_8[VAR_9];
struct passwd VAR_10, VAR_11;
struct passwd *VAR_12, *VAR_13;
const struct rule *rule;
uid_t VAR_14;
uid_t VAR_15 = 0;
gid_t VAR_16[VAR_17 + 1];
int VAR_18;
int VAR_19, VAR_20, VAR_21;
int VAR_22 = 0;
int VAR_23 = 0;
char VAR_24[VAR_25];
const char *VAR_26;
char **VAR_27;
setprogname(""doas"");
closefrom(VAR_28 + 1);
VAR_14 = getuid();
while ((VAR_20 = getopt(VAR_0, VAR_1, ""+C:Lnsu:"")) != -1) {
switch (VAR_20) {
case 'C':
VAR_3 = VAR_29;
break;
case 'L':
#if defined(VAR_30)
exit(timestamp_clear() == -1);
#else
exit(0);
#endif
case 'u':
if (parseuid(VAR_29, &VAR_15) != 0)
errx(1, ""unknown user"");
break;
case 'n':
VAR_23 = 1;
break;
case 's':
VAR_22 = 1;
break;
default:
usage();
break;
}
}
VAR_1 += VAR_31;
VAR_0 -= VAR_31;
if (VAR_3) {
if (VAR_22)
usage();
} else if ((!VAR_22 && !VAR_0) || (VAR_22 && VAR_0))
usage();
VAR_21 = mygetpwuid_r(VAR_14, &VAR_10, &VAR_12);
if (VAR_21 != 0)
err(1, ""getpwuid_r failed"");
if (VAR_12 == NULL)
errx(1, ""no passwd entry for self"");
VAR_18 = getgroups(VAR_17, VAR_16);
if (VAR_18 == -1)
err(1, ""can't get groups"");
VAR_16[VAR_18++] = getgid();
if (VAR_22) {
VAR_5 = getenv(""SHELL"");
if (VAR_5 == NULL || *VAR_5 == '\0') {
VAR_4[0] = VAR_12->pw_shell;
} else
VAR_4[0] = VAR_5;
VAR_1 = VAR_4;
VAR_0 = 1;
}
if (VAR_3) {
checkconfig(VAR_3, VAR_0, VAR_1, VAR_14, VAR_16, VAR_18,
VAR_15);
exit(1);
}
if (geteuid())
errx(1, ""not installed setuid"");
parseconfig(VAR_32, 1);
(void)strlcpy(VAR_8, VAR_1[0], sizeof(VAR_8));
for (VAR_19 = 1; VAR_19 < VAR_0; VAR_19++) {
if (strlcat(VAR_8, "" "", sizeof(VAR_8)) >= sizeof(VAR_8))
break;
if (strlcat(VAR_8, VAR_1[VAR_19], sizeof(VAR_8)) >= sizeof(VAR_8))
break;
}
VAR_7 = VAR_1[0];
if (!permit(VAR_14, VAR_16, VAR_18, &rule, VAR_15, VAR_7,
(const char **)VAR_1 + 1)) {
syslog(VAR_33 | VAR_34,
""command not permitted for %s: %s"", VAR_12->pw_name, VAR_8);
errc(1, VAR_35, NULL);
}
#if defined(VAR_36)
if (!(rule->options & VAR_37)) {
if (VAR_23)
errx(1, ""Authorization required"");
shadowauth(VAR_12->pw_name, rule->options & VAR_38);
}
#elif !defined(VAR_39)
(void) VAR_23;
if (!(rule->options & VAR_37))
errx(1, ""Authorization required"");
#endif
if ((VAR_6 = getenv(""PATH"")) != NULL)
VAR_40 = strdup(VAR_6);
if (VAR_40 == NULL)
VAR_40 = """";
if (rule->cmd) {
if (setenv(""PATH"", VAR_2, 1) == -1)
err(1, ""failed to set PATH '%s'"", VAR_2);
}
VAR_21 = mygetpwuid_r(VAR_15, &VAR_11, &VAR_13);
if (VAR_21 != 0)
err(1, ""getpwuid_r failed"");
if (VAR_13 == NULL)
errx(1, ""no passwd entry for target"");
#if defined(VAR_39)
pamauth(VAR_13->pw_name, VAR_12->pw_name, !VAR_23, rule->options & VAR_37,
rule->options & VAR_38);
#endif
#ifdef VAR_41
if (setusercontext(NULL, VAR_13, VAR_15, VAR_42 |
VAR_43 | VAR_44 | VAR_45 |
VAR_46) != 0)
errx(1, ""failed to set user context for target"");
#else
if (setresgid(VAR_13->pw_gid, VAR_13->pw_gid, VAR_13->pw_gid) != 0)
err(1, ""setresgid"");
if (initgroups(VAR_13->pw_name, VAR_13->pw_gid) != 0)
err(1, ""initgroups"");
if (setresuid(VAR_15, VAR_15, VAR_15) != 0)
err(1, ""setresuid"");
#endif
if (getcwd(VAR_24, sizeof(VAR_24)) == NULL)
VAR_26 = ""(failed)"";
else
VAR_26 = VAR_24;
if (!(rule->options & VAR_47)) {
syslog(VAR_33 | VAR_48,
""%s ran command %s as %s from %s"",
VAR_12->pw_name, VAR_8, VAR_13->pw_name, VAR_26);
}
VAR_27 = prepenv(rule, VAR_12, VAR_13);
if (rule->cmd) {
if (setenv(""PATH"", VAR_2, 1) == -1)
err(1, ""failed to set PATH '%s'"", VAR_2);
} else {
if (setenv(""PATH"", VAR_40, 1) == -1)
err(1, ""failed to set PATH '%s'"", VAR_40);
}
execvpe(VAR_7, VAR_1, VAR_27);
if (VAR_49 == VAR_50)
errx(1, ""%s: command not found"", VAR_7);
err(1, ""%s"", VAR_7);
}",Duncaen/OpenDoas/d5acd52e2a15c36a8e06f9103d35622933aa422d/doas.c/vul/before/0.json,"int
main(int argc, char **argv)
{
	const char *safepath = ""/bin:/sbin:/usr/bin:/usr/sbin:""
	    ""/usr/local/bin:/usr/local/sbin"";
	const char *confpath = NULL;
	char *shargv[] = { NULL, NULL };
	char *sh;
	const char *p;
	const char *cmd;
	char cmdline[LINE_MAX];
	struct passwd mypwstore, targpwstore;
	struct passwd *mypw, *targpw;
	const struct rule *rule;
	uid_t uid;
	uid_t target = 0;
	gid_t groups[NGROUPS_MAX + 1];
	int ngroups;
	int i, ch, rv;
	int sflag = 0;
	int nflag = 0;
	char cwdpath[PATH_MAX];
	const char *cwd;
	char **envp;

	setprogname(""doas"");

	closefrom(STDERR_FILENO + 1);

	uid = getuid();

	while ((ch = getopt(argc, argv, ""+C:Lnsu:"")) != -1) {
		switch (ch) {
		case 'C':
			confpath = optarg;
			break;
		case 'L':
#if defined(USE_TIMESTAMP)
			exit(timestamp_clear() == -1);
#else
			exit(0);
#endif
		case 'u':
			if (parseuid(optarg, &target) != 0)
				errx(1, ""unknown user"");
			break;
		case 'n':
			nflag = 1;
			break;
		case 's':
			sflag = 1;
			break;
		default:
			usage();
			break;
		}
	}
	argv += optind;
	argc -= optind;

	if (confpath) {
		if (sflag)
			usage();
	} else if ((!sflag && !argc) || (sflag && argc))
		usage();

	rv = mygetpwuid_r(uid, &mypwstore, &mypw);
	if (rv != 0)
		err(1, ""getpwuid_r failed"");
	if (mypw == NULL)
		errx(1, ""no passwd entry for self"");
	ngroups = getgroups(NGROUPS_MAX, groups);
	if (ngroups == -1)
		err(1, ""can't get groups"");
	groups[ngroups++] = getgid();

	if (sflag) {
		sh = getenv(""SHELL"");
		if (sh == NULL || *sh == '\0') {
			shargv[0] = mypw->pw_shell;
		} else
			shargv[0] = sh;
		argv = shargv;
		argc = 1;
	}

	if (confpath) {
		checkconfig(confpath, argc, argv, uid, groups, ngroups,
		    target);
		exit(1);	/* fail safe */
	}

	if (geteuid())
		errx(1, ""not installed setuid"");

	parseconfig(DOAS_CONF, 1);

	/* cmdline is used only for logging, no need to abort on truncate */
	(void)strlcpy(cmdline, argv[0], sizeof(cmdline));
	for (i = 1; i < argc; i++) {
		if (strlcat(cmdline, "" "", sizeof(cmdline)) >= sizeof(cmdline))
			break;
		if (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))
			break;
	}

	cmd = argv[0];
	if (!permit(uid, groups, ngroups, &rule, target, cmd,
	    (const char **)argv + 1)) {
		syslog(LOG_AUTHPRIV | LOG_NOTICE,
		    ""command not permitted for %s: %s"", mypw->pw_name, cmdline);
		errc(1, EPERM, NULL);
	}

#if defined(USE_SHADOW)
	if (!(rule->options & NOPASS)) {
		if (nflag)
			errx(1, ""Authorization required"");

		shadowauth(mypw->pw_name, rule->options & PERSIST);
	}
#elif !defined(USE_PAM)
	/* no authentication provider, only allow NOPASS rules */
	(void) nflag;
	if (!(rule->options & NOPASS))
		errx(1, ""Authorization required"");
#endif

	if ((p = getenv(""PATH"")) != NULL)
		formerpath = strdup(p);
	if (formerpath == NULL)
		formerpath = """";

	if (rule->cmd) {
		if (setenv(""PATH"", safepath, 1) == -1)
			err(1, ""failed to set PATH '%s'"", safepath);
	}

	rv = mygetpwuid_r(target, &targpwstore, &targpw);
	if (rv != 0)
		err(1, ""getpwuid_r failed"");
	if (targpw == NULL)
		errx(1, ""no passwd entry for target"");

#if defined(USE_PAM)
	pamauth(targpw->pw_name, mypw->pw_name, !nflag, rule->options & NOPASS,
	    rule->options & PERSIST);
#endif

#ifdef HAVE_LOGIN_CAP_H
	if (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |
	    LOGIN_SETPATH |
	    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |
	    LOGIN_SETUSER) != 0)
		errx(1, ""failed to set user context for target"");
#else
	if (setresgid(targpw->pw_gid, targpw->pw_gid, targpw->pw_gid) != 0)
		err(1, ""setresgid"");
	if (initgroups(targpw->pw_name, targpw->pw_gid) != 0)
		err(1, ""initgroups"");
	if (setresuid(target, target, target) != 0)
		err(1, ""setresuid"");
	if (setenv(""PATH"", safepath, 1) == -1)
		err(1, ""failed to set PATH '%s'"", safepath);
#endif

	if (getcwd(cwdpath, sizeof(cwdpath)) == NULL)
		cwd = ""(failed)"";
	else
		cwd = cwdpath;

	if (!(rule->options & NOLOG)) {
		syslog(LOG_AUTHPRIV | LOG_INFO,
		    ""%s ran command %s as %s from %s"",
		    mypw->pw_name, cmdline, targpw->pw_name, cwd);
	}

	envp = prepenv(rule, mypw, targpw);

	/* setusercontext set path for the next process, so reset it for us */
	if (rule->cmd) {
		if (setenv(""PATH"", safepath, 1) == -1)
			err(1, ""failed to set PATH '%s'"", safepath);
	} else {
		if (setenv(""PATH"", formerpath, 1) == -1)
			err(1, ""failed to set PATH '%s'"", formerpath);
	}
	execvpe(cmd, argv, envp);
	if (errno == ENOENT)
		errx(1, ""%s: command not found"", cmd);
	err(1, ""%s"", cmd);
}","int
main(int VAR_0, char **VAR_1)
{
	const char *VAR_2 = ""/bin:/sbin:/usr/bin:/usr/sbin:""
	    ""/usr/local/bin:/usr/local/sbin"";
	const char *VAR_3 = NULL;
	char *VAR_4[] = { NULL, NULL };
	char *VAR_5;
	const char *VAR_6;
	const char *VAR_7;
	char VAR_8[VAR_9];
	struct passwd VAR_10, VAR_11;
	struct passwd *VAR_12, *VAR_13;
	const struct rule *rule;
	uid_t VAR_14;
	uid_t VAR_15 = 0;
	gid_t VAR_16[VAR_17 + 1];
	int VAR_18;
	int VAR_19, VAR_20, VAR_21;
	int VAR_22 = 0;
	int VAR_23 = 0;
	char VAR_24[VAR_25];
	const char *VAR_26;
	char **VAR_27;

	setprogname(""doas"");

	closefrom(VAR_28 + 1);

	VAR_14 = getuid();

	while ((VAR_20 = getopt(VAR_0, VAR_1, ""+C:Lnsu:"")) != -1) {
		switch (VAR_20) {
		case 'C':
			VAR_3 = VAR_29;
			break;
		case 'L':
#if defined(VAR_30)
			exit(timestamp_clear() == -1);
#else
			exit(0);
#endif
		case 'u':
			if (parseuid(VAR_29, &VAR_15) != 0)
				errx(1, ""unknown user"");
			break;
		case 'n':
			VAR_23 = 1;
			break;
		case 's':
			VAR_22 = 1;
			break;
		default:
			usage();
			break;
		}
	}
	VAR_1 += VAR_31;
	VAR_0 -= VAR_31;

	if (VAR_3) {
		if (VAR_22)
			usage();
	} else if ((!VAR_22 && !VAR_0) || (VAR_22 && VAR_0))
		usage();

	VAR_21 = mygetpwuid_r(VAR_14, &VAR_10, &VAR_12);
	if (VAR_21 != 0)
		err(1, ""getpwuid_r failed"");
	if (VAR_12 == NULL)
		errx(1, ""no passwd entry for self"");
	VAR_18 = getgroups(VAR_17, VAR_16);
	if (VAR_18 == -1)
		err(1, ""can't get groups"");
	VAR_16[VAR_18++] = getgid();

	if (VAR_22) {
		VAR_5 = getenv(""SHELL"");
		if (VAR_5 == NULL || *VAR_5 == '\0') {
			VAR_4[0] = VAR_12->pw_shell;
		} else
			VAR_4[0] = VAR_5;
		VAR_1 = VAR_4;
		VAR_0 = 1;
	}

	if (VAR_3) {
		checkconfig(VAR_3, VAR_0, VAR_1, VAR_14, VAR_16, VAR_18,
		    VAR_15);
		exit(1);	/* COMMENT_0 */
	}

	if (geteuid())
		errx(1, ""not installed setuid"");

	parseconfig(VAR_32, 1);

	/* COMMENT_1 */
	(void)strlcpy(VAR_8, VAR_1[0], sizeof(VAR_8));
	for (VAR_19 = 1; VAR_19 < VAR_0; VAR_19++) {
		if (strlcat(VAR_8, "" "", sizeof(VAR_8)) >= sizeof(VAR_8))
			break;
		if (strlcat(VAR_8, VAR_1[VAR_19], sizeof(VAR_8)) >= sizeof(VAR_8))
			break;
	}

	VAR_7 = VAR_1[0];
	if (!permit(VAR_14, VAR_16, VAR_18, &rule, VAR_15, VAR_7,
	    (const char **)VAR_1 + 1)) {
		syslog(VAR_33 | VAR_34,
		    ""command not permitted for %s: %s"", VAR_12->pw_name, VAR_8);
		errc(1, VAR_35, NULL);
	}

#if defined(VAR_36)
	if (!(rule->options & VAR_37)) {
		if (VAR_23)
			errx(1, ""Authorization required"");

		shadowauth(VAR_12->pw_name, rule->options & VAR_38);
	}
#elif !defined(VAR_39)
	/* COMMENT_2 */
	(void) VAR_23;
	if (!(rule->options & VAR_37))
		errx(1, ""Authorization required"");
#endif

	if ((VAR_6 = getenv(""PATH"")) != NULL)
		VAR_40 = strdup(VAR_6);
	if (VAR_40 == NULL)
		VAR_40 = """";

	if (rule->cmd) {
		if (setenv(""PATH"", VAR_2, 1) == -1)
			err(1, ""failed to set PATH '%s'"", VAR_2);
	}

	VAR_21 = mygetpwuid_r(VAR_15, &VAR_11, &VAR_13);
	if (VAR_21 != 0)
		err(1, ""getpwuid_r failed"");
	if (VAR_13 == NULL)
		errx(1, ""no passwd entry for target"");

#if defined(VAR_39)
	pamauth(VAR_13->pw_name, VAR_12->pw_name, !VAR_23, rule->options & VAR_37,
	    rule->options & VAR_38);
#endif

#ifdef VAR_41
	if (setusercontext(NULL, VAR_13, VAR_15, VAR_42 |
	    VAR_43 |
	    VAR_44 | VAR_45 | VAR_46 |
	    VAR_47) != 0)
		errx(1, ""failed to set user context for target"");
#else
	if (setresgid(VAR_13->pw_gid, VAR_13->pw_gid, VAR_13->pw_gid) != 0)
		err(1, ""setresgid"");
	if (initgroups(VAR_13->pw_name, VAR_13->pw_gid) != 0)
		err(1, ""initgroups"");
	if (setresuid(VAR_15, VAR_15, VAR_15) != 0)
		err(1, ""setresuid"");
	if (setenv(""PATH"", VAR_2, 1) == -1)
		err(1, ""failed to set PATH '%s'"", VAR_2);
#endif

	if (getcwd(VAR_24, sizeof(VAR_24)) == NULL)
		VAR_26 = ""(failed)"";
	else
		VAR_26 = VAR_24;

	if (!(rule->options & VAR_48)) {
		syslog(VAR_33 | VAR_49,
		    ""%s ran command %s as %s from %s"",
		    VAR_12->pw_name, VAR_8, VAR_13->pw_name, VAR_26);
	}

	VAR_27 = prepenv(rule, VAR_12, VAR_13);

	/* COMMENT_3 */
	if (rule->cmd) {
		if (setenv(""PATH"", VAR_2, 1) == -1)
			err(1, ""failed to set PATH '%s'"", VAR_2);
	} else {
		if (setenv(""PATH"", VAR_40, 1) == -1)
			err(1, ""failed to set PATH '%s'"", VAR_40);
	}
	execvpe(VAR_7, VAR_1, VAR_27);
	if (VAR_50 == VAR_51)
		errx(1, ""%s: command not found"", VAR_7);
	err(1, ""%s"", VAR_7);
}",Duncaen/OpenDoas/d5acd52e2a15c36a8e06f9103d35622933aa422d/doas.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -149,6 +149,7 @@
 
 #ifdef HAVE_LOGIN_CAP_H
 	if (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |
+	    LOGIN_SETPATH |
 	    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |
 	    LOGIN_SETUSER) != 0)
 		errx(1, ""failed to set user context for target"");
@@ -159,6 +160,8 @@
 		err(1, ""initgroups"");
 	if (setresuid(target, target, target) != 0)
 		err(1, ""setresuid"");
+	if (setenv(""PATH"", safepath, 1) == -1)
+		err(1, ""failed to set PATH '%s'"", safepath);
 #endif
 
 	if (getcwd(cwdpath, sizeof(cwdpath)) == NULL)","{'deleted_lines': [], 'added_lines': ['\t    LOGIN_SETPATH |', '\tif (setenv(""PATH"", safepath, 1) == -1)', '\t\terr(1, ""failed to set PATH \'%s\'"", safepath);']}",True,In OpenDoas from 6.6 to 6.8 the users PATH variable was incorrectly inherited by authenticated executions if the authenticating rule allowed the user to execute any command. Rules that only allowed to authenticated user to execute specific commands were not affected by this issue.,8.8,HIGH,2,test,2021-01-28T16:58:34Z,3
CVE-2021-27229,['CWE-59'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,mumble-voip/mumble,"FIX(client): Only allow ""http""/""https"" for URLs in ConnectDialog

Our public server list registration script doesn't have an URL scheme
whitelist for the website field.

Turns out a malicious server can register itself with a dangerous URL in
an attempt to attack a user's machine.

User interaction is required, as the URL has to be opened by
right-clicking on the server entry and clicking on ""Open Webpage"".

This commit introduces a client-side whitelist, which only allows ""http""
and ""https"" schemes. We will also implement it in our public list.

In future we should probably add a warning QMessageBox informing the
user that there's no guarantee the URL is safe (regardless of the
scheme).

Thanks a lot to https://positive.security for reporting the RCE
vulnerability to us privately.",e59ee87abe249f345908c7d568f6879d16bfd648,https://github.com/mumble-voip/mumble/commit/e59ee87abe249f345908c7d568f6879d16bfd648,src/mumble/ConnectDialog.cpp,ConnectDialog::on_qaUrl_triggered,"void ConnectDialog::on_qaUrl_triggered() {
ServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());
if (! si || si->qsUrl.isEmpty())
return;
QDesktopServices::openUrl(QUrl(si->qsUrl));
}","void ConnectDialog::on_qaUrl_triggered() {
ServerItem *VAR_0 = VAR_1<ServerItem *>(VAR_2->currentItem());
if (! VAR_0 || VAR_0->qsUrl.isEmpty())
return;
QDesktopServices::openUrl(QUrl(VAR_0->qsUrl));
}",mumble-voip/mumble/e59ee87abe249f345908c7d568f6879d16bfd648/ConnectDialog.cpp/vul/before/0.json,"void ConnectDialog::on_qaUrl_triggered() {
	auto *si = static_cast< const ServerItem * >(qtwServers->currentItem());
	if (!si || si->qsUrl.isEmpty()) {
		return;
	}

	const QStringList allowedSchemes = { QLatin1String(""http""), QLatin1String(""https"") };

	const auto url = QUrl(si->qsUrl);
	if (allowedSchemes.contains(url.scheme())) {
		QDesktopServices::openUrl(url);
	} else {
		// Inform user that the requested URL has been blocked
		QMessageBox msgBox;
		msgBox.setText(QObject::tr(""<b>Blocked URL scheme \""%1\""</b>"").arg(url.scheme()));
		msgBox.setInformativeText(QObject::tr(""The URL uses a scheme that has been blocked for security reasons.""));
		msgBox.setDetailedText(QObject::tr(""Blocked URL: \""%1\"""").arg(url.toString()));
		msgBox.setIcon(QMessageBox::Warning);
		msgBox.exec();
	}
}","void ConnectDialog::on_qaUrl_triggered() {
	auto *VAR_0 = VAR_1< const ServerItem * >(VAR_2->currentItem());
	if (!VAR_0 || VAR_0->qsUrl.isEmpty()) {
		return;
	}

	const QStringList VAR_3 = { QLatin1String(""http""), QLatin1String(""https"") };

	const auto VAR_4 = QUrl(VAR_0->qsUrl);
	if (VAR_3.contains(VAR_4.scheme())) {
		QDesktopServices::openUrl(VAR_4);
	} else {
		/* COMMENT_0 */
		QMessageBox VAR_5;
		VAR_5.setText(QObject::tr(""<b>Blocked URL scheme \""%1\""</b>"").arg(VAR_4.scheme()));
		VAR_5.setInformativeText(QObject::tr(""The URL uses a scheme that has been blocked for security reasons.""));
		VAR_5.setDetailedText(QObject::tr(""Blocked URL: \""%1\"""").arg(VAR_4.toString()));
		VAR_5.setIcon(QMessageBox::Warning);
		VAR_5.exec();
	}
}",mumble-voip/mumble/e59ee87abe249f345908c7d568f6879d16bfd648/ConnectDialog.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,21 @@
 void ConnectDialog::on_qaUrl_triggered() {
-	ServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());
-	if (! si || si->qsUrl.isEmpty())
+	auto *si = static_cast< const ServerItem * >(qtwServers->currentItem());
+	if (!si || si->qsUrl.isEmpty()) {
 		return;
+	}
 
-	QDesktopServices::openUrl(QUrl(si->qsUrl));
+	const QStringList allowedSchemes = { QLatin1String(""http""), QLatin1String(""https"") };
+
+	const auto url = QUrl(si->qsUrl);
+	if (allowedSchemes.contains(url.scheme())) {
+		QDesktopServices::openUrl(url);
+	} else {
+		// Inform user that the requested URL has been blocked
+		QMessageBox msgBox;
+		msgBox.setText(QObject::tr(""<b>Blocked URL scheme \""%1\""</b>"").arg(url.scheme()));
+		msgBox.setInformativeText(QObject::tr(""The URL uses a scheme that has been blocked for security reasons.""));
+		msgBox.setDetailedText(QObject::tr(""Blocked URL: \""%1\"""").arg(url.toString()));
+		msgBox.setIcon(QMessageBox::Warning);
+		msgBox.exec();
+	}
 }","{'deleted_lines': ['\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());', '\tif (! si || si->qsUrl.isEmpty())', '\tQDesktopServices::openUrl(QUrl(si->qsUrl));'], 'added_lines': ['\tauto *si = static_cast< const ServerItem * >(qtwServers->currentItem());', '\tif (!si || si->qsUrl.isEmpty()) {', '\t}', '\tconst QStringList allowedSchemes = { QLatin1String(""http""), QLatin1String(""https"") };', '', '\tconst auto url = QUrl(si->qsUrl);', '\tif (allowedSchemes.contains(url.scheme())) {', '\t\tQDesktopServices::openUrl(url);', '\t} else {', '\t\t// Inform user that the requested URL has been blocked', '\t\tQMessageBox msgBox;', '\t\tmsgBox.setText(QObject::tr(""<b>Blocked URL scheme \\""%1\\""</b>"").arg(url.scheme()));', '\t\tmsgBox.setInformativeText(QObject::tr(""The URL uses a scheme that has been blocked for security reasons.""));', '\t\tmsgBox.setDetailedText(QObject::tr(""Blocked URL: \\""%1\\"""").arg(url.toString()));', '\t\tmsgBox.setIcon(QMessageBox::Warning);', '\t\tmsgBox.exec();', '\t}']}",True,Mumble before 1.3.4 allows remote code execution if a victim navigates to a crafted URL on a server list and clicks on the Open Webpage text.,8.8,HIGH,2,test,2021-02-05T19:01:04Z,3
CVE-2021-45944,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ArtifexSoftware/ghostpdl,"oss-fuzz 30715: Check stack limits after function evaluation.

During function result sampling, after the callout to the Postscript
interpreter, make sure there is enough stack space available before pushing
or popping entries.

In thise case, the Postscript procedure for the ""function"" is totally invalid
(as a function), and leaves the op stack in an unrecoverable state (as far as
function evaluation is concerned). We end up popping more entries off the
stack than are available.

To cope, add in stack limit checking to throw an appropriate error when this
happens.",7861fcad13c497728189feafb41cd57b5b50ea25,https://github.com/ArtifexSoftware/ghostpdl/commit/7861fcad13c497728189feafb41cd57b5b50ea25,psi/zfsample.c,sampled_data_continue,"static int
sampled_data_continue(i_ctx_t *i_ctx_p)
{
os_ptr op = osp;
gs_sampled_data_enum *penum = senum;
gs_function_Sd_params_t * params =
(gs_function_Sd_params_t *)&penum->pfn->params;
int i, j, num_out = params->n;
int code = 0;
byte * data_ptr;
double sampled_data_value_max = (double)((1 << params->BitsPerSample) - 1);
int bps = bits2bytes(params->BitsPerSample), stack_depth_adjust = 0;
if (num_out + O_STACK_PAD + penum->o_stack_depth != ref_stack_count(&o_stack)) {
stack_depth_adjust = ref_stack_count(&o_stack) - penum->o_stack_depth;
if (stack_depth_adjust < 0) {
push(-stack_depth_adjust);
ifree_object(penum->pfn, ""sampled_data_continue(pfn)"");
ifree_object(penum, ""sampled_data_continue((enum)"");
return_error(gs_error_undefinedresult);
}
}
data_ptr = cube_ptr_from_index(params, penum->indexes);
for (i=0; i < num_out; i++) {
ulong cv;
double value;
double rmin = params->Range[2 * i];
double rmax = params->Range[2 * i + 1];
code = real_param(op + i - num_out + 1, &value);
if (code < 0) {
esp -= estack_storage;
return code;
}
if (value < rmin)
value = rmin;
else if (value > rmax)
value = rmax;
value = (value - rmin) / (rmax - rmin);
cv = (int) (value * sampled_data_value_max + 0.5);
for (j = 0; j < bps; j++)
data_ptr[bps * i + j] = (byte)(cv >> ((bps - 1 - j) * 8));
}
pop(num_out);    
if (increment_cube_indexes(params, penum->indexes)) {
if (stack_depth_adjust == 0)
pop(O_STACK_PAD);    
else
pop(stack_depth_adjust - num_out);
code = 0;
if (esp_finish_proc != 0)
code = esp_finish_proc(i_ctx_p);
return code;
} else {
if (stack_depth_adjust) {
stack_depth_adjust -= num_out;
push(O_STACK_PAD - stack_depth_adjust);
for (i=0;i<O_STACK_PAD - stack_depth_adjust;i++)
make_null(op - i);
}
}
return sampled_data_sample(i_ctx_p);
}","static int
sampled_data_continue(i_ctx_t *VAR_0)
{
os_ptr VAR_1 = VAR_2;
gs_sampled_data_enum *VAR_3 = VAR_4;
gs_function_Sd_params_t * VAR_5 =
(gs_function_Sd_params_t *)&VAR_3->pfn->params;
int VAR_6, VAR_7, VAR_8 = VAR_5->n;
int VAR_9 = 0;
byte * VAR_10;
double VAR_11 = (double)((1 << VAR_5->BitsPerSample) - 1);
int VAR_12 = bits2bytes(VAR_5->BitsPerSample), VAR_13 = 0;
if (VAR_8 + VAR_14 + VAR_3->o_stack_depth != ref_stack_count(&VAR_15)) {
VAR_13 = ref_stack_count(&VAR_15) - VAR_3->o_stack_depth;
if (VAR_13 < 0) {
push(-VAR_13);
ifree_object(VAR_3->pfn, ""sampled_data_continue(pfn)"");
ifree_object(VAR_3, ""sampled_data_continue((enum)"");
return_error(VAR_16);
}
}
VAR_10 = cube_ptr_from_index(VAR_5, VAR_3->indexes);
for (VAR_6=0; VAR_6 < VAR_8; VAR_6++) {
ulong VAR_17;
double VAR_18;
double VAR_19 = VAR_5->Range[2 * VAR_6];
double VAR_20 = VAR_5->Range[2 * VAR_6 + 1];
VAR_9 = real_param(VAR_1 + VAR_6 - VAR_8 + 1, &VAR_18);
if (VAR_9 < 0) {
VAR_21 -= VAR_22;
return VAR_9;
}
if (VAR_18 < VAR_19)
VAR_18 = VAR_19;
else if (VAR_18 > VAR_20)
VAR_18 = VAR_20;
VAR_18 = (VAR_18 - VAR_19) / (VAR_20 - VAR_19);
VAR_17 = (int) (VAR_18 * VAR_11 + 0.5);
for (VAR_7 = 0; VAR_7 < VAR_12; VAR_7++)
VAR_10[VAR_12 * VAR_6 + VAR_7] = (byte)(VAR_17 >> ((VAR_12 - 1 - VAR_7) * 8));
}
pop(VAR_8);    
if (increment_cube_indexes(VAR_5, VAR_3->indexes)) {
if (VAR_13 == 0)
pop(VAR_14);    
else
pop(VAR_13 - VAR_8);
VAR_9 = 0;
if (VAR_23 != 0)
VAR_9 = VAR_23(VAR_0);
return VAR_9;
} else {
if (VAR_13) {
VAR_13 -= VAR_8;
push(VAR_14 - VAR_13);
for (VAR_6=0;VAR_6<VAR_14 - VAR_13;VAR_6++)
make_null(VAR_1 - VAR_6);
}
}
return sampled_data_sample(VAR_0);
}",ArtifexSoftware/ghostpdl/7861fcad13c497728189feafb41cd57b5b50ea25/zfsample.c/vul/before/0.json,"static int
sampled_data_continue(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    gs_sampled_data_enum *penum = senum;
    gs_function_Sd_params_t * params =
            (gs_function_Sd_params_t *)&penum->pfn->params;
    int i, j, num_out = params->n;
    int code = 0;
    byte * data_ptr;
    double sampled_data_value_max = (double)((1 << params->BitsPerSample) - 1);
    int bps = bits2bytes(params->BitsPerSample), stack_depth_adjust = 0;

    /*
     * Check to make sure that the procedure produced the correct number of
     * values.  If not, move the stack back to where it belongs and abort
     */
    if (num_out + O_STACK_PAD + penum->o_stack_depth != ref_stack_count(&o_stack)) {
        stack_depth_adjust = ref_stack_count(&o_stack) - penum->o_stack_depth;

        if (stack_depth_adjust < 0) {
            /*
             * If we get to here then there were major problems.  The function
             * removed too many items off of the stack.  We had placed extra
             * (unused) stack stack space to allow for this but the function
             * exceeded even that.  Data on the stack may have been lost.
             * The only thing that we can do is move the stack pointer back and
             * hope.  (We have not seen real Postscript files that have this
             * problem.)
             */
            push(-stack_depth_adjust);
            ifree_object(penum->pfn, ""sampled_data_continue(pfn)"");
            ifree_object(penum, ""sampled_data_continue((enum)"");
            return_error(gs_error_undefinedresult);
        }
    }

    /* Save data from the given function */
    data_ptr = cube_ptr_from_index(params, penum->indexes);
    for (i=0; i < num_out; i++) {
        ulong cv;
        double value;
        double rmin = params->Range[2 * i];
        double rmax = params->Range[2 * i + 1];

        code = real_param(op + i - num_out + 1, &value);
        if (code < 0) {
            esp -= estack_storage;
            return code;
        }
        if (value < rmin)
            value = rmin;
        else if (value > rmax)
            value = rmax;
        value = (value - rmin) / (rmax - rmin);		/* Convert to 0 to 1.0 */
        cv = (int) (value * sampled_data_value_max + 0.5);
        for (j = 0; j < bps; j++)
            data_ptr[bps * i + j] = (byte)(cv >> ((bps - 1 - j) * 8));	/* MSB first */
    }
    pop(num_out);		    /* Move op to base of result values */

    /* Check if we are done collecting data. */

    if (increment_cube_indexes(params, penum->indexes)) {
        if (stack_depth_adjust == 0)
            pop(O_STACK_PAD);	    /* Remove spare stack space */
        else
            pop(stack_depth_adjust - num_out);
        /* Execute the closing procedure, if given */
        code = 0;
        if (esp_finish_proc != 0)
            code = esp_finish_proc(i_ctx_p);

        return code;
    } else {
        if (stack_depth_adjust) {
            stack_depth_adjust -= num_out;
            if ((O_STACK_PAD - stack_depth_adjust) < 0) {
                stack_depth_adjust = -(O_STACK_PAD - stack_depth_adjust);
                check_op(stack_depth_adjust);
                pop(stack_depth_adjust);
            }
            else {
                check_ostack(O_STACK_PAD - stack_depth_adjust);
                push(O_STACK_PAD - stack_depth_adjust);
                for (i=0;i<O_STACK_PAD - stack_depth_adjust;i++)
                    make_null(op - i);
            }
        }
    }

    /* Now get the data for the next location */

    return sampled_data_sample(i_ctx_p);
}","static int
sampled_data_continue(i_ctx_t *VAR_0)
{
    os_ptr VAR_1 = VAR_2;
    gs_sampled_data_enum *VAR_3 = VAR_4;
    gs_function_Sd_params_t * VAR_5 =
            (gs_function_Sd_params_t *)&VAR_3->pfn->params;
    int VAR_6, VAR_7, VAR_8 = VAR_5->n;
    int VAR_9 = 0;
    byte * VAR_10;
    double VAR_11 = (double)((1 << VAR_5->BitsPerSample) - 1);
    int VAR_12 = bits2bytes(VAR_5->BitsPerSample), VAR_13 = 0;

    /* COMMENT_0 */
                                                                           
                                                                         
       
    if (VAR_8 + VAR_14 + VAR_3->o_stack_depth != ref_stack_count(&VAR_15)) {
        VAR_13 = ref_stack_count(&VAR_15) - VAR_3->o_stack_depth;

        if (VAR_13 < 0) {
            /* COMMENT_4 */
                                                                              
                                                                            
                                                                            
                                                                         
                                                                               
                                                                            
                        
               
            push(-VAR_13);
            ifree_object(VAR_3->pfn, ""sampled_data_continue(pfn)"");
            ifree_object(VAR_3, ""sampled_data_continue((enum)"");
            return_error(VAR_16);
        }
    }

    /* COMMENT_13 */
    VAR_10 = cube_ptr_from_index(VAR_5, VAR_3->indexes);
    for (VAR_6=0; VAR_6 < VAR_8; VAR_6++) {
        ulong VAR_17;
        double VAR_18;
        double VAR_19 = VAR_5->Range[2 * VAR_6];
        double VAR_20 = VAR_5->Range[2 * VAR_6 + 1];

        VAR_9 = real_param(VAR_1 + VAR_6 - VAR_8 + 1, &VAR_18);
        if (VAR_9 < 0) {
            VAR_21 -= VAR_22;
            return VAR_9;
        }
        if (VAR_18 < VAR_19)
            VAR_18 = VAR_19;
        else if (VAR_18 > VAR_20)
            VAR_18 = VAR_20;
        VAR_18 = (VAR_18 - VAR_19) / (VAR_20 - VAR_19);		/* COMMENT_14 */
        VAR_17 = (int) (VAR_18 * VAR_11 + 0.5);
        for (VAR_7 = 0; VAR_7 < VAR_12; VAR_7++)
            VAR_10[VAR_12 * VAR_6 + VAR_7] = (byte)(VAR_17 >> ((VAR_12 - 1 - VAR_7) * 8));	/* COMMENT_15 */
    }
    pop(VAR_8);		    /* COMMENT_16 */

    /* COMMENT_17 */

    if (increment_cube_indexes(VAR_5, VAR_3->indexes)) {
        if (VAR_13 == 0)
            pop(VAR_14);	    /* COMMENT_18 */
        else
            pop(VAR_13 - VAR_8);
        /* COMMENT_19 */
        VAR_9 = 0;
        if (VAR_23 != 0)
            VAR_9 = VAR_23(VAR_0);

        return VAR_9;
    } else {
        if (VAR_13) {
            VAR_13 -= VAR_8;
            if ((VAR_14 - VAR_13) < 0) {
                VAR_13 = -(VAR_14 - VAR_13);
                check_op(VAR_13);
                pop(VAR_13);
            }
            else {
                check_ostack(VAR_14 - VAR_13);
                push(VAR_14 - VAR_13);
                for (VAR_6=0;VAR_6<VAR_14 - VAR_13;VAR_6++)
                    make_null(VAR_1 - VAR_6);
            }
        }
    }

    /* COMMENT_20 */

    return sampled_data_sample(VAR_0);
}",ArtifexSoftware/ghostpdl/7861fcad13c497728189feafb41cd57b5b50ea25/zfsample.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -75,9 +75,17 @@
     } else {
         if (stack_depth_adjust) {
             stack_depth_adjust -= num_out;
-            push(O_STACK_PAD - stack_depth_adjust);
-            for (i=0;i<O_STACK_PAD - stack_depth_adjust;i++)
-                make_null(op - i);
+            if ((O_STACK_PAD - stack_depth_adjust) < 0) {
+                stack_depth_adjust = -(O_STACK_PAD - stack_depth_adjust);
+                check_op(stack_depth_adjust);
+                pop(stack_depth_adjust);
+            }
+            else {
+                check_ostack(O_STACK_PAD - stack_depth_adjust);
+                push(O_STACK_PAD - stack_depth_adjust);
+                for (i=0;i<O_STACK_PAD - stack_depth_adjust;i++)
+                    make_null(op - i);
+            }
         }
     }
 ","{'deleted_lines': ['            push(O_STACK_PAD - stack_depth_adjust);', '            for (i=0;i<O_STACK_PAD - stack_depth_adjust;i++)', '                make_null(op - i);'], 'added_lines': ['            if ((O_STACK_PAD - stack_depth_adjust) < 0) {', '                stack_depth_adjust = -(O_STACK_PAD - stack_depth_adjust);', '                check_op(stack_depth_adjust);', '                pop(stack_depth_adjust);', '            }', '            else {', '                check_ostack(O_STACK_PAD - stack_depth_adjust);', '                push(O_STACK_PAD - stack_depth_adjust);', '                for (i=0;i<O_STACK_PAD - stack_depth_adjust;i++)', '                    make_null(op - i);', '            }']}",True,Ghostscript GhostPDL 9.50 through 9.53.3 has a use-after-free in sampled_data_sample (called from sampled_data_continue and interp).,5.5,MEDIUM,1,test,2021-02-12T10:34:23Z,3
CVE-2021-46879,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,fluent/fluent-bit,"flb_pack: fix OSS-Fuzz issue 5076752961110016

Signed-off-by: davkor <david@adalogics.com>",75f0e0e5f7267682674029820524d22460f498b0,https://github.com/fluent/fluent-bit/commit/75f0e0e5f7267682674029820524d22460f498b0,src/flb_pack_gelf.c,flb_msgpack_to_gelf,"flb_sds_t flb_msgpack_to_gelf(flb_sds_t *s, msgpack_object *o,
struct flb_time *tm,
struct flb_gelf_fields *fields)
{
int i;
int loop;
flb_sds_t tmp;
int host_key_found = FLB_FALSE;
int timestamp_key_found = FLB_FALSE;
int level_key_found = FLB_FALSE;
int short_message_key_found = FLB_FALSE;
int full_message_key_found = FLB_FALSE;
char *host_key = NULL;
char *timestamp_key = NULL;
char *level_key = NULL;
char *short_message_key = NULL;
char *full_message_key = NULL;
int host_key_len = 0;
int timestamp_key_len = false;
int level_key_len = 0;
int short_message_key_len = 0;
int full_message_key_len = 0;
if (s == NULL || o == NULL) {
return NULL;
}
if (o->type != MSGPACK_OBJECT_MAP) {
return NULL;
}
if (fields != NULL && fields->host_key != NULL) {
host_key = fields->host_key;
host_key_len = flb_sds_len(fields->host_key);
}
else {
host_key = ""host"";
host_key_len = 4;
}
if (fields != NULL && fields->timestamp_key != NULL) {
timestamp_key = fields->timestamp_key;
timestamp_key_len = flb_sds_len(fields->timestamp_key);
}
else {
timestamp_key = ""timestamp"";
timestamp_key_len = 9;
}
if (fields != NULL && fields->level_key != NULL) {
level_key = fields->level_key;
level_key_len = flb_sds_len(fields->level_key);
}
else {
level_key = ""level"";
level_key_len = 5;
}
if (fields != NULL && fields->short_message_key != NULL) {
short_message_key = fields->short_message_key;
short_message_key_len = flb_sds_len(fields->short_message_key);
}
else {
short_message_key = ""short_message"";
short_message_key_len = 13;
}
if (fields != NULL && fields->full_message_key != NULL) {
full_message_key = fields->full_message_key;
full_message_key_len = flb_sds_len(fields->full_message_key);
}
else {
full_message_key = ""full_message"";
full_message_key_len = 12;
}
tmp = flb_sds_cat(*s, ""{\""version\"":\""1.1\"""", 16);
if (tmp == NULL) {
return NULL;
}
*s = tmp;
loop = o->via.map.size;
if (loop != 0) {
msgpack_object_kv *p = o->via.map.ptr;
for (i = 0; i < loop; i++) {
const char *key = NULL;
int key_len;
const char *val = NULL;
int val_len = 0;
int quote = FLB_FALSE;
int custom_key = FLB_FALSE;
msgpack_object *k = &p[i].key;
msgpack_object *v = &p[i].val;
msgpack_object vtmp; 
if (k->type != MSGPACK_OBJECT_BIN && k->type != MSGPACK_OBJECT_STR) {
continue;
}
if (k->type == MSGPACK_OBJECT_STR) {
key = k->via.str.ptr;
key_len = k->via.str.size;
}
else {
key = k->via.bin.ptr;
key_len = k->via.bin.size;
}
if ((key_len == host_key_len) &&
!strncmp(key, host_key, host_key_len)) {
if (host_key_found == FLB_TRUE) {
continue;
}
host_key_found = FLB_TRUE;
key = ""host"";
key_len = 4;
}
else if ((key_len == short_message_key_len) &&
!strncmp(key, short_message_key, short_message_key_len)) {
if (short_message_key_found == FLB_TRUE) {
continue;
}
short_message_key_found = FLB_TRUE;
key = ""short_message"";
key_len = 13;
}
else if ((key_len == timestamp_key_len) &&
!strncmp(key, timestamp_key, timestamp_key_len)) {
if (timestamp_key_found == FLB_TRUE) {
continue;
}
timestamp_key_found = FLB_TRUE;
key = ""timestamp"";
key_len = 9;
}
else if ((key_len == level_key_len) &&
!strncmp(key, level_key, level_key_len )) {
if (level_key_found == FLB_TRUE) {
continue;
}
level_key_found = FLB_TRUE;
key = ""level"";
key_len = 5;
if (v->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {
if ( v->via.u64 > 7 ) {
flb_warn(""[flb_msgpack_to_gelf] level is %"" PRIu64 "", ""
""but should be in 0..7 or a syslog keyword"", v->via.u64);
}
}
else if (v->type == MSGPACK_OBJECT_STR) {
val     = v->via.str.ptr;
val_len = v->via.str.size;
if (val_len == 1 && val[0] >= '0' && val[0] <= '7') {
v = &vtmp;
v->type = MSGPACK_OBJECT_POSITIVE_INTEGER;
v->via.u64 = (uint64_t)(val[0] - '0');
}
else {
int n;
char* allowed_levels[] = {
""emerg"", ""alert"", ""crit"", ""err"",
""warning"", ""notice"", ""info"", ""debug"",
NULL
};
for (n = 0; allowed_levels[n] != NULL; ++n) {
if (val_len == strlen(allowed_levels[n]) &&
!strncasecmp(val, allowed_levels[n], val_len)) {
v = &vtmp;
v->type = MSGPACK_OBJECT_POSITIVE_INTEGER;
v->via.u64 = (uint64_t)n;
break;
}
}
if (allowed_levels[n] == NULL) {
flb_warn(""[flb_msgpack_to_gelf] level is '%.*s', ""
""but should be in 0..7 or a syslog keyword"", val_len, val);
}
}
}
else {
flb_error(""[flb_msgpack_to_gelf] level must be a non-negative integer or a string"");
return NULL;
}
}
else if ((key_len == full_message_key_len) &&
!strncmp(key, full_message_key, full_message_key_len)) {
if (full_message_key_found == FLB_TRUE) {
continue;
}
full_message_key_found = FLB_TRUE;
key = ""full_message"";
key_len = 12;
}
else if ((key_len == 2)  && !strncmp(key, ""id"", 2)) {
continue;
}
else {
custom_key = FLB_TRUE;
}
if (v->type == MSGPACK_OBJECT_MAP) {
char *prefix = NULL;
int prefix_len = 0;
prefix_len = key_len + 1;
prefix = flb_calloc(1, prefix_len + 1);
if (prefix == NULL) {
return NULL;
}
prefix[0] = '_';
strncpy(prefix + 1, key, key_len);
prefix[prefix_len] = '\0';
tmp = flb_msgpack_gelf_flatten(s, v,
prefix, prefix_len, FLB_FALSE);
if (tmp == NULL) {
flb_free(prefix);
return NULL;
}
*s = tmp;
flb_free(prefix);
}
else if (v->type == MSGPACK_OBJECT_ARRAY) {
if (custom_key == FLB_TRUE) {
tmp = flb_msgpack_gelf_key(s, FLB_FALSE, ""_"", 1, FLB_FALSE,
key, key_len);
}
else {
tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE,
key, key_len);
}
if (tmp == NULL) {
return NULL;
}
*s = tmp;
tmp = flb_msgpack_gelf_flatten(s, v, NULL, 0, FLB_FALSE);
if (tmp == NULL) {
return NULL;
}
*s = tmp;
}
else {
char temp[48] = {0};
if (v->type == MSGPACK_OBJECT_NIL) {
val = ""null"";
val_len = 4;
continue;
}
else if (v->type == MSGPACK_OBJECT_BOOLEAN) {
quote   = FLB_TRUE;
val = v->via.boolean ? ""true"" : ""false"";
val_len = v->via.boolean ? 4 : 5;
}
else if (v->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {
val = temp;
val_len = snprintf(temp, sizeof(temp) - 1,
""%"" PRIu64, v->via.u64);
if (val_len > sizeof(temp)) {
return NULL;
}
}
else if (v->type == MSGPACK_OBJECT_NEGATIVE_INTEGER) {
val = temp;
val_len = snprintf(temp, sizeof(temp) - 1,
""%"" PRId64, v->via.i64);
if (val_len > sizeof(temp)) {
return NULL;
}
}
else if (v->type == MSGPACK_OBJECT_FLOAT) {
val = temp;
val_len = snprintf(temp, sizeof(temp) - 1,
""%f"", v->via.f64);
if (val_len > sizeof(temp)) {
return NULL;
}
}
else if (v->type == MSGPACK_OBJECT_STR) {
quote   = FLB_TRUE;
val     = v->via.str.ptr;
val_len = v->via.str.size;
}
else if (v->type == MSGPACK_OBJECT_BIN) {
quote   = FLB_TRUE;
val     = v->via.bin.ptr;
val_len = v->via.bin.size;
}
else if (v->type == MSGPACK_OBJECT_EXT) {
quote   = FLB_TRUE;
val     = o->via.ext.ptr;
val_len = o->via.ext.size;
}
if (!val || !key) {
continue;
}
if (custom_key == FLB_TRUE) {
tmp = flb_msgpack_gelf_key(s, FLB_FALSE, ""_"", 1, FLB_FALSE,
key, key_len);
}
else {
tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE,
key, key_len);
}
if (tmp == NULL) {
return NULL;
}
*s = tmp;
if (v->type == MSGPACK_OBJECT_EXT) {
tmp = flb_msgpack_gelf_value_ext(s, quote, val, val_len);
}
else {
tmp = flb_msgpack_gelf_value(s, quote, val, val_len);
}
if (tmp == NULL) {
return NULL;
}
*s = tmp;
}
}
}
if (timestamp_key_found == FLB_FALSE && tm != NULL) {
tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE,
""timestamp"", 9);
if (tmp == NULL) {
return NULL;
}
*s = tmp;
tmp = flb_sds_printf(s, ""%"" PRIu32"".%lu"",
tm->tm.tv_sec, tm->tm.tv_nsec / 1000000);
if (tmp == NULL) {
return NULL;
}
*s = tmp;
}
if (short_message_key_found == FLB_FALSE) {
flb_error(""[flb_msgpack_to_gelf] missing short_message key"");
return NULL;
}
tmp = flb_sds_cat(*s, ""}"", 1);
if (tmp == NULL) {
return NULL;
}
*s = tmp;
return *s;
}","flb_sds_t flb_msgpack_to_gelf(flb_sds_t *VAR_0, msgpack_object *VAR_1,
struct flb_time *VAR_2,
struct flb_gelf_fields *VAR_3)
{
int VAR_4;
int VAR_5;
flb_sds_t VAR_6;
int VAR_7 = VAR_8;
int VAR_9 = VAR_8;
int VAR_10 = VAR_8;
int VAR_11 = VAR_8;
int VAR_12 = VAR_8;
char *VAR_13 = NULL;
char *VAR_14 = NULL;
char *VAR_15 = NULL;
char *VAR_16 = NULL;
char *VAR_17 = NULL;
int VAR_18 = 0;
int VAR_19 = false;
int VAR_20 = 0;
int VAR_21 = 0;
int VAR_22 = 0;
if (VAR_0 == NULL || VAR_1 == NULL) {
return NULL;
}
if (VAR_1->type != VAR_23) {
return NULL;
}
if (VAR_3 != NULL && VAR_3->host_key != NULL) {
VAR_13 = VAR_3->host_key;
VAR_18 = flb_sds_len(VAR_3->host_key);
}
else {
VAR_13 = ""host"";
VAR_18 = 4;
}
if (VAR_3 != NULL && VAR_3->timestamp_key != NULL) {
VAR_14 = VAR_3->timestamp_key;
VAR_19 = flb_sds_len(VAR_3->timestamp_key);
}
else {
VAR_14 = ""timestamp"";
VAR_19 = 9;
}
if (VAR_3 != NULL && VAR_3->level_key != NULL) {
VAR_15 = VAR_3->level_key;
VAR_20 = flb_sds_len(VAR_3->level_key);
}
else {
VAR_15 = ""level"";
VAR_20 = 5;
}
if (VAR_3 != NULL && VAR_3->short_message_key != NULL) {
VAR_16 = VAR_3->short_message_key;
VAR_21 = flb_sds_len(VAR_3->short_message_key);
}
else {
VAR_16 = ""short_message"";
VAR_21 = 13;
}
if (VAR_3 != NULL && VAR_3->full_message_key != NULL) {
VAR_17 = VAR_3->full_message_key;
VAR_22 = flb_sds_len(VAR_3->full_message_key);
}
else {
VAR_17 = ""full_message"";
VAR_22 = 12;
}
VAR_6 = flb_sds_cat(*VAR_0, ""{\""version\"":\""1.1\"""", 16);
if (VAR_6 == NULL) {
return NULL;
}
*VAR_0 = VAR_6;
VAR_5 = VAR_1->via.map.size;
if (VAR_5 != 0) {
msgpack_object_kv *VAR_24 = VAR_1->via.map.ptr;
for (VAR_4 = 0; VAR_4 < VAR_5; VAR_4++) {
const char *VAR_25 = NULL;
int VAR_26;
const char *VAR_27 = NULL;
int VAR_28 = 0;
int VAR_29 = VAR_8;
int VAR_30 = VAR_8;
msgpack_object *VAR_31 = &VAR_24[VAR_4].key;
msgpack_object *VAR_32 = &VAR_24[VAR_4].val;
msgpack_object VAR_33; 
if (VAR_31->type != VAR_34 && VAR_31->type != VAR_35) {
continue;
}
if (VAR_31->type == VAR_35) {
VAR_25 = VAR_31->via.str.ptr;
VAR_26 = VAR_31->via.str.size;
}
else {
VAR_25 = VAR_31->via.bin.ptr;
VAR_26 = VAR_31->via.bin.size;
}
if ((VAR_26 == VAR_18) &&
!strncmp(VAR_25, VAR_13, VAR_18)) {
if (VAR_7 == VAR_36) {
continue;
}
VAR_7 = VAR_36;
VAR_25 = ""host"";
VAR_26 = 4;
}
else if ((VAR_26 == VAR_21) &&
!strncmp(VAR_25, VAR_16, VAR_21)) {
if (VAR_11 == VAR_36) {
continue;
}
VAR_11 = VAR_36;
VAR_25 = ""short_message"";
VAR_26 = 13;
}
else if ((VAR_26 == VAR_19) &&
!strncmp(VAR_25, VAR_14, VAR_19)) {
if (VAR_9 == VAR_36) {
continue;
}
VAR_9 = VAR_36;
VAR_25 = ""timestamp"";
VAR_26 = 9;
}
else if ((VAR_26 == VAR_20) &&
!strncmp(VAR_25, VAR_15, VAR_20 )) {
if (VAR_10 == VAR_36) {
continue;
}
VAR_10 = VAR_36;
VAR_25 = ""level"";
VAR_26 = 5;
if (VAR_32->type == VAR_37) {
if ( VAR_32->via.u64 > 7 ) {
flb_warn(""[flb_msgpack_to_gelf] level is %"" VAR_38 "", ""
""but should be in 0..7 or a syslog keyword"", VAR_32->via.u64);
}
}
else if (VAR_32->type == VAR_35) {
VAR_27     = VAR_32->via.str.ptr;
VAR_28 = VAR_32->via.str.size;
if (VAR_28 == 1 && VAR_27[0] >= '0' && VAR_27[0] <= '7') {
VAR_32 = &VAR_33;
VAR_32->type = VAR_37;
VAR_32->via.u64 = (uint64_t)(VAR_27[0] - '0');
}
else {
int VAR_39;
char* VAR_40[] = {
""emerg"", ""alert"", ""crit"", ""err"",
""warning"", ""notice"", ""info"", ""debug"",
NULL
};
for (VAR_39 = 0; VAR_40[VAR_39] != NULL; ++VAR_39) {
if (VAR_28 == strlen(VAR_40[VAR_39]) &&
!strncasecmp(VAR_27, VAR_40[VAR_39], VAR_28)) {
VAR_32 = &VAR_33;
VAR_32->type = VAR_37;
VAR_32->via.u64 = (uint64_t)VAR_39;
break;
}
}
if (VAR_40[VAR_39] == NULL) {
flb_warn(""[flb_msgpack_to_gelf] level is '%.*s', ""
""but should be in 0..7 or a syslog keyword"", VAR_28, VAR_27);
}
}
}
else {
flb_error(""[flb_msgpack_to_gelf] level must be a non-negative integer or a string"");
return NULL;
}
}
else if ((VAR_26 == VAR_22) &&
!strncmp(VAR_25, VAR_17, VAR_22)) {
if (VAR_12 == VAR_36) {
continue;
}
VAR_12 = VAR_36;
VAR_25 = ""full_message"";
VAR_26 = 12;
}
else if ((VAR_26 == 2)  && !strncmp(VAR_25, ""id"", 2)) {
continue;
}
else {
VAR_30 = VAR_36;
}
if (VAR_32->type == VAR_23) {
char *VAR_41 = NULL;
int VAR_42 = 0;
VAR_42 = VAR_26 + 1;
VAR_41 = flb_calloc(1, VAR_42 + 1);
if (VAR_41 == NULL) {
return NULL;
}
VAR_41[0] = '_';
strncpy(VAR_41 + 1, VAR_25, VAR_26);
VAR_41[VAR_42] = '\0';
VAR_6 = flb_msgpack_gelf_flatten(VAR_0, VAR_32,
VAR_41, VAR_42, VAR_8);
if (VAR_6 == NULL) {
flb_free(VAR_41);
return NULL;
}
*VAR_0 = VAR_6;
flb_free(VAR_41);
}
else if (VAR_32->type == VAR_43) {
if (VAR_30 == VAR_36) {
VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, ""_"", 1, VAR_8,
VAR_25, VAR_26);
}
else {
VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, NULL, 0, VAR_8,
VAR_25, VAR_26);
}
if (VAR_6 == NULL) {
return NULL;
}
*VAR_0 = VAR_6;
VAR_6 = flb_msgpack_gelf_flatten(VAR_0, VAR_32, NULL, 0, VAR_8);
if (VAR_6 == NULL) {
return NULL;
}
*VAR_0 = VAR_6;
}
else {
char VAR_44[48] = {0};
if (VAR_32->type == VAR_45) {
VAR_27 = ""null"";
VAR_28 = 4;
continue;
}
else if (VAR_32->type == VAR_46) {
VAR_29   = VAR_36;
VAR_27 = VAR_32->via.boolean ? ""true"" : ""false"";
VAR_28 = VAR_32->via.boolean ? 4 : 5;
}
else if (VAR_32->type == VAR_37) {
VAR_27 = VAR_44;
VAR_28 = snprintf(VAR_44, sizeof(VAR_44) - 1,
""%"" VAR_38, VAR_32->via.u64);
if (VAR_28 > sizeof(VAR_44)) {
return NULL;
}
}
else if (VAR_32->type == VAR_47) {
VAR_27 = VAR_44;
VAR_28 = snprintf(VAR_44, sizeof(VAR_44) - 1,
""%"" VAR_48, VAR_32->via.i64);
if (VAR_28 > sizeof(VAR_44)) {
return NULL;
}
}
else if (VAR_32->type == VAR_49) {
VAR_27 = VAR_44;
VAR_28 = snprintf(VAR_44, sizeof(VAR_44) - 1,
""%f"", VAR_32->via.f64);
if (VAR_28 > sizeof(VAR_44)) {
return NULL;
}
}
else if (VAR_32->type == VAR_35) {
VAR_29   = VAR_36;
VAR_27     = VAR_32->via.str.ptr;
VAR_28 = VAR_32->via.str.size;
}
else if (VAR_32->type == VAR_34) {
VAR_29   = VAR_36;
VAR_27     = VAR_32->via.bin.ptr;
VAR_28 = VAR_32->via.bin.size;
}
else if (VAR_32->type == VAR_50) {
VAR_29   = VAR_36;
VAR_27     = VAR_1->via.ext.ptr;
VAR_28 = VAR_1->via.ext.size;
}
if (!VAR_27 || !VAR_25) {
continue;
}
if (VAR_30 == VAR_36) {
VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, ""_"", 1, VAR_8,
VAR_25, VAR_26);
}
else {
VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, NULL, 0, VAR_8,
VAR_25, VAR_26);
}
if (VAR_6 == NULL) {
return NULL;
}
*VAR_0 = VAR_6;
if (VAR_32->type == VAR_50) {
VAR_6 = flb_msgpack_gelf_value_ext(VAR_0, VAR_29, VAR_27, VAR_28);
}
else {
VAR_6 = flb_msgpack_gelf_value(VAR_0, VAR_29, VAR_27, VAR_28);
}
if (VAR_6 == NULL) {
return NULL;
}
*VAR_0 = VAR_6;
}
}
}
if (VAR_9 == VAR_8 && VAR_2 != NULL) {
VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, NULL, 0, VAR_8,
""timestamp"", 9);
if (VAR_6 == NULL) {
return NULL;
}
*VAR_0 = VAR_6;
VAR_6 = flb_sds_printf(VAR_0, ""%"" VAR_51"".%lu"",
VAR_2->tm.tv_sec, VAR_2->tm.tv_nsec / 1000000);
if (VAR_6 == NULL) {
return NULL;
}
*VAR_0 = VAR_6;
}
if (VAR_11 == VAR_8) {
flb_error(""[flb_msgpack_to_gelf] missing short_message key"");
return NULL;
}
VAR_6 = flb_sds_cat(*VAR_0, ""}"", 1);
if (VAR_6 == NULL) {
return NULL;
}
*VAR_0 = VAR_6;
return *VAR_0;
}",fluent/fluent-bit/75f0e0e5f7267682674029820524d22460f498b0/flb_pack_gelf.c/vul/before/0.json,"flb_sds_t flb_msgpack_to_gelf(flb_sds_t *s, msgpack_object *o,
                              struct flb_time *tm,
                              struct flb_gelf_fields *fields)
{
    int i;
    int loop;
    flb_sds_t tmp;

    int host_key_found = FLB_FALSE;
    int timestamp_key_found = FLB_FALSE;
    int level_key_found = FLB_FALSE;
    int short_message_key_found = FLB_FALSE;
    int full_message_key_found = FLB_FALSE;

    char *host_key = NULL;
    char *timestamp_key = NULL;
    char *level_key = NULL;
    char *short_message_key = NULL;
    char *full_message_key = NULL;

    int host_key_len = 0;
    int timestamp_key_len = false;
    int level_key_len = 0;
    int short_message_key_len = 0;
    int full_message_key_len = 0;

    if (s == NULL || o == NULL) {
        return NULL;
    }

    /* Make sure the incoming object is a map */
    if (o->type != MSGPACK_OBJECT_MAP) {
        return NULL;
    }

    if (fields != NULL && fields->host_key != NULL) {
        host_key = fields->host_key;
        host_key_len = flb_sds_len(fields->host_key);
    }
    else {
        host_key = ""host"";
        host_key_len = 4;
    }

    if (fields != NULL && fields->timestamp_key != NULL) {
        timestamp_key = fields->timestamp_key;
        timestamp_key_len = flb_sds_len(fields->timestamp_key);
    }
    else {
        timestamp_key = ""timestamp"";
        timestamp_key_len = 9;
    }

    if (fields != NULL && fields->level_key != NULL) {
        level_key = fields->level_key;
        level_key_len = flb_sds_len(fields->level_key);
    }
    else {
        level_key = ""level"";
        level_key_len = 5;
    }

    if (fields != NULL && fields->short_message_key != NULL) {
        short_message_key = fields->short_message_key;
        short_message_key_len = flb_sds_len(fields->short_message_key);
    }
    else {
        short_message_key = ""short_message"";
        short_message_key_len = 13;
    }

    if (fields != NULL && fields->full_message_key != NULL) {
        full_message_key = fields->full_message_key;
        full_message_key_len = flb_sds_len(fields->full_message_key);
    }
    else {
        full_message_key = ""full_message"";
        full_message_key_len = 12;
    }

    tmp = flb_sds_cat(*s, ""{\""version\"":\""1.1\"""", 16);
    if (tmp == NULL) {
        return NULL;
    }
    *s = tmp;

    loop = o->via.map.size;
    if (loop != 0) {
        msgpack_object_kv *p = o->via.map.ptr;

        for (i = 0; i < loop; i++) {
            const char *key = NULL;
            int key_len;
            const char *val = NULL;
            int val_len = 0;
            int quote = FLB_FALSE;
            int custom_key = FLB_FALSE;

            msgpack_object *k = &p[i].key;
            msgpack_object *v = &p[i].val;
            msgpack_object vtmp; // used when converting level value from string to int

            if (k->type != MSGPACK_OBJECT_BIN && k->type != MSGPACK_OBJECT_STR) {
                continue;
            }

            if (k->type == MSGPACK_OBJECT_STR) {
                key = k->via.str.ptr;
                key_len = k->via.str.size;
            }
            else {
                key = k->via.bin.ptr;
                key_len = k->via.bin.size;
            }

            if ((key_len == host_key_len) &&
                !strncmp(key, host_key, host_key_len)) {
                if (host_key_found == FLB_TRUE) {
                    continue;
                }
                host_key_found = FLB_TRUE;
                key = ""host"";
                key_len = 4;
            }
            else if ((key_len == short_message_key_len) &&
                     !strncmp(key, short_message_key, short_message_key_len)) {
                if (short_message_key_found == FLB_TRUE) {
                    continue;
                }
                short_message_key_found = FLB_TRUE;
                key = ""short_message"";
                key_len = 13;
            }
            else if ((key_len == timestamp_key_len) &&
                     !strncmp(key, timestamp_key, timestamp_key_len)) {
                if (timestamp_key_found == FLB_TRUE) {
                    continue;
                }
                timestamp_key_found = FLB_TRUE;
                key = ""timestamp"";
                key_len = 9;
            }
            else if ((key_len == level_key_len) &&
                     !strncmp(key, level_key, level_key_len )) {
                if (level_key_found == FLB_TRUE) {
                    continue;
                }
                level_key_found = FLB_TRUE;
                key = ""level"";
                key_len = 5;
                if (v->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {
                    if ( v->via.u64 > 7 ) {
                        flb_warn(""[flb_msgpack_to_gelf] level is %"" PRIu64 "", ""
                                  ""but should be in 0..7 or a syslog keyword"", v->via.u64);
                    }
                }
                else if (v->type == MSGPACK_OBJECT_STR) {
                    val     = v->via.str.ptr;
                    val_len = v->via.str.size;
                    if (val_len == 1 && val[0] >= '0' && val[0] <= '7') {
                        v = &vtmp;
                        v->type = MSGPACK_OBJECT_POSITIVE_INTEGER;
                        v->via.u64 = (uint64_t)(val[0] - '0');
                    }
                    else {
                        int n;
                        char* allowed_levels[] = {
                            ""emerg"", ""alert"", ""crit"", ""err"",
                            ""warning"", ""notice"", ""info"", ""debug"",
                            NULL
                        };
                        for (n = 0; allowed_levels[n] != NULL; ++n) {
                            if (val_len == strlen(allowed_levels[n]) &&
                                !strncasecmp(val, allowed_levels[n], val_len)) {
                                v = &vtmp;
                                v->type = MSGPACK_OBJECT_POSITIVE_INTEGER;
                                v->via.u64 = (uint64_t)n;
                                break;
                            }
                        }
                        if (allowed_levels[n] == NULL) {
                            flb_warn(""[flb_msgpack_to_gelf] level is '%.*s', ""
                                      ""but should be in 0..7 or a syslog keyword"", val_len, val);
                        }
                    }
                }
                else {
                    flb_error(""[flb_msgpack_to_gelf] level must be a non-negative integer or a string"");
                    return NULL;
                }
            }
            else if ((key_len == full_message_key_len) &&
                     !strncmp(key, full_message_key, full_message_key_len)) {
                if (full_message_key_found == FLB_TRUE) {
                    continue;
                }
                full_message_key_found = FLB_TRUE;
                key = ""full_message"";
                key_len = 12;
            }
            else if ((key_len == 2)  && !strncmp(key, ""id"", 2)) {
                /* _id key not allowed */
                continue;
            }
            else {
                custom_key = FLB_TRUE;
            }

            if (v->type == MSGPACK_OBJECT_MAP) {
                char *prefix = NULL;
                int prefix_len = 0;

                prefix_len = key_len + 1;
                prefix = flb_calloc(1, prefix_len + 1);
                if (prefix == NULL) {
                    return NULL;
                }

                prefix[0] = '_';
                strncpy(prefix + 1, key, key_len);
                prefix[prefix_len] = '\0';

                tmp = flb_msgpack_gelf_flatten(s, v,
                                               prefix, prefix_len, FLB_FALSE);
                if (tmp == NULL) {
                    flb_free(prefix);
                    return NULL;
                }
                *s = tmp;
                flb_free(prefix);

            }
            else if (v->type == MSGPACK_OBJECT_ARRAY) {
                if (custom_key == FLB_TRUE) {
                    tmp = flb_msgpack_gelf_key(s, FLB_FALSE, ""_"", 1, FLB_FALSE,
                                             key, key_len);
                }
                else {
                    tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE,
                                             key, key_len);
                }
                if (tmp == NULL) {
                    return NULL;
                }
                *s = tmp;

                tmp = flb_msgpack_gelf_flatten(s, v, NULL, 0, FLB_FALSE);
                if (tmp == NULL) {
                    return NULL;
                }
                *s = tmp;
            }
            else {
                char temp[48] = {0};
                if (v->type == MSGPACK_OBJECT_NIL) {
                    val = ""null"";
                    val_len = 4;
                    continue;
                }
                else if (v->type == MSGPACK_OBJECT_BOOLEAN) {
                    quote   = FLB_TRUE;
                    val = v->via.boolean ? ""true"" : ""false"";
                    val_len = v->via.boolean ? 4 : 5;
                }
                else if (v->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {
                    val = temp;
                    val_len = snprintf(temp, sizeof(temp) - 1,
                                       ""%"" PRIu64, v->via.u64);
                    /*
                     * Check if the value length is larger than our string.
                     * this is needed to avoid stack-based overflows.
                     */
                    if (val_len > sizeof(temp)) {
                        return NULL;
                    }
                }
                else if (v->type == MSGPACK_OBJECT_NEGATIVE_INTEGER) {
                    val = temp;
                    val_len = snprintf(temp, sizeof(temp) - 1,
                                       ""%"" PRId64, v->via.i64);
                    /*
                     * Check if the value length is larger than our string.
                     * this is needed to avoid stack-based overflows.
                     */
                    if (val_len > sizeof(temp)) {
                        return NULL;
                    }
                }
                else if (v->type == MSGPACK_OBJECT_FLOAT) {
                    val = temp;
                    val_len = snprintf(temp, sizeof(temp) - 1,
                                       ""%f"", v->via.f64);
                    /*
                     * Check if the value length is larger than our string.
                     * this is needed to avoid stack-based overflows.
                     */
                    if (val_len > sizeof(temp)) {
                        return NULL;
                    }
                }
                else if (v->type == MSGPACK_OBJECT_STR) {
                    /* String value */
                    quote   = FLB_TRUE;
                    val     = v->via.str.ptr;
                    val_len = v->via.str.size;
                }
                else if (v->type == MSGPACK_OBJECT_BIN) {
                    /* Bin value */
                    quote   = FLB_TRUE;
                    val     = v->via.bin.ptr;
                    val_len = v->via.bin.size;
                }
                else if (v->type == MSGPACK_OBJECT_EXT) {
                    quote   = FLB_TRUE;
                    val     = v->via.ext.ptr;
                    val_len = v->via.ext.size;
                }

                if (!val || !key) {
                  continue;
                }

                if (custom_key == FLB_TRUE) {
                    tmp = flb_msgpack_gelf_key(s, FLB_FALSE, ""_"", 1, FLB_FALSE,
                                             key, key_len);
                }
                else {
                    tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE,
                                             key, key_len);
                }
                if (tmp == NULL) {
                    return NULL;
                }
                *s = tmp;

                if (v->type == MSGPACK_OBJECT_EXT) {
                    tmp = flb_msgpack_gelf_value_ext(s, quote, val, val_len);
                }
                else {
                    tmp = flb_msgpack_gelf_value(s, quote, val, val_len);
                }
                if (tmp == NULL) {
                    return NULL;
                }
                *s = tmp;
            }
        }
    }

    if (timestamp_key_found == FLB_FALSE && tm != NULL) {
        tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE,
                                   ""timestamp"", 9);
        if (tmp == NULL) {
            return NULL;
        }
        *s = tmp;

        tmp = flb_sds_printf(s, ""%"" PRIu32"".%lu"",
                             tm->tm.tv_sec, tm->tm.tv_nsec / 1000000);
        if (tmp == NULL) {
            return NULL;
        }
        *s = tmp;
    }

    if (short_message_key_found == FLB_FALSE) {
        flb_error(""[flb_msgpack_to_gelf] missing short_message key"");
        return NULL;
    }

    tmp = flb_sds_cat(*s, ""}"", 1);
    if (tmp == NULL) {
        return NULL;
    }
    *s = tmp;

    return *s;
}","flb_sds_t flb_msgpack_to_gelf(flb_sds_t *VAR_0, msgpack_object *VAR_1,
                              struct flb_time *VAR_2,
                              struct flb_gelf_fields *VAR_3)
{
    int VAR_4;
    int VAR_5;
    flb_sds_t VAR_6;

    int VAR_7 = VAR_8;
    int VAR_9 = VAR_8;
    int VAR_10 = VAR_8;
    int VAR_11 = VAR_8;
    int VAR_12 = VAR_8;

    char *VAR_13 = NULL;
    char *VAR_14 = NULL;
    char *VAR_15 = NULL;
    char *VAR_16 = NULL;
    char *VAR_17 = NULL;

    int VAR_18 = 0;
    int VAR_19 = false;
    int VAR_20 = 0;
    int VAR_21 = 0;
    int VAR_22 = 0;

    if (VAR_0 == NULL || VAR_1 == NULL) {
        return NULL;
    }

    /* COMMENT_0 */
    if (VAR_1->type != VAR_23) {
        return NULL;
    }

    if (VAR_3 != NULL && VAR_3->host_key != NULL) {
        VAR_13 = VAR_3->host_key;
        VAR_18 = flb_sds_len(VAR_3->host_key);
    }
    else {
        VAR_13 = ""host"";
        VAR_18 = 4;
    }

    if (VAR_3 != NULL && VAR_3->timestamp_key != NULL) {
        VAR_14 = VAR_3->timestamp_key;
        VAR_19 = flb_sds_len(VAR_3->timestamp_key);
    }
    else {
        VAR_14 = ""timestamp"";
        VAR_19 = 9;
    }

    if (VAR_3 != NULL && VAR_3->level_key != NULL) {
        VAR_15 = VAR_3->level_key;
        VAR_20 = flb_sds_len(VAR_3->level_key);
    }
    else {
        VAR_15 = ""level"";
        VAR_20 = 5;
    }

    if (VAR_3 != NULL && VAR_3->short_message_key != NULL) {
        VAR_16 = VAR_3->short_message_key;
        VAR_21 = flb_sds_len(VAR_3->short_message_key);
    }
    else {
        VAR_16 = ""short_message"";
        VAR_21 = 13;
    }

    if (VAR_3 != NULL && VAR_3->full_message_key != NULL) {
        VAR_17 = VAR_3->full_message_key;
        VAR_22 = flb_sds_len(VAR_3->full_message_key);
    }
    else {
        VAR_17 = ""full_message"";
        VAR_22 = 12;
    }

    VAR_6 = flb_sds_cat(*VAR_0, ""{\""version\"":\""1.1\"""", 16);
    if (VAR_6 == NULL) {
        return NULL;
    }
    *VAR_0 = VAR_6;

    VAR_5 = VAR_1->via.map.size;
    if (VAR_5 != 0) {
        msgpack_object_kv *VAR_24 = VAR_1->via.map.ptr;

        for (VAR_4 = 0; VAR_4 < VAR_5; VAR_4++) {
            const char *VAR_25 = NULL;
            int VAR_26;
            const char *VAR_27 = NULL;
            int VAR_28 = 0;
            int VAR_29 = VAR_8;
            int VAR_30 = VAR_8;

            msgpack_object *VAR_31 = &VAR_24[VAR_4].key;
            msgpack_object *VAR_32 = &VAR_24[VAR_4].val;
            msgpack_object VAR_33; /* COMMENT_1 */

            if (VAR_31->type != VAR_34 && VAR_31->type != VAR_35) {
                continue;
            }

            if (VAR_31->type == VAR_35) {
                VAR_25 = VAR_31->via.str.ptr;
                VAR_26 = VAR_31->via.str.size;
            }
            else {
                VAR_25 = VAR_31->via.bin.ptr;
                VAR_26 = VAR_31->via.bin.size;
            }

            if ((VAR_26 == VAR_18) &&
                !strncmp(VAR_25, VAR_13, VAR_18)) {
                if (VAR_7 == VAR_36) {
                    continue;
                }
                VAR_7 = VAR_36;
                VAR_25 = ""host"";
                VAR_26 = 4;
            }
            else if ((VAR_26 == VAR_21) &&
                     !strncmp(VAR_25, VAR_16, VAR_21)) {
                if (VAR_11 == VAR_36) {
                    continue;
                }
                VAR_11 = VAR_36;
                VAR_25 = ""short_message"";
                VAR_26 = 13;
            }
            else if ((VAR_26 == VAR_19) &&
                     !strncmp(VAR_25, VAR_14, VAR_19)) {
                if (VAR_9 == VAR_36) {
                    continue;
                }
                VAR_9 = VAR_36;
                VAR_25 = ""timestamp"";
                VAR_26 = 9;
            }
            else if ((VAR_26 == VAR_20) &&
                     !strncmp(VAR_25, VAR_15, VAR_20 )) {
                if (VAR_10 == VAR_36) {
                    continue;
                }
                VAR_10 = VAR_36;
                VAR_25 = ""level"";
                VAR_26 = 5;
                if (VAR_32->type == VAR_37) {
                    if ( VAR_32->via.u64 > 7 ) {
                        flb_warn(""[flb_msgpack_to_gelf] level is %"" VAR_38 "", ""
                                  ""but should be in 0..7 or a syslog keyword"", VAR_32->via.u64);
                    }
                }
                else if (VAR_32->type == VAR_35) {
                    VAR_27     = VAR_32->via.str.ptr;
                    VAR_28 = VAR_32->via.str.size;
                    if (VAR_28 == 1 && VAR_27[0] >= '0' && VAR_27[0] <= '7') {
                        VAR_32 = &VAR_33;
                        VAR_32->type = VAR_37;
                        VAR_32->via.u64 = (uint64_t)(VAR_27[0] - '0');
                    }
                    else {
                        int VAR_39;
                        char* VAR_40[] = {
                            ""emerg"", ""alert"", ""crit"", ""err"",
                            ""warning"", ""notice"", ""info"", ""debug"",
                            NULL
                        };
                        for (VAR_39 = 0; VAR_40[VAR_39] != NULL; ++VAR_39) {
                            if (VAR_28 == strlen(VAR_40[VAR_39]) &&
                                !strncasecmp(VAR_27, VAR_40[VAR_39], VAR_28)) {
                                VAR_32 = &VAR_33;
                                VAR_32->type = VAR_37;
                                VAR_32->via.u64 = (uint64_t)VAR_39;
                                break;
                            }
                        }
                        if (VAR_40[VAR_39] == NULL) {
                            flb_warn(""[flb_msgpack_to_gelf] level is '%.*s', ""
                                      ""but should be in 0..7 or a syslog keyword"", VAR_28, VAR_27);
                        }
                    }
                }
                else {
                    flb_error(""[flb_msgpack_to_gelf] level must be a non-negative integer or a string"");
                    return NULL;
                }
            }
            else if ((VAR_26 == VAR_22) &&
                     !strncmp(VAR_25, VAR_17, VAR_22)) {
                if (VAR_12 == VAR_36) {
                    continue;
                }
                VAR_12 = VAR_36;
                VAR_25 = ""full_message"";
                VAR_26 = 12;
            }
            else if ((VAR_26 == 2)  && !strncmp(VAR_25, ""id"", 2)) {
                /* COMMENT_2 */
                continue;
            }
            else {
                VAR_30 = VAR_36;
            }

            if (VAR_32->type == VAR_23) {
                char *VAR_41 = NULL;
                int VAR_42 = 0;

                VAR_42 = VAR_26 + 1;
                VAR_41 = flb_calloc(1, VAR_42 + 1);
                if (VAR_41 == NULL) {
                    return NULL;
                }

                VAR_41[0] = '_';
                strncpy(VAR_41 + 1, VAR_25, VAR_26);
                VAR_41[VAR_42] = '\0';

                VAR_6 = flb_msgpack_gelf_flatten(VAR_0, VAR_32,
                                               VAR_41, VAR_42, VAR_8);
                if (VAR_6 == NULL) {
                    flb_free(VAR_41);
                    return NULL;
                }
                *VAR_0 = VAR_6;
                flb_free(VAR_41);

            }
            else if (VAR_32->type == VAR_43) {
                if (VAR_30 == VAR_36) {
                    VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, ""_"", 1, VAR_8,
                                             VAR_25, VAR_26);
                }
                else {
                    VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, NULL, 0, VAR_8,
                                             VAR_25, VAR_26);
                }
                if (VAR_6 == NULL) {
                    return NULL;
                }
                *VAR_0 = VAR_6;

                VAR_6 = flb_msgpack_gelf_flatten(VAR_0, VAR_32, NULL, 0, VAR_8);
                if (VAR_6 == NULL) {
                    return NULL;
                }
                *VAR_0 = VAR_6;
            }
            else {
                char VAR_44[48] = {0};
                if (VAR_32->type == VAR_45) {
                    VAR_27 = ""null"";
                    VAR_28 = 4;
                    continue;
                }
                else if (VAR_32->type == VAR_46) {
                    VAR_29   = VAR_36;
                    VAR_27 = VAR_32->via.boolean ? ""true"" : ""false"";
                    VAR_28 = VAR_32->via.boolean ? 4 : 5;
                }
                else if (VAR_32->type == VAR_37) {
                    VAR_27 = VAR_44;
                    VAR_28 = snprintf(VAR_44, sizeof(VAR_44) - 1,
                                       ""%"" VAR_38, VAR_32->via.u64);
                    /* COMMENT_3 */
                                                                           
                                                                     
                       
                    if (VAR_28 > sizeof(VAR_44)) {
                        return NULL;
                    }
                }
                else if (VAR_32->type == VAR_47) {
                    VAR_27 = VAR_44;
                    VAR_28 = snprintf(VAR_44, sizeof(VAR_44) - 1,
                                       ""%"" VAR_48, VAR_32->via.i64);
                    /* COMMENT_7 */
                                                                           
                                                                     
                       
                    if (VAR_28 > sizeof(VAR_44)) {
                        return NULL;
                    }
                }
                else if (VAR_32->type == VAR_49) {
                    VAR_27 = VAR_44;
                    VAR_28 = snprintf(VAR_44, sizeof(VAR_44) - 1,
                                       ""%f"", VAR_32->via.f64);
                    /* COMMENT_11 */
                                                                           
                                                                     
                       
                    if (VAR_28 > sizeof(VAR_44)) {
                        return NULL;
                    }
                }
                else if (VAR_32->type == VAR_35) {
                    /* COMMENT_15 */
                    VAR_29   = VAR_36;
                    VAR_27     = VAR_32->via.str.ptr;
                    VAR_28 = VAR_32->via.str.size;
                }
                else if (VAR_32->type == VAR_34) {
                    /* COMMENT_16 */
                    VAR_29   = VAR_36;
                    VAR_27     = VAR_32->via.bin.ptr;
                    VAR_28 = VAR_32->via.bin.size;
                }
                else if (VAR_32->type == VAR_50) {
                    VAR_29   = VAR_36;
                    VAR_27     = VAR_32->via.ext.ptr;
                    VAR_28 = VAR_32->via.ext.size;
                }

                if (!VAR_27 || !VAR_25) {
                  continue;
                }

                if (VAR_30 == VAR_36) {
                    VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, ""_"", 1, VAR_8,
                                             VAR_25, VAR_26);
                }
                else {
                    VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, NULL, 0, VAR_8,
                                             VAR_25, VAR_26);
                }
                if (VAR_6 == NULL) {
                    return NULL;
                }
                *VAR_0 = VAR_6;

                if (VAR_32->type == VAR_50) {
                    VAR_6 = flb_msgpack_gelf_value_ext(VAR_0, VAR_29, VAR_27, VAR_28);
                }
                else {
                    VAR_6 = flb_msgpack_gelf_value(VAR_0, VAR_29, VAR_27, VAR_28);
                }
                if (VAR_6 == NULL) {
                    return NULL;
                }
                *VAR_0 = VAR_6;
            }
        }
    }

    if (VAR_9 == VAR_8 && VAR_2 != NULL) {
        VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, NULL, 0, VAR_8,
                                   ""timestamp"", 9);
        if (VAR_6 == NULL) {
            return NULL;
        }
        *VAR_0 = VAR_6;

        VAR_6 = flb_sds_printf(VAR_0, ""%"" VAR_51"".%lu"",
                             VAR_2->tm.tv_sec, VAR_2->tm.tv_nsec / 1000000);
        if (VAR_6 == NULL) {
            return NULL;
        }
        *VAR_0 = VAR_6;
    }

    if (VAR_11 == VAR_8) {
        flb_error(""[flb_msgpack_to_gelf] missing short_message key"");
        return NULL;
    }

    VAR_6 = flb_sds_cat(*VAR_0, ""}"", 1);
    if (VAR_6 == NULL) {
        return NULL;
    }
    *VAR_0 = VAR_6;

    return *VAR_0;
}",fluent/fluent-bit/75f0e0e5f7267682674029820524d22460f498b0/flb_pack_gelf.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -312,8 +312,8 @@
                 }
                 else if (v->type == MSGPACK_OBJECT_EXT) {
                     quote   = FLB_TRUE;
-                    val     = o->via.ext.ptr;
-                    val_len = o->via.ext.size;
+                    val     = v->via.ext.ptr;
+                    val_len = v->via.ext.size;
                 }
 
                 if (!val || !key) {","{'deleted_lines': ['                    val     = o->via.ext.ptr;', '                    val_len = o->via.ext.size;'], 'added_lines': ['                    val     = v->via.ext.ptr;', '                    val_len = v->via.ext.size;']}",True,"An issue was discovered in Treasure Data Fluent Bit 1.7.1, a wrong variable is used to get the msgpack data resulting in a heap overflow in flb_msgpack_gelf_value_ext. An attacker can craft a malicious file and tick the victim to open the file with the software, triggering a heap overflow and execute arbitrary code on the target system.",7.8,HIGH,2,test,2021-02-22T13:44:50Z,3
CVE-2021-44340,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,brackeen/ok-file-formats,ok_jpg: Fix invalid DHT (#11),a9cc1711dd4ed6a215038f1c5c03af0ef52c3211,https://github.com/brackeen/ok-file-formats/commit/a9cc1711dd4ed6a215038f1c5c03af0ef52c3211,ok_jpg.c,ok_jpg_generate_huffman_table,"static void ok_jpg_generate_huffman_table(ok_jpg_huffman_table *huff, const uint8_t *bits) {
int k = 0;
for (uint8_t i = 1; i <= 16; i++) {
for (int j = 1; j <= bits[i]; j++) {
huff->size[k++] = i;
}
}
huff->size[k] = 0;
huff->count = k;
k = 0;
uint16_t code = 0;
int si = huff->size[0];
while (true) {
huff->code[k] = code;
code++;
k++;
int si2 = huff->size[k];
if (si2 == 0) {
break;
}
if (si2 > si) {
code <<= (si2 - si);
si = si2;
}
}
int j = 0;
for (int i = 0; i < 16; i++) {
if (bits[i + 1] == 0) {
huff->maxcode[i] = -1;
} else {
huff->valptr[i] = j;
huff->mincode[i] = huff->code[j];
j += bits[i + 1];
huff->maxcode[i] = huff->code[j - 1];
if (i >= HUFFMAN_LOOKUP_SIZE_BITS) {
huff->maxcode[i] = (huff->maxcode[i] << (15 - i)) | ((1 << (15 - i)) - 1);
}
}
}
}","static void ok_jpg_generate_huffman_table(ok_jpg_huffman_table *VAR_0, const uint8_t *VAR_1) {
int VAR_2 = 0;
for (uint8_t VAR_3 = 1; VAR_3 <= 16; VAR_3++) {
for (int VAR_4 = 1; VAR_4 <= VAR_1[VAR_3]; VAR_4++) {
VAR_0->size[VAR_2++] = VAR_3;
}
}
VAR_0->size[VAR_2] = 0;
VAR_0->count = VAR_2;
VAR_2 = 0;
uint16_t VAR_5 = 0;
int VAR_6 = VAR_0->size[0];
while (true) {
VAR_0->code[VAR_2] = VAR_5;
VAR_5++;
VAR_2++;
int VAR_7 = VAR_0->size[VAR_2];
if (VAR_7 == 0) {
break;
}
if (VAR_7 > VAR_6) {
VAR_5 <<= (VAR_7 - VAR_6);
VAR_6 = VAR_7;
}
}
int VAR_4 = 0;
for (int VAR_3 = 0; VAR_3 < 16; VAR_3++) {
if (VAR_1[VAR_3 + 1] == 0) {
VAR_0->maxcode[VAR_3] = -1;
} else {
VAR_0->valptr[VAR_3] = VAR_4;
VAR_0->mincode[VAR_3] = VAR_0->code[VAR_4];
VAR_4 += VAR_1[VAR_3 + 1];
VAR_0->maxcode[VAR_3] = VAR_0->code[VAR_4 - 1];
if (VAR_3 >= VAR_8) {
VAR_0->maxcode[VAR_3] = (VAR_0->maxcode[VAR_3] << (15 - VAR_3)) | ((1 << (15 - VAR_3)) - 1);
}
}
}
}",brackeen/ok-file-formats/a9cc1711dd4ed6a215038f1c5c03af0ef52c3211/ok_jpg.c/vul/before/0.json,"static bool ok_jpg_generate_huffman_table(ok_jpg_huffman_table *huff, const uint8_t *bits) {
    // JPEG spec: ""Generate_size_table""
    int k = 0;
    for (uint8_t i = 1; i <= 16; i++) {
        uint8_t len = bits[i];
        if (len == 0) {
            continue;
        } else if ((unsigned)k + len >= sizeof(huff->size)) {
            return false;
        } else {
            memset(huff->size + k, i, len);
            k += len;
        }
    }
    huff->size[k] = 0;
    huff->count = k;

    // JPEG spec: ""Generate_code_table""
    k = 0;
    uint16_t code = 0;
    int si = huff->size[0];
    while (true) {
        huff->code[k] = code;
        code++;
        k++;
        int si2 = huff->size[k];
        if (si2 == 0) {
            break;
        }
        if (si2 > si) {
            code <<= (si2 - si);
            si = si2;
        }
    }

    // JPEG spec: ""Decoder_tables""
    int j = 0;
    for (int i = 0; i < 16; i++) {
        if (bits[i + 1] == 0) {
            huff->maxcode[i] = -1;
        } else {
            huff->valptr[i] = j;
            huff->mincode[i] = huff->code[j];
            j += bits[i + 1];
            huff->maxcode[i] = huff->code[j - 1];
            if (i >= HUFFMAN_LOOKUP_SIZE_BITS) {
                huff->maxcode[i] = (huff->maxcode[i] << (15 - i)) | ((1 << (15 - i)) - 1);
            }
        }
    }
    return true;
}","static bool ok_jpg_generate_huffman_table(ok_jpg_huffman_table *VAR_0, const uint8_t *VAR_1) {
    /* COMMENT_0 */
    int VAR_2 = 0;
    for (uint8_t VAR_3 = 1; VAR_3 <= 16; VAR_3++) {
        uint8_t VAR_4 = VAR_1[VAR_3];
        if (VAR_4 == 0) {
            continue;
        } else if ((unsigned)VAR_2 + VAR_4 >= sizeof(VAR_0->size)) {
            return false;
        } else {
            memset(VAR_0->size + VAR_2, VAR_3, VAR_4);
            VAR_2 += VAR_4;
        }
    }
    VAR_0->size[VAR_2] = 0;
    VAR_0->count = VAR_2;

    /* COMMENT_1 */
    VAR_2 = 0;
    uint16_t VAR_5 = 0;
    int VAR_6 = VAR_0->size[0];
    while (true) {
        VAR_0->code[VAR_2] = VAR_5;
        VAR_5++;
        VAR_2++;
        int VAR_7 = VAR_0->size[VAR_2];
        if (VAR_7 == 0) {
            break;
        }
        if (VAR_7 > VAR_6) {
            VAR_5 <<= (VAR_7 - VAR_6);
            VAR_6 = VAR_7;
        }
    }

    /* COMMENT_2 */
    int VAR_8 = 0;
    for (int VAR_3 = 0; VAR_3 < 16; VAR_3++) {
        if (VAR_1[VAR_3 + 1] == 0) {
            VAR_0->maxcode[VAR_3] = -1;
        } else {
            VAR_0->valptr[VAR_3] = VAR_8;
            VAR_0->mincode[VAR_3] = VAR_0->code[VAR_8];
            VAR_8 += VAR_1[VAR_3 + 1];
            VAR_0->maxcode[VAR_3] = VAR_0->code[VAR_8 - 1];
            if (VAR_3 >= VAR_9) {
                VAR_0->maxcode[VAR_3] = (VAR_0->maxcode[VAR_3] << (15 - VAR_3)) | ((1 << (15 - VAR_3)) - 1);
            }
        }
    }
    return true;
}",brackeen/ok-file-formats/a9cc1711dd4ed6a215038f1c5c03af0ef52c3211/ok_jpg.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,9 +1,15 @@
-static void ok_jpg_generate_huffman_table(ok_jpg_huffman_table *huff, const uint8_t *bits) {
+static bool ok_jpg_generate_huffman_table(ok_jpg_huffman_table *huff, const uint8_t *bits) {
     // JPEG spec: ""Generate_size_table""
     int k = 0;
     for (uint8_t i = 1; i <= 16; i++) {
-        for (int j = 1; j <= bits[i]; j++) {
-            huff->size[k++] = i;
+        uint8_t len = bits[i];
+        if (len == 0) {
+            continue;
+        } else if ((unsigned)k + len >= sizeof(huff->size)) {
+            return false;
+        } else {
+            memset(huff->size + k, i, len);
+            k += len;
         }
     }
     huff->size[k] = 0;
@@ -42,4 +48,5 @@
             }
         }
     }
+    return true;
 }","{'deleted_lines': ['static void ok_jpg_generate_huffman_table(ok_jpg_huffman_table *huff, const uint8_t *bits) {', '        for (int j = 1; j <= bits[i]; j++) {', '            huff->size[k++] = i;'], 'added_lines': ['static bool ok_jpg_generate_huffman_table(ok_jpg_huffman_table *huff, const uint8_t *bits) {', '        uint8_t len = bits[i];', '        if (len == 0) {', '            continue;', '        } else if ((unsigned)k + len >= sizeof(huff->size)) {', '            return false;', '        } else {', '            memset(huff->size + k, i, len);', '            k += len;', '    return true;']}",True,"David Brackeen ok-file-formats dev version is vulnerable to Buffer Overflow. When the function of the ok-file-formats project is used, a heap-buffer-overflow occurred in function ok_jpg_generate_huffman_table() in ""/ok_jpg.c:403"".",7.8,HIGH,2,test,2021-03-06T18:17:44Z,3
CVE-2021-44340,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,brackeen/ok-file-formats,ok_jpg: Fix invalid DHT (#11),a9cc1711dd4ed6a215038f1c5c03af0ef52c3211,https://github.com/brackeen/ok-file-formats/commit/a9cc1711dd4ed6a215038f1c5c03af0ef52c3211,ok_jpg.c,ok_jpg_read_dht,"static bool ok_jpg_read_dht(ok_jpg_decoder *decoder) {
ok_jpg *jpg = decoder->jpg;
uint8_t buffer[17];
if (!ok_read(decoder, buffer, 2)) {
return false;
}
int length = readBE16(buffer) - 2;
while (length >= 17) {
if (!ok_read(decoder, buffer, 17)) {
return false;
}
length -= 17;
int Tc = buffer[0] >> 4;
int Th = buffer[0] & 0x0f;
if (Tc > 1 || Th > 3) {
ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid JPEG (Bad DHT Tc/Th)"");
return false;
}
ok_jpg_huffman_table *tables = (Tc == 0 ? decoder->dc_huffman_tables :
decoder->ac_huffman_tables);
ok_jpg_huffman_table *table = tables + Th;
ok_jpg_generate_huffman_table(table, buffer);
if (table->count > 0) {
if (table->count > 256 || table->count > length) {
ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid DHT segment length"");
return false;
}
if (!ok_read(decoder, table->val, (size_t)table->count)) {
return false;
}
length -= table->count;
}
bool is_ac_table = Tc == 1;
ok_jpg_generate_huffman_table_lookups(table, is_ac_table);
}
if (length != 0) {
ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid DHT segment length"");
return false;
} else {
return true;
}
}","static bool ok_jpg_read_dht(ok_jpg_decoder *VAR_0) {
ok_jpg *VAR_1 = VAR_0->jpg;
uint8_t VAR_2[17];
if (!ok_read(VAR_0, VAR_2, 2)) {
return false;
}
int VAR_3 = readBE16(VAR_2) - 2;
while (VAR_3 >= 17) {
if (!ok_read(VAR_0, VAR_2, 17)) {
return false;
}
VAR_3 -= 17;
int VAR_4 = VAR_2[0] >> 4;
int VAR_5 = VAR_2[0] & 0x0f;
if (VAR_4 > 1 || VAR_5 > 3) {
ok_jpg_error(VAR_1, VAR_6, ""Invalid JPEG (Bad DHT Tc/Th)"");
return false;
}
ok_jpg_huffman_table *VAR_7 = (VAR_4 == 0 ? VAR_0->dc_huffman_tables :
VAR_0->ac_huffman_tables);
ok_jpg_huffman_table *VAR_8 = VAR_7 + VAR_5;
ok_jpg_generate_huffman_table(VAR_8, VAR_2);
if (VAR_8->count > 0) {
if (VAR_8->count > 256 || VAR_8->count > VAR_3) {
ok_jpg_error(VAR_1, VAR_6, ""Invalid DHT segment length"");
return false;
}
if (!ok_read(VAR_0, VAR_8->val, (size_t)VAR_8->count)) {
return false;
}
VAR_3 -= VAR_8->count;
}
bool VAR_9 = VAR_4 == 1;
ok_jpg_generate_huffman_table_lookups(VAR_8, VAR_9);
}
if (VAR_3 != 0) {
ok_jpg_error(VAR_1, VAR_6, ""Invalid DHT segment length"");
return false;
} else {
return true;
}
}",brackeen/ok-file-formats/a9cc1711dd4ed6a215038f1c5c03af0ef52c3211/ok_jpg.c/vul/before/1.json,"static bool ok_jpg_read_dht(ok_jpg_decoder *decoder) {
    // JPEG spec: Table B.5
    ok_jpg *jpg = decoder->jpg;
    uint8_t buffer[17];
    if (!ok_read(decoder, buffer, 2)) {
        return false;
    }
    int length = readBE16(buffer) - 2;
    while (length >= 17) {
        if (!ok_read(decoder, buffer, 17)) {
            return false;
        }
        length -= 17;

        int Tc = buffer[0] >> 4;
        int Th = buffer[0] & 0x0f;
        if (Tc > 1 || Th > 3) {
            ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid JPEG (Bad DHT Tc/Th)"");
            return false;
        }
        ok_jpg_huffman_table *tables = (Tc == 0 ? decoder->dc_huffman_tables :
                                        decoder->ac_huffman_tables);
        ok_jpg_huffman_table *table = tables + Th;
        if (!ok_jpg_generate_huffman_table(table, buffer)) {
            ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid DHT"");
            return false;
        } else if (table->count > 0) {
            if (table->count > length) {
                ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid DHT segment length"");
                return false;
            }
            if (!ok_read(decoder, table->val, (size_t)table->count)) {
                return false;
            }
            length -= table->count;
        }
        bool is_ac_table = Tc == 1;
        ok_jpg_generate_huffman_table_lookups(table, is_ac_table);
    }
    if (length != 0) {
        ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid DHT segment length"");
        return false;
    } else {
        return true;
    }
}","static bool ok_jpg_read_dht(ok_jpg_decoder *VAR_0) {
    /* COMMENT_0 */
    ok_jpg *VAR_1 = VAR_0->jpg;
    uint8_t VAR_2[17];
    if (!ok_read(VAR_0, VAR_2, 2)) {
        return false;
    }
    int VAR_3 = readBE16(VAR_2) - 2;
    while (VAR_3 >= 17) {
        if (!ok_read(VAR_0, VAR_2, 17)) {
            return false;
        }
        VAR_3 -= 17;

        int VAR_4 = VAR_2[0] >> 4;
        int VAR_5 = VAR_2[0] & 0x0f;
        if (VAR_4 > 1 || VAR_5 > 3) {
            ok_jpg_error(VAR_1, VAR_6, ""Invalid JPEG (Bad DHT Tc/Th)"");
            return false;
        }
        ok_jpg_huffman_table *VAR_7 = (VAR_4 == 0 ? VAR_0->dc_huffman_tables :
                                        VAR_0->ac_huffman_tables);
        ok_jpg_huffman_table *VAR_8 = VAR_7 + VAR_5;
        if (!ok_jpg_generate_huffman_table(VAR_8, VAR_2)) {
            ok_jpg_error(VAR_1, VAR_6, ""Invalid DHT"");
            return false;
        } else if (VAR_8->count > 0) {
            if (VAR_8->count > VAR_3) {
                ok_jpg_error(VAR_1, VAR_6, ""Invalid DHT segment length"");
                return false;
            }
            if (!ok_read(VAR_0, VAR_8->val, (size_t)VAR_8->count)) {
                return false;
            }
            VAR_3 -= VAR_8->count;
        }
        bool VAR_9 = VAR_4 == 1;
        ok_jpg_generate_huffman_table_lookups(VAR_8, VAR_9);
    }
    if (VAR_3 != 0) {
        ok_jpg_error(VAR_1, VAR_6, ""Invalid DHT segment length"");
        return false;
    } else {
        return true;
    }
}",brackeen/ok-file-formats/a9cc1711dd4ed6a215038f1c5c03af0ef52c3211/ok_jpg.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -21,9 +21,11 @@
         ok_jpg_huffman_table *tables = (Tc == 0 ? decoder->dc_huffman_tables :
                                         decoder->ac_huffman_tables);
         ok_jpg_huffman_table *table = tables + Th;
-        ok_jpg_generate_huffman_table(table, buffer);
-        if (table->count > 0) {
-            if (table->count > 256 || table->count > length) {
+        if (!ok_jpg_generate_huffman_table(table, buffer)) {
+            ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid DHT"");
+            return false;
+        } else if (table->count > 0) {
+            if (table->count > length) {
                 ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid DHT segment length"");
                 return false;
             }","{'deleted_lines': ['        ok_jpg_generate_huffman_table(table, buffer);', '        if (table->count > 0) {', '            if (table->count > 256 || table->count > length) {'], 'added_lines': ['        if (!ok_jpg_generate_huffman_table(table, buffer)) {', '            ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid DHT"");', '            return false;', '        } else if (table->count > 0) {', '            if (table->count > length) {']}",True,"David Brackeen ok-file-formats dev version is vulnerable to Buffer Overflow. When the function of the ok-file-formats project is used, a heap-buffer-overflow occurred in function ok_jpg_generate_huffman_table() in ""/ok_jpg.c:403"".",7.8,HIGH,2,test,2021-03-06T18:17:44Z,3
CVE-2021-28902,['CWE-252'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,CESNET/libyang,"yin parser BUGFIX invalid memory access

... in case there were some unresolved
extensions.
Fixes #1454
Fixes #1455",a3917d95d516e3de267d3cfa5d4d3715a90e8777,https://github.com/CESNET/libyang/commit/a3917d95d516e3de267d3cfa5d4d3715a90e8777,src/parser_yin.c,read_yin_container,"static struct lys_node *
read_yin_container(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options,
struct unres_schema *unres)
{
struct ly_ctx *ctx = module->ctx;
struct lyxml_elem *sub, *next, root;
struct lys_node *node = NULL;
struct lys_node *retval;
struct lys_node_container *cont;
const char *value;
void *reallocated;
int r;
int c_tpdf = 0, c_must = 0, c_ftrs = 0, c_ext = 0;
memset(&root, 0, sizeof root);
cont = calloc(1, sizeof *cont);
LY_CHECK_ERR_RETURN(!cont, LOGMEM(ctx), NULL);
cont->nodetype = LYS_CONTAINER;
cont->prev = (struct lys_node *)cont;
retval = (struct lys_node *)cont;
if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,
OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :
(options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT),
unres)) {
goto error;
}
LOGDBG(LY_LDGYIN, ""parsing %s statement \""%s\"""", yin->name, retval->name);
if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {
goto error;
}
LY_TREE_FOR_SAFE(yin->child, next, sub) {
if (strcmp(sub->ns->value, LY_NSYIN)) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, ""extensions"", ""container"", error);
c_ext++;
} else if (!strcmp(sub->name, ""presence"")) {
if (cont->presence) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
GETVAL(ctx, value, sub, ""value"");
cont->presence = lydict_insert(ctx, value, strlen(value));
if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_PRESENCE, 0, unres)) {
goto error;
}
lyxml_free(ctx, sub);
} else if (!strcmp(sub->name, ""when"")) {
if (cont->when) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
cont->when = read_yin_when(module, sub, unres);
if (!cont->when) {
lyxml_free(ctx, sub);
goto error;
}
lyxml_free(ctx, sub);
} else if (!strcmp(sub->name, ""container"") ||
!strcmp(sub->name, ""leaf-list"") ||
!strcmp(sub->name, ""leaf"") ||
!strcmp(sub->name, ""list"") ||
!strcmp(sub->name, ""choice"") ||
!strcmp(sub->name, ""uses"") ||
!strcmp(sub->name, ""grouping"") ||
!strcmp(sub->name, ""anyxml"") ||
!strcmp(sub->name, ""anydata"") ||
!strcmp(sub->name, ""action"") ||
!strcmp(sub->name, ""notification"")) {
lyxml_unlink_elem(ctx, sub, 2);
lyxml_add_child(ctx, &root, sub);
} else if (!strcmp(sub->name, ""typedef"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_tpdf, cont->tpdf_size, ""typedefs"", ""container"", error);
c_tpdf++;
} else if (!strcmp(sub->name, ""must"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, cont->must_size, ""musts"", ""container"", error);
c_must++;
} else if (!strcmp(sub->name, ""if-feature"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, ""if-features"", ""container"", error);
c_ftrs++;
} else {
LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);
goto error;
}
}
if (c_tpdf) {
cont->tpdf = calloc(c_tpdf, sizeof *cont->tpdf);
LY_CHECK_ERR_GOTO(!cont->tpdf, LOGMEM(ctx), error);
}
if (c_must) {
cont->must = calloc(c_must, sizeof *cont->must);
LY_CHECK_ERR_GOTO(!cont->must, LOGMEM(ctx), error);
}
if (c_ftrs) {
cont->iffeature = calloc(c_ftrs, sizeof *cont->iffeature);
LY_CHECK_ERR_GOTO(!cont->iffeature, LOGMEM(ctx), error);
}
if (c_ext) {
reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);
LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);
retval->ext = reallocated;
memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);
}
LY_TREE_FOR_SAFE(yin->child, next, sub) {
if (strcmp(sub->ns->value, LY_NSYIN)) {
r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);
if (r) {
goto error;
}
} else if (!strcmp(sub->name, ""typedef"")) {
r = fill_yin_typedef(module, retval, sub, &cont->tpdf[cont->tpdf_size], unres);
cont->tpdf_size++;
if (r) {
goto error;
}
} else if (!strcmp(sub->name, ""must"")) {
r = fill_yin_must(module, sub, &cont->must[cont->must_size], unres);
cont->must_size++;
if (r) {
goto error;
}
} else if (!strcmp(sub->name, ""if-feature"")) {
r = fill_yin_iffeature(retval, 0, sub, &cont->iffeature[cont->iffeature_size], unres);
cont->iffeature_size++;
if (r) {
goto error;
}
}
}
lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);
LY_TREE_FOR_SAFE(root.child, next, sub) {
if (!strcmp(sub->name, ""container"")) {
node = read_yin_container(module, retval, sub, options, unres);
} else if (!strcmp(sub->name, ""leaf-list"")) {
node = read_yin_leaflist(module, retval, sub, options, unres);
} else if (!strcmp(sub->name, ""leaf"")) {
node = read_yin_leaf(module, retval, sub, options, unres);
} else if (!strcmp(sub->name, ""list"")) {
node = read_yin_list(module, retval, sub, options, unres);
} else if (!strcmp(sub->name, ""choice"")) {
node = read_yin_choice(module, retval, sub, options, unres);
} else if (!strcmp(sub->name, ""uses"")) {
node = read_yin_uses(module, retval, sub, options, unres);
} else if (!strcmp(sub->name, ""grouping"")) {
node = read_yin_grouping(module, retval, sub, options, unres);
} else if (!strcmp(sub->name, ""anyxml"")) {
node = read_yin_anydata(module, retval, sub, LYS_ANYXML, options, unres);
} else if (!strcmp(sub->name, ""anydata"")) {
node = read_yin_anydata(module, retval, sub, LYS_ANYDATA, options, unres);
} else if (!strcmp(sub->name, ""action"")) {
node = read_yin_rpc_action(module, retval, sub, options, unres);
} else if (!strcmp(sub->name, ""notification"")) {
node = read_yin_notif(module, retval, sub, options, unres);
}
if (!node) {
goto error;
}
lyxml_free(ctx, sub);
}
if (!(ctx->models.flags & LY_CTX_TRUSTED) && (cont->when || cont->must)) {
if (options & LYS_PARSE_OPT_INGRP) {
if (lyxp_node_check_syntax(retval)) {
goto error;
}
} else {
if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {
goto error;
}
}
}
for (r = 0; r < retval->ext_size; ++r) {
if (retval->ext[r]->flags & LYEXT_OPT_VALID) {
retval->flags |= LYS_VALID_EXT;
if (retval->ext[r]->flags & LYEXT_OPT_VALID_SUBTREE) {
retval->flags |= LYS_VALID_EXT_SUBTREE;
break;
}
}
}
return retval;
error:
lys_node_free(ctx, retval, NULL, 0);
while (root.child) {
lyxml_free(ctx, root.child);
}
return NULL;
}","static struct lys_node *
read_yin_container(struct lys_module *VAR_0, struct lys_node *VAR_1, struct lyxml_elem *VAR_2, int VAR_3,
struct unres_schema *VAR_4)
{
struct ly_ctx *VAR_5 = VAR_0->ctx;
struct lyxml_elem *VAR_6, *VAR_7, VAR_8;
struct lys_node *VAR_9 = NULL;
struct lys_node *VAR_10;
struct lys_node_container *VAR_11;
const char *VAR_12;
void *VAR_13;
int VAR_14;
int VAR_15 = 0, VAR_16 = 0, VAR_17 = 0, VAR_18 = 0;
memset(&VAR_8, 0, sizeof VAR_8);
VAR_11 = calloc(1, sizeof *VAR_11);
LY_CHECK_ERR_RETURN(!VAR_11, LOGMEM(VAR_5), NULL);
VAR_11->nodetype = VAR_19;
VAR_11->prev = (struct lys_node *)VAR_11;
VAR_10 = (struct lys_node *)VAR_11;
if (read_yin_common(VAR_0, VAR_1, VAR_10, VAR_20, VAR_2,
VAR_21 | VAR_22 | ((VAR_3 & VAR_23) ? VAR_24 :
(VAR_3 & VAR_25) ? VAR_26 : VAR_26 | VAR_27),
VAR_4)) {
goto error;
}
LOGDBG(VAR_28, ""parsing %s statement \""%s\"""", VAR_2->name, VAR_10->name);
if (lys_node_addchild(VAR_1, lys_main_module(VAR_0), VAR_10, VAR_3)) {
goto error;
}
LY_TREE_FOR_SAFE(VAR_2->child, VAR_7, VAR_6) {
if (strcmp(VAR_6->ns->value, VAR_29)) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_18, VAR_10->ext_size, ""extensions"", ""container"", VAR_30);
VAR_18++;
} else if (!strcmp(VAR_6->name, ""presence"")) {
if (VAR_11->presence) {
LOGVAL(VAR_5, VAR_31, VAR_32, VAR_10, VAR_6->name, VAR_2->name);
goto error;
}
GETVAL(VAR_5, VAR_12, VAR_6, ""value"");
VAR_11->presence = lydict_insert(VAR_5, VAR_12, strlen(VAR_12));
if (lyp_yin_parse_subnode_ext(VAR_0, VAR_10, VAR_20, VAR_6, VAR_33, 0, VAR_4)) {
goto error;
}
lyxml_free(VAR_5, VAR_6);
} else if (!strcmp(VAR_6->name, ""when"")) {
if (VAR_11->when) {
LOGVAL(VAR_5, VAR_31, VAR_32, VAR_10, VAR_6->name, VAR_2->name);
goto error;
}
VAR_11->when = read_yin_when(VAR_0, VAR_6, VAR_4);
if (!VAR_11->when) {
lyxml_free(VAR_5, VAR_6);
goto error;
}
lyxml_free(VAR_5, VAR_6);
} else if (!strcmp(VAR_6->name, ""container"") ||
!strcmp(VAR_6->name, ""leaf-list"") ||
!strcmp(VAR_6->name, ""leaf"") ||
!strcmp(VAR_6->name, ""list"") ||
!strcmp(VAR_6->name, ""choice"") ||
!strcmp(VAR_6->name, ""uses"") ||
!strcmp(VAR_6->name, ""grouping"") ||
!strcmp(VAR_6->name, ""anyxml"") ||
!strcmp(VAR_6->name, ""anydata"") ||
!strcmp(VAR_6->name, ""action"") ||
!strcmp(VAR_6->name, ""notification"")) {
lyxml_unlink_elem(VAR_5, VAR_6, 2);
lyxml_add_child(VAR_5, &VAR_8, VAR_6);
} else if (!strcmp(VAR_6->name, ""typedef"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_15, VAR_11->tpdf_size, ""typedefs"", ""container"", VAR_30);
VAR_15++;
} else if (!strcmp(VAR_6->name, ""must"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_16, VAR_11->must_size, ""musts"", ""container"", VAR_30);
VAR_16++;
} else if (!strcmp(VAR_6->name, ""if-feature"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_17, VAR_10->iffeature_size, ""if-features"", ""container"", VAR_30);
VAR_17++;
} else {
LOGVAL(VAR_5, VAR_34, VAR_32, VAR_10, VAR_6->name);
goto error;
}
}
if (VAR_15) {
VAR_11->tpdf = calloc(VAR_15, sizeof *VAR_11->tpdf);
LY_CHECK_ERR_GOTO(!VAR_11->tpdf, LOGMEM(VAR_5), VAR_30);
}
if (VAR_16) {
VAR_11->must = calloc(VAR_16, sizeof *VAR_11->must);
LY_CHECK_ERR_GOTO(!VAR_11->must, LOGMEM(VAR_5), VAR_30);
}
if (VAR_17) {
VAR_11->iffeature = calloc(VAR_17, sizeof *VAR_11->iffeature);
LY_CHECK_ERR_GOTO(!VAR_11->iffeature, LOGMEM(VAR_5), VAR_30);
}
if (VAR_18) {
VAR_13 = realloc(VAR_10->ext, (VAR_18 + VAR_10->ext_size) * sizeof *VAR_10->ext);
LY_CHECK_ERR_GOTO(!VAR_13, LOGMEM(VAR_5), VAR_30);
VAR_10->ext = VAR_13;
memset(&VAR_10->ext[VAR_10->ext_size], 0, VAR_18 * sizeof *VAR_10->ext);
}
LY_TREE_FOR_SAFE(VAR_2->child, VAR_7, VAR_6) {
if (strcmp(VAR_6->ns->value, VAR_29)) {
VAR_14 = lyp_yin_fill_ext(VAR_10, VAR_20, 0, 0, VAR_0, VAR_6, &VAR_10->ext, &VAR_10->ext_size, VAR_4);
if (VAR_14) {
goto error;
}
} else if (!strcmp(VAR_6->name, ""typedef"")) {
VAR_14 = fill_yin_typedef(VAR_0, VAR_10, VAR_6, &VAR_11->tpdf[VAR_11->tpdf_size], VAR_4);
VAR_11->tpdf_size++;
if (VAR_14) {
goto error;
}
} else if (!strcmp(VAR_6->name, ""must"")) {
VAR_14 = fill_yin_must(VAR_0, VAR_6, &VAR_11->must[VAR_11->must_size], VAR_4);
VAR_11->must_size++;
if (VAR_14) {
goto error;
}
} else if (!strcmp(VAR_6->name, ""if-feature"")) {
VAR_14 = fill_yin_iffeature(VAR_10, 0, VAR_6, &VAR_11->iffeature[VAR_11->iffeature_size], VAR_4);
VAR_11->iffeature_size++;
if (VAR_14) {
goto error;
}
}
}
lyp_reduce_ext_list(&VAR_10->ext, VAR_10->ext_size, VAR_18 + VAR_10->ext_size);
LY_TREE_FOR_SAFE(VAR_8.child, VAR_7, VAR_6) {
if (!strcmp(VAR_6->name, ""container"")) {
VAR_9 = read_yin_container(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
} else if (!strcmp(VAR_6->name, ""leaf-list"")) {
VAR_9 = read_yin_leaflist(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
} else if (!strcmp(VAR_6->name, ""leaf"")) {
VAR_9 = read_yin_leaf(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
} else if (!strcmp(VAR_6->name, ""list"")) {
VAR_9 = read_yin_list(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
} else if (!strcmp(VAR_6->name, ""choice"")) {
VAR_9 = read_yin_choice(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
} else if (!strcmp(VAR_6->name, ""uses"")) {
VAR_9 = read_yin_uses(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
} else if (!strcmp(VAR_6->name, ""grouping"")) {
VAR_9 = read_yin_grouping(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
} else if (!strcmp(VAR_6->name, ""anyxml"")) {
VAR_9 = read_yin_anydata(VAR_0, VAR_10, VAR_6, VAR_35, VAR_3, VAR_4);
} else if (!strcmp(VAR_6->name, ""anydata"")) {
VAR_9 = read_yin_anydata(VAR_0, VAR_10, VAR_6, VAR_36, VAR_3, VAR_4);
} else if (!strcmp(VAR_6->name, ""action"")) {
VAR_9 = read_yin_rpc_action(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
} else if (!strcmp(VAR_6->name, ""notification"")) {
VAR_9 = read_yin_notif(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
}
if (!VAR_9) {
goto error;
}
lyxml_free(VAR_5, VAR_6);
}
if (!(VAR_5->models.flags & VAR_37) && (VAR_11->when || VAR_11->must)) {
if (VAR_3 & VAR_38) {
if (lyxp_node_check_syntax(VAR_10)) {
goto error;
}
} else {
if (unres_schema_add_node(VAR_0, VAR_4, VAR_10, VAR_39, NULL) == -1) {
goto error;
}
}
}
for (VAR_14 = 0; VAR_14 < VAR_10->ext_size; ++VAR_14) {
if (VAR_10->ext[VAR_14]->flags & VAR_40) {
VAR_10->flags |= VAR_41;
if (VAR_10->ext[VAR_14]->flags & VAR_42) {
VAR_10->flags |= VAR_43;
break;
}
}
}
return VAR_10;
error:
lys_node_free(VAR_5, VAR_10, NULL, 0);
while (VAR_8.child) {
lyxml_free(VAR_5, VAR_8.child);
}
return NULL;
}",CESNET/libyang/a3917d95d516e3de267d3cfa5d4d3715a90e8777/parser_yin.c/vul/before/4.json,"static struct lys_node *
read_yin_container(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options,
                   struct unres_schema *unres)
{
    struct ly_ctx *ctx = module->ctx;
    struct lyxml_elem *sub, *next, root;
    struct lys_node *node = NULL;
    struct lys_node *retval;
    struct lys_node_container *cont;
    const char *value;
    void *reallocated;
    int r;
    int c_tpdf = 0, c_must = 0, c_ftrs = 0, c_ext = 0;

    /* init */
    memset(&root, 0, sizeof root);

    cont = calloc(1, sizeof *cont);
    LY_CHECK_ERR_RETURN(!cont, LOGMEM(ctx), NULL);

    cont->nodetype = LYS_CONTAINER;
    cont->prev = (struct lys_node *)cont;
    retval = (struct lys_node *)cont;

    if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,
            OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :
                (options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT),
            unres)) {
        goto error;
    }

    LOGDBG(LY_LDGYIN, ""parsing %s statement \""%s\"""", yin->name, retval->name);

    /* insert the node into the schema tree */
    if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {
        goto error;
    }

    /* process container's specific children */
    LY_TREE_FOR_SAFE(yin->child, next, sub) {
        if (strcmp(sub->ns->value, LY_NSYIN)) {
            /* extension */
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, ""extensions"", ""container"", error);
            c_ext++;
        } else if (!strcmp(sub->name, ""presence"")) {
            if (cont->presence) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }
            GETVAL(ctx, value, sub, ""value"");
            cont->presence = lydict_insert(ctx, value, strlen(value));

            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_PRESENCE, 0, unres)) {
                goto error;
            }
            lyxml_free(ctx, sub);
        } else if (!strcmp(sub->name, ""when"")) {
            if (cont->when) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }

            cont->when = read_yin_when(module, sub, unres);
            if (!cont->when) {
                lyxml_free(ctx, sub);
                goto error;
            }
            lyxml_free(ctx, sub);

            /* data statements */
        } else if (!strcmp(sub->name, ""container"") ||
                !strcmp(sub->name, ""leaf-list"") ||
                !strcmp(sub->name, ""leaf"") ||
                !strcmp(sub->name, ""list"") ||
                !strcmp(sub->name, ""choice"") ||
                !strcmp(sub->name, ""uses"") ||
                !strcmp(sub->name, ""grouping"") ||
                !strcmp(sub->name, ""anyxml"") ||
                !strcmp(sub->name, ""anydata"") ||
                !strcmp(sub->name, ""action"") ||
                !strcmp(sub->name, ""notification"")) {
            lyxml_unlink_elem(ctx, sub, 2);
            lyxml_add_child(ctx, &root, sub);

            /* array counters */
        } else if (!strcmp(sub->name, ""typedef"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_tpdf, cont->tpdf_size, ""typedefs"", ""container"", error);
            c_tpdf++;
        } else if (!strcmp(sub->name, ""must"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, cont->must_size, ""musts"", ""container"", error);
            c_must++;
        } else if (!strcmp(sub->name, ""if-feature"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, ""if-features"", ""container"", error);
            c_ftrs++;
        } else {
            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);
            goto error;
        }
    }

    /* middle part - process nodes with cardinality of 0..n except the data nodes */
    if (c_tpdf) {
        cont->tpdf = calloc(c_tpdf, sizeof *cont->tpdf);
        LY_CHECK_ERR_GOTO(!cont->tpdf, LOGMEM(ctx), error);
    }
    if (c_must) {
        cont->must = calloc(c_must, sizeof *cont->must);
        LY_CHECK_ERR_GOTO(!cont->must, LOGMEM(ctx), error);
    }
    if (c_ftrs) {
        cont->iffeature = calloc(c_ftrs, sizeof *cont->iffeature);
        LY_CHECK_ERR_GOTO(!cont->iffeature, LOGMEM(ctx), error);
    }
    if (c_ext) {
        /* some extensions may be already present from the substatements */
        reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);
        LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);
        retval->ext = reallocated;

        /* init memory */
        memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);
    }

    LY_TREE_FOR_SAFE(yin->child, next, sub) {
        if (strcmp(sub->ns->value, LY_NSYIN)) {
            /* extension */
            r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);
            if (r) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""typedef"")) {
            r = fill_yin_typedef(module, retval, sub, &cont->tpdf[cont->tpdf_size], unres);
            cont->tpdf_size++;
            if (r) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""must"")) {
            r = fill_yin_must(module, sub, &cont->must[cont->must_size], unres);
            cont->must_size++;
            if (r) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""if-feature"")) {
            r = fill_yin_iffeature(retval, 0, sub, &cont->iffeature[cont->iffeature_size], unres);
            cont->iffeature_size++;
            if (r) {
                goto error;
            }
        }
    }

    lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);

    /* last part - process data nodes */
    LY_TREE_FOR_SAFE(root.child, next, sub) {
        if (!strcmp(sub->name, ""container"")) {
            node = read_yin_container(module, retval, sub, options, unres);
        } else if (!strcmp(sub->name, ""leaf-list"")) {
            node = read_yin_leaflist(module, retval, sub, options, unres);
        } else if (!strcmp(sub->name, ""leaf"")) {
            node = read_yin_leaf(module, retval, sub, options, unres);
        } else if (!strcmp(sub->name, ""list"")) {
            node = read_yin_list(module, retval, sub, options, unres);
        } else if (!strcmp(sub->name, ""choice"")) {
            node = read_yin_choice(module, retval, sub, options, unres);
        } else if (!strcmp(sub->name, ""uses"")) {
            node = read_yin_uses(module, retval, sub, options, unres);
        } else if (!strcmp(sub->name, ""grouping"")) {
            node = read_yin_grouping(module, retval, sub, options, unres);
        } else if (!strcmp(sub->name, ""anyxml"")) {
            node = read_yin_anydata(module, retval, sub, LYS_ANYXML, options, unres);
        } else if (!strcmp(sub->name, ""anydata"")) {
            node = read_yin_anydata(module, retval, sub, LYS_ANYDATA, options, unres);
        } else if (!strcmp(sub->name, ""action"")) {
            node = read_yin_rpc_action(module, retval, sub, options, unres);
        } else if (!strcmp(sub->name, ""notification"")) {
            node = read_yin_notif(module, retval, sub, options, unres);
        }
        if (!node) {
            goto error;
        }

        lyxml_free(ctx, sub);
    }

    /* check XPath dependencies */
    if (!(ctx->models.flags & LY_CTX_TRUSTED) && (cont->when || cont->must)) {
        if (options & LYS_PARSE_OPT_INGRP) {
            if (lyxp_node_check_syntax(retval)) {
                goto error;
            }
        } else {
            if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {
                goto error;
            }
        }
    }

    for (r = 0; r < retval->ext_size; ++r) {
        /* extension instance may not yet be resolved */
        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {
             /* set flag, which represent LYEXT_OPT_VALID */
            retval->flags |= LYS_VALID_EXT;
            if (retval->ext[r]->flags & LYEXT_OPT_VALID_SUBTREE) {
                retval->flags |= LYS_VALID_EXT_SUBTREE;
                break;
            }
        }
    }

    return retval;

error:
    lys_node_free(ctx, retval, NULL, 0);
    while (root.child) {
        lyxml_free(ctx, root.child);
    }
    return NULL;
}","static struct lys_node *
read_yin_container(struct lys_module *VAR_0, struct lys_node *VAR_1, struct lyxml_elem *VAR_2, int VAR_3,
                   struct unres_schema *VAR_4)
{
    struct ly_ctx *VAR_5 = VAR_0->ctx;
    struct lyxml_elem *VAR_6, *VAR_7, VAR_8;
    struct lys_node *VAR_9 = NULL;
    struct lys_node *VAR_10;
    struct lys_node_container *VAR_11;
    const char *VAR_12;
    void *VAR_13;
    int VAR_14;
    int VAR_15 = 0, VAR_16 = 0, VAR_17 = 0, VAR_18 = 0;

    /* COMMENT_0 */
    memset(&VAR_8, 0, sizeof VAR_8);

    VAR_11 = calloc(1, sizeof *VAR_11);
    LY_CHECK_ERR_RETURN(!VAR_11, LOGMEM(VAR_5), NULL);

    VAR_11->nodetype = VAR_19;
    VAR_11->prev = (struct lys_node *)VAR_11;
    VAR_10 = (struct lys_node *)VAR_11;

    if (read_yin_common(VAR_0, VAR_1, VAR_10, VAR_20, VAR_2,
            VAR_21 | VAR_22 | ((VAR_3 & VAR_23) ? VAR_24 :
                (VAR_3 & VAR_25) ? VAR_26 : VAR_26 | VAR_27),
            VAR_4)) {
        goto error;
    }

    LOGDBG(VAR_28, ""parsing %s statement \""%s\"""", VAR_2->name, VAR_10->name);

    /* COMMENT_1 */
    if (lys_node_addchild(VAR_1, lys_main_module(VAR_0), VAR_10, VAR_3)) {
        goto error;
    }

    /* COMMENT_2 */
    LY_TREE_FOR_SAFE(VAR_2->child, VAR_7, VAR_6) {
        if (strcmp(VAR_6->ns->value, VAR_29)) {
            /* COMMENT_3 */
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_18, VAR_10->ext_size, ""extensions"", ""container"", VAR_30);
            VAR_18++;
        } else if (!strcmp(VAR_6->name, ""presence"")) {
            if (VAR_11->presence) {
                LOGVAL(VAR_5, VAR_31, VAR_32, VAR_10, VAR_6->name, VAR_2->name);
                goto error;
            }
            GETVAL(VAR_5, VAR_12, VAR_6, ""value"");
            VAR_11->presence = lydict_insert(VAR_5, VAR_12, strlen(VAR_12));

            if (lyp_yin_parse_subnode_ext(VAR_0, VAR_10, VAR_20, VAR_6, VAR_33, 0, VAR_4)) {
                goto error;
            }
            lyxml_free(VAR_5, VAR_6);
        } else if (!strcmp(VAR_6->name, ""when"")) {
            if (VAR_11->when) {
                LOGVAL(VAR_5, VAR_31, VAR_32, VAR_10, VAR_6->name, VAR_2->name);
                goto error;
            }

            VAR_11->when = read_yin_when(VAR_0, VAR_6, VAR_4);
            if (!VAR_11->when) {
                lyxml_free(VAR_5, VAR_6);
                goto error;
            }
            lyxml_free(VAR_5, VAR_6);

            /* COMMENT_4 */
        } else if (!strcmp(VAR_6->name, ""container"") ||
                !strcmp(VAR_6->name, ""leaf-list"") ||
                !strcmp(VAR_6->name, ""leaf"") ||
                !strcmp(VAR_6->name, ""list"") ||
                !strcmp(VAR_6->name, ""choice"") ||
                !strcmp(VAR_6->name, ""uses"") ||
                !strcmp(VAR_6->name, ""grouping"") ||
                !strcmp(VAR_6->name, ""anyxml"") ||
                !strcmp(VAR_6->name, ""anydata"") ||
                !strcmp(VAR_6->name, ""action"") ||
                !strcmp(VAR_6->name, ""notification"")) {
            lyxml_unlink_elem(VAR_5, VAR_6, 2);
            lyxml_add_child(VAR_5, &VAR_8, VAR_6);

            /* COMMENT_5 */
        } else if (!strcmp(VAR_6->name, ""typedef"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_15, VAR_11->tpdf_size, ""typedefs"", ""container"", VAR_30);
            VAR_15++;
        } else if (!strcmp(VAR_6->name, ""must"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_16, VAR_11->must_size, ""musts"", ""container"", VAR_30);
            VAR_16++;
        } else if (!strcmp(VAR_6->name, ""if-feature"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_17, VAR_10->iffeature_size, ""if-features"", ""container"", VAR_30);
            VAR_17++;
        } else {
            LOGVAL(VAR_5, VAR_34, VAR_32, VAR_10, VAR_6->name);
            goto error;
        }
    }

    /* COMMENT_6 */
    if (VAR_15) {
        VAR_11->tpdf = calloc(VAR_15, sizeof *VAR_11->tpdf);
        LY_CHECK_ERR_GOTO(!VAR_11->tpdf, LOGMEM(VAR_5), VAR_30);
    }
    if (VAR_16) {
        VAR_11->must = calloc(VAR_16, sizeof *VAR_11->must);
        LY_CHECK_ERR_GOTO(!VAR_11->must, LOGMEM(VAR_5), VAR_30);
    }
    if (VAR_17) {
        VAR_11->iffeature = calloc(VAR_17, sizeof *VAR_11->iffeature);
        LY_CHECK_ERR_GOTO(!VAR_11->iffeature, LOGMEM(VAR_5), VAR_30);
    }
    if (VAR_18) {
        /* COMMENT_7 */
        VAR_13 = realloc(VAR_10->ext, (VAR_18 + VAR_10->ext_size) * sizeof *VAR_10->ext);
        LY_CHECK_ERR_GOTO(!VAR_13, LOGMEM(VAR_5), VAR_30);
        VAR_10->ext = VAR_13;

        /* COMMENT_8 */
        memset(&VAR_10->ext[VAR_10->ext_size], 0, VAR_18 * sizeof *VAR_10->ext);
    }

    LY_TREE_FOR_SAFE(VAR_2->child, VAR_7, VAR_6) {
        if (strcmp(VAR_6->ns->value, VAR_29)) {
            /* COMMENT_3 */
            VAR_14 = lyp_yin_fill_ext(VAR_10, VAR_20, 0, 0, VAR_0, VAR_6, &VAR_10->ext, &VAR_10->ext_size, VAR_4);
            if (VAR_14) {
                goto error;
            }
        } else if (!strcmp(VAR_6->name, ""typedef"")) {
            VAR_14 = fill_yin_typedef(VAR_0, VAR_10, VAR_6, &VAR_11->tpdf[VAR_11->tpdf_size], VAR_4);
            VAR_11->tpdf_size++;
            if (VAR_14) {
                goto error;
            }
        } else if (!strcmp(VAR_6->name, ""must"")) {
            VAR_14 = fill_yin_must(VAR_0, VAR_6, &VAR_11->must[VAR_11->must_size], VAR_4);
            VAR_11->must_size++;
            if (VAR_14) {
                goto error;
            }
        } else if (!strcmp(VAR_6->name, ""if-feature"")) {
            VAR_14 = fill_yin_iffeature(VAR_10, 0, VAR_6, &VAR_11->iffeature[VAR_11->iffeature_size], VAR_4);
            VAR_11->iffeature_size++;
            if (VAR_14) {
                goto error;
            }
        }
    }

    lyp_reduce_ext_list(&VAR_10->ext, VAR_10->ext_size, VAR_18 + VAR_10->ext_size);

    /* COMMENT_9 */
    LY_TREE_FOR_SAFE(VAR_8.child, VAR_7, VAR_6) {
        if (!strcmp(VAR_6->name, ""container"")) {
            VAR_9 = read_yin_container(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
        } else if (!strcmp(VAR_6->name, ""leaf-list"")) {
            VAR_9 = read_yin_leaflist(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
        } else if (!strcmp(VAR_6->name, ""leaf"")) {
            VAR_9 = read_yin_leaf(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
        } else if (!strcmp(VAR_6->name, ""list"")) {
            VAR_9 = read_yin_list(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
        } else if (!strcmp(VAR_6->name, ""choice"")) {
            VAR_9 = read_yin_choice(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
        } else if (!strcmp(VAR_6->name, ""uses"")) {
            VAR_9 = read_yin_uses(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
        } else if (!strcmp(VAR_6->name, ""grouping"")) {
            VAR_9 = read_yin_grouping(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
        } else if (!strcmp(VAR_6->name, ""anyxml"")) {
            VAR_9 = read_yin_anydata(VAR_0, VAR_10, VAR_6, VAR_35, VAR_3, VAR_4);
        } else if (!strcmp(VAR_6->name, ""anydata"")) {
            VAR_9 = read_yin_anydata(VAR_0, VAR_10, VAR_6, VAR_36, VAR_3, VAR_4);
        } else if (!strcmp(VAR_6->name, ""action"")) {
            VAR_9 = read_yin_rpc_action(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
        } else if (!strcmp(VAR_6->name, ""notification"")) {
            VAR_9 = read_yin_notif(VAR_0, VAR_10, VAR_6, VAR_3, VAR_4);
        }
        if (!VAR_9) {
            goto error;
        }

        lyxml_free(VAR_5, VAR_6);
    }

    /* COMMENT_10 */
    if (!(VAR_5->models.flags & VAR_37) && (VAR_11->when || VAR_11->must)) {
        if (VAR_3 & VAR_38) {
            if (lyxp_node_check_syntax(VAR_10)) {
                goto error;
            }
        } else {
            if (unres_schema_add_node(VAR_0, VAR_4, VAR_10, VAR_39, NULL) == -1) {
                goto error;
            }
        }
    }

    for (VAR_14 = 0; VAR_14 < VAR_10->ext_size; ++VAR_14) {
        /* COMMENT_11 */
        if (VAR_10->ext[VAR_14] && (VAR_10->ext[VAR_14]->flags & VAR_40)) {
             /* COMMENT_12 */
            VAR_10->flags |= VAR_41;
            if (VAR_10->ext[VAR_14]->flags & VAR_42) {
                VAR_10->flags |= VAR_43;
                break;
            }
        }
    }

    return VAR_10;

error:
    lys_node_free(VAR_5, VAR_10, NULL, 0);
    while (VAR_8.child) {
        lyxml_free(VAR_5, VAR_8.child);
    }
    return NULL;
}",CESNET/libyang/a3917d95d516e3de267d3cfa5d4d3715a90e8777/parser_yin.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -197,8 +197,9 @@
     }
 
     for (r = 0; r < retval->ext_size; ++r) {
-        /* set flag, which represent LYEXT_OPT_VALID */
-        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {
+        /* extension instance may not yet be resolved */
+        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {
+             /* set flag, which represent LYEXT_OPT_VALID */
             retval->flags |= LYS_VALID_EXT;
             if (retval->ext[r]->flags & LYEXT_OPT_VALID_SUBTREE) {
                 retval->flags |= LYS_VALID_EXT_SUBTREE;","{'deleted_lines': ['        /* set flag, which represent LYEXT_OPT_VALID */', '        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {'], 'added_lines': ['        /* extension instance may not yet be resolved */', '        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {', '             /* set flag, which represent LYEXT_OPT_VALID */']}",True,"In function read_yin_container() in libyang <= v1.0.225, it doesn't check whether the value of retval->ext[r] is NULL. In some cases, it can be NULL, which leads to the operation of retval->ext[r]->flags that results in a crash.",7.5,HIGH,2,test,2021-03-08T13:08:05Z,3
CVE-2021-28902,['CWE-252'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,CESNET/libyang,"yin parser BUGFIX invalid memory access

... in case there were some unresolved
extensions.
Fixes #1454
Fixes #1455",a3917d95d516e3de267d3cfa5d4d3715a90e8777,https://github.com/CESNET/libyang/commit/a3917d95d516e3de267d3cfa5d4d3715a90e8777,src/parser_yin.c,read_yin_leaflist,"static struct lys_node *
read_yin_leaflist(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options,
struct unres_schema *unres)
{
struct ly_ctx *ctx = module->ctx;
struct lys_node *retval;
struct lys_node_leaflist *llist;
struct lyxml_elem *sub, *next;
const char *value;
char *endptr;
unsigned long val;
int r, has_type = 0;
int c_must = 0, c_ftrs = 0, c_dflt = 0, c_ext = 0;
int f_ordr = 0, f_min = 0, f_max = 0;
void *reallocated;
llist = calloc(1, sizeof *llist);
LY_CHECK_ERR_RETURN(!llist, LOGMEM(ctx), NULL);
llist->nodetype = LYS_LEAFLIST;
llist->prev = (struct lys_node *)llist;
retval = (struct lys_node *)llist;
if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,
OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :
(options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT),
unres)) {
goto error;
}
LOGDBG(LY_LDGYIN, ""parsing %s statement \""%s\"""", yin->name, retval->name);
if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {
goto error;
}
LY_TREE_FOR_SAFE(yin->child, next, sub) {
if (strcmp(sub->ns->value, LY_NSYIN)) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, ""extensions"", ""leaf-list"", error);
c_ext++;
continue;
} else if (!strcmp(sub->name, ""type"")) {
if (has_type) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
llist->type.der = (struct lys_tpdf *)sub;
llist->type.parent = (struct lys_tpdf *)llist;
has_type = 1;
} else if (!strcmp(sub->name, ""units"")) {
if (llist->units) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
GETVAL(ctx, value, sub, ""name"");
llist->units = lydict_insert(ctx, value, strlen(value));
if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_UNITS, 0, unres)) {
goto error;
}
} else if (!strcmp(sub->name, ""ordered-by"")) {
if (f_ordr) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
f_ordr = 1;
if (llist->flags & LYS_CONFIG_R) {
lyxml_free(ctx, sub);
continue;
}
GETVAL(ctx, value, sub, ""value"");
if (!strcmp(value, ""user"")) {
llist->flags |= LYS_USERORDERED;
} else if (strcmp(value, ""system"")) {
LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
goto error;
} 
if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_ORDEREDBY, 0, unres)) {
goto error;
}
} else if (!strcmp(sub->name, ""must"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, llist->must_size, ""musts"", ""leaf-list"", error);
c_must++;
continue;
} else if (!strcmp(sub->name, ""if-feature"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, ""if-features"", ""leaf-list"", error);
c_ftrs++;
continue;
} else if ((module->version >= 2) && !strcmp(sub->name, ""default"")) {
if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_DEFAULT, c_dflt, unres)) {
goto error;
}
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_dflt, llist->dflt_size, ""defaults"", ""leaf-list"", error);
c_dflt++;
continue;
} else if (!strcmp(sub->name, ""min-elements"")) {
if (f_min) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
f_min = 1;
GETVAL(ctx, value, sub, ""value"");
while (isspace(value[0])) {
value++;
}
errno = 0;
endptr = NULL;
val = strtoul(value, &endptr, 10);
if (*endptr || value[0] == '-' || errno || val > UINT32_MAX) {
LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
goto error;
}
llist->min = (uint32_t) val;
if (llist->max && (llist->min > llist->max)) {
LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, ""\""min-elements\"" is bigger than \""max-elements\""."");
goto error;
}
if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MIN, 0, unres)) {
goto error;
}
} else if (!strcmp(sub->name, ""max-elements"")) {
if (f_max) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
f_max = 1;
GETVAL(ctx, value, sub, ""value"");
while (isspace(value[0])) {
value++;
}
if (!strcmp(value, ""unbounded"")) {
llist->max = 0;
} else {
errno = 0;
endptr = NULL;
val = strtoul(value, &endptr, 10);
if (*endptr || value[0] == '-' || errno || val == 0 || val > UINT32_MAX) {
LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
goto error;
}
llist->max = (uint32_t) val;
if (llist->min > llist->max) {
LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, ""\""max-elements\"" is smaller than \""min-elements\""."");
goto error;
}
}
if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MAX, 0, unres)) {
goto error;
}
} else if (!strcmp(sub->name, ""when"")) {
if (llist->when) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
llist->when = read_yin_when(module, sub, unres);
if (!llist->when) {
goto error;
}
} else {
LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);
goto error;
}
}
if (!has_type) {
LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, retval, ""type"", yin->name);
goto error;
}
if (c_must) {
llist->must = calloc(c_must, sizeof *llist->must);
LY_CHECK_ERR_GOTO(!llist->must, LOGMEM(ctx), error);
}
if (c_ftrs) {
llist->iffeature = calloc(c_ftrs, sizeof *llist->iffeature);
LY_CHECK_ERR_GOTO(!llist->iffeature, LOGMEM(ctx), error);
}
if (c_dflt) {
llist->dflt = calloc(c_dflt, sizeof *llist->dflt);
LY_CHECK_ERR_GOTO(!llist->dflt, LOGMEM(ctx), error);
}
if (c_ext) {
reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);
LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);
retval->ext = reallocated;
memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);
}
LY_TREE_FOR_SAFE(yin->child, next, sub) {
if (strcmp(sub->ns->value, LY_NSYIN)) {
r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);
if (r) {
goto error;
}
} else if (!strcmp(sub->name, ""must"")) {
r = fill_yin_must(module, sub, &llist->must[llist->must_size], unres);
llist->must_size++;
if (r) {
goto error;
}
} else if (!strcmp(sub->name, ""if-feature"")) {
r = fill_yin_iffeature(retval, 0, sub, &llist->iffeature[llist->iffeature_size], unres);
llist->iffeature_size++;
if (r) {
goto error;
}
} else if (!strcmp(sub->name, ""default"")) {
GETVAL(ctx, value, sub, ""value"");
if (llist->flags & LYS_CONFIG_W) {
for (r = 0; r < llist->dflt_size; r++) {
if (ly_strequal(llist->dflt[r], value, 1)) {
LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, ""default"");
LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, ""Duplicated default value \""%s\""."", value);
goto error;
}
}
}
llist->dflt[llist->dflt_size++] = lydict_insert(ctx, value, strlen(value));
}
}
lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);
if (unres_schema_add_node(module, unres, &llist->type, UNRES_TYPE_DER, retval) == -1) {
llist->type.der = NULL;
goto error;
}
if (llist->dflt_size && llist->min) {
LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, retval, ""min-elements"", ""leaf-list"");
LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,
""The \""min-elements\"" statement with non-zero value is forbidden on leaf-lists with the \""default\"" statement."");
goto error;
}
for (r = 0; r < llist->dflt_size; r++) {
if (!(ctx->models.flags & LY_CTX_TRUSTED) &&
(unres_schema_add_node(module, unres, &llist->type, UNRES_TYPE_DFLT,
(struct lys_node *)(&llist->dflt[r])) == -1)) {
goto error;
}
}
if (!(ctx->models.flags & LY_CTX_TRUSTED) && (llist->when || llist->must)) {
if (options & LYS_PARSE_OPT_INGRP) {
if (lyxp_node_check_syntax(retval)) {
goto error;
}
} else {
if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {
goto error;
}
}
}
for (r = 0; r < retval->ext_size; ++r) {
if (retval->ext[r]->flags & LYEXT_OPT_VALID) {
retval->flags |= LYS_VALID_EXT;
break;
}
}
return retval;
error:
lys_node_free(ctx, retval, NULL, 0);
return NULL;
}","static struct lys_node *
read_yin_leaflist(struct lys_module *VAR_0, struct lys_node *VAR_1, struct lyxml_elem *VAR_2, int VAR_3,
struct unres_schema *VAR_4)
{
struct ly_ctx *VAR_5 = VAR_0->ctx;
struct lys_node *VAR_6;
struct lys_node_leaflist *VAR_7;
struct lyxml_elem *VAR_8, *VAR_9;
const char *VAR_10;
char *VAR_11;
unsigned long VAR_12;
int VAR_13, VAR_14 = 0;
int VAR_15 = 0, VAR_16 = 0, VAR_17 = 0, VAR_18 = 0;
int VAR_19 = 0, VAR_20 = 0, VAR_21 = 0;
void *VAR_22;
VAR_7 = calloc(1, sizeof *VAR_7);
LY_CHECK_ERR_RETURN(!VAR_7, LOGMEM(VAR_5), NULL);
VAR_7->nodetype = VAR_23;
VAR_7->prev = (struct lys_node *)VAR_7;
VAR_6 = (struct lys_node *)VAR_7;
if (read_yin_common(VAR_0, VAR_1, VAR_6, VAR_24, VAR_2,
VAR_25 | VAR_26 | ((VAR_3 & VAR_27) ? VAR_28 :
(VAR_3 & VAR_29) ? VAR_30 : VAR_30 | VAR_31),
VAR_4)) {
goto error;
}
LOGDBG(VAR_32, ""parsing %s statement \""%s\"""", VAR_2->name, VAR_6->name);
if (lys_node_addchild(VAR_1, lys_main_module(VAR_0), VAR_6, VAR_3)) {
goto error;
}
LY_TREE_FOR_SAFE(VAR_2->child, VAR_9, VAR_8) {
if (strcmp(VAR_8->ns->value, VAR_33)) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_18, VAR_6->ext_size, ""extensions"", ""leaf-list"", VAR_34);
VAR_18++;
continue;
} else if (!strcmp(VAR_8->name, ""type"")) {
if (VAR_14) {
LOGVAL(VAR_5, VAR_35, VAR_36, VAR_6, VAR_8->name, VAR_2->name);
goto error;
}
VAR_7->type.der = (struct lys_tpdf *)VAR_8;
VAR_7->type.parent = (struct lys_tpdf *)VAR_7;
VAR_14 = 1;
} else if (!strcmp(VAR_8->name, ""units"")) {
if (VAR_7->units) {
LOGVAL(VAR_5, VAR_35, VAR_36, VAR_6, VAR_8->name, VAR_2->name);
goto error;
}
GETVAL(VAR_5, VAR_10, VAR_8, ""name"");
VAR_7->units = lydict_insert(VAR_5, VAR_10, strlen(VAR_10));
if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_24, VAR_8, VAR_37, 0, VAR_4)) {
goto error;
}
} else if (!strcmp(VAR_8->name, ""ordered-by"")) {
if (VAR_19) {
LOGVAL(VAR_5, VAR_35, VAR_36, VAR_6, VAR_8->name, VAR_2->name);
goto error;
}
VAR_19 = 1;
if (VAR_7->flags & VAR_38) {
lyxml_free(VAR_5, VAR_8);
continue;
}
GETVAL(VAR_5, VAR_10, VAR_8, ""value"");
if (!strcmp(VAR_10, ""user"")) {
VAR_7->flags |= VAR_39;
} else if (strcmp(VAR_10, ""system"")) {
LOGVAL(VAR_5, VAR_40, VAR_36, VAR_6, VAR_10, VAR_8->name);
goto error;
} 
if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_24, VAR_8, VAR_41, 0, VAR_4)) {
goto error;
}
} else if (!strcmp(VAR_8->name, ""must"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_15, VAR_7->must_size, ""musts"", ""leaf-list"", VAR_34);
VAR_15++;
continue;
} else if (!strcmp(VAR_8->name, ""if-feature"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_16, VAR_6->iffeature_size, ""if-features"", ""leaf-list"", VAR_34);
VAR_16++;
continue;
} else if ((VAR_0->version >= 2) && !strcmp(VAR_8->name, ""default"")) {
if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_24, VAR_8, VAR_42, VAR_17, VAR_4)) {
goto error;
}
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_17, VAR_7->dflt_size, ""defaults"", ""leaf-list"", VAR_34);
VAR_17++;
continue;
} else if (!strcmp(VAR_8->name, ""min-elements"")) {
if (VAR_20) {
LOGVAL(VAR_5, VAR_35, VAR_36, VAR_6, VAR_8->name, VAR_2->name);
goto error;
}
VAR_20 = 1;
GETVAL(VAR_5, VAR_10, VAR_8, ""value"");
while (isspace(VAR_10[0])) {
VAR_10++;
}
VAR_43 = 0;
VAR_11 = NULL;
VAR_12 = strtoul(VAR_10, &VAR_11, 10);
if (*VAR_11 || VAR_10[0] == '-' || VAR_43 || VAR_12 > VAR_44) {
LOGVAL(VAR_5, VAR_40, VAR_36, VAR_6, VAR_10, VAR_8->name);
goto error;
}
VAR_7->min = (uint32_t) VAR_12;
if (VAR_7->max && (VAR_7->min > VAR_7->max)) {
LOGVAL(VAR_5, VAR_40, VAR_36, VAR_6, VAR_10, VAR_8->name);
LOGVAL(VAR_5, VAR_45, VAR_46, NULL, ""\""min-elements\"" is bigger than \""max-elements\""."");
goto error;
}
if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_24, VAR_8, VAR_47, 0, VAR_4)) {
goto error;
}
} else if (!strcmp(VAR_8->name, ""max-elements"")) {
if (VAR_21) {
LOGVAL(VAR_5, VAR_35, VAR_36, VAR_6, VAR_8->name, VAR_2->name);
goto error;
}
VAR_21 = 1;
GETVAL(VAR_5, VAR_10, VAR_8, ""value"");
while (isspace(VAR_10[0])) {
VAR_10++;
}
if (!strcmp(VAR_10, ""unbounded"")) {
VAR_7->max = 0;
} else {
VAR_43 = 0;
VAR_11 = NULL;
VAR_12 = strtoul(VAR_10, &VAR_11, 10);
if (*VAR_11 || VAR_10[0] == '-' || VAR_43 || VAR_12 == 0 || VAR_12 > VAR_44) {
LOGVAL(VAR_5, VAR_40, VAR_36, VAR_6, VAR_10, VAR_8->name);
goto error;
}
VAR_7->max = (uint32_t) VAR_12;
if (VAR_7->min > VAR_7->max) {
LOGVAL(VAR_5, VAR_40, VAR_36, VAR_6, VAR_10, VAR_8->name);
LOGVAL(VAR_5, VAR_45, VAR_46, NULL, ""\""max-elements\"" is smaller than \""min-elements\""."");
goto error;
}
}
if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_24, VAR_8, VAR_48, 0, VAR_4)) {
goto error;
}
} else if (!strcmp(VAR_8->name, ""when"")) {
if (VAR_7->when) {
LOGVAL(VAR_5, VAR_35, VAR_36, VAR_6, VAR_8->name, VAR_2->name);
goto error;
}
VAR_7->when = read_yin_when(VAR_0, VAR_8, VAR_4);
if (!VAR_7->when) {
goto error;
}
} else {
LOGVAL(VAR_5, VAR_49, VAR_36, VAR_6, VAR_8->name);
goto error;
}
}
if (!VAR_14) {
LOGVAL(VAR_5, VAR_50, VAR_36, VAR_6, ""type"", VAR_2->name);
goto error;
}
if (VAR_15) {
VAR_7->must = calloc(VAR_15, sizeof *VAR_7->must);
LY_CHECK_ERR_GOTO(!VAR_7->must, LOGMEM(VAR_5), VAR_34);
}
if (VAR_16) {
VAR_7->iffeature = calloc(VAR_16, sizeof *VAR_7->iffeature);
LY_CHECK_ERR_GOTO(!VAR_7->iffeature, LOGMEM(VAR_5), VAR_34);
}
if (VAR_17) {
VAR_7->dflt = calloc(VAR_17, sizeof *VAR_7->dflt);
LY_CHECK_ERR_GOTO(!VAR_7->dflt, LOGMEM(VAR_5), VAR_34);
}
if (VAR_18) {
VAR_22 = realloc(VAR_6->ext, (VAR_18 + VAR_6->ext_size) * sizeof *VAR_6->ext);
LY_CHECK_ERR_GOTO(!VAR_22, LOGMEM(VAR_5), VAR_34);
VAR_6->ext = VAR_22;
memset(&VAR_6->ext[VAR_6->ext_size], 0, VAR_18 * sizeof *VAR_6->ext);
}
LY_TREE_FOR_SAFE(VAR_2->child, VAR_9, VAR_8) {
if (strcmp(VAR_8->ns->value, VAR_33)) {
VAR_13 = lyp_yin_fill_ext(VAR_6, VAR_24, 0, 0, VAR_0, VAR_8, &VAR_6->ext, &VAR_6->ext_size, VAR_4);
if (VAR_13) {
goto error;
}
} else if (!strcmp(VAR_8->name, ""must"")) {
VAR_13 = fill_yin_must(VAR_0, VAR_8, &VAR_7->must[VAR_7->must_size], VAR_4);
VAR_7->must_size++;
if (VAR_13) {
goto error;
}
} else if (!strcmp(VAR_8->name, ""if-feature"")) {
VAR_13 = fill_yin_iffeature(VAR_6, 0, VAR_8, &VAR_7->iffeature[VAR_7->iffeature_size], VAR_4);
VAR_7->iffeature_size++;
if (VAR_13) {
goto error;
}
} else if (!strcmp(VAR_8->name, ""default"")) {
GETVAL(VAR_5, VAR_10, VAR_8, ""value"");
if (VAR_7->flags & VAR_51) {
for (VAR_13 = 0; VAR_13 < VAR_7->dflt_size; VAR_13++) {
if (ly_strequal(VAR_7->dflt[VAR_13], VAR_10, 1)) {
LOGVAL(VAR_5, VAR_40, VAR_36, VAR_6, VAR_10, ""default"");
LOGVAL(VAR_5, VAR_45, VAR_46, NULL, ""Duplicated default value \""%s\""."", VAR_10);
goto error;
}
}
}
VAR_7->dflt[VAR_7->dflt_size++] = lydict_insert(VAR_5, VAR_10, strlen(VAR_10));
}
}
lyp_reduce_ext_list(&VAR_6->ext, VAR_6->ext_size, VAR_18 + VAR_6->ext_size);
if (unres_schema_add_node(VAR_0, VAR_4, &VAR_7->type, VAR_52, VAR_6) == -1) {
VAR_7->type.der = NULL;
goto error;
}
if (VAR_7->dflt_size && VAR_7->min) {
LOGVAL(VAR_5, VAR_53, VAR_36, VAR_6, ""min-elements"", ""leaf-list"");
LOGVAL(VAR_5, VAR_45, VAR_46, NULL,
""The \""min-elements\"" statement with non-zero value is forbidden on leaf-lists with the \""default\"" statement."");
goto error;
}
for (VAR_13 = 0; VAR_13 < VAR_7->dflt_size; VAR_13++) {
if (!(VAR_5->models.flags & VAR_54) &&
(unres_schema_add_node(VAR_0, VAR_4, &VAR_7->type, VAR_55,
(struct lys_node *)(&VAR_7->dflt[VAR_13])) == -1)) {
goto error;
}
}
if (!(VAR_5->models.flags & VAR_54) && (VAR_7->when || VAR_7->must)) {
if (VAR_3 & VAR_56) {
if (lyxp_node_check_syntax(VAR_6)) {
goto error;
}
} else {
if (unres_schema_add_node(VAR_0, VAR_4, VAR_6, VAR_57, NULL) == -1) {
goto error;
}
}
}
for (VAR_13 = 0; VAR_13 < VAR_6->ext_size; ++VAR_13) {
if (VAR_6->ext[VAR_13]->flags & VAR_58) {
VAR_6->flags |= VAR_59;
break;
}
}
return VAR_6;
error:
lys_node_free(VAR_5, VAR_6, NULL, 0);
return NULL;
}",CESNET/libyang/a3917d95d516e3de267d3cfa5d4d3715a90e8777/parser_yin.c/vul/before/3.json,"static struct lys_node *
read_yin_leaflist(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options,
                  struct unres_schema *unres)
{
    struct ly_ctx *ctx = module->ctx;
    struct lys_node *retval;
    struct lys_node_leaflist *llist;
    struct lyxml_elem *sub, *next;
    const char *value;
    char *endptr;
    unsigned long val;
    int r, has_type = 0;
    int c_must = 0, c_ftrs = 0, c_dflt = 0, c_ext = 0;
    int f_ordr = 0, f_min = 0, f_max = 0;
    void *reallocated;

    llist = calloc(1, sizeof *llist);
    LY_CHECK_ERR_RETURN(!llist, LOGMEM(ctx), NULL);

    llist->nodetype = LYS_LEAFLIST;
    llist->prev = (struct lys_node *)llist;
    retval = (struct lys_node *)llist;

    if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,
            OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :
                (options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT),
            unres)) {
        goto error;
    }

    LOGDBG(LY_LDGYIN, ""parsing %s statement \""%s\"""", yin->name, retval->name);

    /* insert the node into the schema tree */
    if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {
        goto error;
    }

    LY_TREE_FOR_SAFE(yin->child, next, sub) {
        if (strcmp(sub->ns->value, LY_NSYIN)) {
            /* extension */
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, ""extensions"", ""leaf-list"", error);
            c_ext++;
            continue;
        } else if (!strcmp(sub->name, ""type"")) {
            if (has_type) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }
            /* HACK for unres */
            llist->type.der = (struct lys_tpdf *)sub;
            llist->type.parent = (struct lys_tpdf *)llist;
            /* postpone type resolution when if-feature parsing is done since we need
             * if-feature for check_leafref_features() */
            has_type = 1;
        } else if (!strcmp(sub->name, ""units"")) {
            if (llist->units) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }
            GETVAL(ctx, value, sub, ""name"");
            llist->units = lydict_insert(ctx, value, strlen(value));

            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_UNITS, 0, unres)) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""ordered-by"")) {
            if (f_ordr) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }
            /* just checking the flags in llist is not sufficient, we would
             * allow multiple ordered-by statements with the ""system"" value
             */
            f_ordr = 1;

            if (llist->flags & LYS_CONFIG_R) {
                /* RFC 6020, 7.7.5 - ignore ordering when the list represents
                 * state data
                 */
                lyxml_free(ctx, sub);
                continue;
            }

            GETVAL(ctx, value, sub, ""value"");
            if (!strcmp(value, ""user"")) {
                llist->flags |= LYS_USERORDERED;
            } else if (strcmp(value, ""system"")) {
                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
                goto error;
            } /* else system is the default value, so we can ignore it */

            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_ORDEREDBY, 0, unres)) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""must"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, llist->must_size, ""musts"", ""leaf-list"", error);
            c_must++;
            continue;
        } else if (!strcmp(sub->name, ""if-feature"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, ""if-features"", ""leaf-list"", error);
            c_ftrs++;
            continue;
        } else if ((module->version >= 2) && !strcmp(sub->name, ""default"")) {
            /* read the default's extension instances */
            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_DEFAULT, c_dflt, unres)) {
                goto error;
            }

            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_dflt, llist->dflt_size, ""defaults"", ""leaf-list"", error);
            c_dflt++;
            continue;

        } else if (!strcmp(sub->name, ""min-elements"")) {
            if (f_min) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }
            f_min = 1;

            GETVAL(ctx, value, sub, ""value"");
            while (isspace(value[0])) {
                value++;
            }

            /* convert it to uint32_t */
            errno = 0;
            endptr = NULL;
            val = strtoul(value, &endptr, 10);
            if (*endptr || value[0] == '-' || errno || val > UINT32_MAX) {
                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
                goto error;
            }
            llist->min = (uint32_t) val;
            if (llist->max && (llist->min > llist->max)) {
                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, ""\""min-elements\"" is bigger than \""max-elements\""."");
                goto error;
            }

            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MIN, 0, unres)) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""max-elements"")) {
            if (f_max) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }
            f_max = 1;

            GETVAL(ctx, value, sub, ""value"");
            while (isspace(value[0])) {
                value++;
            }

            if (!strcmp(value, ""unbounded"")) {
                llist->max = 0;
            } else {
                /* convert it to uint32_t */
                errno = 0;
                endptr = NULL;
                val = strtoul(value, &endptr, 10);
                if (*endptr || value[0] == '-' || errno || val == 0 || val > UINT32_MAX) {
                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
                    goto error;
                }
                llist->max = (uint32_t) val;
                if (llist->min > llist->max) {
                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, ""\""max-elements\"" is smaller than \""min-elements\""."");
                    goto error;
                }
            }

            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MAX, 0, unres)) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""when"")) {
            if (llist->when) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }

            llist->when = read_yin_when(module, sub, unres);
            if (!llist->when) {
                goto error;
            }
        } else {
            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);
            goto error;
        }

        /* do not free sub, it could have been unlinked and stored in unres */
    }

    /* check constraints */
    if (!has_type) {
        LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, retval, ""type"", yin->name);
        goto error;
    }

    /* middle part - process nodes with cardinality of 0..n */
    if (c_must) {
        llist->must = calloc(c_must, sizeof *llist->must);
        LY_CHECK_ERR_GOTO(!llist->must, LOGMEM(ctx), error);
    }
    if (c_ftrs) {
        llist->iffeature = calloc(c_ftrs, sizeof *llist->iffeature);
        LY_CHECK_ERR_GOTO(!llist->iffeature, LOGMEM(ctx), error);
    }
    if (c_dflt) {
        llist->dflt = calloc(c_dflt, sizeof *llist->dflt);
        LY_CHECK_ERR_GOTO(!llist->dflt, LOGMEM(ctx), error);
    }
    if (c_ext) {
        /* some extensions may be already present from the substatements */
        reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);
        LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);
        retval->ext = reallocated;

        /* init memory */
        memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);
    }

    LY_TREE_FOR_SAFE(yin->child, next, sub) {
        if (strcmp(sub->ns->value, LY_NSYIN)) {
            /* extension */
            r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);
            if (r) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""must"")) {
            r = fill_yin_must(module, sub, &llist->must[llist->must_size], unres);
            llist->must_size++;
            if (r) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""if-feature"")) {
            r = fill_yin_iffeature(retval, 0, sub, &llist->iffeature[llist->iffeature_size], unres);
            llist->iffeature_size++;
            if (r) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""default"")) {
            GETVAL(ctx, value, sub, ""value"");

            /* check for duplicity in case of configuration data,
             * in case of status data duplicities are allowed */
            if (llist->flags & LYS_CONFIG_W) {
                for (r = 0; r < llist->dflt_size; r++) {
                    if (ly_strequal(llist->dflt[r], value, 1)) {
                        LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, ""default"");
                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, ""Duplicated default value \""%s\""."", value);
                        goto error;
                    }
                }
            }
            llist->dflt[llist->dflt_size++] = lydict_insert(ctx, value, strlen(value));
        }
    }

    lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);

    /* finalize type parsing */
    if (unres_schema_add_node(module, unres, &llist->type, UNRES_TYPE_DER, retval) == -1) {
        llist->type.der = NULL;
        goto error;
    }

    if (llist->dflt_size && llist->min) {
        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, retval, ""min-elements"", ""leaf-list"");
        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,
               ""The \""min-elements\"" statement with non-zero value is forbidden on leaf-lists with the \""default\"" statement."");
        goto error;
    }

    /* check default value (if not defined, there still could be some restrictions
     * that need to be checked against a default value from a derived type) */
    for (r = 0; r < llist->dflt_size; r++) {
        if (!(ctx->models.flags & LY_CTX_TRUSTED) &&
                (unres_schema_add_node(module, unres, &llist->type, UNRES_TYPE_DFLT,
                                       (struct lys_node *)(&llist->dflt[r])) == -1)) {
            goto error;
        }
    }

    /* check XPath dependencies */
    if (!(ctx->models.flags & LY_CTX_TRUSTED) && (llist->when || llist->must)) {
        if (options & LYS_PARSE_OPT_INGRP) {
            if (lyxp_node_check_syntax(retval)) {
                goto error;
            }
        } else {
            if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {
                goto error;
            }
        }
    }

    for (r = 0; r < retval->ext_size; ++r) {
        /* set flag, which represent LYEXT_OPT_VALID */
        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {
            retval->flags |= LYS_VALID_EXT;
            break;
        }
    }

    return retval;

error:
    lys_node_free(ctx, retval, NULL, 0);
    return NULL;
}","static struct lys_node *
read_yin_leaflist(struct lys_module *VAR_0, struct lys_node *VAR_1, struct lyxml_elem *VAR_2, int VAR_3,
                  struct unres_schema *VAR_4)
{
    struct ly_ctx *VAR_5 = VAR_0->ctx;
    struct lys_node *VAR_6;
    struct lys_node_leaflist *VAR_7;
    struct lyxml_elem *VAR_8, *VAR_9;
    const char *VAR_10;
    char *VAR_11;
    unsigned long VAR_12;
    int VAR_13, VAR_14 = 0;
    int VAR_15 = 0, VAR_16 = 0, VAR_17 = 0, VAR_18 = 0;
    int VAR_19 = 0, VAR_20 = 0, VAR_21 = 0;
    void *VAR_22;

    VAR_7 = calloc(1, sizeof *VAR_7);
    LY_CHECK_ERR_RETURN(!VAR_7, LOGMEM(VAR_5), NULL);

    VAR_7->nodetype = VAR_23;
    VAR_7->prev = (struct lys_node *)VAR_7;
    VAR_6 = (struct lys_node *)VAR_7;

    if (read_yin_common(VAR_0, VAR_1, VAR_6, VAR_24, VAR_2,
            VAR_25 | VAR_26 | ((VAR_3 & VAR_27) ? VAR_28 :
                (VAR_3 & VAR_29) ? VAR_30 : VAR_30 | VAR_31),
            VAR_4)) {
        goto error;
    }

    LOGDBG(VAR_32, ""parsing %s statement \""%s\"""", VAR_2->name, VAR_6->name);

    /* COMMENT_0 */
    if (lys_node_addchild(VAR_1, lys_main_module(VAR_0), VAR_6, VAR_3)) {
        goto error;
    }

    LY_TREE_FOR_SAFE(VAR_2->child, VAR_9, VAR_8) {
        if (strcmp(VAR_8->ns->value, VAR_33)) {
            /* COMMENT_1 */
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_18, VAR_6->ext_size, ""extensions"", ""leaf-list"", VAR_34);
            VAR_18++;
            continue;
        } else if (!strcmp(VAR_8->name, ""type"")) {
            if (VAR_14) {
                LOGVAL(VAR_5, VAR_35, VAR_36, VAR_6, VAR_8->name, VAR_2->name);
                goto error;
            }
            /* COMMENT_2 */
            VAR_7->type.der = (struct lys_tpdf *)VAR_8;
            VAR_7->type.parent = (struct lys_tpdf *)VAR_7;
            /* COMMENT_3 */
                                                         
            VAR_14 = 1;
        } else if (!strcmp(VAR_8->name, ""units"")) {
            if (VAR_7->units) {
                LOGVAL(VAR_5, VAR_35, VAR_36, VAR_6, VAR_8->name, VAR_2->name);
                goto error;
            }
            GETVAL(VAR_5, VAR_10, VAR_8, ""name"");
            VAR_7->units = lydict_insert(VAR_5, VAR_10, strlen(VAR_10));

            if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_24, VAR_8, VAR_37, 0, VAR_4)) {
                goto error;
            }
        } else if (!strcmp(VAR_8->name, ""ordered-by"")) {
            if (VAR_19) {
                LOGVAL(VAR_5, VAR_35, VAR_36, VAR_6, VAR_8->name, VAR_2->name);
                goto error;
            }
            /* COMMENT_5 */
                                                                           
               
            VAR_19 = 1;

            if (VAR_7->flags & VAR_38) {
                /* COMMENT_8 */
                             
                   
                lyxml_free(VAR_5, VAR_8);
                continue;
            }

            GETVAL(VAR_5, VAR_10, VAR_8, ""value"");
            if (!strcmp(VAR_10, ""user"")) {
                VAR_7->flags |= VAR_39;
            } else if (strcmp(VAR_10, ""system"")) {
                LOGVAL(VAR_5, VAR_40, VAR_36, VAR_6, VAR_10, VAR_8->name);
                goto error;
            } /* COMMENT_11 */

            if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_24, VAR_8, VAR_41, 0, VAR_4)) {
                goto error;
            }
        } else if (!strcmp(VAR_8->name, ""must"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_15, VAR_7->must_size, ""musts"", ""leaf-list"", VAR_34);
            VAR_15++;
            continue;
        } else if (!strcmp(VAR_8->name, ""if-feature"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_16, VAR_6->iffeature_size, ""if-features"", ""leaf-list"", VAR_34);
            VAR_16++;
            continue;
        } else if ((VAR_0->version >= 2) && !strcmp(VAR_8->name, ""default"")) {
            /* COMMENT_12 */
            if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_24, VAR_8, VAR_42, VAR_17, VAR_4)) {
                goto error;
            }

            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_17, VAR_7->dflt_size, ""defaults"", ""leaf-list"", VAR_34);
            VAR_17++;
            continue;

        } else if (!strcmp(VAR_8->name, ""min-elements"")) {
            if (VAR_20) {
                LOGVAL(VAR_5, VAR_35, VAR_36, VAR_6, VAR_8->name, VAR_2->name);
                goto error;
            }
            VAR_20 = 1;

            GETVAL(VAR_5, VAR_10, VAR_8, ""value"");
            while (isspace(VAR_10[0])) {
                VAR_10++;
            }

            /* COMMENT_13 */
            VAR_43 = 0;
            VAR_11 = NULL;
            VAR_12 = strtoul(VAR_10, &VAR_11, 10);
            if (*VAR_11 || VAR_10[0] == '-' || VAR_43 || VAR_12 > VAR_44) {
                LOGVAL(VAR_5, VAR_40, VAR_36, VAR_6, VAR_10, VAR_8->name);
                goto error;
            }
            VAR_7->min = (uint32_t) VAR_12;
            if (VAR_7->max && (VAR_7->min > VAR_7->max)) {
                LOGVAL(VAR_5, VAR_40, VAR_36, VAR_6, VAR_10, VAR_8->name);
                LOGVAL(VAR_5, VAR_45, VAR_46, NULL, ""\""min-elements\"" is bigger than \""max-elements\""."");
                goto error;
            }

            if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_24, VAR_8, VAR_47, 0, VAR_4)) {
                goto error;
            }
        } else if (!strcmp(VAR_8->name, ""max-elements"")) {
            if (VAR_21) {
                LOGVAL(VAR_5, VAR_35, VAR_36, VAR_6, VAR_8->name, VAR_2->name);
                goto error;
            }
            VAR_21 = 1;

            GETVAL(VAR_5, VAR_10, VAR_8, ""value"");
            while (isspace(VAR_10[0])) {
                VAR_10++;
            }

            if (!strcmp(VAR_10, ""unbounded"")) {
                VAR_7->max = 0;
            } else {
                /* COMMENT_13 */
                VAR_43 = 0;
                VAR_11 = NULL;
                VAR_12 = strtoul(VAR_10, &VAR_11, 10);
                if (*VAR_11 || VAR_10[0] == '-' || VAR_43 || VAR_12 == 0 || VAR_12 > VAR_44) {
                    LOGVAL(VAR_5, VAR_40, VAR_36, VAR_6, VAR_10, VAR_8->name);
                    goto error;
                }
                VAR_7->max = (uint32_t) VAR_12;
                if (VAR_7->min > VAR_7->max) {
                    LOGVAL(VAR_5, VAR_40, VAR_36, VAR_6, VAR_10, VAR_8->name);
                    LOGVAL(VAR_5, VAR_45, VAR_46, NULL, ""\""max-elements\"" is smaller than \""min-elements\""."");
                    goto error;
                }
            }

            if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_24, VAR_8, VAR_48, 0, VAR_4)) {
                goto error;
            }
        } else if (!strcmp(VAR_8->name, ""when"")) {
            if (VAR_7->when) {
                LOGVAL(VAR_5, VAR_35, VAR_36, VAR_6, VAR_8->name, VAR_2->name);
                goto error;
            }

            VAR_7->when = read_yin_when(VAR_0, VAR_8, VAR_4);
            if (!VAR_7->when) {
                goto error;
            }
        } else {
            LOGVAL(VAR_5, VAR_49, VAR_36, VAR_6, VAR_8->name);
            goto error;
        }

        /* COMMENT_14 */
    }

    /* COMMENT_15 */
    if (!VAR_14) {
        LOGVAL(VAR_5, VAR_50, VAR_36, VAR_6, ""type"", VAR_2->name);
        goto error;
    }

    /* COMMENT_16 */
    if (VAR_15) {
        VAR_7->must = calloc(VAR_15, sizeof *VAR_7->must);
        LY_CHECK_ERR_GOTO(!VAR_7->must, LOGMEM(VAR_5), VAR_34);
    }
    if (VAR_16) {
        VAR_7->iffeature = calloc(VAR_16, sizeof *VAR_7->iffeature);
        LY_CHECK_ERR_GOTO(!VAR_7->iffeature, LOGMEM(VAR_5), VAR_34);
    }
    if (VAR_17) {
        VAR_7->dflt = calloc(VAR_17, sizeof *VAR_7->dflt);
        LY_CHECK_ERR_GOTO(!VAR_7->dflt, LOGMEM(VAR_5), VAR_34);
    }
    if (VAR_18) {
        /* COMMENT_17 */
        VAR_22 = realloc(VAR_6->ext, (VAR_18 + VAR_6->ext_size) * sizeof *VAR_6->ext);
        LY_CHECK_ERR_GOTO(!VAR_22, LOGMEM(VAR_5), VAR_34);
        VAR_6->ext = VAR_22;

        /* COMMENT_18 */
        memset(&VAR_6->ext[VAR_6->ext_size], 0, VAR_18 * sizeof *VAR_6->ext);
    }

    LY_TREE_FOR_SAFE(VAR_2->child, VAR_9, VAR_8) {
        if (strcmp(VAR_8->ns->value, VAR_33)) {
            /* COMMENT_1 */
            VAR_13 = lyp_yin_fill_ext(VAR_6, VAR_24, 0, 0, VAR_0, VAR_8, &VAR_6->ext, &VAR_6->ext_size, VAR_4);
            if (VAR_13) {
                goto error;
            }
        } else if (!strcmp(VAR_8->name, ""must"")) {
            VAR_13 = fill_yin_must(VAR_0, VAR_8, &VAR_7->must[VAR_7->must_size], VAR_4);
            VAR_7->must_size++;
            if (VAR_13) {
                goto error;
            }
        } else if (!strcmp(VAR_8->name, ""if-feature"")) {
            VAR_13 = fill_yin_iffeature(VAR_6, 0, VAR_8, &VAR_7->iffeature[VAR_7->iffeature_size], VAR_4);
            VAR_7->iffeature_size++;
            if (VAR_13) {
                goto error;
            }
        } else if (!strcmp(VAR_8->name, ""default"")) {
            GETVAL(VAR_5, VAR_10, VAR_8, ""value"");

            /* COMMENT_19 */
                                                                
            if (VAR_7->flags & VAR_51) {
                for (VAR_13 = 0; VAR_13 < VAR_7->dflt_size; VAR_13++) {
                    if (ly_strequal(VAR_7->dflt[VAR_13], VAR_10, 1)) {
                        LOGVAL(VAR_5, VAR_40, VAR_36, VAR_6, VAR_10, ""default"");
                        LOGVAL(VAR_5, VAR_45, VAR_46, NULL, ""Duplicated default value \""%s\""."", VAR_10);
                        goto error;
                    }
                }
            }
            VAR_7->dflt[VAR_7->dflt_size++] = lydict_insert(VAR_5, VAR_10, strlen(VAR_10));
        }
    }

    lyp_reduce_ext_list(&VAR_6->ext, VAR_6->ext_size, VAR_18 + VAR_6->ext_size);

    /* COMMENT_21 */
    if (unres_schema_add_node(VAR_0, VAR_4, &VAR_7->type, VAR_52, VAR_6) == -1) {
        VAR_7->type.der = NULL;
        goto error;
    }

    if (VAR_7->dflt_size && VAR_7->min) {
        LOGVAL(VAR_5, VAR_53, VAR_36, VAR_6, ""min-elements"", ""leaf-list"");
        LOGVAL(VAR_5, VAR_45, VAR_46, NULL,
               ""The \""min-elements\"" statement with non-zero value is forbidden on leaf-lists with the \""default\"" statement."");
        goto error;
    }

    /* COMMENT_22 */
                                                                              
    for (VAR_13 = 0; VAR_13 < VAR_7->dflt_size; VAR_13++) {
        if (!(VAR_5->models.flags & VAR_54) &&
                (unres_schema_add_node(VAR_0, VAR_4, &VAR_7->type, VAR_55,
                                       (struct lys_node *)(&VAR_7->dflt[VAR_13])) == -1)) {
            goto error;
        }
    }

    /* COMMENT_24 */
    if (!(VAR_5->models.flags & VAR_54) && (VAR_7->when || VAR_7->must)) {
        if (VAR_3 & VAR_56) {
            if (lyxp_node_check_syntax(VAR_6)) {
                goto error;
            }
        } else {
            if (unres_schema_add_node(VAR_0, VAR_4, VAR_6, VAR_57, NULL) == -1) {
                goto error;
            }
        }
    }

    for (VAR_13 = 0; VAR_13 < VAR_6->ext_size; ++VAR_13) {
        /* COMMENT_25 */
        if (VAR_6->ext[VAR_13] && (VAR_6->ext[VAR_13]->flags & VAR_58)) {
            VAR_6->flags |= VAR_59;
            break;
        }
    }

    return VAR_6;

error:
    lys_node_free(VAR_5, VAR_6, NULL, 0);
    return NULL;
}",CESNET/libyang/a3917d95d516e3de267d3cfa5d4d3715a90e8777/parser_yin.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -298,7 +298,7 @@
 
     for (r = 0; r < retval->ext_size; ++r) {
         /* set flag, which represent LYEXT_OPT_VALID */
-        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {
+        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {
             retval->flags |= LYS_VALID_EXT;
             break;
         }","{'deleted_lines': ['        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {'], 'added_lines': ['        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {']}",True,"In function read_yin_container() in libyang <= v1.0.225, it doesn't check whether the value of retval->ext[r] is NULL. In some cases, it can be NULL, which leads to the operation of retval->ext[r]->flags that results in a crash.",7.5,HIGH,2,test,2021-03-08T13:08:05Z,3
CVE-2021-28902,['CWE-252'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,CESNET/libyang,"yin parser BUGFIX invalid memory access

... in case there were some unresolved
extensions.
Fixes #1454
Fixes #1455",a3917d95d516e3de267d3cfa5d4d3715a90e8777,https://github.com/CESNET/libyang/commit/a3917d95d516e3de267d3cfa5d4d3715a90e8777,src/parser_yin.c,read_yin_anydata,"static struct lys_node *
read_yin_anydata(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, LYS_NODE type,
int options, struct unres_schema *unres)
{
struct ly_ctx *ctx = module->ctx;
struct lys_node *retval;
struct lys_node_anydata *anyxml;
struct lyxml_elem *sub, *next;
const char *value;
int r;
int f_mand = 0;
int c_must = 0, c_ftrs = 0, c_ext = 0;
void *reallocated;
anyxml = calloc(1, sizeof *anyxml);
LY_CHECK_ERR_RETURN(!anyxml, LOGMEM(ctx), NULL);
anyxml->nodetype = type;
anyxml->prev = (struct lys_node *)anyxml;
retval = (struct lys_node *)anyxml;
if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,
OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :
(options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT), unres)) {
goto error;
}
LOGDBG(LY_LDGYIN, ""parsing %s statement \""%s\"""", yin->name, retval->name);
if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {
goto error;
}
LY_TREE_FOR_SAFE(yin->child, next, sub) {
if (strcmp(sub->ns->value, LY_NSYIN)) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, ""extensions"", ""anydata"", error);
c_ext++;
} else if (!strcmp(sub->name, ""mandatory"")) {
if (f_mand) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
f_mand = 1;
GETVAL(ctx, value, sub, ""value"");
if (!strcmp(value, ""true"")) {
anyxml->flags |= LYS_MAND_TRUE;
} else if (!strcmp(value, ""false"")) {
anyxml->flags |= LYS_MAND_FALSE;
} else {
LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
goto error;
}
if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MANDATORY, 0, unres)) {
goto error;
}
lyxml_free(ctx, sub);
} else if (!strcmp(sub->name, ""when"")) {
if (anyxml->when) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
anyxml->when = read_yin_when(module, sub, unres);
if (!anyxml->when) {
lyxml_free(ctx, sub);
goto error;
}
lyxml_free(ctx, sub);
} else if (!strcmp(sub->name, ""must"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, anyxml->must_size, ""musts"", ""anydata"", error);
c_must++;
} else if (!strcmp(sub->name, ""if-feature"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, ""if-features"", ""anydata"", error);
c_ftrs++;
} else {
LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);
goto error;
}
}
if (c_must) {
anyxml->must = calloc(c_must, sizeof *anyxml->must);
LY_CHECK_ERR_GOTO(!anyxml->must, LOGMEM(ctx), error);
}
if (c_ftrs) {
anyxml->iffeature = calloc(c_ftrs, sizeof *anyxml->iffeature);
LY_CHECK_ERR_GOTO(!anyxml->iffeature, LOGMEM(ctx), error);
}
if (c_ext) {
reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);
LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);
retval->ext = reallocated;
memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);
}
LY_TREE_FOR_SAFE(yin->child, next, sub) {
if (strcmp(sub->ns->value, LY_NSYIN)) {
r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);
if (r) {
goto error;
}
} else if (!strcmp(sub->name, ""must"")) {
r = fill_yin_must(module, sub, &anyxml->must[anyxml->must_size], unres);
anyxml->must_size++;
if (r) {
goto error;
}
} else if (!strcmp(sub->name, ""if-feature"")) {
r = fill_yin_iffeature(retval, 0, sub, &anyxml->iffeature[anyxml->iffeature_size], unres);
anyxml->iffeature_size++;
if (r) {
goto error;
}
}
}
lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);
if (!(ctx->models.flags & LY_CTX_TRUSTED) && (anyxml->when || anyxml->must)) {
if (options & LYS_PARSE_OPT_INGRP) {
if (lyxp_node_check_syntax(retval)) {
goto error;
}
} else {
if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {
goto error;
}
}
}
for (r = 0; r < retval->ext_size; ++r) {
if (retval->ext[r]->flags & LYEXT_OPT_VALID) {
retval->flags |= LYS_VALID_EXT;
break;
}
}
return retval;
error:
lys_node_free(ctx, retval, NULL, 0);
return NULL;
}","static struct lys_node *
read_yin_anydata(struct lys_module *VAR_0, struct lys_node *VAR_1, struct lyxml_elem *VAR_2, LYS_NODE VAR_3,
int VAR_4, struct unres_schema *VAR_5)
{
struct ly_ctx *VAR_6 = VAR_0->ctx;
struct lys_node *VAR_7;
struct lys_node_anydata *VAR_8;
struct lyxml_elem *VAR_9, *VAR_10;
const char *VAR_11;
int VAR_12;
int VAR_13 = 0;
int VAR_14 = 0, VAR_15 = 0, VAR_16 = 0;
void *VAR_17;
VAR_8 = calloc(1, sizeof *VAR_8);
LY_CHECK_ERR_RETURN(!VAR_8, LOGMEM(VAR_6), NULL);
VAR_8->nodetype = VAR_3;
VAR_8->prev = (struct lys_node *)VAR_8;
VAR_7 = (struct lys_node *)VAR_8;
if (read_yin_common(VAR_0, VAR_1, VAR_7, VAR_18, VAR_2,
VAR_19 | VAR_20 | ((VAR_4 & VAR_21) ? VAR_22 :
(VAR_4 & VAR_23) ? VAR_24 : VAR_24 | VAR_25), VAR_5)) {
goto error;
}
LOGDBG(VAR_26, ""parsing %s statement \""%s\"""", VAR_2->name, VAR_7->name);
if (lys_node_addchild(VAR_1, lys_main_module(VAR_0), VAR_7, VAR_4)) {
goto error;
}
LY_TREE_FOR_SAFE(VAR_2->child, VAR_10, VAR_9) {
if (strcmp(VAR_9->ns->value, VAR_27)) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_6, VAR_16, VAR_7->ext_size, ""extensions"", ""anydata"", VAR_28);
VAR_16++;
} else if (!strcmp(VAR_9->name, ""mandatory"")) {
if (VAR_13) {
LOGVAL(VAR_6, VAR_29, VAR_30, VAR_7, VAR_9->name, VAR_2->name);
goto error;
}
VAR_13 = 1;
GETVAL(VAR_6, VAR_11, VAR_9, ""value"");
if (!strcmp(VAR_11, ""true"")) {
VAR_8->flags |= VAR_31;
} else if (!strcmp(VAR_11, ""false"")) {
VAR_8->flags |= VAR_32;
} else {
LOGVAL(VAR_6, VAR_33, VAR_30, VAR_7, VAR_11, VAR_9->name);
goto error;
}
if (lyp_yin_parse_subnode_ext(VAR_0, VAR_7, VAR_18, VAR_9, VAR_34, 0, VAR_5)) {
goto error;
}
lyxml_free(VAR_6, VAR_9);
} else if (!strcmp(VAR_9->name, ""when"")) {
if (VAR_8->when) {
LOGVAL(VAR_6, VAR_29, VAR_30, VAR_7, VAR_9->name, VAR_2->name);
goto error;
}
VAR_8->when = read_yin_when(VAR_0, VAR_9, VAR_5);
if (!VAR_8->when) {
lyxml_free(VAR_6, VAR_9);
goto error;
}
lyxml_free(VAR_6, VAR_9);
} else if (!strcmp(VAR_9->name, ""must"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_6, VAR_14, VAR_8->must_size, ""musts"", ""anydata"", VAR_28);
VAR_14++;
} else if (!strcmp(VAR_9->name, ""if-feature"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_6, VAR_15, VAR_7->iffeature_size, ""if-features"", ""anydata"", VAR_28);
VAR_15++;
} else {
LOGVAL(VAR_6, VAR_35, VAR_30, VAR_7, VAR_9->name);
goto error;
}
}
if (VAR_14) {
VAR_8->must = calloc(VAR_14, sizeof *VAR_8->must);
LY_CHECK_ERR_GOTO(!VAR_8->must, LOGMEM(VAR_6), VAR_28);
}
if (VAR_15) {
VAR_8->iffeature = calloc(VAR_15, sizeof *VAR_8->iffeature);
LY_CHECK_ERR_GOTO(!VAR_8->iffeature, LOGMEM(VAR_6), VAR_28);
}
if (VAR_16) {
VAR_17 = realloc(VAR_7->ext, (VAR_16 + VAR_7->ext_size) * sizeof *VAR_7->ext);
LY_CHECK_ERR_GOTO(!VAR_17, LOGMEM(VAR_6), VAR_28);
VAR_7->ext = VAR_17;
memset(&VAR_7->ext[VAR_7->ext_size], 0, VAR_16 * sizeof *VAR_7->ext);
}
LY_TREE_FOR_SAFE(VAR_2->child, VAR_10, VAR_9) {
if (strcmp(VAR_9->ns->value, VAR_27)) {
VAR_12 = lyp_yin_fill_ext(VAR_7, VAR_18, 0, 0, VAR_0, VAR_9, &VAR_7->ext, &VAR_7->ext_size, VAR_5);
if (VAR_12) {
goto error;
}
} else if (!strcmp(VAR_9->name, ""must"")) {
VAR_12 = fill_yin_must(VAR_0, VAR_9, &VAR_8->must[VAR_8->must_size], VAR_5);
VAR_8->must_size++;
if (VAR_12) {
goto error;
}
} else if (!strcmp(VAR_9->name, ""if-feature"")) {
VAR_12 = fill_yin_iffeature(VAR_7, 0, VAR_9, &VAR_8->iffeature[VAR_8->iffeature_size], VAR_5);
VAR_8->iffeature_size++;
if (VAR_12) {
goto error;
}
}
}
lyp_reduce_ext_list(&VAR_7->ext, VAR_7->ext_size, VAR_16 + VAR_7->ext_size);
if (!(VAR_6->models.flags & VAR_36) && (VAR_8->when || VAR_8->must)) {
if (VAR_4 & VAR_37) {
if (lyxp_node_check_syntax(VAR_7)) {
goto error;
}
} else {
if (unres_schema_add_node(VAR_0, VAR_5, VAR_7, VAR_38, NULL) == -1) {
goto error;
}
}
}
for (VAR_12 = 0; VAR_12 < VAR_7->ext_size; ++VAR_12) {
if (VAR_7->ext[VAR_12]->flags & VAR_39) {
VAR_7->flags |= VAR_40;
break;
}
}
return VAR_7;
error:
lys_node_free(VAR_6, VAR_7, NULL, 0);
return NULL;
}",CESNET/libyang/a3917d95d516e3de267d3cfa5d4d3715a90e8777/parser_yin.c/vul/before/0.json,"static struct lys_node *
read_yin_anydata(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, LYS_NODE type,
                 int options, struct unres_schema *unres)
{
    struct ly_ctx *ctx = module->ctx;
    struct lys_node *retval;
    struct lys_node_anydata *anyxml;
    struct lyxml_elem *sub, *next;
    const char *value;
    int r;
    int f_mand = 0;
    int c_must = 0, c_ftrs = 0, c_ext = 0;
    void *reallocated;

    anyxml = calloc(1, sizeof *anyxml);
    LY_CHECK_ERR_RETURN(!anyxml, LOGMEM(ctx), NULL);

    anyxml->nodetype = type;
    anyxml->prev = (struct lys_node *)anyxml;
    retval = (struct lys_node *)anyxml;

    if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,
            OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :
            (options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT), unres)) {
        goto error;
    }

    LOGDBG(LY_LDGYIN, ""parsing %s statement \""%s\"""", yin->name, retval->name);

    /* insert the node into the schema tree */
    if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {
        goto error;
    }

    LY_TREE_FOR_SAFE(yin->child, next, sub) {
        if (strcmp(sub->ns->value, LY_NSYIN)) {
            /* extension */
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, ""extensions"", ""anydata"", error);
            c_ext++;
        } else if (!strcmp(sub->name, ""mandatory"")) {
            if (f_mand) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }
            /* just checking the flags in leaf is not sufficient, we would allow
             * multiple mandatory statements with the ""false"" value
             */
            f_mand = 1;

            GETVAL(ctx, value, sub, ""value"");
            if (!strcmp(value, ""true"")) {
                anyxml->flags |= LYS_MAND_TRUE;
            } else if (!strcmp(value, ""false"")) {
                anyxml->flags |= LYS_MAND_FALSE;
            } else {
                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
                goto error;
            }
            /* else false is the default value, so we can ignore it */

            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MANDATORY, 0, unres)) {
                goto error;
            }
            lyxml_free(ctx, sub);
        } else if (!strcmp(sub->name, ""when"")) {
            if (anyxml->when) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }

            anyxml->when = read_yin_when(module, sub, unres);
            if (!anyxml->when) {
                lyxml_free(ctx, sub);
                goto error;
            }
            lyxml_free(ctx, sub);
        } else if (!strcmp(sub->name, ""must"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, anyxml->must_size, ""musts"", ""anydata"", error);
            c_must++;
        } else if (!strcmp(sub->name, ""if-feature"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, ""if-features"", ""anydata"", error);
            c_ftrs++;

        } else {
            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);
            goto error;
        }
    }

    /* middle part - process nodes with cardinality of 0..n */
    if (c_must) {
        anyxml->must = calloc(c_must, sizeof *anyxml->must);
        LY_CHECK_ERR_GOTO(!anyxml->must, LOGMEM(ctx), error);
    }
    if (c_ftrs) {
        anyxml->iffeature = calloc(c_ftrs, sizeof *anyxml->iffeature);
        LY_CHECK_ERR_GOTO(!anyxml->iffeature, LOGMEM(ctx), error);
    }
    if (c_ext) {
        /* some extensions may be already present from the substatements */
        reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);
        LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);
        retval->ext = reallocated;

        /* init memory */
        memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);
    }

    LY_TREE_FOR_SAFE(yin->child, next, sub) {
        if (strcmp(sub->ns->value, LY_NSYIN)) {
            /* extension */
            r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);
            if (r) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""must"")) {
            r = fill_yin_must(module, sub, &anyxml->must[anyxml->must_size], unres);
            anyxml->must_size++;
            if (r) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""if-feature"")) {
            r = fill_yin_iffeature(retval, 0, sub, &anyxml->iffeature[anyxml->iffeature_size], unres);
            anyxml->iffeature_size++;
            if (r) {
                goto error;
            }
        }
    }

    lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);

    /* check XPath dependencies */
    if (!(ctx->models.flags & LY_CTX_TRUSTED) && (anyxml->when || anyxml->must)) {
        if (options & LYS_PARSE_OPT_INGRP) {
            if (lyxp_node_check_syntax(retval)) {
                goto error;
            }
        } else {
            if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {
                goto error;
            }
        }
    }

    for (r = 0; r < retval->ext_size; ++r) {
        /* set flag, which represent LYEXT_OPT_VALID */
        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {
            retval->flags |= LYS_VALID_EXT;
            break;
        }
    }

    return retval;

error:
    lys_node_free(ctx, retval, NULL, 0);
    return NULL;
}","static struct lys_node *
read_yin_anydata(struct lys_module *VAR_0, struct lys_node *VAR_1, struct lyxml_elem *VAR_2, LYS_NODE VAR_3,
                 int VAR_4, struct unres_schema *VAR_5)
{
    struct ly_ctx *VAR_6 = VAR_0->ctx;
    struct lys_node *VAR_7;
    struct lys_node_anydata *VAR_8;
    struct lyxml_elem *VAR_9, *VAR_10;
    const char *VAR_11;
    int VAR_12;
    int VAR_13 = 0;
    int VAR_14 = 0, VAR_15 = 0, VAR_16 = 0;
    void *VAR_17;

    VAR_8 = calloc(1, sizeof *VAR_8);
    LY_CHECK_ERR_RETURN(!VAR_8, LOGMEM(VAR_6), NULL);

    VAR_8->nodetype = VAR_3;
    VAR_8->prev = (struct lys_node *)VAR_8;
    VAR_7 = (struct lys_node *)VAR_8;

    if (read_yin_common(VAR_0, VAR_1, VAR_7, VAR_18, VAR_2,
            VAR_19 | VAR_20 | ((VAR_4 & VAR_21) ? VAR_22 :
            (VAR_4 & VAR_23) ? VAR_24 : VAR_24 | VAR_25), VAR_5)) {
        goto error;
    }

    LOGDBG(VAR_26, ""parsing %s statement \""%s\"""", VAR_2->name, VAR_7->name);

    /* COMMENT_0 */
    if (lys_node_addchild(VAR_1, lys_main_module(VAR_0), VAR_7, VAR_4)) {
        goto error;
    }

    LY_TREE_FOR_SAFE(VAR_2->child, VAR_10, VAR_9) {
        if (strcmp(VAR_9->ns->value, VAR_27)) {
            /* COMMENT_1 */
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_6, VAR_16, VAR_7->ext_size, ""extensions"", ""anydata"", VAR_28);
            VAR_16++;
        } else if (!strcmp(VAR_9->name, ""mandatory"")) {
            if (VAR_13) {
                LOGVAL(VAR_6, VAR_29, VAR_30, VAR_7, VAR_9->name, VAR_2->name);
                goto error;
            }
            /* COMMENT_2 */
                                                                   
               
            VAR_13 = 1;

            GETVAL(VAR_6, VAR_11, VAR_9, ""value"");
            if (!strcmp(VAR_11, ""true"")) {
                VAR_8->flags |= VAR_31;
            } else if (!strcmp(VAR_11, ""false"")) {
                VAR_8->flags |= VAR_32;
            } else {
                LOGVAL(VAR_6, VAR_33, VAR_30, VAR_7, VAR_11, VAR_9->name);
                goto error;
            }
            /* COMMENT_5 */

            if (lyp_yin_parse_subnode_ext(VAR_0, VAR_7, VAR_18, VAR_9, VAR_34, 0, VAR_5)) {
                goto error;
            }
            lyxml_free(VAR_6, VAR_9);
        } else if (!strcmp(VAR_9->name, ""when"")) {
            if (VAR_8->when) {
                LOGVAL(VAR_6, VAR_29, VAR_30, VAR_7, VAR_9->name, VAR_2->name);
                goto error;
            }

            VAR_8->when = read_yin_when(VAR_0, VAR_9, VAR_5);
            if (!VAR_8->when) {
                lyxml_free(VAR_6, VAR_9);
                goto error;
            }
            lyxml_free(VAR_6, VAR_9);
        } else if (!strcmp(VAR_9->name, ""must"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_6, VAR_14, VAR_8->must_size, ""musts"", ""anydata"", VAR_28);
            VAR_14++;
        } else if (!strcmp(VAR_9->name, ""if-feature"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_6, VAR_15, VAR_7->iffeature_size, ""if-features"", ""anydata"", VAR_28);
            VAR_15++;

        } else {
            LOGVAL(VAR_6, VAR_35, VAR_30, VAR_7, VAR_9->name);
            goto error;
        }
    }

    /* COMMENT_6 */
    if (VAR_14) {
        VAR_8->must = calloc(VAR_14, sizeof *VAR_8->must);
        LY_CHECK_ERR_GOTO(!VAR_8->must, LOGMEM(VAR_6), VAR_28);
    }
    if (VAR_15) {
        VAR_8->iffeature = calloc(VAR_15, sizeof *VAR_8->iffeature);
        LY_CHECK_ERR_GOTO(!VAR_8->iffeature, LOGMEM(VAR_6), VAR_28);
    }
    if (VAR_16) {
        /* COMMENT_7 */
        VAR_17 = realloc(VAR_7->ext, (VAR_16 + VAR_7->ext_size) * sizeof *VAR_7->ext);
        LY_CHECK_ERR_GOTO(!VAR_17, LOGMEM(VAR_6), VAR_28);
        VAR_7->ext = VAR_17;

        /* COMMENT_8 */
        memset(&VAR_7->ext[VAR_7->ext_size], 0, VAR_16 * sizeof *VAR_7->ext);
    }

    LY_TREE_FOR_SAFE(VAR_2->child, VAR_10, VAR_9) {
        if (strcmp(VAR_9->ns->value, VAR_27)) {
            /* COMMENT_1 */
            VAR_12 = lyp_yin_fill_ext(VAR_7, VAR_18, 0, 0, VAR_0, VAR_9, &VAR_7->ext, &VAR_7->ext_size, VAR_5);
            if (VAR_12) {
                goto error;
            }
        } else if (!strcmp(VAR_9->name, ""must"")) {
            VAR_12 = fill_yin_must(VAR_0, VAR_9, &VAR_8->must[VAR_8->must_size], VAR_5);
            VAR_8->must_size++;
            if (VAR_12) {
                goto error;
            }
        } else if (!strcmp(VAR_9->name, ""if-feature"")) {
            VAR_12 = fill_yin_iffeature(VAR_7, 0, VAR_9, &VAR_8->iffeature[VAR_8->iffeature_size], VAR_5);
            VAR_8->iffeature_size++;
            if (VAR_12) {
                goto error;
            }
        }
    }

    lyp_reduce_ext_list(&VAR_7->ext, VAR_7->ext_size, VAR_16 + VAR_7->ext_size);

    /* COMMENT_9 */
    if (!(VAR_6->models.flags & VAR_36) && (VAR_8->when || VAR_8->must)) {
        if (VAR_4 & VAR_37) {
            if (lyxp_node_check_syntax(VAR_7)) {
                goto error;
            }
        } else {
            if (unres_schema_add_node(VAR_0, VAR_5, VAR_7, VAR_38, NULL) == -1) {
                goto error;
            }
        }
    }

    for (VAR_12 = 0; VAR_12 < VAR_7->ext_size; ++VAR_12) {
        /* COMMENT_10 */
        if (VAR_7->ext[VAR_12] && (VAR_7->ext[VAR_12]->flags & VAR_39)) {
            VAR_7->flags |= VAR_40;
            break;
        }
    }

    return VAR_7;

error:
    lys_node_free(VAR_6, VAR_7, NULL, 0);
    return NULL;
}",CESNET/libyang/a3917d95d516e3de267d3cfa5d4d3715a90e8777/parser_yin.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -145,7 +145,7 @@
 
     for (r = 0; r < retval->ext_size; ++r) {
         /* set flag, which represent LYEXT_OPT_VALID */
-        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {
+        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {
             retval->flags |= LYS_VALID_EXT;
             break;
         }","{'deleted_lines': ['        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {'], 'added_lines': ['        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {']}",True,"In function read_yin_container() in libyang <= v1.0.225, it doesn't check whether the value of retval->ext[r] is NULL. In some cases, it can be NULL, which leads to the operation of retval->ext[r]->flags that results in a crash.",7.5,HIGH,2,test,2021-03-08T13:08:05Z,3
CVE-2021-28902,['CWE-252'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,CESNET/libyang,"yin parser BUGFIX invalid memory access

... in case there were some unresolved
extensions.
Fixes #1454
Fixes #1455",a3917d95d516e3de267d3cfa5d4d3715a90e8777,https://github.com/CESNET/libyang/commit/a3917d95d516e3de267d3cfa5d4d3715a90e8777,src/parser_yin.c,read_yin_leaf,"static struct lys_node *
read_yin_leaf(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options,
struct unres_schema *unres)
{
struct ly_ctx *ctx = module->ctx;
struct lys_node *retval;
struct lys_node_leaf *leaf;
struct lyxml_elem *sub, *next;
const char *value;
int r, has_type = 0;
int c_must = 0, c_ftrs = 0, f_mand = 0, c_ext = 0;
void *reallocated;
leaf = calloc(1, sizeof *leaf);
LY_CHECK_ERR_RETURN(!leaf, LOGMEM(ctx), NULL);
leaf->nodetype = LYS_LEAF;
leaf->prev = (struct lys_node *)leaf;
retval = (struct lys_node *)leaf;
if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,
OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :
(options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT),
unres)) {
goto error;
}
LOGDBG(LY_LDGYIN, ""parsing %s statement \""%s\"""", yin->name, retval->name);
if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {
goto error;
}
LY_TREE_FOR_SAFE(yin->child, next, sub) {
if (strcmp(sub->ns->value, LY_NSYIN)) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, ""extensions"", ""leaf"", error);
c_ext++;
continue;
} else if (!strcmp(sub->name, ""type"")) {
if (has_type) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
leaf->type.der = (struct lys_tpdf *)sub;
leaf->type.parent = (struct lys_tpdf *)leaf;
has_type = 1;
} else if (!strcmp(sub->name, ""default"")) {
if (leaf->dflt) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
GETVAL(ctx, value, sub, ""value"");
leaf->dflt = lydict_insert(ctx, value, strlen(value));
if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_DEFAULT, 0, unres)) {
goto error;
}
} else if (!strcmp(sub->name, ""units"")) {
if (leaf->units) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
GETVAL(ctx, value, sub, ""name"");
leaf->units = lydict_insert(ctx, value, strlen(value));
if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_UNITS, 0, unres)) {
goto error;
}
} else if (!strcmp(sub->name, ""mandatory"")) {
if (f_mand) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
f_mand = 1;
GETVAL(ctx, value, sub, ""value"");
if (!strcmp(value, ""true"")) {
leaf->flags |= LYS_MAND_TRUE;
} else if (!strcmp(value, ""false"")) {
leaf->flags |= LYS_MAND_FALSE;
} else {
LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
goto error;
}                   
if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MANDATORY, 0, unres)) {
goto error;
}
} else if (!strcmp(sub->name, ""when"")) {
if (leaf->when) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
leaf->when = read_yin_when(module, sub, unres);
if (!leaf->when) {
goto error;
}
} else if (!strcmp(sub->name, ""must"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, leaf->must_size, ""musts"", ""leaf"", error);
c_must++;
continue;
} else if (!strcmp(sub->name, ""if-feature"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, ""musts"", ""leaf"", error);
c_ftrs++;
continue;
} else {
LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);
goto error;
}
}
if (!has_type) {
LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, retval, ""type"", yin->name);
goto error;
}
if (leaf->dflt && (leaf->flags & LYS_MAND_TRUE)) {
LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, retval, ""mandatory"", ""leaf"");
LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,
""The \""mandatory\"" statement is forbidden on leaf with the \""default\"" statement."");
goto error;
}
if (c_must) {
leaf->must = calloc(c_must, sizeof *leaf->must);
LY_CHECK_ERR_GOTO(!leaf->must, LOGMEM(ctx), error);
}
if (c_ftrs) {
leaf->iffeature = calloc(c_ftrs, sizeof *leaf->iffeature);
LY_CHECK_ERR_GOTO(!leaf->iffeature, LOGMEM(ctx), error);
}
if (c_ext) {
reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);
LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);
retval->ext = reallocated;
memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);
}
LY_TREE_FOR_SAFE(yin->child, next, sub) {
if (strcmp(sub->ns->value, LY_NSYIN)) {
r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);
if (r) {
goto error;
}
} else if (!strcmp(sub->name, ""must"")) {
r = fill_yin_must(module, sub, &leaf->must[leaf->must_size], unres);
leaf->must_size++;
if (r) {
goto error;
}
} else if (!strcmp(sub->name, ""if-feature"")) {
r = fill_yin_iffeature(retval, 0, sub, &leaf->iffeature[leaf->iffeature_size], unres);
leaf->iffeature_size++;
if (r) {
goto error;
}
}
}
lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);
if (unres_schema_add_node(module, unres, &leaf->type, UNRES_TYPE_DER, retval) == -1) {
leaf->type.der = NULL;
goto error;
}
if (!(ctx->models.flags & LY_CTX_TRUSTED) &&
(unres_schema_add_node(module, unres, &leaf->type, UNRES_TYPE_DFLT,
(struct lys_node *)(&leaf->dflt)) == -1)) {
goto error;
}
if (!(ctx->models.flags & LY_CTX_TRUSTED) && (leaf->when || leaf->must)) {
if (options & LYS_PARSE_OPT_INGRP) {
if (lyxp_node_check_syntax(retval)) {
goto error;
}
} else {
if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {
goto error;
}
}
}
for (r = 0; r < retval->ext_size; ++r) {
if (retval->ext[r]->flags & LYEXT_OPT_VALID) {
retval->flags |= LYS_VALID_EXT;
break;
}
}
return retval;
error:
lys_node_free(ctx, retval, NULL, 0);
return NULL;
}","static struct lys_node *
read_yin_leaf(struct lys_module *VAR_0, struct lys_node *VAR_1, struct lyxml_elem *VAR_2, int VAR_3,
struct unres_schema *VAR_4)
{
struct ly_ctx *VAR_5 = VAR_0->ctx;
struct lys_node *VAR_6;
struct lys_node_leaf *VAR_7;
struct lyxml_elem *VAR_8, *VAR_9;
const char *VAR_10;
int VAR_11, VAR_12 = 0;
int VAR_13 = 0, VAR_14 = 0, VAR_15 = 0, VAR_16 = 0;
void *VAR_17;
VAR_7 = calloc(1, sizeof *VAR_7);
LY_CHECK_ERR_RETURN(!VAR_7, LOGMEM(VAR_5), NULL);
VAR_7->nodetype = VAR_18;
VAR_7->prev = (struct lys_node *)VAR_7;
VAR_6 = (struct lys_node *)VAR_7;
if (read_yin_common(VAR_0, VAR_1, VAR_6, VAR_19, VAR_2,
VAR_20 | VAR_21 | ((VAR_3 & VAR_22) ? VAR_23 :
(VAR_3 & VAR_24) ? VAR_25 : VAR_25 | VAR_26),
VAR_4)) {
goto error;
}
LOGDBG(VAR_27, ""parsing %s statement \""%s\"""", VAR_2->name, VAR_6->name);
if (lys_node_addchild(VAR_1, lys_main_module(VAR_0), VAR_6, VAR_3)) {
goto error;
}
LY_TREE_FOR_SAFE(VAR_2->child, VAR_9, VAR_8) {
if (strcmp(VAR_8->ns->value, VAR_28)) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_16, VAR_6->ext_size, ""extensions"", ""leaf"", VAR_29);
VAR_16++;
continue;
} else if (!strcmp(VAR_8->name, ""type"")) {
if (VAR_12) {
LOGVAL(VAR_5, VAR_30, VAR_31, VAR_6, VAR_8->name, VAR_2->name);
goto error;
}
VAR_7->type.der = (struct lys_tpdf *)VAR_8;
VAR_7->type.parent = (struct lys_tpdf *)VAR_7;
VAR_12 = 1;
} else if (!strcmp(VAR_8->name, ""default"")) {
if (VAR_7->dflt) {
LOGVAL(VAR_5, VAR_30, VAR_31, VAR_6, VAR_8->name, VAR_2->name);
goto error;
}
GETVAL(VAR_5, VAR_10, VAR_8, ""value"");
VAR_7->dflt = lydict_insert(VAR_5, VAR_10, strlen(VAR_10));
if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_19, VAR_8, VAR_32, 0, VAR_4)) {
goto error;
}
} else if (!strcmp(VAR_8->name, ""units"")) {
if (VAR_7->units) {
LOGVAL(VAR_5, VAR_30, VAR_31, VAR_6, VAR_8->name, VAR_2->name);
goto error;
}
GETVAL(VAR_5, VAR_10, VAR_8, ""name"");
VAR_7->units = lydict_insert(VAR_5, VAR_10, strlen(VAR_10));
if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_19, VAR_8, VAR_33, 0, VAR_4)) {
goto error;
}
} else if (!strcmp(VAR_8->name, ""mandatory"")) {
if (VAR_15) {
LOGVAL(VAR_5, VAR_30, VAR_31, VAR_6, VAR_8->name, VAR_2->name);
goto error;
}
VAR_15 = 1;
GETVAL(VAR_5, VAR_10, VAR_8, ""value"");
if (!strcmp(VAR_10, ""true"")) {
VAR_7->flags |= VAR_34;
} else if (!strcmp(VAR_10, ""false"")) {
VAR_7->flags |= VAR_35;
} else {
LOGVAL(VAR_5, VAR_36, VAR_31, VAR_6, VAR_10, VAR_8->name);
goto error;
}                   
if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_19, VAR_8, VAR_37, 0, VAR_4)) {
goto error;
}
} else if (!strcmp(VAR_8->name, ""when"")) {
if (VAR_7->when) {
LOGVAL(VAR_5, VAR_30, VAR_31, VAR_6, VAR_8->name, VAR_2->name);
goto error;
}
VAR_7->when = read_yin_when(VAR_0, VAR_8, VAR_4);
if (!VAR_7->when) {
goto error;
}
} else if (!strcmp(VAR_8->name, ""must"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_13, VAR_7->must_size, ""musts"", ""leaf"", VAR_29);
VAR_13++;
continue;
} else if (!strcmp(VAR_8->name, ""if-feature"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_14, VAR_6->iffeature_size, ""musts"", ""leaf"", VAR_29);
VAR_14++;
continue;
} else {
LOGVAL(VAR_5, VAR_38, VAR_31, VAR_6, VAR_8->name);
goto error;
}
}
if (!VAR_12) {
LOGVAL(VAR_5, VAR_39, VAR_31, VAR_6, ""type"", VAR_2->name);
goto error;
}
if (VAR_7->dflt && (VAR_7->flags & VAR_34)) {
LOGVAL(VAR_5, VAR_40, VAR_31, VAR_6, ""mandatory"", ""leaf"");
LOGVAL(VAR_5, VAR_41, VAR_42, NULL,
""The \""mandatory\"" statement is forbidden on leaf with the \""default\"" statement."");
goto error;
}
if (VAR_13) {
VAR_7->must = calloc(VAR_13, sizeof *VAR_7->must);
LY_CHECK_ERR_GOTO(!VAR_7->must, LOGMEM(VAR_5), VAR_29);
}
if (VAR_14) {
VAR_7->iffeature = calloc(VAR_14, sizeof *VAR_7->iffeature);
LY_CHECK_ERR_GOTO(!VAR_7->iffeature, LOGMEM(VAR_5), VAR_29);
}
if (VAR_16) {
VAR_17 = realloc(VAR_6->ext, (VAR_16 + VAR_6->ext_size) * sizeof *VAR_6->ext);
LY_CHECK_ERR_GOTO(!VAR_17, LOGMEM(VAR_5), VAR_29);
VAR_6->ext = VAR_17;
memset(&VAR_6->ext[VAR_6->ext_size], 0, VAR_16 * sizeof *VAR_6->ext);
}
LY_TREE_FOR_SAFE(VAR_2->child, VAR_9, VAR_8) {
if (strcmp(VAR_8->ns->value, VAR_28)) {
VAR_11 = lyp_yin_fill_ext(VAR_6, VAR_19, 0, 0, VAR_0, VAR_8, &VAR_6->ext, &VAR_6->ext_size, VAR_4);
if (VAR_11) {
goto error;
}
} else if (!strcmp(VAR_8->name, ""must"")) {
VAR_11 = fill_yin_must(VAR_0, VAR_8, &VAR_7->must[VAR_7->must_size], VAR_4);
VAR_7->must_size++;
if (VAR_11) {
goto error;
}
} else if (!strcmp(VAR_8->name, ""if-feature"")) {
VAR_11 = fill_yin_iffeature(VAR_6, 0, VAR_8, &VAR_7->iffeature[VAR_7->iffeature_size], VAR_4);
VAR_7->iffeature_size++;
if (VAR_11) {
goto error;
}
}
}
lyp_reduce_ext_list(&VAR_6->ext, VAR_6->ext_size, VAR_16 + VAR_6->ext_size);
if (unres_schema_add_node(VAR_0, VAR_4, &VAR_7->type, VAR_43, VAR_6) == -1) {
VAR_7->type.der = NULL;
goto error;
}
if (!(VAR_5->models.flags & VAR_44) &&
(unres_schema_add_node(VAR_0, VAR_4, &VAR_7->type, VAR_45,
(struct lys_node *)(&VAR_7->dflt)) == -1)) {
goto error;
}
if (!(VAR_5->models.flags & VAR_44) && (VAR_7->when || VAR_7->must)) {
if (VAR_3 & VAR_46) {
if (lyxp_node_check_syntax(VAR_6)) {
goto error;
}
} else {
if (unres_schema_add_node(VAR_0, VAR_4, VAR_6, VAR_47, NULL) == -1) {
goto error;
}
}
}
for (VAR_11 = 0; VAR_11 < VAR_6->ext_size; ++VAR_11) {
if (VAR_6->ext[VAR_11]->flags & VAR_48) {
VAR_6->flags |= VAR_49;
break;
}
}
return VAR_6;
error:
lys_node_free(VAR_5, VAR_6, NULL, 0);
return NULL;
}",CESNET/libyang/a3917d95d516e3de267d3cfa5d4d3715a90e8777/parser_yin.c/vul/before/1.json,"static struct lys_node *
read_yin_leaf(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options,
              struct unres_schema *unres)
{
    struct ly_ctx *ctx = module->ctx;
    struct lys_node *retval;
    struct lys_node_leaf *leaf;
    struct lyxml_elem *sub, *next;
    const char *value;
    int r, has_type = 0;
    int c_must = 0, c_ftrs = 0, f_mand = 0, c_ext = 0;
    void *reallocated;

    leaf = calloc(1, sizeof *leaf);
    LY_CHECK_ERR_RETURN(!leaf, LOGMEM(ctx), NULL);

    leaf->nodetype = LYS_LEAF;
    leaf->prev = (struct lys_node *)leaf;
    retval = (struct lys_node *)leaf;

    if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,
            OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :
                (options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT),
            unres)) {
        goto error;
    }

    LOGDBG(LY_LDGYIN, ""parsing %s statement \""%s\"""", yin->name, retval->name);

    /* insert the node into the schema tree */
    if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {
        goto error;
    }

    LY_TREE_FOR_SAFE(yin->child, next, sub) {
        if (strcmp(sub->ns->value, LY_NSYIN)) {
            /* extension */
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, ""extensions"", ""leaf"", error);
            c_ext++;
            continue;
        } else if (!strcmp(sub->name, ""type"")) {
            if (has_type) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }
            /* HACK for unres */
            leaf->type.der = (struct lys_tpdf *)sub;
            leaf->type.parent = (struct lys_tpdf *)leaf;
            /* postpone type resolution when if-feature parsing is done since we need
             * if-feature for check_leafref_features() */
            has_type = 1;
        } else if (!strcmp(sub->name, ""default"")) {
            if (leaf->dflt) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }
            GETVAL(ctx, value, sub, ""value"");
            leaf->dflt = lydict_insert(ctx, value, strlen(value));

            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_DEFAULT, 0, unres)) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""units"")) {
            if (leaf->units) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }
            GETVAL(ctx, value, sub, ""name"");
            leaf->units = lydict_insert(ctx, value, strlen(value));

            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_UNITS, 0, unres)) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""mandatory"")) {
            if (f_mand) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }
            /* just checking the flags in leaf is not sufficient, we would allow
             * multiple mandatory statements with the ""false"" value
             */
            f_mand = 1;

            GETVAL(ctx, value, sub, ""value"");
            if (!strcmp(value, ""true"")) {
                leaf->flags |= LYS_MAND_TRUE;
            } else if (!strcmp(value, ""false"")) {
                leaf->flags |= LYS_MAND_FALSE;
            } else {
                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
                goto error;
            }                   /* else false is the default value, so we can ignore it */

            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MANDATORY, 0, unres)) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""when"")) {
            if (leaf->when) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }

            leaf->when = read_yin_when(module, sub, unres);
            if (!leaf->when) {
                goto error;
            }

        } else if (!strcmp(sub->name, ""must"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, leaf->must_size, ""musts"", ""leaf"", error);
            c_must++;
            continue;
        } else if (!strcmp(sub->name, ""if-feature"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, ""musts"", ""leaf"", error);
            c_ftrs++;
            continue;

        } else {
            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);
            goto error;
        }

        /* do not free sub, it could have been unlinked and stored in unres */
    }

    /* check mandatory parameters */
    if (!has_type) {
        LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, retval, ""type"", yin->name);
        goto error;
    }
    if (leaf->dflt && (leaf->flags & LYS_MAND_TRUE)) {
        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, retval, ""mandatory"", ""leaf"");
        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,
               ""The \""mandatory\"" statement is forbidden on leaf with the \""default\"" statement."");
        goto error;
    }

    /* middle part - process nodes with cardinality of 0..n */
    if (c_must) {
        leaf->must = calloc(c_must, sizeof *leaf->must);
        LY_CHECK_ERR_GOTO(!leaf->must, LOGMEM(ctx), error);
    }
    if (c_ftrs) {
        leaf->iffeature = calloc(c_ftrs, sizeof *leaf->iffeature);
        LY_CHECK_ERR_GOTO(!leaf->iffeature, LOGMEM(ctx), error);
    }
    if (c_ext) {
        /* some extensions may be already present from the substatements */
        reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);
        LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);
        retval->ext = reallocated;

        /* init memory */
        memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);
    }

    LY_TREE_FOR_SAFE(yin->child, next, sub) {
        if (strcmp(sub->ns->value, LY_NSYIN)) {
            /* extension */
            r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);
            if (r) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""must"")) {
            r = fill_yin_must(module, sub, &leaf->must[leaf->must_size], unres);
            leaf->must_size++;
            if (r) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""if-feature"")) {
            r = fill_yin_iffeature(retval, 0, sub, &leaf->iffeature[leaf->iffeature_size], unres);
            leaf->iffeature_size++;
            if (r) {
                goto error;
            }
        }
    }

    lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);

    /* finalize type parsing */
    if (unres_schema_add_node(module, unres, &leaf->type, UNRES_TYPE_DER, retval) == -1) {
        leaf->type.der = NULL;
        goto error;
    }

    /* check default value (if not defined, there still could be some restrictions
     * that need to be checked against a default value from a derived type) */
    if (!(ctx->models.flags & LY_CTX_TRUSTED) &&
            (unres_schema_add_node(module, unres, &leaf->type, UNRES_TYPE_DFLT,
                                   (struct lys_node *)(&leaf->dflt)) == -1)) {
        goto error;
    }

    /* check XPath dependencies */
    if (!(ctx->models.flags & LY_CTX_TRUSTED) && (leaf->when || leaf->must)) {
        if (options & LYS_PARSE_OPT_INGRP) {
            if (lyxp_node_check_syntax(retval)) {
                goto error;
            }
        } else {
            if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {
                goto error;
            }
        }
    }

    for (r = 0; r < retval->ext_size; ++r) {
        /* set flag, which represent LYEXT_OPT_VALID */
        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {
            retval->flags |= LYS_VALID_EXT;
            break;
        }
    }

    return retval;

error:
    lys_node_free(ctx, retval, NULL, 0);
    return NULL;
}","static struct lys_node *
read_yin_leaf(struct lys_module *VAR_0, struct lys_node *VAR_1, struct lyxml_elem *VAR_2, int VAR_3,
              struct unres_schema *VAR_4)
{
    struct ly_ctx *VAR_5 = VAR_0->ctx;
    struct lys_node *VAR_6;
    struct lys_node_leaf *VAR_7;
    struct lyxml_elem *VAR_8, *VAR_9;
    const char *VAR_10;
    int VAR_11, VAR_12 = 0;
    int VAR_13 = 0, VAR_14 = 0, VAR_15 = 0, VAR_16 = 0;
    void *VAR_17;

    VAR_7 = calloc(1, sizeof *VAR_7);
    LY_CHECK_ERR_RETURN(!VAR_7, LOGMEM(VAR_5), NULL);

    VAR_7->nodetype = VAR_18;
    VAR_7->prev = (struct lys_node *)VAR_7;
    VAR_6 = (struct lys_node *)VAR_7;

    if (read_yin_common(VAR_0, VAR_1, VAR_6, VAR_19, VAR_2,
            VAR_20 | VAR_21 | ((VAR_3 & VAR_22) ? VAR_23 :
                (VAR_3 & VAR_24) ? VAR_25 : VAR_25 | VAR_26),
            VAR_4)) {
        goto error;
    }

    LOGDBG(VAR_27, ""parsing %s statement \""%s\"""", VAR_2->name, VAR_6->name);

    /* COMMENT_0 */
    if (lys_node_addchild(VAR_1, lys_main_module(VAR_0), VAR_6, VAR_3)) {
        goto error;
    }

    LY_TREE_FOR_SAFE(VAR_2->child, VAR_9, VAR_8) {
        if (strcmp(VAR_8->ns->value, VAR_28)) {
            /* COMMENT_1 */
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_16, VAR_6->ext_size, ""extensions"", ""leaf"", VAR_29);
            VAR_16++;
            continue;
        } else if (!strcmp(VAR_8->name, ""type"")) {
            if (VAR_12) {
                LOGVAL(VAR_5, VAR_30, VAR_31, VAR_6, VAR_8->name, VAR_2->name);
                goto error;
            }
            /* COMMENT_2 */
            VAR_7->type.der = (struct lys_tpdf *)VAR_8;
            VAR_7->type.parent = (struct lys_tpdf *)VAR_7;
            /* COMMENT_3 */
                                                         
            VAR_12 = 1;
        } else if (!strcmp(VAR_8->name, ""default"")) {
            if (VAR_7->dflt) {
                LOGVAL(VAR_5, VAR_30, VAR_31, VAR_6, VAR_8->name, VAR_2->name);
                goto error;
            }
            GETVAL(VAR_5, VAR_10, VAR_8, ""value"");
            VAR_7->dflt = lydict_insert(VAR_5, VAR_10, strlen(VAR_10));

            if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_19, VAR_8, VAR_32, 0, VAR_4)) {
                goto error;
            }
        } else if (!strcmp(VAR_8->name, ""units"")) {
            if (VAR_7->units) {
                LOGVAL(VAR_5, VAR_30, VAR_31, VAR_6, VAR_8->name, VAR_2->name);
                goto error;
            }
            GETVAL(VAR_5, VAR_10, VAR_8, ""name"");
            VAR_7->units = lydict_insert(VAR_5, VAR_10, strlen(VAR_10));

            if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_19, VAR_8, VAR_33, 0, VAR_4)) {
                goto error;
            }
        } else if (!strcmp(VAR_8->name, ""mandatory"")) {
            if (VAR_15) {
                LOGVAL(VAR_5, VAR_30, VAR_31, VAR_6, VAR_8->name, VAR_2->name);
                goto error;
            }
            /* COMMENT_5 */
                                                                   
               
            VAR_15 = 1;

            GETVAL(VAR_5, VAR_10, VAR_8, ""value"");
            if (!strcmp(VAR_10, ""true"")) {
                VAR_7->flags |= VAR_34;
            } else if (!strcmp(VAR_10, ""false"")) {
                VAR_7->flags |= VAR_35;
            } else {
                LOGVAL(VAR_5, VAR_36, VAR_31, VAR_6, VAR_10, VAR_8->name);
                goto error;
            }                   /* COMMENT_8 */

            if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_19, VAR_8, VAR_37, 0, VAR_4)) {
                goto error;
            }
        } else if (!strcmp(VAR_8->name, ""when"")) {
            if (VAR_7->when) {
                LOGVAL(VAR_5, VAR_30, VAR_31, VAR_6, VAR_8->name, VAR_2->name);
                goto error;
            }

            VAR_7->when = read_yin_when(VAR_0, VAR_8, VAR_4);
            if (!VAR_7->when) {
                goto error;
            }

        } else if (!strcmp(VAR_8->name, ""must"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_13, VAR_7->must_size, ""musts"", ""leaf"", VAR_29);
            VAR_13++;
            continue;
        } else if (!strcmp(VAR_8->name, ""if-feature"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_14, VAR_6->iffeature_size, ""musts"", ""leaf"", VAR_29);
            VAR_14++;
            continue;

        } else {
            LOGVAL(VAR_5, VAR_38, VAR_31, VAR_6, VAR_8->name);
            goto error;
        }

        /* COMMENT_9 */
    }

    /* COMMENT_10 */
    if (!VAR_12) {
        LOGVAL(VAR_5, VAR_39, VAR_31, VAR_6, ""type"", VAR_2->name);
        goto error;
    }
    if (VAR_7->dflt && (VAR_7->flags & VAR_34)) {
        LOGVAL(VAR_5, VAR_40, VAR_31, VAR_6, ""mandatory"", ""leaf"");
        LOGVAL(VAR_5, VAR_41, VAR_42, NULL,
               ""The \""mandatory\"" statement is forbidden on leaf with the \""default\"" statement."");
        goto error;
    }

    /* COMMENT_11 */
    if (VAR_13) {
        VAR_7->must = calloc(VAR_13, sizeof *VAR_7->must);
        LY_CHECK_ERR_GOTO(!VAR_7->must, LOGMEM(VAR_5), VAR_29);
    }
    if (VAR_14) {
        VAR_7->iffeature = calloc(VAR_14, sizeof *VAR_7->iffeature);
        LY_CHECK_ERR_GOTO(!VAR_7->iffeature, LOGMEM(VAR_5), VAR_29);
    }
    if (VAR_16) {
        /* COMMENT_12 */
        VAR_17 = realloc(VAR_6->ext, (VAR_16 + VAR_6->ext_size) * sizeof *VAR_6->ext);
        LY_CHECK_ERR_GOTO(!VAR_17, LOGMEM(VAR_5), VAR_29);
        VAR_6->ext = VAR_17;

        /* COMMENT_13 */
        memset(&VAR_6->ext[VAR_6->ext_size], 0, VAR_16 * sizeof *VAR_6->ext);
    }

    LY_TREE_FOR_SAFE(VAR_2->child, VAR_9, VAR_8) {
        if (strcmp(VAR_8->ns->value, VAR_28)) {
            /* COMMENT_1 */
            VAR_11 = lyp_yin_fill_ext(VAR_6, VAR_19, 0, 0, VAR_0, VAR_8, &VAR_6->ext, &VAR_6->ext_size, VAR_4);
            if (VAR_11) {
                goto error;
            }
        } else if (!strcmp(VAR_8->name, ""must"")) {
            VAR_11 = fill_yin_must(VAR_0, VAR_8, &VAR_7->must[VAR_7->must_size], VAR_4);
            VAR_7->must_size++;
            if (VAR_11) {
                goto error;
            }
        } else if (!strcmp(VAR_8->name, ""if-feature"")) {
            VAR_11 = fill_yin_iffeature(VAR_6, 0, VAR_8, &VAR_7->iffeature[VAR_7->iffeature_size], VAR_4);
            VAR_7->iffeature_size++;
            if (VAR_11) {
                goto error;
            }
        }
    }

    lyp_reduce_ext_list(&VAR_6->ext, VAR_6->ext_size, VAR_16 + VAR_6->ext_size);

    /* COMMENT_14 */
    if (unres_schema_add_node(VAR_0, VAR_4, &VAR_7->type, VAR_43, VAR_6) == -1) {
        VAR_7->type.der = NULL;
        goto error;
    }

    /* COMMENT_15 */
                                                                              
    if (!(VAR_5->models.flags & VAR_44) &&
            (unres_schema_add_node(VAR_0, VAR_4, &VAR_7->type, VAR_45,
                                   (struct lys_node *)(&VAR_7->dflt)) == -1)) {
        goto error;
    }

    /* COMMENT_17 */
    if (!(VAR_5->models.flags & VAR_44) && (VAR_7->when || VAR_7->must)) {
        if (VAR_3 & VAR_46) {
            if (lyxp_node_check_syntax(VAR_6)) {
                goto error;
            }
        } else {
            if (unres_schema_add_node(VAR_0, VAR_4, VAR_6, VAR_47, NULL) == -1) {
                goto error;
            }
        }
    }

    for (VAR_11 = 0; VAR_11 < VAR_6->ext_size; ++VAR_11) {
        /* COMMENT_18 */
        if (VAR_6->ext[VAR_11] && (VAR_6->ext[VAR_11]->flags & VAR_48)) {
            VAR_6->flags |= VAR_49;
            break;
        }
    }

    return VAR_6;

error:
    lys_node_free(VAR_5, VAR_6, NULL, 0);
    return NULL;
}",CESNET/libyang/a3917d95d516e3de267d3cfa5d4d3715a90e8777/parser_yin.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -206,7 +206,7 @@
 
     for (r = 0; r < retval->ext_size; ++r) {
         /* set flag, which represent LYEXT_OPT_VALID */
-        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {
+        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {
             retval->flags |= LYS_VALID_EXT;
             break;
         }","{'deleted_lines': ['        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {'], 'added_lines': ['        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {']}",True,"In function read_yin_container() in libyang <= v1.0.225, it doesn't check whether the value of retval->ext[r] is NULL. In some cases, it can be NULL, which leads to the operation of retval->ext[r]->flags that results in a crash.",7.5,HIGH,2,test,2021-03-08T13:08:05Z,3
CVE-2021-28902,['CWE-252'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,CESNET/libyang,"yin parser BUGFIX invalid memory access

... in case there were some unresolved
extensions.
Fixes #1454
Fixes #1455",a3917d95d516e3de267d3cfa5d4d3715a90e8777,https://github.com/CESNET/libyang/commit/a3917d95d516e3de267d3cfa5d4d3715a90e8777,src/parser_yin.c,read_yin_list,"static struct lys_node *
read_yin_list(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options,
struct unres_schema *unres)
{
struct ly_ctx *ctx = module->ctx;
struct lys_node *retval, *node;
struct lys_node_list *list;
struct lyxml_elem *sub, *next, root, uniq;
int r;
int c_tpdf = 0, c_must = 0, c_uniq = 0, c_ftrs = 0, c_ext = 0;
int f_ordr = 0, f_max = 0, f_min = 0;
const char *value;
char *auxs;
unsigned long val;
void *reallocated;
memset(&root, 0, sizeof root);
memset(&uniq, 0, sizeof uniq);
list = calloc(1, sizeof *list);
LY_CHECK_ERR_RETURN(!list, LOGMEM(ctx), NULL);
list->nodetype = LYS_LIST;
list->prev = (struct lys_node *)list;
retval = (struct lys_node *)list;
if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,
OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :
(options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT),
unres)) {
goto error;
}
LOGDBG(LY_LDGYIN, ""parsing %s statement \""%s\"""", yin->name, retval->name);
if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {
goto error;
}
LY_TREE_FOR_SAFE(yin->child, next, sub) {
if (strcmp(sub->ns->value, LY_NSYIN)) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, ""extensions"", ""list"", error);
c_ext++;
continue;
} else if (!strcmp(sub->name, ""container"") ||
!strcmp(sub->name, ""leaf-list"") ||
!strcmp(sub->name, ""leaf"") ||
!strcmp(sub->name, ""list"") ||
!strcmp(sub->name, ""choice"") ||
!strcmp(sub->name, ""uses"") ||
!strcmp(sub->name, ""grouping"") ||
!strcmp(sub->name, ""anyxml"") ||
!strcmp(sub->name, ""anydata"") ||
!strcmp(sub->name, ""action"") ||
!strcmp(sub->name, ""notification"")) {
lyxml_unlink_elem(ctx, sub, 2);
lyxml_add_child(ctx, &root, sub);
} else if (!strcmp(sub->name, ""key"")) {
if (list->keys_size) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, list->name);
goto error;
}
GETVAL(ctx, value, sub, ""value"");
list->keys_str = lydict_insert(ctx, value, 0);
while ((value = strpbrk(value, "" \t\n""))) {
list->keys_size++;
while (isspace(*value)) {
value++;
}
}
list->keys_size++;
list->keys = calloc(list->keys_size, sizeof *list->keys);
LY_CHECK_ERR_GOTO(!list->keys, LOGMEM(ctx), error);
if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_KEY, 0, unres)) {
goto error;
}
lyxml_free(ctx, sub);
} else if (!strcmp(sub->name, ""unique"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_uniq, list->unique_size, ""uniques"", ""list"", error);
c_uniq++;
lyxml_unlink_elem(ctx, sub, 2);
lyxml_add_child(ctx, &uniq, sub);
} else if (!strcmp(sub->name, ""typedef"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_tpdf, list->tpdf_size, ""typedefs"", ""list"", error);
c_tpdf++;
} else if (!strcmp(sub->name, ""must"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, list->must_size, ""musts"", ""list"", error);
c_must++;
} else if (!strcmp(sub->name, ""if-feature"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, ""if-features"", ""list"", error);
c_ftrs++;
} else if (!strcmp(sub->name, ""ordered-by"")) {
if (f_ordr) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
f_ordr = 1;
if (list->flags & LYS_CONFIG_R) {
lyxml_free(ctx, sub);
continue;
}
GETVAL(ctx, value, sub, ""value"");
if (!strcmp(value, ""user"")) {
list->flags |= LYS_USERORDERED;
} else if (strcmp(value, ""system"")) {
LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
goto error;
} 
if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_ORDEREDBY, 0, unres)) {
goto error;
}
lyxml_free(ctx, sub);
} else if (!strcmp(sub->name, ""min-elements"")) {
if (f_min) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
f_min = 1;
GETVAL(ctx, value, sub, ""value"");
while (isspace(value[0])) {
value++;
}
errno = 0;
auxs = NULL;
val = strtoul(value, &auxs, 10);
if (*auxs || value[0] == '-' || errno || val > UINT32_MAX) {
LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
goto error;
}
list->min = (uint32_t) val;
if (list->max && (list->min > list->max)) {
LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, ""\""min-elements\"" is bigger than \""max-elements\""."");
lyxml_free(ctx, sub);
goto error;
}
if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MIN, 0, unres)) {
goto error;
}
lyxml_free(ctx, sub);
} else if (!strcmp(sub->name, ""max-elements"")) {
if (f_max) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
f_max = 1;
GETVAL(ctx, value, sub, ""value"");
while (isspace(value[0])) {
value++;
}
if (!strcmp(value, ""unbounded"")) {
list->max = 0;;
} else {
errno = 0;
auxs = NULL;
val = strtoul(value, &auxs, 10);
if (*auxs || value[0] == '-' || errno || val == 0 || val > UINT32_MAX) {
LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
goto error;
}
list->max = (uint32_t) val;
if (list->min > list->max) {
LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, ""\""max-elements\"" is smaller than \""min-elements\""."");
goto error;
}
}
if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MAX, 0, unres)) {
goto error;
}
lyxml_free(ctx, sub);
} else if (!strcmp(sub->name, ""when"")) {
if (list->when) {
LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
goto error;
}
list->when = read_yin_when(module, sub, unres);
if (!list->when) {
lyxml_free(ctx, sub);
goto error;
}
lyxml_free(ctx, sub);
} else {
LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);
goto error;
}
}
for (node = retval; node && !(node->nodetype & (LYS_GROUPING | LYS_AUGMENT | LYS_EXT)); node = node->parent);
if (!node && (list->flags & LYS_CONFIG_W) && !list->keys_str) {
LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, retval, ""key"", ""list"");
goto error;
}
if (c_tpdf) {
list->tpdf = calloc(c_tpdf, sizeof *list->tpdf);
LY_CHECK_ERR_GOTO(!list->tpdf, LOGMEM(ctx), error);
}
if (c_must) {
list->must = calloc(c_must, sizeof *list->must);
LY_CHECK_ERR_GOTO(!list->must, LOGMEM(ctx), error);
}
if (c_ftrs) {
list->iffeature = calloc(c_ftrs, sizeof *list->iffeature);
LY_CHECK_ERR_GOTO(!list->iffeature, LOGMEM(ctx), error);
}
if (c_ext) {
reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);
LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);
retval->ext = reallocated;
memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);
}
LY_TREE_FOR_SAFE(yin->child, next, sub) {
if (strcmp(sub->ns->value, LY_NSYIN)) {
r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);
if (r) {
goto error;
}
} else if (!strcmp(sub->name, ""typedef"")) {
r = fill_yin_typedef(module, retval, sub, &list->tpdf[list->tpdf_size], unres);
list->tpdf_size++;
if (r) {
goto error;
}
} else if (!strcmp(sub->name, ""if-feature"")) {
r = fill_yin_iffeature(retval, 0, sub, &list->iffeature[list->iffeature_size], unres);
list->iffeature_size++;
if (r) {
goto error;
}
} else if (!strcmp(sub->name, ""must"")) {
r = fill_yin_must(module, sub, &list->must[list->must_size], unres);
list->must_size++;
if (r) {
goto error;
}
}
}
lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);
LY_TREE_FOR_SAFE(root.child, next, sub) {
if (!strcmp(sub->name, ""container"")) {
node = read_yin_container(module, retval, sub, options, unres);
} else if (!strcmp(sub->name, ""leaf-list"")) {
node = read_yin_leaflist(module, retval, sub, options, unres);
} else if (!strcmp(sub->name, ""leaf"")) {
node = read_yin_leaf(module, retval, sub, options, unres);
} else if (!strcmp(sub->name, ""list"")) {
node = read_yin_list(module, retval, sub, options, unres);
} else if (!strcmp(sub->name, ""choice"")) {
node = read_yin_choice(module, retval, sub, options, unres);
} else if (!strcmp(sub->name, ""uses"")) {
node = read_yin_uses(module, retval, sub, options, unres);
} else if (!strcmp(sub->name, ""grouping"")) {
node = read_yin_grouping(module, retval, sub, options, unres);
} else if (!strcmp(sub->name, ""anyxml"")) {
node = read_yin_anydata(module, retval, sub, LYS_ANYXML, options, unres);
} else if (!strcmp(sub->name, ""anydata"")) {
node = read_yin_anydata(module, retval, sub, LYS_ANYDATA, options, unres);
} else if (!strcmp(sub->name, ""action"")) {
node = read_yin_rpc_action(module, retval, sub, options, unres);
} else if (!strcmp(sub->name, ""notification"")) {
node = read_yin_notif(module, retval, sub, options, unres);
} else {
LOGINT(ctx);
goto error;
}
if (!node) {
goto error;
}
lyxml_free(ctx, sub);
}
if (list->keys_str) {
if (unres_schema_add_node(module, unres, list, UNRES_LIST_KEYS, NULL) == -1) {
goto error;
}
} 
if (c_uniq) {
list->unique = calloc(c_uniq, sizeof *list->unique);
LY_CHECK_ERR_GOTO(!list->unique, LOGMEM(ctx), error);
LY_TREE_FOR_SAFE(uniq.child, next, sub) {
r = fill_yin_unique(module, retval, sub, &list->unique[list->unique_size], unres);
list->unique_size++;
if (r) {
goto error;
}
if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub,
LYEXT_SUBSTMT_UNIQUE, list->unique_size - 1, unres)) {
goto error;
}
lyxml_free(ctx, sub);
}
}
if (!(ctx->models.flags & LY_CTX_TRUSTED) && (list->when || list->must)) {
if (options & LYS_PARSE_OPT_INGRP) {
if (lyxp_node_check_syntax(retval)) {
goto error;
}
} else {
if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {
goto error;
}
}
}
for (r = 0; r < retval->ext_size; ++r) {
if (retval->ext[r]->flags & LYEXT_OPT_VALID) {
retval->flags |= LYS_VALID_EXT;
if (retval->ext[r]->flags & LYEXT_OPT_VALID_SUBTREE) {
retval->flags |= LYS_VALID_EXT_SUBTREE;
break;
}
}
}
return retval;
error:
lys_node_free(ctx, retval, NULL, 0);
while (root.child) {
lyxml_free(ctx, root.child);
}
while (uniq.child) {
lyxml_free(ctx, uniq.child);
}
return NULL;
}","static struct lys_node *
read_yin_list(struct lys_module *VAR_0, struct lys_node *VAR_1, struct lyxml_elem *VAR_2, int VAR_3,
struct unres_schema *VAR_4)
{
struct ly_ctx *VAR_5 = VAR_0->ctx;
struct lys_node *VAR_6, *VAR_7;
struct lys_node_list *VAR_8;
struct lyxml_elem *VAR_9, *VAR_10, VAR_11, VAR_12;
int VAR_13;
int VAR_14 = 0, VAR_15 = 0, VAR_16 = 0, VAR_17 = 0, VAR_18 = 0;
int VAR_19 = 0, VAR_20 = 0, VAR_21 = 0;
const char *VAR_22;
char *VAR_23;
unsigned long VAR_24;
void *VAR_25;
memset(&VAR_11, 0, sizeof VAR_11);
memset(&VAR_12, 0, sizeof VAR_12);
VAR_8 = calloc(1, sizeof *VAR_8);
LY_CHECK_ERR_RETURN(!VAR_8, LOGMEM(VAR_5), NULL);
VAR_8->nodetype = VAR_26;
VAR_8->prev = (struct lys_node *)VAR_8;
VAR_6 = (struct lys_node *)VAR_8;
if (read_yin_common(VAR_0, VAR_1, VAR_6, VAR_27, VAR_2,
VAR_28 | VAR_29 | ((VAR_3 & VAR_30) ? VAR_31 :
(VAR_3 & VAR_32) ? VAR_33 : VAR_33 | VAR_34),
VAR_4)) {
goto error;
}
LOGDBG(VAR_35, ""parsing %s statement \""%s\"""", VAR_2->name, VAR_6->name);
if (lys_node_addchild(VAR_1, lys_main_module(VAR_0), VAR_6, VAR_3)) {
goto error;
}
LY_TREE_FOR_SAFE(VAR_2->child, VAR_10, VAR_9) {
if (strcmp(VAR_9->ns->value, VAR_36)) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_18, VAR_6->ext_size, ""extensions"", ""list"", VAR_37);
VAR_18++;
continue;
} else if (!strcmp(VAR_9->name, ""container"") ||
!strcmp(VAR_9->name, ""leaf-list"") ||
!strcmp(VAR_9->name, ""leaf"") ||
!strcmp(VAR_9->name, ""list"") ||
!strcmp(VAR_9->name, ""choice"") ||
!strcmp(VAR_9->name, ""uses"") ||
!strcmp(VAR_9->name, ""grouping"") ||
!strcmp(VAR_9->name, ""anyxml"") ||
!strcmp(VAR_9->name, ""anydata"") ||
!strcmp(VAR_9->name, ""action"") ||
!strcmp(VAR_9->name, ""notification"")) {
lyxml_unlink_elem(VAR_5, VAR_9, 2);
lyxml_add_child(VAR_5, &VAR_11, VAR_9);
} else if (!strcmp(VAR_9->name, ""key"")) {
if (VAR_8->keys_size) {
LOGVAL(VAR_5, VAR_38, VAR_39, VAR_6, VAR_9->name, VAR_8->name);
goto error;
}
GETVAL(VAR_5, VAR_22, VAR_9, ""value"");
VAR_8->keys_str = lydict_insert(VAR_5, VAR_22, 0);
while ((VAR_22 = strpbrk(VAR_22, "" \t\n""))) {
VAR_8->keys_size++;
while (isspace(*VAR_22)) {
VAR_22++;
}
}
VAR_8->keys_size++;
VAR_8->keys = calloc(VAR_8->keys_size, sizeof *VAR_8->keys);
LY_CHECK_ERR_GOTO(!VAR_8->keys, LOGMEM(VAR_5), VAR_37);
if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_27, VAR_9, VAR_40, 0, VAR_4)) {
goto error;
}
lyxml_free(VAR_5, VAR_9);
} else if (!strcmp(VAR_9->name, ""unique"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_16, VAR_8->unique_size, ""uniques"", ""list"", VAR_37);
VAR_16++;
lyxml_unlink_elem(VAR_5, VAR_9, 2);
lyxml_add_child(VAR_5, &VAR_12, VAR_9);
} else if (!strcmp(VAR_9->name, ""typedef"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_14, VAR_8->tpdf_size, ""typedefs"", ""list"", VAR_37);
VAR_14++;
} else if (!strcmp(VAR_9->name, ""must"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_15, VAR_8->must_size, ""musts"", ""list"", VAR_37);
VAR_15++;
} else if (!strcmp(VAR_9->name, ""if-feature"")) {
YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_17, VAR_6->iffeature_size, ""if-features"", ""list"", VAR_37);
VAR_17++;
} else if (!strcmp(VAR_9->name, ""ordered-by"")) {
if (VAR_19) {
LOGVAL(VAR_5, VAR_38, VAR_39, VAR_6, VAR_9->name, VAR_2->name);
goto error;
}
VAR_19 = 1;
if (VAR_8->flags & VAR_41) {
lyxml_free(VAR_5, VAR_9);
continue;
}
GETVAL(VAR_5, VAR_22, VAR_9, ""value"");
if (!strcmp(VAR_22, ""user"")) {
VAR_8->flags |= VAR_42;
} else if (strcmp(VAR_22, ""system"")) {
LOGVAL(VAR_5, VAR_43, VAR_39, VAR_6, VAR_22, VAR_9->name);
goto error;
} 
if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_27, VAR_9, VAR_44, 0, VAR_4)) {
goto error;
}
lyxml_free(VAR_5, VAR_9);
} else if (!strcmp(VAR_9->name, ""min-elements"")) {
if (VAR_21) {
LOGVAL(VAR_5, VAR_38, VAR_39, VAR_6, VAR_9->name, VAR_2->name);
goto error;
}
VAR_21 = 1;
GETVAL(VAR_5, VAR_22, VAR_9, ""value"");
while (isspace(VAR_22[0])) {
VAR_22++;
}
VAR_45 = 0;
VAR_23 = NULL;
VAR_24 = strtoul(VAR_22, &VAR_23, 10);
if (*VAR_23 || VAR_22[0] == '-' || VAR_45 || VAR_24 > VAR_46) {
LOGVAL(VAR_5, VAR_43, VAR_39, VAR_6, VAR_22, VAR_9->name);
goto error;
}
VAR_8->min = (uint32_t) VAR_24;
if (VAR_8->max && (VAR_8->min > VAR_8->max)) {
LOGVAL(VAR_5, VAR_43, VAR_39, VAR_6, VAR_22, VAR_9->name);
LOGVAL(VAR_5, VAR_47, VAR_48, NULL, ""\""min-elements\"" is bigger than \""max-elements\""."");
lyxml_free(VAR_5, VAR_9);
goto error;
}
if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_27, VAR_9, VAR_49, 0, VAR_4)) {
goto error;
}
lyxml_free(VAR_5, VAR_9);
} else if (!strcmp(VAR_9->name, ""max-elements"")) {
if (VAR_20) {
LOGVAL(VAR_5, VAR_38, VAR_39, VAR_6, VAR_9->name, VAR_2->name);
goto error;
}
VAR_20 = 1;
GETVAL(VAR_5, VAR_22, VAR_9, ""value"");
while (isspace(VAR_22[0])) {
VAR_22++;
}
if (!strcmp(VAR_22, ""unbounded"")) {
VAR_8->max = 0;;
} else {
VAR_45 = 0;
VAR_23 = NULL;
VAR_24 = strtoul(VAR_22, &VAR_23, 10);
if (*VAR_23 || VAR_22[0] == '-' || VAR_45 || VAR_24 == 0 || VAR_24 > VAR_46) {
LOGVAL(VAR_5, VAR_43, VAR_39, VAR_6, VAR_22, VAR_9->name);
goto error;
}
VAR_8->max = (uint32_t) VAR_24;
if (VAR_8->min > VAR_8->max) {
LOGVAL(VAR_5, VAR_43, VAR_39, VAR_6, VAR_22, VAR_9->name);
LOGVAL(VAR_5, VAR_47, VAR_48, NULL, ""\""max-elements\"" is smaller than \""min-elements\""."");
goto error;
}
}
if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_27, VAR_9, VAR_50, 0, VAR_4)) {
goto error;
}
lyxml_free(VAR_5, VAR_9);
} else if (!strcmp(VAR_9->name, ""when"")) {
if (VAR_8->when) {
LOGVAL(VAR_5, VAR_38, VAR_39, VAR_6, VAR_9->name, VAR_2->name);
goto error;
}
VAR_8->when = read_yin_when(VAR_0, VAR_9, VAR_4);
if (!VAR_8->when) {
lyxml_free(VAR_5, VAR_9);
goto error;
}
lyxml_free(VAR_5, VAR_9);
} else {
LOGVAL(VAR_5, VAR_51, VAR_39, VAR_6, VAR_9->name);
goto error;
}
}
for (VAR_7 = VAR_6; VAR_7 && !(VAR_7->nodetype & (VAR_52 | VAR_53 | VAR_54)); VAR_7 = VAR_7->parent);
if (!VAR_7 && (VAR_8->flags & VAR_55) && !VAR_8->keys_str) {
LOGVAL(VAR_5, VAR_56, VAR_39, VAR_6, ""key"", ""list"");
goto error;
}
if (VAR_14) {
VAR_8->tpdf = calloc(VAR_14, sizeof *VAR_8->tpdf);
LY_CHECK_ERR_GOTO(!VAR_8->tpdf, LOGMEM(VAR_5), VAR_37);
}
if (VAR_15) {
VAR_8->must = calloc(VAR_15, sizeof *VAR_8->must);
LY_CHECK_ERR_GOTO(!VAR_8->must, LOGMEM(VAR_5), VAR_37);
}
if (VAR_17) {
VAR_8->iffeature = calloc(VAR_17, sizeof *VAR_8->iffeature);
LY_CHECK_ERR_GOTO(!VAR_8->iffeature, LOGMEM(VAR_5), VAR_37);
}
if (VAR_18) {
VAR_25 = realloc(VAR_6->ext, (VAR_18 + VAR_6->ext_size) * sizeof *VAR_6->ext);
LY_CHECK_ERR_GOTO(!VAR_25, LOGMEM(VAR_5), VAR_37);
VAR_6->ext = VAR_25;
memset(&VAR_6->ext[VAR_6->ext_size], 0, VAR_18 * sizeof *VAR_6->ext);
}
LY_TREE_FOR_SAFE(VAR_2->child, VAR_10, VAR_9) {
if (strcmp(VAR_9->ns->value, VAR_36)) {
VAR_13 = lyp_yin_fill_ext(VAR_6, VAR_27, 0, 0, VAR_0, VAR_9, &VAR_6->ext, &VAR_6->ext_size, VAR_4);
if (VAR_13) {
goto error;
}
} else if (!strcmp(VAR_9->name, ""typedef"")) {
VAR_13 = fill_yin_typedef(VAR_0, VAR_6, VAR_9, &VAR_8->tpdf[VAR_8->tpdf_size], VAR_4);
VAR_8->tpdf_size++;
if (VAR_13) {
goto error;
}
} else if (!strcmp(VAR_9->name, ""if-feature"")) {
VAR_13 = fill_yin_iffeature(VAR_6, 0, VAR_9, &VAR_8->iffeature[VAR_8->iffeature_size], VAR_4);
VAR_8->iffeature_size++;
if (VAR_13) {
goto error;
}
} else if (!strcmp(VAR_9->name, ""must"")) {
VAR_13 = fill_yin_must(VAR_0, VAR_9, &VAR_8->must[VAR_8->must_size], VAR_4);
VAR_8->must_size++;
if (VAR_13) {
goto error;
}
}
}
lyp_reduce_ext_list(&VAR_6->ext, VAR_6->ext_size, VAR_18 + VAR_6->ext_size);
LY_TREE_FOR_SAFE(VAR_11.child, VAR_10, VAR_9) {
if (!strcmp(VAR_9->name, ""container"")) {
VAR_7 = read_yin_container(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
} else if (!strcmp(VAR_9->name, ""leaf-list"")) {
VAR_7 = read_yin_leaflist(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
} else if (!strcmp(VAR_9->name, ""leaf"")) {
VAR_7 = read_yin_leaf(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
} else if (!strcmp(VAR_9->name, ""list"")) {
VAR_7 = read_yin_list(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
} else if (!strcmp(VAR_9->name, ""choice"")) {
VAR_7 = read_yin_choice(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
} else if (!strcmp(VAR_9->name, ""uses"")) {
VAR_7 = read_yin_uses(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
} else if (!strcmp(VAR_9->name, ""grouping"")) {
VAR_7 = read_yin_grouping(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
} else if (!strcmp(VAR_9->name, ""anyxml"")) {
VAR_7 = read_yin_anydata(VAR_0, VAR_6, VAR_9, VAR_57, VAR_3, VAR_4);
} else if (!strcmp(VAR_9->name, ""anydata"")) {
VAR_7 = read_yin_anydata(VAR_0, VAR_6, VAR_9, VAR_58, VAR_3, VAR_4);
} else if (!strcmp(VAR_9->name, ""action"")) {
VAR_7 = read_yin_rpc_action(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
} else if (!strcmp(VAR_9->name, ""notification"")) {
VAR_7 = read_yin_notif(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
} else {
LOGINT(VAR_5);
goto error;
}
if (!VAR_7) {
goto error;
}
lyxml_free(VAR_5, VAR_9);
}
if (VAR_8->keys_str) {
if (unres_schema_add_node(VAR_0, VAR_4, VAR_8, VAR_59, NULL) == -1) {
goto error;
}
} 
if (VAR_16) {
VAR_8->unique = calloc(VAR_16, sizeof *VAR_8->unique);
LY_CHECK_ERR_GOTO(!VAR_8->unique, LOGMEM(VAR_5), VAR_37);
LY_TREE_FOR_SAFE(VAR_12.child, VAR_10, VAR_9) {
VAR_13 = fill_yin_unique(VAR_0, VAR_6, VAR_9, &VAR_8->unique[VAR_8->unique_size], VAR_4);
VAR_8->unique_size++;
if (VAR_13) {
goto error;
}
if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_27, VAR_9,
VAR_60, VAR_8->unique_size - 1, VAR_4)) {
goto error;
}
lyxml_free(VAR_5, VAR_9);
}
}
if (!(VAR_5->models.flags & VAR_61) && (VAR_8->when || VAR_8->must)) {
if (VAR_3 & VAR_62) {
if (lyxp_node_check_syntax(VAR_6)) {
goto error;
}
} else {
if (unres_schema_add_node(VAR_0, VAR_4, VAR_6, VAR_63, NULL) == -1) {
goto error;
}
}
}
for (VAR_13 = 0; VAR_13 < VAR_6->ext_size; ++VAR_13) {
if (VAR_6->ext[VAR_13]->flags & VAR_64) {
VAR_6->flags |= VAR_65;
if (VAR_6->ext[VAR_13]->flags & VAR_66) {
VAR_6->flags |= VAR_67;
break;
}
}
}
return VAR_6;
error:
lys_node_free(VAR_5, VAR_6, NULL, 0);
while (VAR_11.child) {
lyxml_free(VAR_5, VAR_11.child);
}
while (VAR_12.child) {
lyxml_free(VAR_5, VAR_12.child);
}
return NULL;
}",CESNET/libyang/a3917d95d516e3de267d3cfa5d4d3715a90e8777/parser_yin.c/vul/before/2.json,"static struct lys_node *
read_yin_list(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options,
              struct unres_schema *unres)
{
    struct ly_ctx *ctx = module->ctx;
    struct lys_node *retval, *node;
    struct lys_node_list *list;
    struct lyxml_elem *sub, *next, root, uniq;
    int r;
    int c_tpdf = 0, c_must = 0, c_uniq = 0, c_ftrs = 0, c_ext = 0;
    int f_ordr = 0, f_max = 0, f_min = 0;
    const char *value;
    char *auxs;
    unsigned long val;
    void *reallocated;

    /* init */
    memset(&root, 0, sizeof root);
    memset(&uniq, 0, sizeof uniq);

    list = calloc(1, sizeof *list);
    LY_CHECK_ERR_RETURN(!list, LOGMEM(ctx), NULL);

    list->nodetype = LYS_LIST;
    list->prev = (struct lys_node *)list;
    retval = (struct lys_node *)list;

    if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,
            OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :
                (options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT),
            unres)) {
        goto error;
    }

    LOGDBG(LY_LDGYIN, ""parsing %s statement \""%s\"""", yin->name, retval->name);

    /* insert the node into the schema tree */
    if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {
        goto error;
    }

    /* process list's specific children */
    LY_TREE_FOR_SAFE(yin->child, next, sub) {
        if (strcmp(sub->ns->value, LY_NSYIN)) {
            /* extension */
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, ""extensions"", ""list"", error);
            c_ext++;
            continue;

        /* data statements */
        } else if (!strcmp(sub->name, ""container"") ||
                !strcmp(sub->name, ""leaf-list"") ||
                !strcmp(sub->name, ""leaf"") ||
                !strcmp(sub->name, ""list"") ||
                !strcmp(sub->name, ""choice"") ||
                !strcmp(sub->name, ""uses"") ||
                !strcmp(sub->name, ""grouping"") ||
                !strcmp(sub->name, ""anyxml"") ||
                !strcmp(sub->name, ""anydata"") ||
                !strcmp(sub->name, ""action"") ||
                !strcmp(sub->name, ""notification"")) {
            lyxml_unlink_elem(ctx, sub, 2);
            lyxml_add_child(ctx, &root, sub);

            /* array counters */
        } else if (!strcmp(sub->name, ""key"")) {
            /* check cardinality 0..1 */
            if (list->keys_size) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, list->name);
                goto error;
            }

            /* count the number of keys */
            GETVAL(ctx, value, sub, ""value"");
            list->keys_str = lydict_insert(ctx, value, 0);
            while ((value = strpbrk(value, "" \t\n""))) {
                list->keys_size++;
                while (isspace(*value)) {
                    value++;
                }
            }
            list->keys_size++;
            list->keys = calloc(list->keys_size, sizeof *list->keys);
            LY_CHECK_ERR_GOTO(!list->keys, LOGMEM(ctx), error);

            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_KEY, 0, unres)) {
                goto error;
            }
            lyxml_free(ctx, sub);
        } else if (!strcmp(sub->name, ""unique"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_uniq, list->unique_size, ""uniques"", ""list"", error);
            c_uniq++;
            lyxml_unlink_elem(ctx, sub, 2);
            lyxml_add_child(ctx, &uniq, sub);
        } else if (!strcmp(sub->name, ""typedef"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_tpdf, list->tpdf_size, ""typedefs"", ""list"", error);
            c_tpdf++;
        } else if (!strcmp(sub->name, ""must"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, list->must_size, ""musts"", ""list"", error);
            c_must++;
        } else if (!strcmp(sub->name, ""if-feature"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, ""if-features"", ""list"", error);
            c_ftrs++;

            /* optional stetments */
        } else if (!strcmp(sub->name, ""ordered-by"")) {
            if (f_ordr) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }
            /* just checking the flags in llist is not sufficient, we would
             * allow multiple ordered-by statements with the ""system"" value
             */
            f_ordr = 1;

            if (list->flags & LYS_CONFIG_R) {
                /* RFC 6020, 7.7.5 - ignore ordering when the list represents
                 * state data
                 */
                lyxml_free(ctx, sub);
                continue;
            }

            GETVAL(ctx, value, sub, ""value"");
            if (!strcmp(value, ""user"")) {
                list->flags |= LYS_USERORDERED;
            } else if (strcmp(value, ""system"")) {
                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
                goto error;
            } /* else system is the default value, so we can ignore it */

            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_ORDEREDBY, 0, unres)) {
                goto error;
            }
            lyxml_free(ctx, sub);
        } else if (!strcmp(sub->name, ""min-elements"")) {
            if (f_min) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }
            f_min = 1;

            GETVAL(ctx, value, sub, ""value"");
            while (isspace(value[0])) {
                value++;
            }

            /* convert it to uint32_t */
            errno = 0;
            auxs = NULL;
            val = strtoul(value, &auxs, 10);
            if (*auxs || value[0] == '-' || errno || val > UINT32_MAX) {
                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
                goto error;
            }
            list->min = (uint32_t) val;
            if (list->max && (list->min > list->max)) {
                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, ""\""min-elements\"" is bigger than \""max-elements\""."");
                lyxml_free(ctx, sub);
                goto error;
            }
            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MIN, 0, unres)) {
                goto error;
            }
            lyxml_free(ctx, sub);
        } else if (!strcmp(sub->name, ""max-elements"")) {
            if (f_max) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }
            f_max = 1;

            GETVAL(ctx, value, sub, ""value"");
            while (isspace(value[0])) {
                value++;
            }

            if (!strcmp(value, ""unbounded"")) {
                list->max = 0;;
            } else {
                /* convert it to uint32_t */
                errno = 0;
                auxs = NULL;
                val = strtoul(value, &auxs, 10);
                if (*auxs || value[0] == '-' || errno || val == 0 || val > UINT32_MAX) {
                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
                    goto error;
                }
                list->max = (uint32_t) val;
                if (list->min > list->max) {
                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);
                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, ""\""max-elements\"" is smaller than \""min-elements\""."");
                    goto error;
                }
            }
            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MAX, 0, unres)) {
                goto error;
            }
            lyxml_free(ctx, sub);
        } else if (!strcmp(sub->name, ""when"")) {
            if (list->when) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);
                goto error;
            }

            list->when = read_yin_when(module, sub, unres);
            if (!list->when) {
                lyxml_free(ctx, sub);
                goto error;
            }
            lyxml_free(ctx, sub);
        } else {
            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);
            goto error;
        }
    }

    /* check - if list is configuration, key statement is mandatory
     * (but only if we are not in a grouping or augment, then the check is deferred) */
    for (node = retval; node && !(node->nodetype & (LYS_GROUPING | LYS_AUGMENT | LYS_EXT)); node = node->parent);
    if (!node && (list->flags & LYS_CONFIG_W) && !list->keys_str) {
        LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, retval, ""key"", ""list"");
        goto error;
    }

    /* middle part - process nodes with cardinality of 0..n except the data nodes */
    if (c_tpdf) {
        list->tpdf = calloc(c_tpdf, sizeof *list->tpdf);
        LY_CHECK_ERR_GOTO(!list->tpdf, LOGMEM(ctx), error);
    }
    if (c_must) {
        list->must = calloc(c_must, sizeof *list->must);
        LY_CHECK_ERR_GOTO(!list->must, LOGMEM(ctx), error);
    }
    if (c_ftrs) {
        list->iffeature = calloc(c_ftrs, sizeof *list->iffeature);
        LY_CHECK_ERR_GOTO(!list->iffeature, LOGMEM(ctx), error);
    }
    if (c_ext) {
        /* some extensions may be already present from the substatements */
        reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);
        LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);
        retval->ext = reallocated;

        /* init memory */
        memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);
    }

    LY_TREE_FOR_SAFE(yin->child, next, sub) {
        if (strcmp(sub->ns->value, LY_NSYIN)) {
            /* extension */
            r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);
            if (r) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""typedef"")) {
            r = fill_yin_typedef(module, retval, sub, &list->tpdf[list->tpdf_size], unres);
            list->tpdf_size++;
            if (r) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""if-feature"")) {
            r = fill_yin_iffeature(retval, 0, sub, &list->iffeature[list->iffeature_size], unres);
            list->iffeature_size++;
            if (r) {
                goto error;
            }
        } else if (!strcmp(sub->name, ""must"")) {
            r = fill_yin_must(module, sub, &list->must[list->must_size], unres);
            list->must_size++;
            if (r) {
                goto error;
            }
        }
    }

    lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);

    /* last part - process data nodes */
    LY_TREE_FOR_SAFE(root.child, next, sub) {
        if (!strcmp(sub->name, ""container"")) {
            node = read_yin_container(module, retval, sub, options, unres);
        } else if (!strcmp(sub->name, ""leaf-list"")) {
            node = read_yin_leaflist(module, retval, sub, options, unres);
        } else if (!strcmp(sub->name, ""leaf"")) {
            node = read_yin_leaf(module, retval, sub, options, unres);
        } else if (!strcmp(sub->name, ""list"")) {
            node = read_yin_list(module, retval, sub, options, unres);
        } else if (!strcmp(sub->name, ""choice"")) {
            node = read_yin_choice(module, retval, sub, options, unres);
        } else if (!strcmp(sub->name, ""uses"")) {
            node = read_yin_uses(module, retval, sub, options, unres);
        } else if (!strcmp(sub->name, ""grouping"")) {
            node = read_yin_grouping(module, retval, sub, options, unres);
        } else if (!strcmp(sub->name, ""anyxml"")) {
            node = read_yin_anydata(module, retval, sub, LYS_ANYXML, options, unres);
        } else if (!strcmp(sub->name, ""anydata"")) {
            node = read_yin_anydata(module, retval, sub, LYS_ANYDATA, options, unres);
        } else if (!strcmp(sub->name, ""action"")) {
            node = read_yin_rpc_action(module, retval, sub, options, unres);
        } else if (!strcmp(sub->name, ""notification"")) {
            node = read_yin_notif(module, retval, sub, options, unres);
        } else {
            LOGINT(ctx);
            goto error;
        }
        if (!node) {
            goto error;
        }

        lyxml_free(ctx, sub);
    }

    if (list->keys_str) {
        if (unres_schema_add_node(module, unres, list, UNRES_LIST_KEYS, NULL) == -1) {
            goto error;
        }
    } /* else config false list without a key, key_str presence in case of config true is checked earlier */

    /* process unique statements */
    if (c_uniq) {
        list->unique = calloc(c_uniq, sizeof *list->unique);
        LY_CHECK_ERR_GOTO(!list->unique, LOGMEM(ctx), error);

        LY_TREE_FOR_SAFE(uniq.child, next, sub) {
            r = fill_yin_unique(module, retval, sub, &list->unique[list->unique_size], unres);
            list->unique_size++;
            if (r) {
                goto error;
            }

            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub,
                                     LYEXT_SUBSTMT_UNIQUE, list->unique_size - 1, unres)) {
                goto error;
            }
            lyxml_free(ctx, sub);
        }
    }

    /* check XPath dependencies */
    if (!(ctx->models.flags & LY_CTX_TRUSTED) && (list->when || list->must)) {
        if (options & LYS_PARSE_OPT_INGRP) {
            if (lyxp_node_check_syntax(retval)) {
                goto error;
            }
        } else {
            if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {
                goto error;
            }
        }
    }

    for (r = 0; r < retval->ext_size; ++r) {
        /* set flag, which represent LYEXT_OPT_VALID */
        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {
            retval->flags |= LYS_VALID_EXT;
            if (retval->ext[r]->flags & LYEXT_OPT_VALID_SUBTREE) {
                retval->flags |= LYS_VALID_EXT_SUBTREE;
                break;
            }
        }
    }

    return retval;

error:

    lys_node_free(ctx, retval, NULL, 0);
    while (root.child) {
        lyxml_free(ctx, root.child);
    }
    while (uniq.child) {
        lyxml_free(ctx, uniq.child);
    }

    return NULL;
}","static struct lys_node *
read_yin_list(struct lys_module *VAR_0, struct lys_node *VAR_1, struct lyxml_elem *VAR_2, int VAR_3,
              struct unres_schema *VAR_4)
{
    struct ly_ctx *VAR_5 = VAR_0->ctx;
    struct lys_node *VAR_6, *VAR_7;
    struct lys_node_list *VAR_8;
    struct lyxml_elem *VAR_9, *VAR_10, VAR_11, VAR_12;
    int VAR_13;
    int VAR_14 = 0, VAR_15 = 0, VAR_16 = 0, VAR_17 = 0, VAR_18 = 0;
    int VAR_19 = 0, VAR_20 = 0, VAR_21 = 0;
    const char *VAR_22;
    char *VAR_23;
    unsigned long VAR_24;
    void *VAR_25;

    /* COMMENT_0 */
    memset(&VAR_11, 0, sizeof VAR_11);
    memset(&VAR_12, 0, sizeof VAR_12);

    VAR_8 = calloc(1, sizeof *VAR_8);
    LY_CHECK_ERR_RETURN(!VAR_8, LOGMEM(VAR_5), NULL);

    VAR_8->nodetype = VAR_26;
    VAR_8->prev = (struct lys_node *)VAR_8;
    VAR_6 = (struct lys_node *)VAR_8;

    if (read_yin_common(VAR_0, VAR_1, VAR_6, VAR_27, VAR_2,
            VAR_28 | VAR_29 | ((VAR_3 & VAR_30) ? VAR_31 :
                (VAR_3 & VAR_32) ? VAR_33 : VAR_33 | VAR_34),
            VAR_4)) {
        goto error;
    }

    LOGDBG(VAR_35, ""parsing %s statement \""%s\"""", VAR_2->name, VAR_6->name);

    /* COMMENT_1 */
    if (lys_node_addchild(VAR_1, lys_main_module(VAR_0), VAR_6, VAR_3)) {
        goto error;
    }

    /* COMMENT_2 */
    LY_TREE_FOR_SAFE(VAR_2->child, VAR_10, VAR_9) {
        if (strcmp(VAR_9->ns->value, VAR_36)) {
            /* COMMENT_3 */
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_18, VAR_6->ext_size, ""extensions"", ""list"", VAR_37);
            VAR_18++;
            continue;

        /* COMMENT_4 */
        } else if (!strcmp(VAR_9->name, ""container"") ||
                !strcmp(VAR_9->name, ""leaf-list"") ||
                !strcmp(VAR_9->name, ""leaf"") ||
                !strcmp(VAR_9->name, ""list"") ||
                !strcmp(VAR_9->name, ""choice"") ||
                !strcmp(VAR_9->name, ""uses"") ||
                !strcmp(VAR_9->name, ""grouping"") ||
                !strcmp(VAR_9->name, ""anyxml"") ||
                !strcmp(VAR_9->name, ""anydata"") ||
                !strcmp(VAR_9->name, ""action"") ||
                !strcmp(VAR_9->name, ""notification"")) {
            lyxml_unlink_elem(VAR_5, VAR_9, 2);
            lyxml_add_child(VAR_5, &VAR_11, VAR_9);

            /* COMMENT_5 */
        } else if (!strcmp(VAR_9->name, ""key"")) {
            /* COMMENT_6 */
            if (VAR_8->keys_size) {
                LOGVAL(VAR_5, VAR_38, VAR_39, VAR_6, VAR_9->name, VAR_8->name);
                goto error;
            }

            /* COMMENT_7 */
            GETVAL(VAR_5, VAR_22, VAR_9, ""value"");
            VAR_8->keys_str = lydict_insert(VAR_5, VAR_22, 0);
            while ((VAR_22 = strpbrk(VAR_22, "" \t\n""))) {
                VAR_8->keys_size++;
                while (isspace(*VAR_22)) {
                    VAR_22++;
                }
            }
            VAR_8->keys_size++;
            VAR_8->keys = calloc(VAR_8->keys_size, sizeof *VAR_8->keys);
            LY_CHECK_ERR_GOTO(!VAR_8->keys, LOGMEM(VAR_5), VAR_37);

            if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_27, VAR_9, VAR_40, 0, VAR_4)) {
                goto error;
            }
            lyxml_free(VAR_5, VAR_9);
        } else if (!strcmp(VAR_9->name, ""unique"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_16, VAR_8->unique_size, ""uniques"", ""list"", VAR_37);
            VAR_16++;
            lyxml_unlink_elem(VAR_5, VAR_9, 2);
            lyxml_add_child(VAR_5, &VAR_12, VAR_9);
        } else if (!strcmp(VAR_9->name, ""typedef"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_14, VAR_8->tpdf_size, ""typedefs"", ""list"", VAR_37);
            VAR_14++;
        } else if (!strcmp(VAR_9->name, ""must"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_15, VAR_8->must_size, ""musts"", ""list"", VAR_37);
            VAR_15++;
        } else if (!strcmp(VAR_9->name, ""if-feature"")) {
            YIN_CHECK_ARRAY_OVERFLOW_GOTO(VAR_5, VAR_17, VAR_6->iffeature_size, ""if-features"", ""list"", VAR_37);
            VAR_17++;

            /* COMMENT_8 */
        } else if (!strcmp(VAR_9->name, ""ordered-by"")) {
            if (VAR_19) {
                LOGVAL(VAR_5, VAR_38, VAR_39, VAR_6, VAR_9->name, VAR_2->name);
                goto error;
            }
            /* COMMENT_9 */
                                                                           
               
            VAR_19 = 1;

            if (VAR_8->flags & VAR_41) {
                /* COMMENT_12 */
                             
                   
                lyxml_free(VAR_5, VAR_9);
                continue;
            }

            GETVAL(VAR_5, VAR_22, VAR_9, ""value"");
            if (!strcmp(VAR_22, ""user"")) {
                VAR_8->flags |= VAR_42;
            } else if (strcmp(VAR_22, ""system"")) {
                LOGVAL(VAR_5, VAR_43, VAR_39, VAR_6, VAR_22, VAR_9->name);
                goto error;
            } /* COMMENT_15 */

            if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_27, VAR_9, VAR_44, 0, VAR_4)) {
                goto error;
            }
            lyxml_free(VAR_5, VAR_9);
        } else if (!strcmp(VAR_9->name, ""min-elements"")) {
            if (VAR_21) {
                LOGVAL(VAR_5, VAR_38, VAR_39, VAR_6, VAR_9->name, VAR_2->name);
                goto error;
            }
            VAR_21 = 1;

            GETVAL(VAR_5, VAR_22, VAR_9, ""value"");
            while (isspace(VAR_22[0])) {
                VAR_22++;
            }

            /* COMMENT_16 */
            VAR_45 = 0;
            VAR_23 = NULL;
            VAR_24 = strtoul(VAR_22, &VAR_23, 10);
            if (*VAR_23 || VAR_22[0] == '-' || VAR_45 || VAR_24 > VAR_46) {
                LOGVAL(VAR_5, VAR_43, VAR_39, VAR_6, VAR_22, VAR_9->name);
                goto error;
            }
            VAR_8->min = (uint32_t) VAR_24;
            if (VAR_8->max && (VAR_8->min > VAR_8->max)) {
                LOGVAL(VAR_5, VAR_43, VAR_39, VAR_6, VAR_22, VAR_9->name);
                LOGVAL(VAR_5, VAR_47, VAR_48, NULL, ""\""min-elements\"" is bigger than \""max-elements\""."");
                lyxml_free(VAR_5, VAR_9);
                goto error;
            }
            if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_27, VAR_9, VAR_49, 0, VAR_4)) {
                goto error;
            }
            lyxml_free(VAR_5, VAR_9);
        } else if (!strcmp(VAR_9->name, ""max-elements"")) {
            if (VAR_20) {
                LOGVAL(VAR_5, VAR_38, VAR_39, VAR_6, VAR_9->name, VAR_2->name);
                goto error;
            }
            VAR_20 = 1;

            GETVAL(VAR_5, VAR_22, VAR_9, ""value"");
            while (isspace(VAR_22[0])) {
                VAR_22++;
            }

            if (!strcmp(VAR_22, ""unbounded"")) {
                VAR_8->max = 0;;
            } else {
                /* COMMENT_16 */
                VAR_45 = 0;
                VAR_23 = NULL;
                VAR_24 = strtoul(VAR_22, &VAR_23, 10);
                if (*VAR_23 || VAR_22[0] == '-' || VAR_45 || VAR_24 == 0 || VAR_24 > VAR_46) {
                    LOGVAL(VAR_5, VAR_43, VAR_39, VAR_6, VAR_22, VAR_9->name);
                    goto error;
                }
                VAR_8->max = (uint32_t) VAR_24;
                if (VAR_8->min > VAR_8->max) {
                    LOGVAL(VAR_5, VAR_43, VAR_39, VAR_6, VAR_22, VAR_9->name);
                    LOGVAL(VAR_5, VAR_47, VAR_48, NULL, ""\""max-elements\"" is smaller than \""min-elements\""."");
                    goto error;
                }
            }
            if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_27, VAR_9, VAR_50, 0, VAR_4)) {
                goto error;
            }
            lyxml_free(VAR_5, VAR_9);
        } else if (!strcmp(VAR_9->name, ""when"")) {
            if (VAR_8->when) {
                LOGVAL(VAR_5, VAR_38, VAR_39, VAR_6, VAR_9->name, VAR_2->name);
                goto error;
            }

            VAR_8->when = read_yin_when(VAR_0, VAR_9, VAR_4);
            if (!VAR_8->when) {
                lyxml_free(VAR_5, VAR_9);
                goto error;
            }
            lyxml_free(VAR_5, VAR_9);
        } else {
            LOGVAL(VAR_5, VAR_51, VAR_39, VAR_6, VAR_9->name);
            goto error;
        }
    }

    /* COMMENT_17 */
                                                                                       
    for (VAR_7 = VAR_6; VAR_7 && !(VAR_7->nodetype & (VAR_52 | VAR_53 | VAR_54)); VAR_7 = VAR_7->parent);
    if (!VAR_7 && (VAR_8->flags & VAR_55) && !VAR_8->keys_str) {
        LOGVAL(VAR_5, VAR_56, VAR_39, VAR_6, ""key"", ""list"");
        goto error;
    }

    /* COMMENT_19 */
    if (VAR_14) {
        VAR_8->tpdf = calloc(VAR_14, sizeof *VAR_8->tpdf);
        LY_CHECK_ERR_GOTO(!VAR_8->tpdf, LOGMEM(VAR_5), VAR_37);
    }
    if (VAR_15) {
        VAR_8->must = calloc(VAR_15, sizeof *VAR_8->must);
        LY_CHECK_ERR_GOTO(!VAR_8->must, LOGMEM(VAR_5), VAR_37);
    }
    if (VAR_17) {
        VAR_8->iffeature = calloc(VAR_17, sizeof *VAR_8->iffeature);
        LY_CHECK_ERR_GOTO(!VAR_8->iffeature, LOGMEM(VAR_5), VAR_37);
    }
    if (VAR_18) {
        /* COMMENT_20 */
        VAR_25 = realloc(VAR_6->ext, (VAR_18 + VAR_6->ext_size) * sizeof *VAR_6->ext);
        LY_CHECK_ERR_GOTO(!VAR_25, LOGMEM(VAR_5), VAR_37);
        VAR_6->ext = VAR_25;

        /* COMMENT_21 */
        memset(&VAR_6->ext[VAR_6->ext_size], 0, VAR_18 * sizeof *VAR_6->ext);
    }

    LY_TREE_FOR_SAFE(VAR_2->child, VAR_10, VAR_9) {
        if (strcmp(VAR_9->ns->value, VAR_36)) {
            /* COMMENT_3 */
            VAR_13 = lyp_yin_fill_ext(VAR_6, VAR_27, 0, 0, VAR_0, VAR_9, &VAR_6->ext, &VAR_6->ext_size, VAR_4);
            if (VAR_13) {
                goto error;
            }
        } else if (!strcmp(VAR_9->name, ""typedef"")) {
            VAR_13 = fill_yin_typedef(VAR_0, VAR_6, VAR_9, &VAR_8->tpdf[VAR_8->tpdf_size], VAR_4);
            VAR_8->tpdf_size++;
            if (VAR_13) {
                goto error;
            }
        } else if (!strcmp(VAR_9->name, ""if-feature"")) {
            VAR_13 = fill_yin_iffeature(VAR_6, 0, VAR_9, &VAR_8->iffeature[VAR_8->iffeature_size], VAR_4);
            VAR_8->iffeature_size++;
            if (VAR_13) {
                goto error;
            }
        } else if (!strcmp(VAR_9->name, ""must"")) {
            VAR_13 = fill_yin_must(VAR_0, VAR_9, &VAR_8->must[VAR_8->must_size], VAR_4);
            VAR_8->must_size++;
            if (VAR_13) {
                goto error;
            }
        }
    }

    lyp_reduce_ext_list(&VAR_6->ext, VAR_6->ext_size, VAR_18 + VAR_6->ext_size);

    /* COMMENT_22 */
    LY_TREE_FOR_SAFE(VAR_11.child, VAR_10, VAR_9) {
        if (!strcmp(VAR_9->name, ""container"")) {
            VAR_7 = read_yin_container(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
        } else if (!strcmp(VAR_9->name, ""leaf-list"")) {
            VAR_7 = read_yin_leaflist(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
        } else if (!strcmp(VAR_9->name, ""leaf"")) {
            VAR_7 = read_yin_leaf(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
        } else if (!strcmp(VAR_9->name, ""list"")) {
            VAR_7 = read_yin_list(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
        } else if (!strcmp(VAR_9->name, ""choice"")) {
            VAR_7 = read_yin_choice(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
        } else if (!strcmp(VAR_9->name, ""uses"")) {
            VAR_7 = read_yin_uses(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
        } else if (!strcmp(VAR_9->name, ""grouping"")) {
            VAR_7 = read_yin_grouping(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
        } else if (!strcmp(VAR_9->name, ""anyxml"")) {
            VAR_7 = read_yin_anydata(VAR_0, VAR_6, VAR_9, VAR_57, VAR_3, VAR_4);
        } else if (!strcmp(VAR_9->name, ""anydata"")) {
            VAR_7 = read_yin_anydata(VAR_0, VAR_6, VAR_9, VAR_58, VAR_3, VAR_4);
        } else if (!strcmp(VAR_9->name, ""action"")) {
            VAR_7 = read_yin_rpc_action(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
        } else if (!strcmp(VAR_9->name, ""notification"")) {
            VAR_7 = read_yin_notif(VAR_0, VAR_6, VAR_9, VAR_3, VAR_4);
        } else {
            LOGINT(VAR_5);
            goto error;
        }
        if (!VAR_7) {
            goto error;
        }

        lyxml_free(VAR_5, VAR_9);
    }

    if (VAR_8->keys_str) {
        if (unres_schema_add_node(VAR_0, VAR_4, VAR_8, VAR_59, NULL) == -1) {
            goto error;
        }
    } /* COMMENT_23 */

    /* COMMENT_24 */
    if (VAR_16) {
        VAR_8->unique = calloc(VAR_16, sizeof *VAR_8->unique);
        LY_CHECK_ERR_GOTO(!VAR_8->unique, LOGMEM(VAR_5), VAR_37);

        LY_TREE_FOR_SAFE(VAR_12.child, VAR_10, VAR_9) {
            VAR_13 = fill_yin_unique(VAR_0, VAR_6, VAR_9, &VAR_8->unique[VAR_8->unique_size], VAR_4);
            VAR_8->unique_size++;
            if (VAR_13) {
                goto error;
            }

            if (lyp_yin_parse_subnode_ext(VAR_0, VAR_6, VAR_27, VAR_9,
                                     VAR_60, VAR_8->unique_size - 1, VAR_4)) {
                goto error;
            }
            lyxml_free(VAR_5, VAR_9);
        }
    }

    /* COMMENT_25 */
    if (!(VAR_5->models.flags & VAR_61) && (VAR_8->when || VAR_8->must)) {
        if (VAR_3 & VAR_62) {
            if (lyxp_node_check_syntax(VAR_6)) {
                goto error;
            }
        } else {
            if (unres_schema_add_node(VAR_0, VAR_4, VAR_6, VAR_63, NULL) == -1) {
                goto error;
            }
        }
    }

    for (VAR_13 = 0; VAR_13 < VAR_6->ext_size; ++VAR_13) {
        /* COMMENT_26 */
        if (VAR_6->ext[VAR_13] && (VAR_6->ext[VAR_13]->flags & VAR_64)) {
            VAR_6->flags |= VAR_65;
            if (VAR_6->ext[VAR_13]->flags & VAR_66) {
                VAR_6->flags |= VAR_67;
                break;
            }
        }
    }

    return VAR_6;

error:

    lys_node_free(VAR_5, VAR_6, NULL, 0);
    while (VAR_11.child) {
        lyxml_free(VAR_5, VAR_11.child);
    }
    while (VAR_12.child) {
        lyxml_free(VAR_5, VAR_12.child);
    }

    return NULL;
}",CESNET/libyang/a3917d95d516e3de267d3cfa5d4d3715a90e8777/parser_yin.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -353,7 +353,7 @@
 
     for (r = 0; r < retval->ext_size; ++r) {
         /* set flag, which represent LYEXT_OPT_VALID */
-        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {
+        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {
             retval->flags |= LYS_VALID_EXT;
             if (retval->ext[r]->flags & LYEXT_OPT_VALID_SUBTREE) {
                 retval->flags |= LYS_VALID_EXT_SUBTREE;","{'deleted_lines': ['        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {'], 'added_lines': ['        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {']}",True,"In function read_yin_container() in libyang <= v1.0.225, it doesn't check whether the value of retval->ext[r] is NULL. In some cases, it can be NULL, which leads to the operation of retval->ext[r]->flags that results in a crash.",7.5,HIGH,2,test,2021-03-08T13:08:05Z,3
CVE-2021-31272,['CWE-22'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,SerenityOS/serenity,"Userland: Fix tar/unzip directory traversal vulnerability

This change validates the filenames within a tar/zip archive during
extraction. If the filename within a the archive is outside of the
current working directory the file will be skipped and not extracted
onto the host system.

Closes #3991
Closes #3992",3844e8569689dd476064a0759d704bc64fb3ca2c,https://github.com/SerenityOS/serenity/commit/3844e8569689dd476064a0759d704bc64fb3ca2c,Userland/Utilities/unzip.cpp,unpack_file_for_central_directory_index,"static bool unpack_file_for_central_directory_index(off_t central_directory_index, const MappedFile& file)
{
enum CentralFileDirectoryHeaderOffsets {
CFDHCompressionMethodOffset = 10,
CFDHLocalFileHeaderIndexOffset = 42,
};
enum LocalFileHeaderOffsets {
LFHCompressionMethodOffset = 8,
LFHCompressedSizeOffset = 18,
LFHFileNameLengthOffset = 26,
LFHExtraFieldLengthOffset = 28,
LFHFileNameBaseOffset = 30,
};
enum CompressionMethod {
None = 0,
Shrunk = 1,
Factor1 = 2,
Factor2 = 3,
Factor3 = 4,
Factor4 = 5,
Implode = 6,
Deflate = 8,
EnhancedDeflate = 9,
PKWareDCLImplode = 10,
BZIP2 = 12,
LZMA = 14,
TERSE = 18,
LZ77 = 19,
};
u8 buffer[4];
if (!seek_and_read(buffer, file, central_directory_index + CFDHLocalFileHeaderIndexOffset, 4))
return false;
off_t local_file_header_index = buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
if (!seek_and_read(buffer, file, local_file_header_index + LFHCompressionMethodOffset, 2))
return false;
auto compression_method = buffer[1] << 8 | buffer[0];
VERIFY(compression_method == None);
if (!seek_and_read(buffer, file, local_file_header_index + LFHCompressedSizeOffset, 4))
return false;
off_t compressed_file_size = buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
if (!seek_and_read(buffer, file, local_file_header_index + LFHFileNameLengthOffset, 2))
return false;
off_t file_name_length = buffer[1] << 8 | buffer[0];
if (!seek_and_read(buffer, file, local_file_header_index + LFHExtraFieldLengthOffset, 2))
return false;
off_t extra_field_length = buffer[1] << 8 | buffer[0];
char file_name[file_name_length + 1];
if (!seek_and_read((u8*)file_name, file, local_file_header_index + LFHFileNameBaseOffset, file_name_length))
return false;
file_name[file_name_length] = '\0';
if (file_name[file_name_length - 1] == '/') {
if (mkdir(file_name, 0755) < 0) {
perror(""mkdir"");
return false;
}
} else {
auto new_file = Core::File::construct(String { file_name });
if (!new_file->open(Core::IODevice::WriteOnly)) {
fprintf(stderr, ""Can't write file %s: %s\n"", file_name, new_file->error_string());
return false;
}
printf("" extracting: %s\n"", file_name);
u8 raw_file_contents[compressed_file_size];
if (!seek_and_read(raw_file_contents, file, local_file_header_index + LFHFileNameBaseOffset + file_name_length + extra_field_length, compressed_file_size))
return false;
if (!new_file->write(raw_file_contents, compressed_file_size)) {
fprintf(stderr, ""Can't write file contents in %s: %s\n"", file_name, new_file->error_string());
return false;
}
if (!new_file->close()) {
fprintf(stderr, ""Can't close file %s: %s\n"", file_name, new_file->error_string());
return false;
}
}
return true;
}","static bool unpack_file_for_central_directory_index(off_t VAR_0, const MappedFile& VAR_1)
{
enum CentralFileDirectoryHeaderOffsets {
VAR_2 = 10,
VAR_3 = 42,
};
enum LocalFileHeaderOffsets {
VAR_4 = 8,
VAR_5 = 18,
VAR_6 = 26,
VAR_7 = 28,
VAR_8 = 30,
};
enum CompressionMethod {
VAR_9 = 0,
VAR_10 = 1,
VAR_11 = 2,
VAR_12 = 3,
VAR_13 = 4,
VAR_14 = 5,
VAR_15 = 6,
VAR_16 = 8,
VAR_17 = 9,
VAR_18 = 10,
VAR_19 = 12,
VAR_20 = 14,
VAR_21 = 18,
VAR_22 = 19,
};
u8 VAR_23[4];
if (!seek_and_read(VAR_23, VAR_1, VAR_0 + VAR_3, 4))
return false;
off_t VAR_24 = VAR_23[3] << 24 | VAR_23[2] << 16 | VAR_23[1] << 8 | VAR_23[0];
if (!seek_and_read(VAR_23, VAR_1, VAR_24 + VAR_4, 2))
return false;
auto VAR_25 = VAR_23[1] << 8 | VAR_23[0];
VERIFY(VAR_25 == VAR_9);
if (!seek_and_read(VAR_23, VAR_1, VAR_24 + VAR_5, 4))
return false;
off_t VAR_26 = VAR_23[3] << 24 | VAR_23[2] << 16 | VAR_23[1] << 8 | VAR_23[0];
if (!seek_and_read(VAR_23, VAR_1, VAR_24 + VAR_6, 2))
return false;
off_t VAR_27 = VAR_23[1] << 8 | VAR_23[0];
if (!seek_and_read(VAR_23, VAR_1, VAR_24 + VAR_7, 2))
return false;
off_t VAR_28 = VAR_23[1] << 8 | VAR_23[0];
char VAR_29[VAR_27 + 1];
if (!seek_and_read((u8*)VAR_29, VAR_1, VAR_24 + VAR_8, VAR_27))
return false;
VAR_29[VAR_27] = '\0';
if (VAR_29[VAR_27 - 1] == '/') {
if (mkdir(VAR_29, 0755) < 0) {
perror(""mkdir"");
return false;
}
} else {
auto VAR_30 = Core::File::construct(String { VAR_29 });
if (!VAR_30->open(Core::IODevice::WriteOnly)) {
fprintf(VAR_31, ""Can't write file %s: %s\n"", VAR_29, VAR_30->error_string());
return false;
}
printf("" extracting: %s\n"", VAR_29);
u8 VAR_32[VAR_26];
if (!seek_and_read(VAR_32, VAR_1, VAR_24 + VAR_8 + VAR_27 + VAR_28, VAR_26))
return false;
if (!VAR_30->write(VAR_32, VAR_26)) {
fprintf(VAR_31, ""Can't write file contents in %s: %s\n"", VAR_29, VAR_30->error_string());
return false;
}
if (!VAR_30->close()) {
fprintf(VAR_31, ""Can't close file %s: %s\n"", VAR_29, VAR_30->error_string());
return false;
}
}
return true;
}",SerenityOS/serenity/3844e8569689dd476064a0759d704bc64fb3ca2c/unzip.cpp/vul/before/1.json,"static bool unpack_file_for_central_directory_index(off_t central_directory_index, const MappedFile& file, const AK::String target_path)
{
    enum CentralFileDirectoryHeaderOffsets {
        CFDHCompressionMethodOffset = 10,
        CFDHLocalFileHeaderIndexOffset = 42,
    };
    enum LocalFileHeaderOffsets {
        LFHCompressionMethodOffset = 8,
        LFHCompressedSizeOffset = 18,
        LFHFileNameLengthOffset = 26,
        LFHExtraFieldLengthOffset = 28,
        LFHFileNameBaseOffset = 30,
    };
    enum CompressionMethod {
        None = 0,
        Shrunk = 1,
        Factor1 = 2,
        Factor2 = 3,
        Factor3 = 4,
        Factor4 = 5,
        Implode = 6,
        Deflate = 8,
        EnhancedDeflate = 9,
        PKWareDCLImplode = 10,
        BZIP2 = 12,
        LZMA = 14,
        TERSE = 18,
        LZ77 = 19,
    };

    u8 buffer[4];
    if (!seek_and_read(buffer, file, central_directory_index + CFDHLocalFileHeaderIndexOffset, 4))
        return false;
    off_t local_file_header_index = buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];

    if (!seek_and_read(buffer, file, local_file_header_index + LFHCompressionMethodOffset, 2))
        return false;
    auto compression_method = buffer[1] << 8 | buffer[0];
    // FIXME: Remove once any decompression is supported.
    VERIFY(compression_method == None);

    if (!seek_and_read(buffer, file, local_file_header_index + LFHCompressedSizeOffset, 4))
        return false;
    off_t compressed_file_size = buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];

    if (!seek_and_read(buffer, file, local_file_header_index + LFHFileNameLengthOffset, 2))
        return false;
    off_t file_name_length = buffer[1] << 8 | buffer[0];

    if (!seek_and_read(buffer, file, local_file_header_index + LFHExtraFieldLengthOffset, 2))
        return false;
    off_t extra_field_length = buffer[1] << 8 | buffer[0];

    char file_name[file_name_length + 1];
    if (!seek_and_read((u8*)file_name, file, local_file_header_index + LFHFileNameBaseOffset, file_name_length))
        return false;
    file_name[file_name_length] = '\0';

    // determine where the archive intends to write a file
    StringBuilder destination_path_raw;
    if (file_name[0] != '/') {
        destination_path_raw.append(target_path);
        destination_path_raw.append(""/"");
    }
    destination_path_raw.append(file_name);
    LexicalPath destination_path(destination_path_raw.to_string());
    if (!(destination_path.string().starts_with(target_path))) {
        fprintf(stderr, ""File %s path is outside of current working directory, skipping\n"", file_name);
        return false;
    }

    // Ignore zips containing target path.
    // This will prevent mkdir from failing later when it probably shouldn't
    if (destination_path.string() == target_path) {
        return true;
    }

    if (file_name[file_name_length - 1] == '/') {
        if (mkdir(file_name, 0755) < 0) {
            perror(""mkdir"");
            return false;
        }
    } else {
        auto new_file = Core::File::construct(String { file_name });
        if (!new_file->open(Core::IODevice::WriteOnly)) {
            fprintf(stderr, ""Can't write file %s: %s\n"", file_name, new_file->error_string());
            return false;
        }

        printf("" extracting: %s\n"", file_name);
        u8 raw_file_contents[compressed_file_size];
        if (!seek_and_read(raw_file_contents, file, local_file_header_index + LFHFileNameBaseOffset + file_name_length + extra_field_length, compressed_file_size))
            return false;

        // FIXME: Try to uncompress data here. We're just ignoring it as no decompression methods are implemented yet.
        if (!new_file->write(raw_file_contents, compressed_file_size)) {
            fprintf(stderr, ""Can't write file contents in %s: %s\n"", file_name, new_file->error_string());
            return false;
        }

        if (!new_file->close()) {
            fprintf(stderr, ""Can't close file %s: %s\n"", file_name, new_file->error_string());
            return false;
        }
    }

    return true;
}","static bool unpack_file_for_central_directory_index(off_t VAR_0, const MappedFile& VAR_1, const AK::String VAR_2)
{
    enum CentralFileDirectoryHeaderOffsets {
        VAR_3 = 10,
        VAR_4 = 42,
    };
    enum LocalFileHeaderOffsets {
        VAR_5 = 8,
        VAR_6 = 18,
        VAR_7 = 26,
        VAR_8 = 28,
        VAR_9 = 30,
    };
    enum CompressionMethod {
        VAR_10 = 0,
        VAR_11 = 1,
        VAR_12 = 2,
        VAR_13 = 3,
        VAR_14 = 4,
        VAR_15 = 5,
        VAR_16 = 6,
        VAR_17 = 8,
        VAR_18 = 9,
        VAR_19 = 10,
        VAR_20 = 12,
        VAR_21 = 14,
        VAR_22 = 18,
        VAR_23 = 19,
    };

    u8 VAR_24[4];
    if (!seek_and_read(VAR_24, VAR_1, VAR_0 + VAR_4, 4))
        return false;
    off_t VAR_25 = VAR_24[3] << 24 | VAR_24[2] << 16 | VAR_24[1] << 8 | VAR_24[0];

    if (!seek_and_read(VAR_24, VAR_1, VAR_25 + VAR_5, 2))
        return false;
    auto VAR_26 = VAR_24[1] << 8 | VAR_24[0];
    /* COMMENT_0 */
    VERIFY(VAR_26 == VAR_10);

    if (!seek_and_read(VAR_24, VAR_1, VAR_25 + VAR_6, 4))
        return false;
    off_t VAR_27 = VAR_24[3] << 24 | VAR_24[2] << 16 | VAR_24[1] << 8 | VAR_24[0];

    if (!seek_and_read(VAR_24, VAR_1, VAR_25 + VAR_7, 2))
        return false;
    off_t VAR_28 = VAR_24[1] << 8 | VAR_24[0];

    if (!seek_and_read(VAR_24, VAR_1, VAR_25 + VAR_8, 2))
        return false;
    off_t VAR_29 = VAR_24[1] << 8 | VAR_24[0];

    char VAR_30[VAR_28 + 1];
    if (!seek_and_read((u8*)VAR_30, VAR_1, VAR_25 + VAR_9, VAR_28))
        return false;
    VAR_30[VAR_28] = '\0';

    /* COMMENT_1 */
    StringBuilder VAR_31;
    if (VAR_30[0] != '/') {
        VAR_31.append(VAR_2);
        VAR_31.append(""/"");
    }
    VAR_31.append(VAR_30);
    LexicalPath VAR_32(VAR_31.to_string());
    if (!(VAR_32.string().starts_with(VAR_2))) {
        fprintf(VAR_33, ""File %s path is outside of current working directory, skipping\n"", VAR_30);
        return false;
    }

    /* COMMENT_2 */
    /* COMMENT_3 */
    if (VAR_32.string() == VAR_2) {
        return true;
    }

    if (VAR_30[VAR_28 - 1] == '/') {
        if (mkdir(VAR_30, 0755) < 0) {
            perror(""mkdir"");
            return false;
        }
    } else {
        auto VAR_34 = Core::File::construct(String { VAR_30 });
        if (!VAR_34->open(Core::IODevice::WriteOnly)) {
            fprintf(VAR_33, ""Can't write file %s: %s\n"", VAR_30, VAR_34->error_string());
            return false;
        }

        printf("" extracting: %s\n"", VAR_30);
        u8 VAR_35[VAR_27];
        if (!seek_and_read(VAR_35, VAR_1, VAR_25 + VAR_9 + VAR_28 + VAR_29, VAR_27))
            return false;

        /* COMMENT_4 */
        if (!VAR_34->write(VAR_35, VAR_27)) {
            fprintf(VAR_33, ""Can't write file contents in %s: %s\n"", VAR_30, VAR_34->error_string());
            return false;
        }

        if (!VAR_34->close()) {
            fprintf(VAR_33, ""Can't close file %s: %s\n"", VAR_30, VAR_34->error_string());
            return false;
        }
    }

    return true;
}",SerenityOS/serenity/3844e8569689dd476064a0759d704bc64fb3ca2c/unzip.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-static bool unpack_file_for_central_directory_index(off_t central_directory_index, const MappedFile& file)
+static bool unpack_file_for_central_directory_index(off_t central_directory_index, const MappedFile& file, const AK::String target_path)
 {
     enum CentralFileDirectoryHeaderOffsets {
         CFDHCompressionMethodOffset = 10,
@@ -56,6 +56,25 @@
         return false;
     file_name[file_name_length] = '\0';
 
+    // determine where the archive intends to write a file
+    StringBuilder destination_path_raw;
+    if (file_name[0] != '/') {
+        destination_path_raw.append(target_path);
+        destination_path_raw.append(""/"");
+    }
+    destination_path_raw.append(file_name);
+    LexicalPath destination_path(destination_path_raw.to_string());
+    if (!(destination_path.string().starts_with(target_path))) {
+        fprintf(stderr, ""File %s path is outside of current working directory, skipping\n"", file_name);
+        return false;
+    }
+
+    // Ignore zips containing target path.
+    // This will prevent mkdir from failing later when it probably shouldn't
+    if (destination_path.string() == target_path) {
+        return true;
+    }
+
     if (file_name[file_name_length - 1] == '/') {
         if (mkdir(file_name, 0755) < 0) {
             perror(""mkdir"");","{'deleted_lines': ['static bool unpack_file_for_central_directory_index(off_t central_directory_index, const MappedFile& file)'], 'added_lines': ['static bool unpack_file_for_central_directory_index(off_t central_directory_index, const MappedFile& file, const AK::String target_path)', '    // determine where the archive intends to write a file', '    StringBuilder destination_path_raw;', ""    if (file_name[0] != '/') {"", '        destination_path_raw.append(target_path);', '        destination_path_raw.append(""/"");', '    }', '    destination_path_raw.append(file_name);', '    LexicalPath destination_path(destination_path_raw.to_string());', '    if (!(destination_path.string().starts_with(target_path))) {', '        fprintf(stderr, ""File %s path is outside of current working directory, skipping\\n"", file_name);', '        return false;', '    }', '', '    // Ignore zips containing target path.', ""    // This will prevent mkdir from failing later when it probably shouldn't"", '    if (destination_path.string() == target_path) {', '        return true;', '    }', '']}",True,SerenityOS before commit 3844e8569689dd476064a0759d704bc64fb3ca2c contains a directory traversal vulnerability in tar/unzip that may lead to command execution or privilege escalation.,9.8,CRITICAL,3,test,2021-03-18T01:41:34Z,3
CVE-2021-31272,['CWE-22'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,SerenityOS/serenity,"Userland: Fix tar/unzip directory traversal vulnerability

This change validates the filenames within a tar/zip archive during
extraction. If the filename within a the archive is outside of the
current working directory the file will be skipped and not extracted
onto the host system.

Closes #3991
Closes #3992",3844e8569689dd476064a0759d704bc64fb3ca2c,https://github.com/SerenityOS/serenity/commit/3844e8569689dd476064a0759d704bc64fb3ca2c,Userland/Utilities/unzip.cpp,main,"int main(int argc, char** argv)
{
const char* path;
int map_size_limit = 32 * MiB;
Core::ArgsParser args_parser;
args_parser.add_option(map_size_limit, ""Maximum chunk size to map"", ""map-size-limit"", 0, ""size"");
args_parser.add_positional_argument(path, ""File to unzip"", ""path"", Core::ArgsParser::Required::Yes);
args_parser.parse(argc, argv);
String zip_file_path { path };
struct stat st;
int rc = stat(zip_file_path.characters(), &st);
if (rc < 0) {
perror(""stat"");
return 1;
}
if (st.st_size >= map_size_limit) {
fprintf(stderr, ""unzip warning: Refusing to map file since it is larger than %s, pass '--map-size-limit %d' to get around this\n"",
human_readable_size(map_size_limit).characters(),
round_up_to_power_of_two(st.st_size, 16));
return 1;
}
auto file_or_error = MappedFile ::map(zip_file_path);
if (file_or_error.is_error()) {
warnln(""Failed to open {}: {}"", zip_file_path, file_or_error.error());
return 1;
}
auto& mapped_file = *file_or_error.value();
printf(""Archive: %s\n"", zip_file_path.characters());
off_t index = 0;
while (find_next_central_directory(st.st_size, mapped_file, index, index)) {
bool success = unpack_file_for_central_directory_index(index, mapped_file);
if (!success) {
printf(""Could not find local file header for a file.\n"");
return 4;
}
}
return 0;
}","int main(int VAR_0, char** VAR_1)
{
const char* VAR_2;
int VAR_3 = 32 * VAR_4;
Core::ArgsParser VAR_5;
VAR_5.add_option(VAR_3, ""Maximum chunk size to map"", ""map-size-limit"", 0, ""size"");
VAR_5.add_positional_argument(VAR_2, ""File to unzip"", ""path"", Core::ArgsParser::Required::Yes);
VAR_5.parse(VAR_0, VAR_1);
String VAR_6 { VAR_2 };
struct stat VAR_7;
int VAR_8 = stat(VAR_6.characters(), &VAR_7);
if (VAR_8 < 0) {
perror(""stat"");
return 1;
}
if (VAR_7.st_size >= VAR_3) {
fprintf(VAR_9, ""unzip warning: Refusing to map file since it is larger than %s, pass '--map-size-limit %d' to get around this\n"",
human_readable_size(VAR_3).characters(),
round_up_to_power_of_two(VAR_7.st_size, 16));
return 1;
}
auto VAR_10 = MappedFile ::map(VAR_6);
if (VAR_10.is_error()) {
warnln(""Failed to open {}: {}"", VAR_6, VAR_10.error());
return 1;
}
auto& VAR_11 = *VAR_10.value();
printf(""Archive: %s\n"", VAR_6.characters());
off_t VAR_12 = 0;
while (find_next_central_directory(VAR_7.st_size, VAR_11, VAR_12, VAR_12)) {
bool VAR_13 = unpack_file_for_central_directory_index(VAR_12, VAR_11);
if (!VAR_13) {
printf(""Could not find local file header for a file.\n"");
return 4;
}
}
return 0;
}",SerenityOS/serenity/3844e8569689dd476064a0759d704bc64fb3ca2c/unzip.cpp/vul/before/0.json,"int main(int argc, char** argv)
{
    const char* path;
    int map_size_limit = 32 * MiB;

    Core::ArgsParser args_parser;
    args_parser.add_option(map_size_limit, ""Maximum chunk size to map"", ""map-size-limit"", 0, ""size"");
    args_parser.add_positional_argument(path, ""File to unzip"", ""path"", Core::ArgsParser::Required::Yes);
    args_parser.parse(argc, argv);

    StringBuilder target_path_raw;
    // Currently unzip doesn't support extracting to a specified location. If that is implemented the target_path
    // should be replaced with the target path from the command line arguements instead of "".""
    target_path_raw.append(realpath(""."", nullptr));
    target_path_raw.append(""/"");
    LexicalPath target_path(target_path_raw.to_string());
    auto target_path_string = target_path.string();
    if (unveil(target_path_string.characters(), ""rwc"") < 0) {
        perror(""unveil"");
        return 1;
    }

    auto zip_path = realpath(path, nullptr);
    if (unveil(zip_path, ""r"") < 0) {
        perror(""unveil"");
        return 1;
    }

    if (unveil(nullptr, nullptr) < 0) {
        perror(""unveil"");
        return 1;
    }

    String zip_file_path { path };

    struct stat st;
    int rc = stat(zip_file_path.characters(), &st);
    if (rc < 0) {
        perror(""stat"");
        return 1;
    }

    // FIXME: Map file chunk-by-chunk once we have mmap() with offset.
    //        This will require mapping some parts then unmapping them repeatedly,
    //        but it would be significantly faster and less syscall heavy than seek()/read() at every read.
    if (st.st_size >= map_size_limit) {
        fprintf(stderr, ""unzip warning: Refusing to map file since it is larger than %s, pass '--map-size-limit %d' to get around this\n"",
            human_readable_size(map_size_limit).characters(),
            round_up_to_power_of_two(st.st_size, 16));
        return 1;
    }

    auto file_or_error = MappedFile ::map(zip_file_path);
    if (file_or_error.is_error()) {
        warnln(""Failed to open {}: {}"", zip_file_path, file_or_error.error());
        return 1;
    }
    auto& mapped_file = *file_or_error.value();

    printf(""Archive: %s\n"", zip_file_path.characters());

    off_t index = 0;
    while (find_next_central_directory(st.st_size, mapped_file, index, index)) {
        bool success = unpack_file_for_central_directory_index(index, mapped_file, target_path_string);
        if (!success) {
            printf(""Could not find local file header for a file.\n"");
            return 4;
        }
    }

    return 0;
}","int main(int VAR_0, char** VAR_1)
{
    const char* VAR_2;
    int VAR_3 = 32 * VAR_4;

    Core::ArgsParser VAR_5;
    VAR_5.add_option(VAR_3, ""Maximum chunk size to map"", ""map-size-limit"", 0, ""size"");
    VAR_5.add_positional_argument(VAR_2, ""File to unzip"", ""path"", Core::ArgsParser::Required::Yes);
    VAR_5.parse(VAR_0, VAR_1);

    StringBuilder VAR_6;
    /* COMMENT_0 */
    /* COMMENT_1 */
    VAR_6.append(realpath(""."", nullptr));
    VAR_6.append(""/"");
    LexicalPath VAR_7(VAR_6.to_string());
    auto VAR_8 = VAR_7.string();
    if (unveil(VAR_8.characters(), ""rwc"") < 0) {
        perror(""unveil"");
        return 1;
    }

    auto VAR_9 = realpath(VAR_2, nullptr);
    if (unveil(VAR_9, ""r"") < 0) {
        perror(""unveil"");
        return 1;
    }

    if (unveil(nullptr, nullptr) < 0) {
        perror(""unveil"");
        return 1;
    }

    String VAR_10 { VAR_2 };

    struct stat VAR_11;
    int VAR_12 = stat(VAR_10.characters(), &VAR_11);
    if (VAR_12 < 0) {
        perror(""stat"");
        return 1;
    }

    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    if (VAR_11.st_size >= VAR_3) {
        fprintf(VAR_13, ""unzip warning: Refusing to map file since it is larger than %s, pass '--map-size-limit %d' to get around this\n"",
            human_readable_size(VAR_3).characters(),
            round_up_to_power_of_two(VAR_11.st_size, 16));
        return 1;
    }

    auto VAR_14 = MappedFile ::map(VAR_10);
    if (VAR_14.is_error()) {
        warnln(""Failed to open {}: {}"", VAR_10, VAR_14.error());
        return 1;
    }
    auto& VAR_15 = *VAR_14.value();

    printf(""Archive: %s\n"", VAR_10.characters());

    off_t VAR_16 = 0;
    while (find_next_central_directory(VAR_11.st_size, VAR_15, VAR_16, VAR_16)) {
        bool VAR_17 = unpack_file_for_central_directory_index(VAR_16, VAR_15, VAR_8);
        if (!VAR_17) {
            printf(""Could not find local file header for a file.\n"");
            return 4;
        }
    }

    return 0;
}",SerenityOS/serenity/3844e8569689dd476064a0759d704bc64fb3ca2c/unzip.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,6 +7,29 @@
     args_parser.add_option(map_size_limit, ""Maximum chunk size to map"", ""map-size-limit"", 0, ""size"");
     args_parser.add_positional_argument(path, ""File to unzip"", ""path"", Core::ArgsParser::Required::Yes);
     args_parser.parse(argc, argv);
+
+    StringBuilder target_path_raw;
+    // Currently unzip doesn't support extracting to a specified location. If that is implemented the target_path
+    // should be replaced with the target path from the command line arguements instead of "".""
+    target_path_raw.append(realpath(""."", nullptr));
+    target_path_raw.append(""/"");
+    LexicalPath target_path(target_path_raw.to_string());
+    auto target_path_string = target_path.string();
+    if (unveil(target_path_string.characters(), ""rwc"") < 0) {
+        perror(""unveil"");
+        return 1;
+    }
+
+    auto zip_path = realpath(path, nullptr);
+    if (unveil(zip_path, ""r"") < 0) {
+        perror(""unveil"");
+        return 1;
+    }
+
+    if (unveil(nullptr, nullptr) < 0) {
+        perror(""unveil"");
+        return 1;
+    }
 
     String zip_file_path { path };
 
@@ -38,7 +61,7 @@
 
     off_t index = 0;
     while (find_next_central_directory(st.st_size, mapped_file, index, index)) {
-        bool success = unpack_file_for_central_directory_index(index, mapped_file);
+        bool success = unpack_file_for_central_directory_index(index, mapped_file, target_path_string);
         if (!success) {
             printf(""Could not find local file header for a file.\n"");
             return 4;","{'deleted_lines': ['        bool success = unpack_file_for_central_directory_index(index, mapped_file);'], 'added_lines': ['', '    StringBuilder target_path_raw;', ""    // Currently unzip doesn't support extracting to a specified location. If that is implemented the target_path"", '    // should be replaced with the target path from the command line arguements instead of "".""', '    target_path_raw.append(realpath(""."", nullptr));', '    target_path_raw.append(""/"");', '    LexicalPath target_path(target_path_raw.to_string());', '    auto target_path_string = target_path.string();', '    if (unveil(target_path_string.characters(), ""rwc"") < 0) {', '        perror(""unveil"");', '        return 1;', '    }', '', '    auto zip_path = realpath(path, nullptr);', '    if (unveil(zip_path, ""r"") < 0) {', '        perror(""unveil"");', '        return 1;', '    }', '', '    if (unveil(nullptr, nullptr) < 0) {', '        perror(""unveil"");', '        return 1;', '    }', '        bool success = unpack_file_for_central_directory_index(index, mapped_file, target_path_string);']}",True,SerenityOS before commit 3844e8569689dd476064a0759d704bc64fb3ca2c contains a directory traversal vulnerability in tar/unzip that may lead to command execution or privilege escalation.,9.8,CRITICAL,3,test,2021-03-18T01:41:34Z,3
CVE-2021-31272,['CWE-22'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,SerenityOS/serenity,"Userland: Fix tar/unzip directory traversal vulnerability

This change validates the filenames within a tar/zip archive during
extraction. If the filename within a the archive is outside of the
current working directory the file will be skipped and not extracted
onto the host system.

Closes #3991
Closes #3992",3844e8569689dd476064a0759d704bc64fb3ca2c,https://github.com/SerenityOS/serenity/commit/3844e8569689dd476064a0759d704bc64fb3ca2c,Userland/Utilities/tar.cpp,main,"int main(int argc, char** argv)
{
bool create = false;
bool extract = false;
bool list = false;
bool verbose = false;
bool gzip = false;
const char* archive_file = nullptr;
Vector<const char*> paths;
Core::ArgsParser args_parser;
args_parser.add_option(create, ""Create archive"", ""create"", 'c');
args_parser.add_option(extract, ""Extract archive"", ""extract"", 'x');
args_parser.add_option(list, ""List contents"", ""list"", 't');
args_parser.add_option(verbose, ""Print paths"", ""verbose"", 'v');
args_parser.add_option(gzip, ""compress or uncompress file using gzip"", ""gzip"", 'z');
args_parser.add_option(archive_file, ""Archive file"", ""file"", 'f', ""FILE"");
args_parser.add_positional_argument(paths, ""Paths"", ""PATHS"", Core::ArgsParser::Required::No);
args_parser.parse(argc, argv);
if (create + extract + list != 1) {
warnln(""exactly one of -c, -x, and -t can be used"");
return 1;
}
if (list || extract) {
auto file = Core::File::standard_input();
if (archive_file) {
auto maybe_file = Core::File::open(archive_file, Core::IODevice::OpenMode::ReadOnly);
if (maybe_file.is_error()) {
warnln(""Core::File::open: {}"", maybe_file.error());
return 1;
}
file = maybe_file.value();
}
Core::InputFileStream file_stream(file);
Compress::GzipDecompressor gzip_stream(file_stream);
InputStream& file_input_stream = file_stream;
InputStream& gzip_input_stream = gzip_stream;
Tar::TarInputStream tar_stream((gzip) ? gzip_input_stream : file_input_stream);
if (!tar_stream.valid()) {
warnln(""the provided file is not a well-formatted ustar file"");
return 1;
}
for (; !tar_stream.finished(); tar_stream.advance()) {
if (list || verbose)
outln(""{}"", tar_stream.header().file_name());
if (extract) {
Tar::TarFileStream file_stream = tar_stream.file_contents();
const Tar::Header& header = tar_stream.header();
switch (header.type_flag()) {
case Tar::NormalFile:
case Tar::AlternateNormalFile: {
int fd = open(String(header.file_name()).characters(), O_CREAT | O_WRONLY, header.mode());
if (fd < 0) {
perror(""open"");
return 1;
}
Array<u8, buffer_size> buffer;
size_t nread;
while ((nread = file_stream.read(buffer)) > 0) {
if (write(fd, buffer.data(), nread) < 0) {
perror(""write"");
return 1;
}
}
close(fd);
break;
}
case Tar::Directory: {
if (mkdir(String(header.file_name()).characters(), header.mode())) {
perror(""mkdir"");
return 1;
}
break;
}
default:
VERIFY_NOT_REACHED();
}
}
}
file_stream.close();
return 0;
}
if (create) {
if (paths.size() == 0) {
warnln(""you must provide at least one path to be archived"");
return 1;
}
auto file = Core::File::standard_output();
if (archive_file) {
auto maybe_file = Core::File::open(archive_file, Core::IODevice::OpenMode::WriteOnly);
if (maybe_file.is_error()) {
warnln(""Core::File::open: {}"", maybe_file.error());
return 1;
}
file = maybe_file.value();
}
Core::OutputFileStream file_stream(file);
Compress::GzipCompressor gzip_stream(file_stream);
OutputStream& file_output_stream = file_stream;
OutputStream& gzip_output_stream = gzip_stream;
Tar::TarOutputStream tar_stream((gzip) ? gzip_output_stream : file_output_stream);
auto add_file = [&](String path) {
auto file = Core::File::construct(path);
if (!file->open(Core::IODevice::ReadOnly)) {
warnln(""Failed to open {}: {}"", path, file->error_string());
return;
}
struct stat statbuf;
if (lstat(path.characters(), &statbuf) < 0) {
warnln(""Failed stating {}"", path);
return;
}
auto canonicalized_path = LexicalPath::canonicalized_path(path);
tar_stream.add_file(canonicalized_path, statbuf.st_mode, file->read_all());
if (verbose)
outln(""{}"", canonicalized_path);
};
auto add_directory = [&](String path, auto handle_directory) -> void {
struct stat statbuf;
if (lstat(path.characters(), &statbuf) < 0) {
warnln(""Failed stating {}"", path);
return;
}
auto canonicalized_path = LexicalPath::canonicalized_path(path);
tar_stream.add_directory(canonicalized_path, statbuf.st_mode);
if (verbose)
outln(""{}"", canonicalized_path);
Core::DirIterator it(path, Core::DirIterator::Flags::SkipParentAndBaseDir);
while (it.has_next()) {
auto child_path = it.next_full_path();
if (!Core::File::is_directory(child_path)) {
add_file(child_path);
} else {
handle_directory(child_path, handle_directory);
}
}
};
for (const String& path : paths) {
if (Core::File::is_directory(path)) {
add_directory(path, add_directory);
} else {
add_file(path);
}
}
tar_stream.finish();
return 0;
}
return 0;
}","int main(int VAR_0, char** VAR_1)
{
bool VAR_2 = false;
bool VAR_3 = false;
bool VAR_4 = false;
bool VAR_5 = false;
bool VAR_6 = false;
const char* VAR_7 = nullptr;
Vector<const char*> VAR_8;
Core::ArgsParser VAR_9;
VAR_9.add_option(VAR_2, ""Create archive"", ""create"", 'c');
VAR_9.add_option(VAR_3, ""Extract archive"", ""extract"", 'x');
VAR_9.add_option(VAR_4, ""List contents"", ""list"", 't');
VAR_9.add_option(VAR_5, ""Print paths"", ""verbose"", 'v');
VAR_9.add_option(VAR_6, ""compress or uncompress file using gzip"", ""gzip"", 'z');
VAR_9.add_option(VAR_7, ""Archive file"", ""file"", 'f', ""FILE"");
VAR_9.add_positional_argument(VAR_8, ""Paths"", ""PATHS"", Core::ArgsParser::Required::No);
VAR_9.parse(VAR_0, VAR_1);
if (VAR_2 + VAR_3 + VAR_4 != 1) {
warnln(""exactly one of -c, -x, and -t can be used"");
return 1;
}
if (VAR_4 || VAR_3) {
auto VAR_10 = Core::File::standard_input();
if (VAR_7) {
auto VAR_11 = Core::File::open(VAR_7, Core::IODevice::OpenMode::ReadOnly);
if (VAR_11.is_error()) {
warnln(""Core::File::open: {}"", VAR_11.error());
return 1;
}
VAR_10 = VAR_11.value();
}
Core::InputFileStream file_stream(file);
Compress::GzipDecompressor gzip_stream(file_stream);
InputStream& VAR_12 = file_stream;
InputStream& VAR_13 = VAR_14;
Tar::TarInputStream VAR_15((VAR_6) ? VAR_13 : VAR_12);
if (!VAR_15.valid()) {
warnln(""the provided file is not a well-formatted ustar file"");
return 1;
}
for (; !VAR_15.finished(); VAR_15.advance()) {
if (VAR_4 || VAR_5)
outln(""{}"", VAR_15.header().file_name());
if (VAR_3) {
Tar::TarFileStream file_stream = VAR_15.file_contents();
const Tar::Header& VAR_16 = VAR_15.header();
switch (VAR_16.type_flag()) {
case Tar::NormalFile:
case Tar::AlternateNormalFile: {
int VAR_17 = open(String(VAR_16.file_name()).characters(), VAR_18 | VAR_19, VAR_16.mode());
if (VAR_17 < 0) {
perror(""open"");
return 1;
}
Array<u8, buffer_size> VAR_20;
size_t VAR_21;
while ((VAR_21 = file_stream.read(VAR_20)) > 0) {
if (write(VAR_17, VAR_20.data(), VAR_21) < 0) {
perror(""write"");
return 1;
}
}
close(VAR_17);
break;
}
case Tar::Directory: {
if (mkdir(String(VAR_16.file_name()).characters(), VAR_16.mode())) {
perror(""mkdir"");
return 1;
}
break;
}
default:
VERIFY_NOT_REACHED();
}
}
}
file_stream.close();
return 0;
}
if (VAR_2) {
if (VAR_8.size() == 0) {
warnln(""you must provide at least one path to be archived"");
return 1;
}
auto file = Core::File::standard_output();
if (VAR_7) {
auto VAR_11 = Core::File::open(VAR_7, Core::IODevice::OpenMode::WriteOnly);
if (VAR_11.is_error()) {
warnln(""Core::File::open: {}"", VAR_11.error());
return 1;
}
file = VAR_11.value();
}
Core::OutputFileStream file_stream(file);
Compress::GzipCompressor gzip_stream(file_stream);
OutputStream& VAR_22 = file_stream;
OutputStream& VAR_23 = VAR_14;
Tar::TarOutputStream VAR_15((VAR_6) ? VAR_23 : VAR_22);
auto VAR_24 = [&](String VAR_25) {
auto file = Core::File::construct(VAR_25);
if (!file->open(Core::IODevice::ReadOnly)) {
warnln(""Failed to open {}: {}"", VAR_25, file->error_string());
return;
}
struct stat VAR_26;
if (lstat(VAR_25.characters(), &VAR_26) < 0) {
warnln(""Failed stating {}"", VAR_25);
return;
}
auto VAR_27 = LexicalPath::canonicalized_path(VAR_25);
VAR_15.add_file(VAR_27, VAR_26.st_mode, file->read_all());
if (VAR_5)
outln(""{}"", VAR_27);
};
auto VAR_28 = [&](String VAR_25, auto VAR_29) -> void {
struct stat VAR_26;
if (lstat(VAR_25.characters(), &VAR_26) < 0) {
warnln(""Failed stating {}"", VAR_25);
return;
}
auto VAR_27 = LexicalPath::canonicalized_path(VAR_25);
VAR_15.add_directory(VAR_27, VAR_26.st_mode);
if (VAR_5)
outln(""{}"", VAR_27);
Core::DirIterator it(path, Core::DirIterator::Flags::SkipParentAndBaseDir);
while (VAR_30.has_next()) {
auto VAR_31 = VAR_30.next_full_path();
if (!Core::File::is_directory(VAR_31)) {
VAR_24(VAR_31);
} else {
VAR_29(VAR_31, VAR_29);
}
}
};
for (const String& path : VAR_8) {
if (Core::File::is_directory(path)) {
VAR_28(path, VAR_28);
} else {
VAR_24(path);
}
}
VAR_15.finish();
return 0;
}
return 0;
}",SerenityOS/serenity/3844e8569689dd476064a0759d704bc64fb3ca2c/tar.cpp/vul/before/0.json,"int main(int argc, char** argv)
{
    bool create = false;
    bool extract = false;
    bool list = false;
    bool verbose = false;
    bool gzip = false;
    const char* archive_file = nullptr;
    Vector<const char*> paths;

    Core::ArgsParser args_parser;
    args_parser.add_option(create, ""Create archive"", ""create"", 'c');
    args_parser.add_option(extract, ""Extract archive"", ""extract"", 'x');
    args_parser.add_option(list, ""List contents"", ""list"", 't');
    args_parser.add_option(verbose, ""Print paths"", ""verbose"", 'v');
    args_parser.add_option(gzip, ""compress or uncompress file using gzip"", ""gzip"", 'z');
    args_parser.add_option(archive_file, ""Archive file"", ""file"", 'f', ""FILE"");
    args_parser.add_positional_argument(paths, ""Paths"", ""PATHS"", Core::ArgsParser::Required::No);
    args_parser.parse(argc, argv);

    // Currently tar doesn't support extracting to a specified location. If that is implemented the target path
    // should be unveiled with rwc instead of the current directory.
    StringBuilder target_path_raw;
    target_path_raw.append(realpath(""."", nullptr));
    target_path_raw.append(""/"");
    LexicalPath target_path(target_path_raw.to_string());
    auto target_path_string = target_path.string();
    if (unveil(target_path_string.characters(), ""rwc"") < 0) {
        perror(""unveil"");
        return 1;
    }

    if (create + extract + list != 1) {
        warnln(""exactly one of -c, -x, and -t can be used"");
        return 1;
    }

    if (list || extract) {
        auto file = Core::File::standard_input();

        if (archive_file) {
            // make sure we can read the archive path
            auto archive_file_path = realpath(archive_file, nullptr);
            if (unveil(archive_file_path, ""r"") < 0) {
                perror(""unveil"");
                return 1;
            }
            if (unveil(nullptr, nullptr) < 0) {
                perror(""unveil"");
                return 1;
            }
            auto maybe_file = Core::File::open(archive_file, Core::IODevice::OpenMode::ReadOnly);
            if (maybe_file.is_error()) {
                warnln(""Core::File::open: {}"", maybe_file.error());
                return 1;
            }
            file = maybe_file.value();
        }

        Core::InputFileStream file_stream(file);
        Compress::GzipDecompressor gzip_stream(file_stream);

        InputStream& file_input_stream = file_stream;
        InputStream& gzip_input_stream = gzip_stream;
        Tar::TarInputStream tar_stream((gzip) ? gzip_input_stream : file_input_stream);
        if (!tar_stream.valid()) {
            warnln(""the provided file is not a well-formatted ustar file"");
            return 1;
        }

        for (; !tar_stream.finished(); tar_stream.advance()) {
            auto file_name = tar_stream.header().file_name();

            if (list || verbose)
                outln(""{}"", file_name);

            if (extract) {
                Tar::TarFileStream file_stream = tar_stream.file_contents();

                const Tar::Header& header = tar_stream.header();

                // determine where the archive intends to write a file
                StringBuilder destination_path_raw;
                if (file_name[0] != '/') {
                    destination_path_raw.append(target_path_string);
                    destination_path_raw.append(""/"");
                }
                destination_path_raw.append(file_name);
                LexicalPath destination_path(destination_path_raw.to_string());

                if (!(destination_path.string().starts_with(target_path_string))) {
                    fprintf(stderr, ""File %s path is outside of current working directory, skipping\n"", file_name.to_string().characters());
                    return false;
                }

                // Ignore tars containing target path.
                // This will prevent mkdir from failing later when it probably shouldn't
                if (destination_path.string() == target_path_string) {
                    continue;
                }

                switch (header.type_flag()) {
                case Tar::NormalFile:
                case Tar::AlternateNormalFile: {
                    int fd = open(String(header.file_name()).characters(), O_CREAT | O_WRONLY, header.mode());
                    if (fd < 0) {
                        perror(""open"");
                        return 1;
                    }

                    Array<u8, buffer_size> buffer;
                    size_t nread;
                    while ((nread = file_stream.read(buffer)) > 0) {
                        if (write(fd, buffer.data(), nread) < 0) {
                            perror(""write"");
                            return 1;
                        }
                    }
                    close(fd);
                    break;
                }
                case Tar::Directory: {
                    if (mkdir(String(header.file_name()).characters(), header.mode())) {
                        perror(""mkdir"");
                        return 1;
                    }
                    break;
                }
                default:
                    // FIXME: Implement other file types
                    VERIFY_NOT_REACHED();
                }
            }
        }
        file_stream.close();
        return 0;
    }

    if (create) {
        if (paths.size() == 0) {
            warnln(""you must provide at least one path to be archived"");
            return 1;
        }

        auto file = Core::File::standard_output();

        if (archive_file) {
            auto maybe_file = Core::File::open(archive_file, Core::IODevice::OpenMode::WriteOnly);
            if (maybe_file.is_error()) {
                warnln(""Core::File::open: {}"", maybe_file.error());
                return 1;
            }
            file = maybe_file.value();
        }

        Core::OutputFileStream file_stream(file);
        Compress::GzipCompressor gzip_stream(file_stream);

        OutputStream& file_output_stream = file_stream;
        OutputStream& gzip_output_stream = gzip_stream;
        Tar::TarOutputStream tar_stream((gzip) ? gzip_output_stream : file_output_stream);

        auto add_file = [&](String path) {
            auto file = Core::File::construct(path);
            if (!file->open(Core::IODevice::ReadOnly)) {
                warnln(""Failed to open {}: {}"", path, file->error_string());
                return;
            }

            struct stat statbuf;
            if (lstat(path.characters(), &statbuf) < 0) {
                warnln(""Failed stating {}"", path);
                return;
            }
            auto canonicalized_path = LexicalPath::canonicalized_path(path);
            tar_stream.add_file(canonicalized_path, statbuf.st_mode, file->read_all());
            if (verbose)
                outln(""{}"", canonicalized_path);
        };

        auto add_directory = [&](String path, auto handle_directory) -> void {
            struct stat statbuf;
            if (lstat(path.characters(), &statbuf) < 0) {
                warnln(""Failed stating {}"", path);
                return;
            }
            auto canonicalized_path = LexicalPath::canonicalized_path(path);
            tar_stream.add_directory(canonicalized_path, statbuf.st_mode);
            if (verbose)
                outln(""{}"", canonicalized_path);

            Core::DirIterator it(path, Core::DirIterator::Flags::SkipParentAndBaseDir);
            while (it.has_next()) {
                auto child_path = it.next_full_path();
                if (!Core::File::is_directory(child_path)) {
                    add_file(child_path);
                } else {
                    handle_directory(child_path, handle_directory);
                }
            }
        };

        for (const String& path : paths) {
            if (Core::File::is_directory(path)) {
                add_directory(path, add_directory);
            } else {
                add_file(path);
            }
        }

        tar_stream.finish();

        return 0;
    }

    return 0;
}","int main(int VAR_0, char** VAR_1)
{
    bool VAR_2 = false;
    bool VAR_3 = false;
    bool VAR_4 = false;
    bool VAR_5 = false;
    bool VAR_6 = false;
    const char* VAR_7 = nullptr;
    Vector<const char*> VAR_8;

    Core::ArgsParser VAR_9;
    VAR_9.add_option(VAR_2, ""Create archive"", ""create"", 'c');
    VAR_9.add_option(VAR_3, ""Extract archive"", ""extract"", 'x');
    VAR_9.add_option(VAR_4, ""List contents"", ""list"", 't');
    VAR_9.add_option(VAR_5, ""Print paths"", ""verbose"", 'v');
    VAR_9.add_option(VAR_6, ""compress or uncompress file using gzip"", ""gzip"", 'z');
    VAR_9.add_option(VAR_7, ""Archive file"", ""file"", 'f', ""FILE"");
    VAR_9.add_positional_argument(VAR_8, ""Paths"", ""PATHS"", Core::ArgsParser::Required::No);
    VAR_9.parse(VAR_0, VAR_1);

    /* COMMENT_0 */
    /* COMMENT_1 */
    StringBuilder VAR_10;
    VAR_10.append(realpath(""."", nullptr));
    VAR_10.append(""/"");
    LexicalPath VAR_11(VAR_10.to_string());
    auto VAR_12 = VAR_11.string();
    if (unveil(VAR_12.characters(), ""rwc"") < 0) {
        perror(""unveil"");
        return 1;
    }

    if (VAR_2 + VAR_3 + VAR_4 != 1) {
        warnln(""exactly one of -c, -x, and -t can be used"");
        return 1;
    }

    if (VAR_4 || VAR_3) {
        auto VAR_13 = Core::File::standard_input();

        if (VAR_7) {
            /* COMMENT_2 */
            auto VAR_14 = realpath(VAR_7, nullptr);
            if (unveil(VAR_14, ""r"") < 0) {
                perror(""unveil"");
                return 1;
            }
            if (unveil(nullptr, nullptr) < 0) {
                perror(""unveil"");
                return 1;
            }
            auto VAR_15 = Core::File::open(VAR_7, Core::IODevice::OpenMode::ReadOnly);
            if (VAR_15.is_error()) {
                warnln(""Core::File::open: {}"", VAR_15.error());
                return 1;
            }
            VAR_13 = VAR_15.value();
        }

        Core::InputFileStream file_stream(file);
        Compress::GzipDecompressor gzip_stream(file_stream);

        InputStream& VAR_16 = file_stream;
        InputStream& VAR_17 = VAR_18;
        Tar::TarInputStream VAR_19((VAR_6) ? VAR_17 : VAR_16);
        if (!VAR_19.valid()) {
            warnln(""the provided file is not a well-formatted ustar file"");
            return 1;
        }

        for (; !VAR_19.finished(); VAR_19.advance()) {
            auto VAR_20 = VAR_19.header().file_name();

            if (VAR_4 || VAR_5)
                outln(""{}"", VAR_20);

            if (VAR_3) {
                Tar::TarFileStream file_stream = VAR_19.file_contents();

                const Tar::Header& VAR_21 = VAR_19.header();

                /* COMMENT_3 */
                StringBuilder VAR_22;
                if (VAR_20[0] != '/') {
                    VAR_22.append(VAR_12);
                    VAR_22.append(""/"");
                }
                VAR_22.append(VAR_20);
                LexicalPath VAR_23(VAR_22.to_string());

                if (!(VAR_23.string().starts_with(VAR_12))) {
                    fprintf(VAR_24, ""File %s path is outside of current working directory, skipping\n"", VAR_20.to_string().characters());
                    return false;
                }

                /* COMMENT_4 */
                /* COMMENT_5 */
                if (VAR_23.string() == VAR_12) {
                    continue;
                }

                switch (VAR_21.type_flag()) {
                case Tar::NormalFile:
                case Tar::AlternateNormalFile: {
                    int VAR_25 = open(String(VAR_21.file_name()).characters(), VAR_26 | VAR_27, VAR_21.mode());
                    if (VAR_25 < 0) {
                        perror(""open"");
                        return 1;
                    }

                    Array<u8, buffer_size> VAR_28;
                    size_t VAR_29;
                    while ((VAR_29 = file_stream.read(VAR_28)) > 0) {
                        if (write(VAR_25, VAR_28.data(), VAR_29) < 0) {
                            perror(""write"");
                            return 1;
                        }
                    }
                    close(VAR_25);
                    break;
                }
                case Tar::Directory: {
                    if (mkdir(String(VAR_21.file_name()).characters(), VAR_21.mode())) {
                        perror(""mkdir"");
                        return 1;
                    }
                    break;
                }
                default:
                    /* COMMENT_6 */
                    VERIFY_NOT_REACHED();
                }
            }
        }
        file_stream.close();
        return 0;
    }

    if (VAR_2) {
        if (VAR_8.size() == 0) {
            warnln(""you must provide at least one path to be archived"");
            return 1;
        }

        auto file = Core::File::standard_output();

        if (VAR_7) {
            auto VAR_15 = Core::File::open(VAR_7, Core::IODevice::OpenMode::WriteOnly);
            if (VAR_15.is_error()) {
                warnln(""Core::File::open: {}"", VAR_15.error());
                return 1;
            }
            file = VAR_15.value();
        }

        Core::OutputFileStream file_stream(file);
        Compress::GzipCompressor gzip_stream(file_stream);

        OutputStream& VAR_30 = file_stream;
        OutputStream& VAR_31 = VAR_18;
        Tar::TarOutputStream VAR_19((VAR_6) ? VAR_31 : VAR_30);

        auto VAR_32 = [&](String VAR_33) {
            auto file = Core::File::construct(VAR_33);
            if (!file->open(Core::IODevice::ReadOnly)) {
                warnln(""Failed to open {}: {}"", VAR_33, file->error_string());
                return;
            }

            struct stat VAR_34;
            if (lstat(VAR_33.characters(), &VAR_34) < 0) {
                warnln(""Failed stating {}"", VAR_33);
                return;
            }
            auto VAR_35 = LexicalPath::canonicalized_path(VAR_33);
            VAR_19.add_file(VAR_35, VAR_34.st_mode, file->read_all());
            if (VAR_5)
                outln(""{}"", VAR_35);
        };

        auto VAR_36 = [&](String VAR_33, auto VAR_37) -> void {
            struct stat VAR_34;
            if (lstat(VAR_33.characters(), &VAR_34) < 0) {
                warnln(""Failed stating {}"", VAR_33);
                return;
            }
            auto VAR_35 = LexicalPath::canonicalized_path(VAR_33);
            VAR_19.add_directory(VAR_35, VAR_34.st_mode);
            if (VAR_5)
                outln(""{}"", VAR_35);

            Core::DirIterator it(path, Core::DirIterator::Flags::SkipParentAndBaseDir);
            while (VAR_38.has_next()) {
                auto VAR_39 = VAR_38.next_full_path();
                if (!Core::File::is_directory(VAR_39)) {
                    VAR_32(VAR_39);
                } else {
                    VAR_37(VAR_39, VAR_37);
                }
            }
        };

        for (const String& path : VAR_8) {
            if (Core::File::is_directory(path)) {
                VAR_36(path, VAR_36);
            } else {
                VAR_32(path);
            }
        }

        VAR_19.finish();

        return 0;
    }

    return 0;
}",SerenityOS/serenity/3844e8569689dd476064a0759d704bc64fb3ca2c/tar.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,6 +18,18 @@
     args_parser.add_positional_argument(paths, ""Paths"", ""PATHS"", Core::ArgsParser::Required::No);
     args_parser.parse(argc, argv);
 
+    // Currently tar doesn't support extracting to a specified location. If that is implemented the target path
+    // should be unveiled with rwc instead of the current directory.
+    StringBuilder target_path_raw;
+    target_path_raw.append(realpath(""."", nullptr));
+    target_path_raw.append(""/"");
+    LexicalPath target_path(target_path_raw.to_string());
+    auto target_path_string = target_path.string();
+    if (unveil(target_path_string.characters(), ""rwc"") < 0) {
+        perror(""unveil"");
+        return 1;
+    }
+
     if (create + extract + list != 1) {
         warnln(""exactly one of -c, -x, and -t can be used"");
         return 1;
@@ -27,6 +39,16 @@
         auto file = Core::File::standard_input();
 
         if (archive_file) {
+            // make sure we can read the archive path
+            auto archive_file_path = realpath(archive_file, nullptr);
+            if (unveil(archive_file_path, ""r"") < 0) {
+                perror(""unveil"");
+                return 1;
+            }
+            if (unveil(nullptr, nullptr) < 0) {
+                perror(""unveil"");
+                return 1;
+            }
             auto maybe_file = Core::File::open(archive_file, Core::IODevice::OpenMode::ReadOnly);
             if (maybe_file.is_error()) {
                 warnln(""Core::File::open: {}"", maybe_file.error());
@@ -45,14 +67,38 @@
             warnln(""the provided file is not a well-formatted ustar file"");
             return 1;
         }
+
         for (; !tar_stream.finished(); tar_stream.advance()) {
+            auto file_name = tar_stream.header().file_name();
+
             if (list || verbose)
-                outln(""{}"", tar_stream.header().file_name());
+                outln(""{}"", file_name);
 
             if (extract) {
                 Tar::TarFileStream file_stream = tar_stream.file_contents();
 
                 const Tar::Header& header = tar_stream.header();
+
+                // determine where the archive intends to write a file
+                StringBuilder destination_path_raw;
+                if (file_name[0] != '/') {
+                    destination_path_raw.append(target_path_string);
+                    destination_path_raw.append(""/"");
+                }
+                destination_path_raw.append(file_name);
+                LexicalPath destination_path(destination_path_raw.to_string());
+
+                if (!(destination_path.string().starts_with(target_path_string))) {
+                    fprintf(stderr, ""File %s path is outside of current working directory, skipping\n"", file_name.to_string().characters());
+                    return false;
+                }
+
+                // Ignore tars containing target path.
+                // This will prevent mkdir from failing later when it probably shouldn't
+                if (destination_path.string() == target_path_string) {
+                    continue;
+                }
+
                 switch (header.type_flag()) {
                 case Tar::NormalFile:
                 case Tar::AlternateNormalFile: {","{'deleted_lines': ['                outln(""{}"", tar_stream.header().file_name());'], 'added_lines': [""    // Currently tar doesn't support extracting to a specified location. If that is implemented the target path"", '    // should be unveiled with rwc instead of the current directory.', '    StringBuilder target_path_raw;', '    target_path_raw.append(realpath(""."", nullptr));', '    target_path_raw.append(""/"");', '    LexicalPath target_path(target_path_raw.to_string());', '    auto target_path_string = target_path.string();', '    if (unveil(target_path_string.characters(), ""rwc"") < 0) {', '        perror(""unveil"");', '        return 1;', '    }', '', '            // make sure we can read the archive path', '            auto archive_file_path = realpath(archive_file, nullptr);', '            if (unveil(archive_file_path, ""r"") < 0) {', '                perror(""unveil"");', '                return 1;', '            }', '            if (unveil(nullptr, nullptr) < 0) {', '                perror(""unveil"");', '                return 1;', '            }', '', '            auto file_name = tar_stream.header().file_name();', '', '                outln(""{}"", file_name);', '', '                // determine where the archive intends to write a file', '                StringBuilder destination_path_raw;', ""                if (file_name[0] != '/') {"", '                    destination_path_raw.append(target_path_string);', '                    destination_path_raw.append(""/"");', '                }', '                destination_path_raw.append(file_name);', '                LexicalPath destination_path(destination_path_raw.to_string());', '', '                if (!(destination_path.string().starts_with(target_path_string))) {', '                    fprintf(stderr, ""File %s path is outside of current working directory, skipping\\n"", file_name.to_string().characters());', '                    return false;', '                }', '', '                // Ignore tars containing target path.', ""                // This will prevent mkdir from failing later when it probably shouldn't"", '                if (destination_path.string() == target_path_string) {', '                    continue;', '                }', '']}",True,SerenityOS before commit 3844e8569689dd476064a0759d704bc64fb3ca2c contains a directory traversal vulnerability in tar/unzip that may lead to command execution or privilege escalation.,9.8,CRITICAL,3,test,2021-03-18T01:41:34Z,3
CVE-2021-21401,['CWE-763'],AV:N/AC:L/Au:S/C:N/I:P/A:P,0,nanopb,"Fix invalid free() with oneof (#647)

Nanopb would call free() or realloc() on an invalid
(attacker controlled) pointer value when all the following
conditions are true:

- PB_ENABLE_MALLOC is defined at the compile time
- Message definition contains an oneof field, and the oneof
  contains at least one pointer type field and at least one
  non-pointer type field.
- Data being decoded first contains a non-pointer value for
  the oneof field, and later contains an overwriting pointer
  value.

Depending on message layout, the bug may not be exploitable in all
cases, but it is known to be exploitable at least with string and
bytes fields. Actual security impact will also depend on the heap
implementation used.",e2f0ccf939d9f82931d085acb6df8e9a182a4261,https://github.com/nanopb/nanopb/commit/e2f0ccf939d9f82931d085acb6df8e9a182a4261,pb_decode.c,pb_release_union_field,"static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field)
{
pb_field_iter_t old_field = *field;
pb_size_t old_tag = *(pb_size_t*)field->pSize; 
pb_size_t new_tag = field->tag; 
if (old_tag == 0)
return true; 
if (old_tag == new_tag)
return true; 
if (!pb_field_iter_find(&old_field, old_tag))
PB_RETURN_ERROR(stream, ""invalid union tag"");
pb_release_single_field(&old_field);
return true;
}","static bool pb_release_union_field(pb_istream_t *VAR_0, pb_field_iter_t *VAR_1)
{
pb_field_iter_t VAR_2 = *VAR_1;
pb_size_t VAR_3 = *(pb_size_t*)VAR_1->pSize; 
pb_size_t VAR_4 = VAR_1->tag; 
if (VAR_3 == 0)
return true; 
if (VAR_3 == VAR_4)
return true; 
if (!pb_field_iter_find(&VAR_2, VAR_3))
PB_RETURN_ERROR(VAR_0, ""invalid union tag"");
pb_release_single_field(&VAR_2);
return true;
}",nanopb/e2f0ccf939d9f82931d085acb6df8e9a182a4261/pb_decode.c/vul/before/0.json,"static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field)
{
    pb_field_iter_t old_field = *field;
    pb_size_t old_tag = *(pb_size_t*)field->pSize; /* Previous which_ value */
    pb_size_t new_tag = field->tag; /* New which_ value */

    if (old_tag == 0)
        return true; /* Ok, no old data in union */

    if (old_tag == new_tag)
        return true; /* Ok, old data is of same type => merge */

    /* Release old data. The find can fail if the message struct contains
     * invalid data. */
    if (!pb_field_iter_find(&old_field, old_tag))
        PB_RETURN_ERROR(stream, ""invalid union tag"");

    pb_release_single_field(&old_field);

    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)
    {
        /* Initialize the pointer to NULL to make sure it is valid
         * even in case of error return. */
        *(void**)field->pField = NULL;
        field->pData = NULL;
    }

    return true;
}","static bool pb_release_union_field(pb_istream_t *VAR_0, pb_field_iter_t *VAR_1)
{
    pb_field_iter_t VAR_2 = *VAR_1;
    pb_size_t VAR_3 = *(pb_size_t*)VAR_1->pSize; /* COMMENT_0 */
    pb_size_t VAR_4 = VAR_1->tag; /* COMMENT_1 */

    if (VAR_3 == 0)
        return true; /* COMMENT_2 */

    if (VAR_3 == VAR_4)
        return true; /* COMMENT_3 */

    /* COMMENT_4 */
                       
    if (!pb_field_iter_find(&VAR_2, VAR_3))
        PB_RETURN_ERROR(VAR_0, ""invalid union tag"");

    pb_release_single_field(&VAR_2);

    if (PB_ATYPE(VAR_1->type) == VAR_5)
    {
        /* COMMENT_6 */
                                           
        *(void**)VAR_1->pField = NULL;
        VAR_1->pData = NULL;
    }

    return true;
}",nanopb/e2f0ccf939d9f82931d085acb6df8e9a182a4261/pb_decode.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,5 +17,13 @@
 
     pb_release_single_field(&old_field);
 
+    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)
+    {
+        /* Initialize the pointer to NULL to make sure it is valid
+         * even in case of error return. */
+        *(void**)field->pField = NULL;
+        field->pData = NULL;
+    }
+
     return true;
 }","{'deleted_lines': [], 'added_lines': ['    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)', '    {', '        /* Initialize the pointer to NULL to make sure it is valid', '         * even in case of error return. */', '        *(void**)field->pField = NULL;', '        field->pData = NULL;', '    }', '']}",True,"Nanopb is a small code-size Protocol Buffers implementation in ansi C. In Nanopb before versions 0.3.9.8 and 0.4.5, decoding a specifically formed message can cause invalid `free()` or `realloc()` calls if the message type contains an `oneof` field, and the `oneof` directly contains both a pointer field and a non-pointer field. If the message data first contains the non-pointer field and then the pointer field, the data of the non-pointer field is incorrectly treated as if it was a pointer value. Such message data rarely occurs in normal messages, but it is a concern when untrusted data is parsed. This has been fixed in versions 0.3.9.8 and 0.4.5. See referenced GitHub Security Advisory for more information including workarounds.",7.1,HIGH,2,test,2021-03-20T07:45:04Z,3
CVE-2021-23206,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,michaelrsweet/htmldoc,Fix crash bugs with bogus table attributes (Issue #416),ba61a3ece382389ae4482c7027af8b32e8ab4cc8,https://github.com/michaelrsweet/htmldoc/commit/ba61a3ece382389ae4482c7027af8b32e8ab4cc8,htmldoc/ps-pdf.cxx,render_table_row,"static void
render_table_row(hdtable_t &table,
tree_t    ***cells,
int       row,
uchar     *height_var,
float     left,                 float     right,                 float     bottom,                 float     top,                 float     *x,
float     *y,
int       *page)
{
intcol,
tcol,
colspan,
rowspan,
tempspace;
floatwidth,
temp_y;
inttemp_page;
uchar*var;
intdo_valign;  int           row_page;
floatrow_y,
row_starty,
row_height,temp_height;  uchar*bgcolor;
floatbgrgb[3];
do_valign  = 1;
row_height = 0.0f;
row_page   = *page;
row_y      = *y - table.cellpadding;
row_starty = row_y;
DEBUG_printf((""BEFORE row_y = %.1f, *y = %.1f, row_page = %d\n"",
row_y, *y, row_page));
for (col = 0, rowspan = 9999; col < table.num_cols; col += colspan)
{
if (table.row_spans[col] == 0)
{
if ((var = htmlGetVariable(cells[row][col], (uchar *)""ROWSPAN"")) != NULL)
table.row_spans[col] = atoi((char *)var);
if (table.row_spans[col] == 1)
table.row_spans[col] = 0;
if (table.row_spans[col] > (table.num_rows - row))
table.row_spans[col] = table.num_rows - row;
table.span_heights[col] = 0.0f;
}
if (table.row_spans[col] < rowspan)
rowspan = table.row_spans[col];
for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)
if (cells[row][col] != cells[row][col + colspan])
break;
}
if (!rowspan)
rowspan = 1;
for (col = 0; col < table.num_cols;)
{
for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)
if (cells[row][col] != cells[row][col + colspan])
break;
colspan --;
DEBUG_printf((""    col = %d, colspan = %d, left = %.1f, right = %.1f, cell = %p\n"", col, colspan, table.col_lefts[col], table.col_rights[col + colspan], (void *)cells[row][col]));
*x        = table.col_lefts[col];
temp_y    = *y - table.cellpadding;
temp_page = *page;
tempspace = 0;
if (row == 0 || cells[row][col] != cells[row - 1][col])
{
check_pages(*page);
if (cells[row][col] == NULL)
bgcolor = NULL;
else if ((bgcolor = htmlGetVariable(cells[row][col], (uchar *)""BGCOLOR"")) != NULL)
{
memcpy(bgrgb, background_color, sizeof(bgrgb));
get_color(bgcolor, bgrgb, 0);
width       = table.col_rights[col + colspan] - table.col_lefts[col] + 2 * table.cellpadding;
table.border_left = table.col_lefts[col] - table.cellpadding;
table.cell_bg[col] = new_render(*page, RENDER_BOX, table.border_left, row_y, width + table.border, 0.0, bgrgb);
}
else
{
table.cell_bg[col] = NULL;
new_render(*page, RENDER_TEXT, -1.0f, -1.0f, 0.0, 0.0, (void *)"""");
}
DEBUG_printf((""cell_bg[%d] = %p, pages[%d].end = %p\n"", col, (void *)table.cell_bg[col], *page, (void *)pages[*page].end));
table.cell_start[col] = pages[*page].end;
table.cell_page[col]  = temp_page;
table.cell_y[col]     = temp_y;
if (table.debug)
{
check_pages(*page);
render_t *r;
char table_text[255];
snprintf(table_text, sizeof(table_text), ""cell=%p [%d,%d]"",
(void *)cells[row][col], row, col);
r = new_render(temp_page, RENDER_TEXT, *x, temp_y,
get_width((uchar *)table_text, TYPE_COURIER, STYLE_NORMAL, 1),
_htmlSizes[1], table_text);
r->data.text.typeface = TYPE_COURIER;
r->data.text.style    = STYLE_NORMAL;
r->data.text.size     = (float)_htmlSizes[1];
}
if (cells[row][col] != NULL && cells[row][col]->child != NULL)
{
DEBUG_printf((""    parsing cell %d,%d; width = %.1f\n"", row, col, table.col_rights[col + colspan] - table.col_lefts[col]));
bottom += table.cellpadding;
top    -= table.cellpadding;
parse_doc(cells[row][col]->child, table.col_lefts + col, table.col_rights + col + colspan, &bottom, &top, x, &temp_y, &temp_page, NULL, &tempspace);
bottom -= table.cellpadding;
top    += table.cellpadding;
}
table.cell_endpage[col] = temp_page;
table.cell_endy[col]    = temp_y;
table.cell_height[col]  = *y - table.cellpadding - temp_y;
table.cell_end[col]     = pages[*page].end;
if (table.cell_start[col] == NULL)
table.cell_start[col] = pages[*page].start;
DEBUG_printf((""row = %d, col = %d, y = %.1f, cell_y = %.1f, cell_height = %.1f\n"", row, col, *y - table.cellpadding, temp_y, table.cell_height[col]));
DEBUG_printf((""cell_start[%d] = %p, cell_end[%d] = %p\n"", col, (void *)table.cell_start[col], col, (void *)table.cell_end[col]));
}
if (table.row_spans[col] == 0 &&
table.cell_page[col] == table.cell_endpage[col] &&
table.cell_height[col] > row_height)
row_height = table.cell_height[col];
if (table.row_spans[col] <= rowspan)
{
if (table.cell_page[col] != table.cell_endpage[col])
do_valign = 0;
if (table.cell_endpage[col] > row_page)
{
row_page = table.cell_endpage[col];
row_y    = table.cell_endy[col];
}
else if (table.cell_endy[col] < row_y && table.cell_endpage[col] == row_page)
row_y = table.cell_endy[col];
}
DEBUG_printf((""**** col = %d, row = %d, row_y = %.1f, row_page = %d\n"", col, row, row_y, row_page));
for (col ++; colspan > 0; colspan --, col ++)
{
table.cell_start[col]   = NULL;
table.cell_page[col]    = table.cell_page[col - 1];
table.cell_y[col]       = table.cell_y[col - 1];
table.cell_end[col]     = NULL;
table.cell_endpage[col] = table.cell_endpage[col - 1];
table.cell_endy[col]    = table.cell_endy[col - 1];
table.cell_height[col]  = table.cell_height[col - 1];
}
}
DEBUG_printf((""row = %d, row_y = %.1f, row_height = %.1f\n"", row, row_y, row_height));
for (col = 0; col < table.num_cols; col += colspan)
{
for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)
if (cells[row][col] != cells[row][col + colspan])
break;
if (table.row_spans[col])
table.span_heights[col] += row_height;
DEBUG_printf((""col = %d, cell_y = %.1f, cell_page = %d, cell_endpage = %d, row_spans = %d, span_heights = %.1f, cell_height = %.1f\n"", col, table.cell_y[col], table.cell_page[col], table.cell_endpage[col], table.row_spans[col], table.span_heights[col], table.cell_height[col]));
}
for (col = 0; col < table.num_cols; col += colspan)
{
for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)
if (cells[row][col] != cells[row][col + colspan])
break;
if (table.row_spans[col] == rowspan &&
table.cell_page[col] == table.cell_endpage[col] &&
table.cell_height[col] > table.span_heights[col])
{
temp_height = table.cell_height[col] - table.span_heights[col];
row_height  += temp_height;
DEBUG_printf((""Adjusting row-span height by %.1f, new row_height = %.1f\n"", temp_height, row_height));
for (tcol = 0; tcol < table.num_cols; tcol ++)
if (table.row_spans[tcol])
{
table.span_heights[tcol] += temp_height;
DEBUG_printf((""col = %d, span_heights = %.1f\n"", tcol, table.span_heights[tcol]));
}
}
}
DEBUG_printf((""AFTER row = %d, row_page = %d, row_y = %.1f, row_height = %.1f, *y = %.1f, do_valign = %d\n"", row, row_page, row_y, row_height, *y, do_valign));
if (do_valign)
{
height_var = NULL;
if (cells[row][0] != NULL)
{
if ((height_var = htmlGetVariable(cells[row][0]->parent, (uchar *)""HEIGHT"")) == NULL)
for (col = 0; col < table.num_cols; col ++)
if (htmlGetVariable(cells[row][col], (uchar *)""ROWSPAN"") == NULL)
if ((height_var = htmlGetVariable(cells[row][col], (uchar *)""HEIGHT"")) != NULL)
break;
}
if (height_var != NULL)
{
if (height_var[strlen((char *)height_var) - 1] == '%')
temp_height = (float)(atof((char *)height_var) * 0.01f * PagePrintLength);
else
temp_height = (float)(atof((char *)height_var) * PagePrintWidth / _htmlBrowserWidth);
if (table.height > 0 && temp_height > table.height)
temp_height = table.height;
temp_height -= 2 * table.cellpadding;
if (temp_height > row_height)
{
row_height = temp_height;
row_y      = *y - temp_height;
}
}
for (col = 0; col < table.num_cols; col += colspan + 1)
{
render_t*p;
floatdelta_y;
for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)
if (cells[row][col] != cells[row][col + colspan])
break;
colspan --;
if (table.cell_start[col] == NULL || table.row_spans[col] > rowspan ||
cells[row][col] == NULL || cells[row][col]->child == NULL)
continue;
if (table.row_spans[col] == 1)
{
int tcol;
float span_height = 0.0f;
for (tcol = 0; tcol < table.num_cols; tcol ++)
{
if (table.row_spans[col] == 1 && table.span_heights[col] > span_height)
span_height = table.span_heights[col];
}
switch (cells[row][col]->valignment)
{
case ALIGN_MIDDLE :
delta_y = (span_height - table.cell_height[col]) * 0.5f;
break;
case ALIGN_BOTTOM :
delta_y = span_height - table.cell_height[col];
break;
default :
delta_y = 0.0f;
break;
}
}
else if (table.row_spans[col])
{
delta_y = 0.0f;
}
else
{
switch (cells[row][col]->valignment)
{
case ALIGN_MIDDLE :
delta_y = (row_height - table.cell_height[col]) * 0.5f;
break;
case ALIGN_BOTTOM :
delta_y = row_height - table.cell_height[col];
break;
default :
delta_y = 0.0f;
break;
}
}
DEBUG_printf((""row = %d, col = %d, valign = %d, rowspans = %d, cell_height = %.1f, span_heights = %.1f, delta_y = %.1f\n"", row, col, cells[row][col]->valignment, table.row_spans[col], table.cell_height[col], table.span_heights[col], delta_y));
if (delta_y > 0.0f)
{
if (table.cell_start[col] == table.cell_end[col])
p = table.cell_start[col];
else
p = table.cell_start[col]->next;
for (; p != NULL; p = p->next)
{
DEBUG_printf((""aligning %p (%s), y was %.1f, now %.1f\n"",
(void *)p, p->data.text.buffer, p->y, p->y - delta_y));
p->y -= delta_y;
if (p == table.cell_end[col])
break;
}
}
#ifdef DEBUG
else
{
if (table.cell_start[col] == table.cell_end[col])
p = table.cell_start[col];
else
p = table.cell_start[col]->next;
for (; p != NULL; p = p->next)
{
printf(""NOT aligning %p (%s)\n"", (void *)p, p->data.text.buffer);
if (p == table.cell_end[col])
break;
}
}
#endif 
}
}
for (col = 0, temp_page = -1, temp_y = 99999999; col < table.num_cols; col ++)
if (table.row_spans[col] <= rowspan &&
cells[row][col] != NULL && cells[row][col]->child != NULL)
{
if (table.cell_endpage[col] > temp_page)
{
temp_page = table.cell_endpage[col];
temp_y    = table.cell_endy[col];
}
else if (table.cell_endpage[col] == temp_page && table.cell_endy[col] < temp_y)
temp_y = table.cell_endy[col];
}
for (col = 0; col < table.num_cols; col ++)
if (table.row_spans[col] <= rowspan &&
cells[row][col] != NULL && cells[row][col]->child != NULL)
{
table.cell_endpage[col] = temp_page;
table.cell_endy[col]    = temp_y;
}
row_y -= table.cellpadding;
table.border_left = table.col_lefts[0] - table.cellpadding;
width       = table.col_rights[table.num_cols - 1] - table.col_lefts[0] + 2 * table.cellpadding;
for (bgcolor = NULL, col = 0; col < table.num_cols; col ++)
if (table.row_spans[col] <= rowspan &&
cells[row][col] &&
!htmlGetVariable(cells[row][col], (uchar *)""ROWSPAN"") &&
(bgcolor = htmlGetVariable(cells[row][col]->parent,
(uchar *)""BGCOLOR"")) != NULL)
break;
if (bgcolor)
{
memcpy(bgrgb, background_color, sizeof(bgrgb));
get_color(bgcolor, bgrgb, 0);
if (row_page > *page)
{
new_render(*page, RENDER_BOX, table.border_left, bottom,
width, row_starty - bottom + table.cellpadding, bgrgb,
pages[*page].start);
for (temp_page = *page + 1; temp_page < row_page; temp_page ++)
{
new_render(temp_page, RENDER_BOX, table.border_left, bottom,
width, top - bottom, bgrgb, pages[temp_page].start);
}
check_pages(*page);
new_render(row_page, RENDER_BOX, table.border_left, row_y,
width, top - row_y, bgrgb,
pages[row_page].start);
}
else
{
new_render(row_page, RENDER_BOX, table.border_left, row_y,
width, row_height + 2 * table.cellpadding, bgrgb,
pages[row_page].start);
}
}
for (col = 0; col < table.num_cols; col += colspan + 1)
{
for (colspan = 0; (col + colspan) < table.num_cols; colspan ++)
if (cells[row][col] != cells[row][col + colspan])
break;
else if (table.row_spans[col + colspan] > 0)
{
DEBUG_printf((""row = %d, col = %d, decrementing row_spans (%d) to %d...\n"", row,
col, table.row_spans[col + colspan],
table.row_spans[col + colspan] - rowspan));
table.row_spans[col + colspan] -= rowspan;
}
colspan --;
width = table.col_rights[col + colspan] - table.col_lefts[col] +
2 * table.cellpadding;
if (cells[row][col] == NULL || cells[row][col]->child == NULL ||
table.row_spans[col] > 0)
continue;
DEBUG_printf((""DRAWING BORDER+BACKGROUND: col=%d, row=%d, cell_page=%d, cell_y=%.1f\n""
""                           cell_endpage=%d, cell_endy=%.1f\n"",
col, row, table.cell_page[col], table.cell_y[col],
table.cell_endpage[col], table.cell_endy[col]));
if ((bgcolor = htmlGetVariable(cells[row][col],
(uchar *)""BGCOLOR"")) != NULL)
{
memcpy(bgrgb, background_color, sizeof(bgrgb));
get_color(bgcolor, bgrgb, 0);
}
table.border_left = table.col_lefts[col] - table.cellpadding;
if (table.cell_page[col] != table.cell_endpage[col])
{
if (table.border > 0)
{
new_render(table.cell_page[col], RENDER_BOX, table.border_left,
table.cell_y[col] + table.cellpadding,
width + table.border, table.border, table.border_rgb);
new_render(table.cell_page[col], RENDER_BOX, table.border_left, bottom,
table.border, table.cell_y[col] - bottom + table.cellpadding + table.border, table.border_rgb);
new_render(table.cell_page[col], RENDER_BOX,
table.border_left + width, bottom,
table.border, table.cell_y[col] - bottom + table.cellpadding + table.border, table.border_rgb);
}
if (bgcolor != NULL)
{
table.cell_bg[col]->y      = bottom;
table.cell_bg[col]->height = table.cell_y[col] - bottom + table.cellpadding + table.border;
}
for (temp_page = table.cell_page[col] + 1; temp_page < table.cell_endpage[col]; temp_page ++)
{
if (table.border > 0.0f)
{
new_render(temp_page, RENDER_BOX, table.border_left, bottom,
table.border, top - bottom, table.border_rgb);
new_render(temp_page, RENDER_BOX,
table.border_left + width, bottom,
table.border, top - bottom, table.border_rgb);
}
if (bgcolor != NULL)
new_render(temp_page, RENDER_BOX, table.border_left, bottom,
width + table.border, top - bottom, bgrgb,
pages[temp_page].start);
}
if (table.border > 0.0f)
{
new_render(table.cell_endpage[col], RENDER_BOX, table.border_left, row_y,
table.border, top - row_y, table.border_rgb);
new_render(table.cell_endpage[col], RENDER_BOX,
table.border_left + width, row_y,
table.border, top - row_y, table.border_rgb);
new_render(table.cell_endpage[col], RENDER_BOX, table.border_left, row_y,
width + table.border, table.border, table.border_rgb);
}
if (bgcolor != NULL)
{
check_pages(table.cell_endpage[col]);
new_render(table.cell_endpage[col], RENDER_BOX, table.border_left, row_y,
width + table.border, top - row_y, bgrgb,
pages[table.cell_endpage[col]].start);
}
}
else
{
if (table.border > 0.0f)
{
new_render(table.cell_page[col], RENDER_BOX, table.border_left,
table.cell_y[col] + table.cellpadding,
width + table.border, table.border, table.border_rgb);
new_render(table.cell_page[col], RENDER_BOX, table.border_left, row_y,
table.border, table.cell_y[col] - row_y + table.cellpadding + table.border, table.border_rgb);
new_render(table.cell_page[col], RENDER_BOX,
table.border_left + width, row_y,
table.border, table.cell_y[col] - row_y + table.cellpadding + table.border, table.border_rgb);
new_render(table.cell_page[col], RENDER_BOX, table.border_left, row_y,
width + table.border, table.border, table.border_rgb);
}
if (bgcolor != NULL)
{
table.cell_bg[col]->y      = row_y;
table.cell_bg[col]->height = table.cell_y[col] - row_y + table.cellpadding + table.border;
}
}
}
*page = row_page;
*y    = row_y;
}","static void
render_table_row(hdtable_t &VAR_0,
tree_t    ***VAR_1,
int       VAR_2,
uchar     *VAR_3,
float     VAR_4,
float     VAR_5,
float     VAR_6,
float     VAR_7,
float     *VAR_8,
float     *VAR_9,
int       *VAR_10)
{
intVAR_11,
VAR_12,
VAR_13,
VAR_14,
VAR_15;
floatVAR_16,
VAR_17;
intVAR_18;
uchar*VAR_19;
intVAR_20;
int           VAR_21;
floatVAR_22,
VAR_23,
VAR_24,
VAR_25;
uchar*VAR_26;
floatVAR_27[3];
VAR_20  = 1;
VAR_24 = 0.0f;
VAR_21   = *VAR_10;
VAR_22      = *VAR_9 - VAR_0.cellpadding;
VAR_23 = VAR_22;
DEBUG_printf((""BEFORE row_y = %.1f, *y = %.1f, row_page = %d\n"",
VAR_22, *VAR_9, VAR_21));
for (VAR_11 = 0, VAR_14 = 9999; VAR_11 < VAR_0.num_cols; VAR_11 += VAR_13)
{
if (VAR_0.row_spans[VAR_11] == 0)
{
if ((VAR_19 = htmlGetVariable(VAR_1[VAR_2][VAR_11], (uchar *)""ROWSPAN"")) != NULL)
VAR_0.row_spans[VAR_11] = atoi((char *)VAR_19);
if (VAR_0.row_spans[VAR_11] == 1)
VAR_0.row_spans[VAR_11] = 0;
if (VAR_0.row_spans[VAR_11] > (VAR_0.num_rows - VAR_2))
VAR_0.row_spans[VAR_11] = VAR_0.num_rows - VAR_2;
VAR_0.span_heights[VAR_11] = 0.0f;
}
if (VAR_0.row_spans[VAR_11] < VAR_14)
VAR_14 = VAR_0.row_spans[VAR_11];
for (VAR_13 = 1; (VAR_11 + VAR_13) < VAR_0.num_cols; VAR_13 ++)
if (VAR_1[VAR_2][VAR_11] != VAR_1[VAR_2][VAR_11 + VAR_13])
break;
}
if (!VAR_14)
VAR_14 = 1;
for (VAR_11 = 0; VAR_11 < VAR_0.num_cols;)
{
for (VAR_13 = 1; (VAR_11 + VAR_13) < VAR_0.num_cols; VAR_13 ++)
if (VAR_1[VAR_2][VAR_11] != VAR_1[VAR_2][VAR_11 + VAR_13])
break;
VAR_13 --;
DEBUG_printf((""    col = %d, colspan = %d, left = %.1f, right = %.1f, cell = %p\n"", VAR_11, VAR_13, VAR_0.col_lefts[VAR_11], VAR_0.col_rights[VAR_11 + VAR_13], (void *)VAR_1[VAR_2][VAR_11]));
*VAR_8        = VAR_0.col_lefts[VAR_11];
VAR_17    = *VAR_9 - VAR_0.cellpadding;
VAR_18 = *VAR_10;
VAR_15 = 0;
if (VAR_2 == 0 || VAR_1[VAR_2][VAR_11] != VAR_1[VAR_2 - 1][VAR_11])
{
check_pages(*VAR_10);
if (VAR_1[VAR_2][VAR_11] == NULL)
VAR_26 = NULL;
else if ((VAR_26 = htmlGetVariable(VAR_1[VAR_2][VAR_11], (uchar *)""BGCOLOR"")) != NULL)
{
memcpy(VAR_27, VAR_28, sizeof(VAR_27));
get_color(VAR_26, VAR_27, 0);
VAR_16       = VAR_0.col_rights[VAR_11 + VAR_13] - VAR_0.col_lefts[VAR_11] + 2 * VAR_0.cellpadding;
VAR_0.border_left = VAR_0.col_lefts[VAR_11] - VAR_0.cellpadding;
VAR_0.cell_bg[VAR_11] = new_render(*VAR_10, VAR_29, VAR_0.border_left, VAR_22, VAR_16 + VAR_0.border, 0.0, VAR_27);
}
else
{
VAR_0.cell_bg[VAR_11] = NULL;
new_render(*VAR_10, VAR_30, -1.0f, -1.0f, 0.0, 0.0, (void *)"""");
}
DEBUG_printf((""cell_bg[%d] = %p, pages[%d].end = %p\n"", VAR_11, (void *)VAR_0.cell_bg[VAR_11], *VAR_10, (void *)VAR_31[*VAR_10].end));
VAR_0.cell_start[VAR_11] = VAR_31[*VAR_10].end;
VAR_0.cell_page[VAR_11]  = VAR_18;
VAR_0.cell_y[VAR_11]     = VAR_17;
if (VAR_0.debug)
{
check_pages(*VAR_10);
render_t *VAR_32;
char VAR_33[255];
snprintf(VAR_33, sizeof(VAR_33), ""cell=%p [%d,%d]"",
(void *)VAR_1[VAR_2][VAR_11], VAR_2, VAR_11);
VAR_32 = new_render(VAR_18, VAR_30, *VAR_8, VAR_17,
get_width((uchar *)VAR_33, VAR_34, VAR_35, 1),
VAR_36[1], VAR_33);
VAR_32->data.text.typeface = VAR_34;
VAR_32->data.text.style    = VAR_35;
VAR_32->data.text.size     = (float)VAR_36[1];
}
if (VAR_1[VAR_2][VAR_11] != NULL && VAR_1[VAR_2][VAR_11]->child != NULL)
{
DEBUG_printf((""    parsing cell %d,%d; width = %.1f\n"", VAR_2, VAR_11, VAR_0.col_rights[VAR_11 + VAR_13] - VAR_0.col_lefts[VAR_11]));
VAR_6 += VAR_0.cellpadding;
VAR_7    -= VAR_0.cellpadding;
parse_doc(VAR_1[VAR_2][VAR_11]->child, VAR_0.col_lefts + VAR_11, VAR_0.col_rights + VAR_11 + VAR_13, &VAR_6, &VAR_7, VAR_8, &VAR_17, &VAR_18, NULL, &VAR_15);
VAR_6 -= VAR_0.cellpadding;
VAR_7    += VAR_0.cellpadding;
}
VAR_0.cell_endpage[VAR_11] = VAR_18;
VAR_0.cell_endy[VAR_11]    = VAR_17;
VAR_0.cell_height[VAR_11]  = *VAR_9 - VAR_0.cellpadding - VAR_17;
VAR_0.cell_end[VAR_11]     = VAR_31[*VAR_10].end;
if (VAR_0.cell_start[VAR_11] == NULL)
VAR_0.cell_start[VAR_11] = VAR_31[*VAR_10].start;
DEBUG_printf((""row = %d, col = %d, y = %.1f, cell_y = %.1f, cell_height = %.1f\n"", VAR_2, VAR_11, *VAR_9 - VAR_0.cellpadding, VAR_17, VAR_0.cell_height[VAR_11]));
DEBUG_printf((""cell_start[%d] = %p, cell_end[%d] = %p\n"", VAR_11, (void *)VAR_0.cell_start[VAR_11], VAR_11, (void *)VAR_0.cell_end[VAR_11]));
}
if (VAR_0.row_spans[VAR_11] == 0 &&
VAR_0.cell_page[VAR_11] == VAR_0.cell_endpage[VAR_11] &&
VAR_0.cell_height[VAR_11] > VAR_24)
VAR_24 = VAR_0.cell_height[VAR_11];
if (VAR_0.row_spans[VAR_11] <= VAR_14)
{
if (VAR_0.cell_page[VAR_11] != VAR_0.cell_endpage[VAR_11])
VAR_20 = 0;
if (VAR_0.cell_endpage[VAR_11] > VAR_21)
{
VAR_21 = VAR_0.cell_endpage[VAR_11];
VAR_22    = VAR_0.cell_endy[VAR_11];
}
else if (VAR_0.cell_endy[VAR_11] < VAR_22 && VAR_0.cell_endpage[VAR_11] == VAR_21)
VAR_22 = VAR_0.cell_endy[VAR_11];
}
DEBUG_printf((""**** col = %d, row = %d, row_y = %.1f, row_page = %d\n"", VAR_11, VAR_2, VAR_22, VAR_21));
for (VAR_11 ++; VAR_13 > 0; VAR_13 --, VAR_11 ++)
{
VAR_0.cell_start[VAR_11]   = NULL;
VAR_0.cell_page[VAR_11]    = VAR_0.cell_page[VAR_11 - 1];
VAR_0.cell_y[VAR_11]       = VAR_0.cell_y[VAR_11 - 1];
VAR_0.cell_end[VAR_11]     = NULL;
VAR_0.cell_endpage[VAR_11] = VAR_0.cell_endpage[VAR_11 - 1];
VAR_0.cell_endy[VAR_11]    = VAR_0.cell_endy[VAR_11 - 1];
VAR_0.cell_height[VAR_11]  = VAR_0.cell_height[VAR_11 - 1];
}
}
DEBUG_printf((""row = %d, row_y = %.1f, row_height = %.1f\n"", VAR_2, VAR_22, VAR_24));
for (VAR_11 = 0; VAR_11 < VAR_0.num_cols; VAR_11 += VAR_13)
{
for (VAR_13 = 1; (VAR_11 + VAR_13) < VAR_0.num_cols; VAR_13 ++)
if (VAR_1[VAR_2][VAR_11] != VAR_1[VAR_2][VAR_11 + VAR_13])
break;
if (VAR_0.row_spans[VAR_11])
VAR_0.span_heights[VAR_11] += VAR_24;
DEBUG_printf((""col = %d, cell_y = %.1f, cell_page = %d, cell_endpage = %d, row_spans = %d, span_heights = %.1f, cell_height = %.1f\n"", VAR_11, VAR_0.cell_y[VAR_11], VAR_0.cell_page[VAR_11], VAR_0.cell_endpage[VAR_11], VAR_0.row_spans[VAR_11], VAR_0.span_heights[VAR_11], VAR_0.cell_height[VAR_11]));
}
for (VAR_11 = 0; VAR_11 < VAR_0.num_cols; VAR_11 += VAR_13)
{
for (VAR_13 = 1; (VAR_11 + VAR_13) < VAR_0.num_cols; VAR_13 ++)
if (VAR_1[VAR_2][VAR_11] != VAR_1[VAR_2][VAR_11 + VAR_13])
break;
if (VAR_0.row_spans[VAR_11] == VAR_14 &&
VAR_0.cell_page[VAR_11] == VAR_0.cell_endpage[VAR_11] &&
VAR_0.cell_height[VAR_11] > VAR_0.span_heights[VAR_11])
{
VAR_25 = VAR_0.cell_height[VAR_11] - VAR_0.span_heights[VAR_11];
VAR_24  += VAR_25;
DEBUG_printf((""Adjusting row-span height by %.1f, new row_height = %.1f\n"", VAR_25, VAR_24));
for (VAR_12 = 0; VAR_12 < VAR_0.num_cols; VAR_12 ++)
if (VAR_0.row_spans[VAR_12])
{
VAR_0.span_heights[VAR_12] += VAR_25;
DEBUG_printf((""col = %d, span_heights = %.1f\n"", VAR_12, VAR_0.span_heights[VAR_12]));
}
}
}
DEBUG_printf((""AFTER row = %d, row_page = %d, row_y = %.1f, row_height = %.1f, *y = %.1f, do_valign = %d\n"", VAR_2, VAR_21, VAR_22, VAR_24, *VAR_9, VAR_20));
if (VAR_20)
{
VAR_3 = NULL;
if (VAR_1[VAR_2][0] != NULL)
{
if ((VAR_3 = htmlGetVariable(VAR_1[VAR_2][0]->parent, (uchar *)""HEIGHT"")) == NULL)
for (VAR_11 = 0; VAR_11 < VAR_0.num_cols; VAR_11 ++)
if (htmlGetVariable(VAR_1[VAR_2][VAR_11], (uchar *)""ROWSPAN"") == NULL)
if ((VAR_3 = htmlGetVariable(VAR_1[VAR_2][VAR_11], (uchar *)""HEIGHT"")) != NULL)
break;
}
if (VAR_3 != NULL)
{
if (VAR_3[strlen((char *)VAR_3) - 1] == '%')
VAR_25 = (float)(atof((char *)VAR_3) * 0.01f * VAR_37);
else
VAR_25 = (float)(atof((char *)VAR_3) * VAR_38 / VAR_39);
if (VAR_0.height > 0 && VAR_25 > VAR_0.height)
VAR_25 = VAR_0.height;
VAR_25 -= 2 * VAR_0.cellpadding;
if (VAR_25 > VAR_24)
{
VAR_24 = VAR_25;
VAR_22      = *VAR_9 - VAR_25;
}
}
for (VAR_11 = 0; VAR_11 < VAR_0.num_cols; VAR_11 += VAR_13 + 1)
{
render_t*VAR_40;
floatVAR_41;
for (VAR_13 = 1; (VAR_11 + VAR_13) < VAR_0.num_cols; VAR_13 ++)
if (VAR_1[VAR_2][VAR_11] != VAR_1[VAR_2][VAR_11 + VAR_13])
break;
VAR_13 --;
if (VAR_0.cell_start[VAR_11] == NULL || VAR_0.row_spans[VAR_11] > VAR_14 ||
VAR_1[VAR_2][VAR_11] == NULL || VAR_1[VAR_2][VAR_11]->child == NULL)
continue;
if (VAR_0.row_spans[VAR_11] == 1)
{
int VAR_12;
float VAR_42 = 0.0f;
for (VAR_12 = 0; VAR_12 < VAR_0.num_cols; VAR_12 ++)
{
if (VAR_0.row_spans[VAR_11] == 1 && VAR_0.span_heights[VAR_11] > VAR_42)
VAR_42 = VAR_0.span_heights[VAR_11];
}
switch (VAR_1[VAR_2][VAR_11]->valignment)
{
case VAR_43 :
VAR_41 = (VAR_42 - VAR_0.cell_height[VAR_11]) * 0.5f;
break;
case VAR_44 :
VAR_41 = VAR_42 - VAR_0.cell_height[VAR_11];
break;
default :
VAR_41 = 0.0f;
break;
}
}
else if (VAR_0.row_spans[VAR_11])
{
VAR_41 = 0.0f;
}
else
{
switch (VAR_1[VAR_2][VAR_11]->valignment)
{
case VAR_43 :
VAR_41 = (VAR_24 - VAR_0.cell_height[VAR_11]) * 0.5f;
break;
case VAR_44 :
VAR_41 = VAR_24 - VAR_0.cell_height[VAR_11];
break;
default :
VAR_41 = 0.0f;
break;
}
}
DEBUG_printf((""row = %d, col = %d, valign = %d, rowspans = %d, cell_height = %.1f, span_heights = %.1f, delta_y = %.1f\n"", VAR_2, VAR_11, VAR_1[VAR_2][VAR_11]->valignment, VAR_0.row_spans[VAR_11], VAR_0.cell_height[VAR_11], VAR_0.span_heights[VAR_11], VAR_41));
if (VAR_41 > 0.0f)
{
if (VAR_0.cell_start[VAR_11] == VAR_0.cell_end[VAR_11])
VAR_40 = VAR_0.cell_start[VAR_11];
else
VAR_40 = VAR_0.cell_start[VAR_11]->next;
for (; VAR_40 != NULL; VAR_40 = VAR_40->next)
{
DEBUG_printf((""aligning %p (%s), y was %.1f, now %.1f\n"",
(void *)VAR_40, VAR_40->data.text.buffer, VAR_40->y, VAR_40->y - VAR_41));
VAR_40->y -= VAR_41;
if (VAR_40 == VAR_0.cell_end[VAR_11])
break;
}
}
#ifdef VAR_45
else
{
if (VAR_0.cell_start[VAR_11] == VAR_0.cell_end[VAR_11])
VAR_40 = VAR_0.cell_start[VAR_11];
else
VAR_40 = VAR_0.cell_start[VAR_11]->next;
for (; VAR_40 != NULL; VAR_40 = VAR_40->next)
{
printf(""NOT aligning %p (%s)\n"", (void *)VAR_40, VAR_40->data.text.buffer);
if (VAR_40 == VAR_0.cell_end[VAR_11])
break;
}
}
#endif 
}
}
for (VAR_11 = 0, VAR_18 = -1, VAR_17 = 99999999; VAR_11 < VAR_0.num_cols; VAR_11 ++)
if (VAR_0.row_spans[VAR_11] <= VAR_14 &&
VAR_1[VAR_2][VAR_11] != NULL && VAR_1[VAR_2][VAR_11]->child != NULL)
{
if (VAR_0.cell_endpage[VAR_11] > VAR_18)
{
VAR_18 = VAR_0.cell_endpage[VAR_11];
VAR_17    = VAR_0.cell_endy[VAR_11];
}
else if (VAR_0.cell_endpage[VAR_11] == VAR_18 && VAR_0.cell_endy[VAR_11] < VAR_17)
VAR_17 = VAR_0.cell_endy[VAR_11];
}
for (VAR_11 = 0; VAR_11 < VAR_0.num_cols; VAR_11 ++)
if (VAR_0.row_spans[VAR_11] <= VAR_14 &&
VAR_1[VAR_2][VAR_11] != NULL && VAR_1[VAR_2][VAR_11]->child != NULL)
{
VAR_0.cell_endpage[VAR_11] = VAR_18;
VAR_0.cell_endy[VAR_11]    = VAR_17;
}
VAR_22 -= VAR_0.cellpadding;
VAR_0.border_left = VAR_0.col_lefts[0] - VAR_0.cellpadding;
VAR_16       = VAR_0.col_rights[VAR_0.num_cols - 1] - VAR_0.col_lefts[0] + 2 * VAR_0.cellpadding;
for (VAR_26 = NULL, VAR_11 = 0; VAR_11 < VAR_0.num_cols; VAR_11 ++)
if (VAR_0.row_spans[VAR_11] <= VAR_14 &&
VAR_1[VAR_2][VAR_11] &&
!htmlGetVariable(VAR_1[VAR_2][VAR_11], (uchar *)""ROWSPAN"") &&
(VAR_26 = htmlGetVariable(VAR_1[VAR_2][VAR_11]->parent,
(uchar *)""BGCOLOR"")) != NULL)
break;
if (VAR_26)
{
memcpy(VAR_27, VAR_28, sizeof(VAR_27));
get_color(VAR_26, VAR_27, 0);
if (VAR_21 > *VAR_10)
{
new_render(*VAR_10, VAR_29, VAR_0.border_left, VAR_6,
VAR_16, VAR_23 - VAR_6 + VAR_0.cellpadding, VAR_27,
VAR_31[*VAR_10].start);
for (VAR_18 = *VAR_10 + 1; VAR_18 < VAR_21; VAR_18 ++)
{
new_render(VAR_18, VAR_29, VAR_0.border_left, VAR_6,
VAR_16, VAR_7 - VAR_6, VAR_27, VAR_31[VAR_18].start);
}
check_pages(*VAR_10);
new_render(VAR_21, VAR_29, VAR_0.border_left, VAR_22,
VAR_16, VAR_7 - VAR_22, VAR_27,
VAR_31[VAR_21].start);
}
else
{
new_render(VAR_21, VAR_29, VAR_0.border_left, VAR_22,
VAR_16, VAR_24 + 2 * VAR_0.cellpadding, VAR_27,
VAR_31[VAR_21].start);
}
}
for (VAR_11 = 0; VAR_11 < VAR_0.num_cols; VAR_11 += VAR_13 + 1)
{
for (VAR_13 = 0; (VAR_11 + VAR_13) < VAR_0.num_cols; VAR_13 ++)
if (VAR_1[VAR_2][VAR_11] != VAR_1[VAR_2][VAR_11 + VAR_13])
break;
else if (VAR_0.row_spans[VAR_11 + VAR_13] > 0)
{
DEBUG_printf((""row = %d, col = %d, decrementing row_spans (%d) to %d...\n"", VAR_2,
VAR_11, VAR_0.row_spans[VAR_11 + VAR_13],
VAR_0.row_spans[VAR_11 + VAR_13] - VAR_14));
VAR_0.row_spans[VAR_11 + VAR_13] -= VAR_14;
}
VAR_13 --;
VAR_16 = VAR_0.col_rights[VAR_11 + VAR_13] - VAR_0.col_lefts[VAR_11] +
2 * VAR_0.cellpadding;
if (VAR_1[VAR_2][VAR_11] == NULL || VAR_1[VAR_2][VAR_11]->child == NULL ||
VAR_0.row_spans[VAR_11] > 0)
continue;
DEBUG_printf((""DRAWING BORDER+BACKGROUND: col=%d, row=%d, cell_page=%d, cell_y=%.1f\n""
""                           cell_endpage=%d, cell_endy=%.1f\n"",
VAR_11, VAR_2, VAR_0.cell_page[VAR_11], VAR_0.cell_y[VAR_11],
VAR_0.cell_endpage[VAR_11], VAR_0.cell_endy[VAR_11]));
if ((VAR_26 = htmlGetVariable(VAR_1[VAR_2][VAR_11],
(uchar *)""BGCOLOR"")) != NULL)
{
memcpy(VAR_27, VAR_28, sizeof(VAR_27));
get_color(VAR_26, VAR_27, 0);
}
VAR_0.border_left = VAR_0.col_lefts[VAR_11] - VAR_0.cellpadding;
if (VAR_0.cell_page[VAR_11] != VAR_0.cell_endpage[VAR_11])
{
if (VAR_0.border > 0)
{
new_render(VAR_0.cell_page[VAR_11], VAR_29, VAR_0.border_left,
VAR_0.cell_y[VAR_11] + VAR_0.cellpadding,
VAR_16 + VAR_0.border, VAR_0.border, VAR_0.border_rgb);
new_render(VAR_0.cell_page[VAR_11], VAR_29, VAR_0.border_left, VAR_6,
VAR_0.border, VAR_0.cell_y[VAR_11] - VAR_6 + VAR_0.cellpadding + VAR_0.border, VAR_0.border_rgb);
new_render(VAR_0.cell_page[VAR_11], VAR_29,
VAR_0.border_left + VAR_16, VAR_6,
VAR_0.border, VAR_0.cell_y[VAR_11] - VAR_6 + VAR_0.cellpadding + VAR_0.border, VAR_0.border_rgb);
}
if (VAR_26 != NULL)
{
VAR_0.cell_bg[VAR_11]->y      = VAR_6;
VAR_0.cell_bg[VAR_11]->height = VAR_0.cell_y[VAR_11] - VAR_6 + VAR_0.cellpadding + VAR_0.border;
}
for (VAR_18 = VAR_0.cell_page[VAR_11] + 1; VAR_18 < VAR_0.cell_endpage[VAR_11]; VAR_18 ++)
{
if (VAR_0.border > 0.0f)
{
new_render(VAR_18, VAR_29, VAR_0.border_left, VAR_6,
VAR_0.border, VAR_7 - VAR_6, VAR_0.border_rgb);
new_render(VAR_18, VAR_29,
VAR_0.border_left + VAR_16, VAR_6,
VAR_0.border, VAR_7 - VAR_6, VAR_0.border_rgb);
}
if (VAR_26 != NULL)
new_render(VAR_18, VAR_29, VAR_0.border_left, VAR_6,
VAR_16 + VAR_0.border, VAR_7 - VAR_6, VAR_27,
VAR_31[VAR_18].start);
}
if (VAR_0.border > 0.0f)
{
new_render(VAR_0.cell_endpage[VAR_11], VAR_29, VAR_0.border_left, VAR_22,
VAR_0.border, VAR_7 - VAR_22, VAR_0.border_rgb);
new_render(VAR_0.cell_endpage[VAR_11], VAR_29,
VAR_0.border_left + VAR_16, VAR_22,
VAR_0.border, VAR_7 - VAR_22, VAR_0.border_rgb);
new_render(VAR_0.cell_endpage[VAR_11], VAR_29, VAR_0.border_left, VAR_22,
VAR_16 + VAR_0.border, VAR_0.border, VAR_0.border_rgb);
}
if (VAR_26 != NULL)
{
check_pages(VAR_0.cell_endpage[VAR_11]);
new_render(VAR_0.cell_endpage[VAR_11], VAR_29, VAR_0.border_left, VAR_22,
VAR_16 + VAR_0.border, VAR_7 - VAR_22, VAR_27,
VAR_31[VAR_0.cell_endpage[VAR_11]].start);
}
}
else
{
if (VAR_0.border > 0.0f)
{
new_render(VAR_0.cell_page[VAR_11], VAR_29, VAR_0.border_left,
VAR_0.cell_y[VAR_11] + VAR_0.cellpadding,
VAR_16 + VAR_0.border, VAR_0.border, VAR_0.border_rgb);
new_render(VAR_0.cell_page[VAR_11], VAR_29, VAR_0.border_left, VAR_22,
VAR_0.border, VAR_0.cell_y[VAR_11] - VAR_22 + VAR_0.cellpadding + VAR_0.border, VAR_0.border_rgb);
new_render(VAR_0.cell_page[VAR_11], VAR_29,
VAR_0.border_left + VAR_16, VAR_22,
VAR_0.border, VAR_0.cell_y[VAR_11] - VAR_22 + VAR_0.cellpadding + VAR_0.border, VAR_0.border_rgb);
new_render(VAR_0.cell_page[VAR_11], VAR_29, VAR_0.border_left, VAR_22,
VAR_16 + VAR_0.border, VAR_0.border, VAR_0.border_rgb);
}
if (VAR_26 != NULL)
{
VAR_0.cell_bg[VAR_11]->y      = VAR_22;
VAR_0.cell_bg[VAR_11]->height = VAR_0.cell_y[VAR_11] - VAR_22 + VAR_0.cellpadding + VAR_0.border;
}
}
}
*VAR_10 = VAR_21;
*VAR_9    = VAR_22;
}",michaelrsweet/htmldoc/ba61a3ece382389ae4482c7027af8b32e8ab4cc8/ps-pdf.cxx/vul/before/0.json,"static void
render_table_row(hdtable_t &table,
                 tree_t    ***cells,
                 int       row,
                 uchar     *height_var,
                 float     left,		// I - Left margin
                 float     right,		// I - Printable width
                 float     bottom,		// I - Bottom margin
                 float     top,			// I - Printable top
                 float     *x,
                 float     *y,
                 int       *page)
{
  int		col,
		tcol,
		colspan,
		rowspan,
		tempspace;
  float		width,
		temp_y;
  int		temp_page;
  uchar		*var;
  int		do_valign;		// True if we should do vertical alignment of cells
  int           row_page;
  float		row_y,
                row_starty,
                row_height,		// Total height of the row
		temp_height;		// Temporary holder
  uchar		*bgcolor;
  float		bgrgb[3];


  do_valign  = 1;
  row_height = 0.0f;
  row_page   = *page;
  row_y      = *y - table.cellpadding;
  row_starty = row_y;

  DEBUG_printf((""BEFORE row_y = %.1f, *y = %.1f, row_page = %d\n"",
                row_y, *y, row_page));

  for (col = 0, rowspan = 9999; col < table.num_cols; col += colspan)
  {
    if (table.row_spans[col] == 0)
    {
      if ((var = htmlGetVariable(cells[row][col], (uchar *)""ROWSPAN"")) != NULL)
        table.row_spans[col] = atoi((char *)var);

      if (table.row_spans[col] <= 1)
        table.row_spans[col] = 0;

      if (table.row_spans[col] > (table.num_rows - row))
        table.row_spans[col] = table.num_rows - row;

      table.span_heights[col] = 0.0f;
    }

    if (table.row_spans[col] < rowspan)
      rowspan = table.row_spans[col];

    for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)
      if (cells[row][col] != cells[row][col + colspan])
        break;
  }

  if (!rowspan)
    rowspan = 1;

  for (col = 0; col < table.num_cols;)
  {
    for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)
      if (cells[row][col] != cells[row][col + colspan])
        break;
    colspan --;

    DEBUG_printf((""    col = %d, colspan = %d, left = %.1f, right = %.1f, cell = %p\n"", col, colspan, table.col_lefts[col], table.col_rights[col + colspan], (void *)cells[row][col]));

    *x        = table.col_lefts[col];
    temp_y    = *y - table.cellpadding;
    temp_page = *page;
    tempspace = 0;

    if (row == 0 || cells[row][col] != cells[row - 1][col])
    {
      check_pages(*page);

      if (cells[row][col] == NULL)
        bgcolor = NULL;
      else if ((bgcolor = htmlGetVariable(cells[row][col], (uchar *)""BGCOLOR"")) != NULL)
      {
        memcpy(bgrgb, background_color, sizeof(bgrgb));

        get_color(bgcolor, bgrgb, 0);

        width       = table.col_rights[col + colspan] - table.col_lefts[col] + 2 * table.cellpadding;
        table.border_left = table.col_lefts[col] - table.cellpadding;

        table.cell_bg[col] = new_render(*page, RENDER_BOX, table.border_left, row_y, width + table.border, 0.0, bgrgb);
      }
      else
      {
        table.cell_bg[col] = NULL;

        new_render(*page, RENDER_TEXT, -1.0f, -1.0f, 0.0, 0.0, (void *)"""");
      }

      DEBUG_printf((""cell_bg[%d] = %p, pages[%d].end = %p\n"", col, (void *)table.cell_bg[col], *page, (void *)pages[*page].end));

      table.cell_start[col] = pages[*page].end;
      table.cell_page[col]  = temp_page;
      table.cell_y[col]     = temp_y;

      if (table.debug)
      {
        check_pages(*page);

        render_t *r;
        char table_text[255];

        snprintf(table_text, sizeof(table_text), ""cell=%p [%d,%d]"",
                 (void *)cells[row][col], row, col);
        r = new_render(temp_page, RENDER_TEXT, *x, temp_y,
                       get_width((uchar *)table_text, TYPE_COURIER, STYLE_NORMAL, 1),
                       _htmlSizes[1], table_text);

        r->data.text.typeface = TYPE_COURIER;
        r->data.text.style    = STYLE_NORMAL;
        r->data.text.size     = (float)_htmlSizes[1];
      }

      if (cells[row][col] != NULL && cells[row][col]->child != NULL)
      {
        DEBUG_printf((""    parsing cell %d,%d; width = %.1f\n"", row, col, table.col_rights[col + colspan] - table.col_lefts[col]));

        bottom += table.cellpadding;
        top    -= table.cellpadding;

        parse_doc(cells[row][col]->child, table.col_lefts + col, table.col_rights + col + colspan, &bottom, &top, x, &temp_y, &temp_page, NULL, &tempspace);

        bottom -= table.cellpadding;
        top    += table.cellpadding;
      }

      table.cell_endpage[col] = temp_page;
      table.cell_endy[col]    = temp_y;
      table.cell_height[col]  = *y - table.cellpadding - temp_y;
      table.cell_end[col]     = pages[*page].end;

      if (table.cell_start[col] == NULL)
        table.cell_start[col] = pages[*page].start;

      DEBUG_printf((""row = %d, col = %d, y = %.1f, cell_y = %.1f, cell_height = %.1f\n"", row, col, *y - table.cellpadding, temp_y, table.cell_height[col]));
      DEBUG_printf((""cell_start[%d] = %p, cell_end[%d] = %p\n"", col, (void *)table.cell_start[col], col, (void *)table.cell_end[col]));
    }

    if (table.row_spans[col] == 0 &&
        table.cell_page[col] == table.cell_endpage[col] &&
        table.cell_height[col] > row_height)
      row_height = table.cell_height[col];

    if (table.row_spans[col] <= rowspan)
    {
      if (table.cell_page[col] != table.cell_endpage[col])
        do_valign = 0;

      if (table.cell_endpage[col] > row_page)
      {
        row_page = table.cell_endpage[col];
        row_y    = table.cell_endy[col];
      }
      else if (table.cell_endy[col] < row_y && table.cell_endpage[col] == row_page)
        row_y = table.cell_endy[col];
    }

    DEBUG_printf((""**** col = %d, row = %d, row_y = %.1f, row_page = %d\n"", col, row, row_y, row_page));

    for (col ++; colspan > 0; colspan --, col ++)
    {
      table.cell_start[col]   = NULL;
      table.cell_page[col]    = table.cell_page[col - 1];
      table.cell_y[col]       = table.cell_y[col - 1];
      table.cell_end[col]     = NULL;
      table.cell_endpage[col] = table.cell_endpage[col - 1];
      table.cell_endy[col]    = table.cell_endy[col - 1];
      table.cell_height[col]  = table.cell_height[col - 1];
    }
  }

  DEBUG_printf((""row = %d, row_y = %.1f, row_height = %.1f\n"", row, row_y, row_height));

  for (col = 0; col < table.num_cols; col += colspan)
  {
    for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)
      if (cells[row][col] != cells[row][col + colspan])
        break;

    if (table.row_spans[col])
      table.span_heights[col] += row_height;

    DEBUG_printf((""col = %d, cell_y = %.1f, cell_page = %d, cell_endpage = %d, row_spans = %d, span_heights = %.1f, cell_height = %.1f\n"", col, table.cell_y[col], table.cell_page[col], table.cell_endpage[col], table.row_spans[col], table.span_heights[col], table.cell_height[col]));
  }

  for (col = 0; col < table.num_cols; col += colspan)
  {
    for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)
      if (cells[row][col] != cells[row][col + colspan])
        break;

    if (table.row_spans[col] == rowspan &&
        table.cell_page[col] == table.cell_endpage[col] &&
        table.cell_height[col] > table.span_heights[col])
    {
      temp_height = table.cell_height[col] - table.span_heights[col];
      row_height  += temp_height;
      DEBUG_printf((""Adjusting row-span height by %.1f, new row_height = %.1f\n"", temp_height, row_height));

      for (tcol = 0; tcol < table.num_cols; tcol ++)
        if (table.row_spans[tcol])
        {
          table.span_heights[tcol] += temp_height;
          DEBUG_printf((""col = %d, span_heights = %.1f\n"", tcol, table.span_heights[tcol]));
        }
    }
  }

  DEBUG_printf((""AFTER row = %d, row_page = %d, row_y = %.1f, row_height = %.1f, *y = %.1f, do_valign = %d\n"", row, row_page, row_y, row_height, *y, do_valign));

 /*
  * Do the vertical alignment
  */

  if (do_valign)
  {
    height_var = NULL;

    if (cells[row][0] != NULL)
    {
      if ((height_var = htmlGetVariable(cells[row][0]->parent, (uchar *)""HEIGHT"")) == NULL)
	for (col = 0; col < table.num_cols; col ++)
	  if (htmlGetVariable(cells[row][col], (uchar *)""ROWSPAN"") == NULL)
	    if ((height_var = htmlGetVariable(cells[row][col], (uchar *)""HEIGHT"")) != NULL)
	      break;
    }

    if (height_var != NULL)
    {
      // Hardcode the row height...
      if (height_var[strlen((char *)height_var) - 1] == '%')
        temp_height = (float)(atof((char *)height_var) * 0.01f * PagePrintLength);
      else
        temp_height = (float)(atof((char *)height_var) * PagePrintWidth / _htmlBrowserWidth);

      if (table.height > 0 && temp_height > table.height)
        temp_height = table.height;

      temp_height -= 2 * table.cellpadding;

      if (temp_height > row_height)
      {
        // Only enforce the height if it is > the actual row height.
        row_height = temp_height;
        row_y      = *y - temp_height;
      }
    }

    for (col = 0; col < table.num_cols; col += colspan + 1)
    {
      render_t	*p;
      float	delta_y;


      for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)
        if (cells[row][col] != cells[row][col + colspan])
          break;

      colspan --;

      if (table.cell_start[col] == NULL || table.row_spans[col] > rowspan ||
          cells[row][col] == NULL || cells[row][col]->child == NULL)
        continue;

      if (table.row_spans[col] == 1)
      {
        int tcol;
        float span_height = 0.0f;

        for (tcol = 0; tcol < table.num_cols; tcol ++)
        {
          if (table.row_spans[col] == 1 && table.span_heights[col] > span_height)
            span_height = table.span_heights[col];
        }

        switch (cells[row][col]->valignment)
        {
          case ALIGN_MIDDLE :
//              delta_y = (table.span_heights[col] - table.cell_height[col]) * 0.5f;
              delta_y = (span_height - table.cell_height[col]) * 0.5f;
              break;

          case ALIGN_BOTTOM :
//              delta_y = table.span_heights[col] - table.cell_height[col];
              delta_y = span_height - table.cell_height[col];
              break;

          default :
              delta_y = 0.0f;
              break;
        }
      }
      else if (table.row_spans[col])
      {
        delta_y = 0.0f;
      }
      else
      {
        switch (cells[row][col]->valignment)
        {
          case ALIGN_MIDDLE :
              delta_y = (row_height - table.cell_height[col]) * 0.5f;
              break;

          case ALIGN_BOTTOM :
              delta_y = row_height - table.cell_height[col];
              break;

          default :
              delta_y = 0.0f;
              break;
        }
      }

      DEBUG_printf((""row = %d, col = %d, valign = %d, rowspans = %d, cell_height = %.1f, span_heights = %.1f, delta_y = %.1f\n"", row, col, cells[row][col]->valignment, table.row_spans[col], table.cell_height[col], table.span_heights[col], delta_y));

      if (delta_y > 0.0f)
      {
        if (table.cell_start[col] == table.cell_end[col])
          p = table.cell_start[col];
        else
          p = table.cell_start[col]->next;

        for (; p != NULL; p = p->next)
        {
          DEBUG_printf((""aligning %p (%s), y was %.1f, now %.1f\n"",
                        (void *)p, p->data.text.buffer, p->y, p->y - delta_y));

          p->y -= delta_y;
          if (p == table.cell_end[col])
            break;
        }
      }
#ifdef DEBUG
      else
      {
        if (table.cell_start[col] == table.cell_end[col])
          p = table.cell_start[col];
        else
          p = table.cell_start[col]->next;

        for (; p != NULL; p = p->next)
        {
          printf(""NOT aligning %p (%s)\n"", (void *)p, p->data.text.buffer);

          if (p == table.cell_end[col])
            break;
        }
      }
#endif /* DEBUG */
    }
  }

  // Update all current columns with ROWSPAN <= rowspan to use the same
  // end page and row...
  for (col = 0, temp_page = -1, temp_y = 99999999; col < table.num_cols; col ++)
    if (table.row_spans[col] <= rowspan &&
        cells[row][col] != NULL && cells[row][col]->child != NULL)
    {
      if (table.cell_endpage[col] > temp_page)
      {
        temp_page = table.cell_endpage[col];
        temp_y    = table.cell_endy[col];
      }
      else if (table.cell_endpage[col] == temp_page && table.cell_endy[col] < temp_y)
        temp_y = table.cell_endy[col];
    }

  for (col = 0; col < table.num_cols; col ++)
    if (table.row_spans[col] <= rowspan &&
        cells[row][col] != NULL && cells[row][col]->child != NULL)
    {
      table.cell_endpage[col] = temp_page;
      table.cell_endy[col]    = temp_y;
    }

  row_y -= table.cellpadding;

  table.border_left = table.col_lefts[0] - table.cellpadding;
  width       = table.col_rights[table.num_cols - 1] - table.col_lefts[0] + 2 * table.cellpadding;

  for (bgcolor = NULL, col = 0; col < table.num_cols; col ++)
    if (table.row_spans[col] <= rowspan &&
        cells[row][col] &&
        !htmlGetVariable(cells[row][col], (uchar *)""ROWSPAN"") &&
        (bgcolor = htmlGetVariable(cells[row][col]->parent,
                                   (uchar *)""BGCOLOR"")) != NULL)
      break;

  if (bgcolor)
  {
    memcpy(bgrgb, background_color, sizeof(bgrgb));

    get_color(bgcolor, bgrgb, 0);

    if (row_page > *page)
    {
      // Draw background on multiple pages...

      // Bottom of first page...
      new_render(*page, RENDER_BOX, table.border_left, bottom,
                 width, row_starty - bottom + table.cellpadding, bgrgb,
                 pages[*page].start);

      // Intervening pages...
      for (temp_page = *page + 1; temp_page < row_page; temp_page ++)
      {
        new_render(temp_page, RENDER_BOX, table.border_left, bottom,
                   width, top - bottom, bgrgb, pages[temp_page].start);
      }

      // Top of last page...
      check_pages(*page);

      new_render(row_page, RENDER_BOX, table.border_left, row_y,
                 width, top - row_y, bgrgb,
                 pages[row_page].start);
    }
    else
    {
      // Draw background in row...
      new_render(row_page, RENDER_BOX, table.border_left, row_y,
                 width, row_height + 2 * table.cellpadding, bgrgb,
                 pages[row_page].start);
    }
  }

  for (col = 0; col < table.num_cols; col += colspan + 1)
  {
    for (colspan = 0; (col + colspan) < table.num_cols; colspan ++)
      if (cells[row][col] != cells[row][col + colspan])
        break;
      else if (table.row_spans[col + colspan] > 0)
      {
        DEBUG_printf((""row = %d, col = %d, decrementing row_spans (%d) to %d...\n"", row,
                      col, table.row_spans[col + colspan],
                      table.row_spans[col + colspan] - rowspan));
        table.row_spans[col + colspan] -= rowspan;
      }

    colspan --;

    width = table.col_rights[col + colspan] - table.col_lefts[col] +
            2 * table.cellpadding;

    if (cells[row][col] == NULL || cells[row][col]->child == NULL ||
        table.row_spans[col] > 0)
      continue;

    DEBUG_printf((""DRAWING BORDER+BACKGROUND: col=%d, row=%d, cell_page=%d, cell_y=%.1f\n""
                  ""                           cell_endpage=%d, cell_endy=%.1f\n"",
                  col, row, table.cell_page[col], table.cell_y[col],
                  table.cell_endpage[col], table.cell_endy[col]));

    if ((bgcolor = htmlGetVariable(cells[row][col],
                                   (uchar *)""BGCOLOR"")) != NULL)
    {
      memcpy(bgrgb, background_color, sizeof(bgrgb));

      get_color(bgcolor, bgrgb, 0);
    }

    table.border_left = table.col_lefts[col] - table.cellpadding;

    if (table.cell_page[col] != table.cell_endpage[col])
    {
     /*
      * Crossing a page boundary...
      */

      if (table.border > 0)
      {
       /*
        * +---+---+---+
        * |   |   |   |
        */

        // Top
        new_render(table.cell_page[col], RENDER_BOX, table.border_left,
                   table.cell_y[col] + table.cellpadding,
                   width + table.border, table.border, table.border_rgb);
        // Left
        new_render(table.cell_page[col], RENDER_BOX, table.border_left, bottom,
                   table.border, table.cell_y[col] - bottom + table.cellpadding + table.border, table.border_rgb);
        // Right
        new_render(table.cell_page[col], RENDER_BOX,
                   table.border_left + width, bottom,
                   table.border, table.cell_y[col] - bottom + table.cellpadding + table.border, table.border_rgb);
      }

      if (bgcolor != NULL)
      {
        table.cell_bg[col]->y      = bottom;
        table.cell_bg[col]->height = table.cell_y[col] - bottom + table.cellpadding + table.border;
      }

      for (temp_page = table.cell_page[col] + 1; temp_page < table.cell_endpage[col]; temp_page ++)
      {
       /*
        * |   |   |   |
        * |   |   |   |
        */

        if (table.border > 0.0f)
        {
          // Left
          new_render(temp_page, RENDER_BOX, table.border_left, bottom,
                     table.border, top - bottom, table.border_rgb);
          // Right
          new_render(temp_page, RENDER_BOX,
                     table.border_left + width, bottom,
                     table.border, top - bottom, table.border_rgb);
        }

        if (bgcolor != NULL)
          new_render(temp_page, RENDER_BOX, table.border_left, bottom,
                     width + table.border, top - bottom, bgrgb,
                     pages[temp_page].start);
      }

      if (table.border > 0.0f)
      {
       /*
        * |   |   |   |
        * +---+---+---+
        */

        // Left
        new_render(table.cell_endpage[col], RENDER_BOX, table.border_left, row_y,
                   table.border, top - row_y, table.border_rgb);
        // Right
        new_render(table.cell_endpage[col], RENDER_BOX,
                   table.border_left + width, row_y,
                   table.border, top - row_y, table.border_rgb);
        // Bottom
        new_render(table.cell_endpage[col], RENDER_BOX, table.border_left, row_y,
                   width + table.border, table.border, table.border_rgb);
      }

      if (bgcolor != NULL)
      {
        check_pages(table.cell_endpage[col]);

        new_render(table.cell_endpage[col], RENDER_BOX, table.border_left, row_y,
                   width + table.border, top - row_y, bgrgb,
                   pages[table.cell_endpage[col]].start);
      }
    }
    else
    {
     /*
      * +---+---+---+
      * |   |   |   |
      * +---+---+---+
      */

      if (table.border > 0.0f)
      {
        // Top
        new_render(table.cell_page[col], RENDER_BOX, table.border_left,
                   table.cell_y[col] + table.cellpadding,
                   width + table.border, table.border, table.border_rgb);
        // Left
        new_render(table.cell_page[col], RENDER_BOX, table.border_left, row_y,
                   table.border, table.cell_y[col] - row_y + table.cellpadding + table.border, table.border_rgb);
        // Right
        new_render(table.cell_page[col], RENDER_BOX,
                   table.border_left + width, row_y,
                   table.border, table.cell_y[col] - row_y + table.cellpadding + table.border, table.border_rgb);
        // Bottom
        new_render(table.cell_page[col], RENDER_BOX, table.border_left, row_y,
                   width + table.border, table.border, table.border_rgb);
      }

      if (bgcolor != NULL)
      {
        table.cell_bg[col]->y      = row_y;
        table.cell_bg[col]->height = table.cell_y[col] - row_y + table.cellpadding + table.border;
      }
    }
  }

  *page = row_page;
  *y    = row_y;
}","static void
render_table_row(hdtable_t &VAR_0,
                 tree_t    ***VAR_1,
                 int       VAR_2,
                 uchar     *VAR_3,
                 float     VAR_4,		/* COMMENT_0 */
                 float     VAR_5,		/* COMMENT_1 */
                 float     VAR_6,		/* COMMENT_2 */
                 float     VAR_7,			/* COMMENT_3 */
                 float     *VAR_8,
                 float     *VAR_9,
                 int       *VAR_10)
{
  int		VAR_11,
		VAR_12,
		VAR_13,
		VAR_14,
		VAR_15;
  float		VAR_16,
		VAR_17;
  int		VAR_18;
  uchar		*VAR_19;
  int		VAR_20;		/* COMMENT_4 */
  int           VAR_21;
  float		VAR_22,
                VAR_23,
                VAR_24,		/* COMMENT_5 */
		VAR_25;		/* COMMENT_6 */
  uchar		*VAR_26;
  float		VAR_27[3];


  VAR_20  = 1;
  VAR_24 = 0.0f;
  VAR_21   = *VAR_10;
  VAR_22      = *VAR_9 - VAR_0.cellpadding;
  VAR_23 = VAR_22;

  DEBUG_printf((""BEFORE row_y = %.1f, *y = %.1f, row_page = %d\n"",
                VAR_22, *VAR_9, VAR_21));

  for (VAR_11 = 0, VAR_14 = 9999; VAR_11 < VAR_0.num_cols; VAR_11 += VAR_13)
  {
    if (VAR_0.row_spans[VAR_11] == 0)
    {
      if ((VAR_19 = htmlGetVariable(VAR_1[VAR_2][VAR_11], (uchar *)""ROWSPAN"")) != NULL)
        VAR_0.row_spans[VAR_11] = atoi((char *)VAR_19);

      if (VAR_0.row_spans[VAR_11] <= 1)
        VAR_0.row_spans[VAR_11] = 0;

      if (VAR_0.row_spans[VAR_11] > (VAR_0.num_rows - VAR_2))
        VAR_0.row_spans[VAR_11] = VAR_0.num_rows - VAR_2;

      VAR_0.span_heights[VAR_11] = 0.0f;
    }

    if (VAR_0.row_spans[VAR_11] < VAR_14)
      VAR_14 = VAR_0.row_spans[VAR_11];

    for (VAR_13 = 1; (VAR_11 + VAR_13) < VAR_0.num_cols; VAR_13 ++)
      if (VAR_1[VAR_2][VAR_11] != VAR_1[VAR_2][VAR_11 + VAR_13])
        break;
  }

  if (!VAR_14)
    VAR_14 = 1;

  for (VAR_11 = 0; VAR_11 < VAR_0.num_cols;)
  {
    for (VAR_13 = 1; (VAR_11 + VAR_13) < VAR_0.num_cols; VAR_13 ++)
      if (VAR_1[VAR_2][VAR_11] != VAR_1[VAR_2][VAR_11 + VAR_13])
        break;
    VAR_13 --;

    DEBUG_printf((""    col = %d, colspan = %d, left = %.1f, right = %.1f, cell = %p\n"", VAR_11, VAR_13, VAR_0.col_lefts[VAR_11], VAR_0.col_rights[VAR_11 + VAR_13], (void *)VAR_1[VAR_2][VAR_11]));

    *VAR_8        = VAR_0.col_lefts[VAR_11];
    VAR_17    = *VAR_9 - VAR_0.cellpadding;
    VAR_18 = *VAR_10;
    VAR_15 = 0;

    if (VAR_2 == 0 || VAR_1[VAR_2][VAR_11] != VAR_1[VAR_2 - 1][VAR_11])
    {
      check_pages(*VAR_10);

      if (VAR_1[VAR_2][VAR_11] == NULL)
        VAR_26 = NULL;
      else if ((VAR_26 = htmlGetVariable(VAR_1[VAR_2][VAR_11], (uchar *)""BGCOLOR"")) != NULL)
      {
        memcpy(VAR_27, VAR_28, sizeof(VAR_27));

        get_color(VAR_26, VAR_27, 0);

        VAR_16       = VAR_0.col_rights[VAR_11 + VAR_13] - VAR_0.col_lefts[VAR_11] + 2 * VAR_0.cellpadding;
        VAR_0.border_left = VAR_0.col_lefts[VAR_11] - VAR_0.cellpadding;

        VAR_0.cell_bg[VAR_11] = new_render(*VAR_10, VAR_29, VAR_0.border_left, VAR_22, VAR_16 + VAR_0.border, 0.0, VAR_27);
      }
      else
      {
        VAR_0.cell_bg[VAR_11] = NULL;

        new_render(*VAR_10, VAR_30, -1.0f, -1.0f, 0.0, 0.0, (void *)"""");
      }

      DEBUG_printf((""cell_bg[%d] = %p, pages[%d].end = %p\n"", VAR_11, (void *)VAR_0.cell_bg[VAR_11], *VAR_10, (void *)VAR_31[*VAR_10].end));

      VAR_0.cell_start[VAR_11] = VAR_31[*VAR_10].end;
      VAR_0.cell_page[VAR_11]  = VAR_18;
      VAR_0.cell_y[VAR_11]     = VAR_17;

      if (VAR_0.debug)
      {
        check_pages(*VAR_10);

        render_t *VAR_32;
        char VAR_33[255];

        snprintf(VAR_33, sizeof(VAR_33), ""cell=%p [%d,%d]"",
                 (void *)VAR_1[VAR_2][VAR_11], VAR_2, VAR_11);
        VAR_32 = new_render(VAR_18, VAR_30, *VAR_8, VAR_17,
                       get_width((uchar *)VAR_33, VAR_34, VAR_35, 1),
                       VAR_36[1], VAR_33);

        VAR_32->data.text.typeface = VAR_34;
        VAR_32->data.text.style    = VAR_35;
        VAR_32->data.text.size     = (float)VAR_36[1];
      }

      if (VAR_1[VAR_2][VAR_11] != NULL && VAR_1[VAR_2][VAR_11]->child != NULL)
      {
        DEBUG_printf((""    parsing cell %d,%d; width = %.1f\n"", VAR_2, VAR_11, VAR_0.col_rights[VAR_11 + VAR_13] - VAR_0.col_lefts[VAR_11]));

        VAR_6 += VAR_0.cellpadding;
        VAR_7    -= VAR_0.cellpadding;

        parse_doc(VAR_1[VAR_2][VAR_11]->child, VAR_0.col_lefts + VAR_11, VAR_0.col_rights + VAR_11 + VAR_13, &VAR_6, &VAR_7, VAR_8, &VAR_17, &VAR_18, NULL, &VAR_15);

        VAR_6 -= VAR_0.cellpadding;
        VAR_7    += VAR_0.cellpadding;
      }

      VAR_0.cell_endpage[VAR_11] = VAR_18;
      VAR_0.cell_endy[VAR_11]    = VAR_17;
      VAR_0.cell_height[VAR_11]  = *VAR_9 - VAR_0.cellpadding - VAR_17;
      VAR_0.cell_end[VAR_11]     = VAR_31[*VAR_10].end;

      if (VAR_0.cell_start[VAR_11] == NULL)
        VAR_0.cell_start[VAR_11] = VAR_31[*VAR_10].start;

      DEBUG_printf((""row = %d, col = %d, y = %.1f, cell_y = %.1f, cell_height = %.1f\n"", VAR_2, VAR_11, *VAR_9 - VAR_0.cellpadding, VAR_17, VAR_0.cell_height[VAR_11]));
      DEBUG_printf((""cell_start[%d] = %p, cell_end[%d] = %p\n"", VAR_11, (void *)VAR_0.cell_start[VAR_11], VAR_11, (void *)VAR_0.cell_end[VAR_11]));
    }

    if (VAR_0.row_spans[VAR_11] == 0 &&
        VAR_0.cell_page[VAR_11] == VAR_0.cell_endpage[VAR_11] &&
        VAR_0.cell_height[VAR_11] > VAR_24)
      VAR_24 = VAR_0.cell_height[VAR_11];

    if (VAR_0.row_spans[VAR_11] <= VAR_14)
    {
      if (VAR_0.cell_page[VAR_11] != VAR_0.cell_endpage[VAR_11])
        VAR_20 = 0;

      if (VAR_0.cell_endpage[VAR_11] > VAR_21)
      {
        VAR_21 = VAR_0.cell_endpage[VAR_11];
        VAR_22    = VAR_0.cell_endy[VAR_11];
      }
      else if (VAR_0.cell_endy[VAR_11] < VAR_22 && VAR_0.cell_endpage[VAR_11] == VAR_21)
        VAR_22 = VAR_0.cell_endy[VAR_11];
    }

    DEBUG_printf((""**** col = %d, row = %d, row_y = %.1f, row_page = %d\n"", VAR_11, VAR_2, VAR_22, VAR_21));

    for (VAR_11 ++; VAR_13 > 0; VAR_13 --, VAR_11 ++)
    {
      VAR_0.cell_start[VAR_11]   = NULL;
      VAR_0.cell_page[VAR_11]    = VAR_0.cell_page[VAR_11 - 1];
      VAR_0.cell_y[VAR_11]       = VAR_0.cell_y[VAR_11 - 1];
      VAR_0.cell_end[VAR_11]     = NULL;
      VAR_0.cell_endpage[VAR_11] = VAR_0.cell_endpage[VAR_11 - 1];
      VAR_0.cell_endy[VAR_11]    = VAR_0.cell_endy[VAR_11 - 1];
      VAR_0.cell_height[VAR_11]  = VAR_0.cell_height[VAR_11 - 1];
    }
  }

  DEBUG_printf((""row = %d, row_y = %.1f, row_height = %.1f\n"", VAR_2, VAR_22, VAR_24));

  for (VAR_11 = 0; VAR_11 < VAR_0.num_cols; VAR_11 += VAR_13)
  {
    for (VAR_13 = 1; (VAR_11 + VAR_13) < VAR_0.num_cols; VAR_13 ++)
      if (VAR_1[VAR_2][VAR_11] != VAR_1[VAR_2][VAR_11 + VAR_13])
        break;

    if (VAR_0.row_spans[VAR_11])
      VAR_0.span_heights[VAR_11] += VAR_24;

    DEBUG_printf((""col = %d, cell_y = %.1f, cell_page = %d, cell_endpage = %d, row_spans = %d, span_heights = %.1f, cell_height = %.1f\n"", VAR_11, VAR_0.cell_y[VAR_11], VAR_0.cell_page[VAR_11], VAR_0.cell_endpage[VAR_11], VAR_0.row_spans[VAR_11], VAR_0.span_heights[VAR_11], VAR_0.cell_height[VAR_11]));
  }

  for (VAR_11 = 0; VAR_11 < VAR_0.num_cols; VAR_11 += VAR_13)
  {
    for (VAR_13 = 1; (VAR_11 + VAR_13) < VAR_0.num_cols; VAR_13 ++)
      if (VAR_1[VAR_2][VAR_11] != VAR_1[VAR_2][VAR_11 + VAR_13])
        break;

    if (VAR_0.row_spans[VAR_11] == VAR_14 &&
        VAR_0.cell_page[VAR_11] == VAR_0.cell_endpage[VAR_11] &&
        VAR_0.cell_height[VAR_11] > VAR_0.span_heights[VAR_11])
    {
      VAR_25 = VAR_0.cell_height[VAR_11] - VAR_0.span_heights[VAR_11];
      VAR_24  += VAR_25;
      DEBUG_printf((""Adjusting row-span height by %.1f, new row_height = %.1f\n"", VAR_25, VAR_24));

      for (VAR_12 = 0; VAR_12 < VAR_0.num_cols; VAR_12 ++)
        if (VAR_0.row_spans[VAR_12])
        {
          VAR_0.span_heights[VAR_12] += VAR_25;
          DEBUG_printf((""col = %d, span_heights = %.1f\n"", VAR_12, VAR_0.span_heights[VAR_12]));
        }
    }
  }

  DEBUG_printf((""AFTER row = %d, row_page = %d, row_y = %.1f, row_height = %.1f, *y = %.1f, do_valign = %d\n"", VAR_2, VAR_21, VAR_22, VAR_24, *VAR_9, VAR_20));

 /* COMMENT_7 */
                             
    

  if (VAR_20)
  {
    VAR_3 = NULL;

    if (VAR_1[VAR_2][0] != NULL)
    {
      if ((VAR_3 = htmlGetVariable(VAR_1[VAR_2][0]->parent, (uchar *)""HEIGHT"")) == NULL)
	for (VAR_11 = 0; VAR_11 < VAR_0.num_cols; VAR_11 ++)
	  if (htmlGetVariable(VAR_1[VAR_2][VAR_11], (uchar *)""ROWSPAN"") == NULL)
	    if ((VAR_3 = htmlGetVariable(VAR_1[VAR_2][VAR_11], (uchar *)""HEIGHT"")) != NULL)
	      break;
    }

    if (VAR_3 != NULL)
    {
      /* COMMENT_10 */
      if (VAR_3[strlen((char *)VAR_3) - 1] == '%')
        VAR_25 = (float)(atof((char *)VAR_3) * 0.01f * VAR_37);
      else
        VAR_25 = (float)(atof((char *)VAR_3) * VAR_38 / VAR_39);

      if (VAR_0.height > 0 && VAR_25 > VAR_0.height)
        VAR_25 = VAR_0.height;

      VAR_25 -= 2 * VAR_0.cellpadding;

      if (VAR_25 > VAR_24)
      {
        /* COMMENT_11 */
        VAR_24 = VAR_25;
        VAR_22      = *VAR_9 - VAR_25;
      }
    }

    for (VAR_11 = 0; VAR_11 < VAR_0.num_cols; VAR_11 += VAR_13 + 1)
    {
      render_t	*VAR_40;
      float	VAR_41;


      for (VAR_13 = 1; (VAR_11 + VAR_13) < VAR_0.num_cols; VAR_13 ++)
        if (VAR_1[VAR_2][VAR_11] != VAR_1[VAR_2][VAR_11 + VAR_13])
          break;

      VAR_13 --;

      if (VAR_0.cell_start[VAR_11] == NULL || VAR_0.row_spans[VAR_11] > VAR_14 ||
          VAR_1[VAR_2][VAR_11] == NULL || VAR_1[VAR_2][VAR_11]->child == NULL)
        continue;

      if (VAR_0.row_spans[VAR_11] == 1)
      {
        int VAR_12;
        float VAR_42 = 0.0f;

        for (VAR_12 = 0; VAR_12 < VAR_0.num_cols; VAR_12 ++)
        {
          if (VAR_0.row_spans[VAR_11] == 1 && VAR_0.span_heights[VAR_11] > VAR_42)
            VAR_42 = VAR_0.span_heights[VAR_11];
        }

        switch (VAR_1[VAR_2][VAR_11]->valignment)
        {
          case VAR_43 :
/* COMMENT_12 */
              VAR_41 = (VAR_42 - VAR_0.cell_height[VAR_11]) * 0.5f;
              break;

          case VAR_44 :
/* COMMENT_13 */
              VAR_41 = VAR_42 - VAR_0.cell_height[VAR_11];
              break;

          default :
              VAR_41 = 0.0f;
              break;
        }
      }
      else if (VAR_0.row_spans[VAR_11])
      {
        VAR_41 = 0.0f;
      }
      else
      {
        switch (VAR_1[VAR_2][VAR_11]->valignment)
        {
          case VAR_43 :
              VAR_41 = (VAR_24 - VAR_0.cell_height[VAR_11]) * 0.5f;
              break;

          case VAR_44 :
              VAR_41 = VAR_24 - VAR_0.cell_height[VAR_11];
              break;

          default :
              VAR_41 = 0.0f;
              break;
        }
      }

      DEBUG_printf((""row = %d, col = %d, valign = %d, rowspans = %d, cell_height = %.1f, span_heights = %.1f, delta_y = %.1f\n"", VAR_2, VAR_11, VAR_1[VAR_2][VAR_11]->valignment, VAR_0.row_spans[VAR_11], VAR_0.cell_height[VAR_11], VAR_0.span_heights[VAR_11], VAR_41));

      if (VAR_41 > 0.0f)
      {
        if (VAR_0.cell_start[VAR_11] == VAR_0.cell_end[VAR_11])
          VAR_40 = VAR_0.cell_start[VAR_11];
        else
          VAR_40 = VAR_0.cell_start[VAR_11]->next;

        for (; VAR_40 != NULL; VAR_40 = VAR_40->next)
        {
          DEBUG_printf((""aligning %p (%s), y was %.1f, now %.1f\n"",
                        (void *)VAR_40, VAR_40->data.text.buffer, VAR_40->y, VAR_40->y - VAR_41));

          VAR_40->y -= VAR_41;
          if (VAR_40 == VAR_0.cell_end[VAR_11])
            break;
        }
      }
#ifdef VAR_45
      else
      {
        if (VAR_0.cell_start[VAR_11] == VAR_0.cell_end[VAR_11])
          VAR_40 = VAR_0.cell_start[VAR_11];
        else
          VAR_40 = VAR_0.cell_start[VAR_11]->next;

        for (; VAR_40 != NULL; VAR_40 = VAR_40->next)
        {
          printf(""NOT aligning %p (%s)\n"", (void *)VAR_40, VAR_40->data.text.buffer);

          if (VAR_40 == VAR_0.cell_end[VAR_11])
            break;
        }
      }
#endif /* COMMENT_14 */
    }
  }

  /* COMMENT_15 */
  /* COMMENT_16 */
  for (VAR_11 = 0, VAR_18 = -1, VAR_17 = 99999999; VAR_11 < VAR_0.num_cols; VAR_11 ++)
    if (VAR_0.row_spans[VAR_11] <= VAR_14 &&
        VAR_1[VAR_2][VAR_11] != NULL && VAR_1[VAR_2][VAR_11]->child != NULL)
    {
      if (VAR_0.cell_endpage[VAR_11] > VAR_18)
      {
        VAR_18 = VAR_0.cell_endpage[VAR_11];
        VAR_17    = VAR_0.cell_endy[VAR_11];
      }
      else if (VAR_0.cell_endpage[VAR_11] == VAR_18 && VAR_0.cell_endy[VAR_11] < VAR_17)
        VAR_17 = VAR_0.cell_endy[VAR_11];
    }

  for (VAR_11 = 0; VAR_11 < VAR_0.num_cols; VAR_11 ++)
    if (VAR_0.row_spans[VAR_11] <= VAR_14 &&
        VAR_1[VAR_2][VAR_11] != NULL && VAR_1[VAR_2][VAR_11]->child != NULL)
    {
      VAR_0.cell_endpage[VAR_11] = VAR_18;
      VAR_0.cell_endy[VAR_11]    = VAR_17;
    }

  VAR_22 -= VAR_0.cellpadding;

  VAR_0.border_left = VAR_0.col_lefts[0] - VAR_0.cellpadding;
  VAR_16       = VAR_0.col_rights[VAR_0.num_cols - 1] - VAR_0.col_lefts[0] + 2 * VAR_0.cellpadding;

  for (VAR_26 = NULL, VAR_11 = 0; VAR_11 < VAR_0.num_cols; VAR_11 ++)
    if (VAR_0.row_spans[VAR_11] <= VAR_14 &&
        VAR_1[VAR_2][VAR_11] &&
        !htmlGetVariable(VAR_1[VAR_2][VAR_11], (uchar *)""ROWSPAN"") &&
        (VAR_26 = htmlGetVariable(VAR_1[VAR_2][VAR_11]->parent,
                                   (uchar *)""BGCOLOR"")) != NULL)
      break;

  if (VAR_26)
  {
    memcpy(VAR_27, VAR_28, sizeof(VAR_27));

    get_color(VAR_26, VAR_27, 0);

    if (VAR_21 > *VAR_10)
    {
      /* COMMENT_17 */

      /* COMMENT_18 */
      new_render(*VAR_10, VAR_29, VAR_0.border_left, VAR_6,
                 VAR_16, VAR_23 - VAR_6 + VAR_0.cellpadding, VAR_27,
                 VAR_31[*VAR_10].start);

      /* COMMENT_19 */
      for (VAR_18 = *VAR_10 + 1; VAR_18 < VAR_21; VAR_18 ++)
      {
        new_render(VAR_18, VAR_29, VAR_0.border_left, VAR_6,
                   VAR_16, VAR_7 - VAR_6, VAR_27, VAR_31[VAR_18].start);
      }

      /* COMMENT_20 */
      check_pages(*VAR_10);

      new_render(VAR_21, VAR_29, VAR_0.border_left, VAR_22,
                 VAR_16, VAR_7 - VAR_22, VAR_27,
                 VAR_31[VAR_21].start);
    }
    else
    {
      /* COMMENT_21 */
      new_render(VAR_21, VAR_29, VAR_0.border_left, VAR_22,
                 VAR_16, VAR_24 + 2 * VAR_0.cellpadding, VAR_27,
                 VAR_31[VAR_21].start);
    }
  }

  for (VAR_11 = 0; VAR_11 < VAR_0.num_cols; VAR_11 += VAR_13 + 1)
  {
    for (VAR_13 = 0; (VAR_11 + VAR_13) < VAR_0.num_cols; VAR_13 ++)
      if (VAR_1[VAR_2][VAR_11] != VAR_1[VAR_2][VAR_11 + VAR_13])
        break;
      else if (VAR_0.row_spans[VAR_11 + VAR_13] > 0)
      {
        DEBUG_printf((""row = %d, col = %d, decrementing row_spans (%d) to %d...\n"", VAR_2,
                      VAR_11, VAR_0.row_spans[VAR_11 + VAR_13],
                      VAR_0.row_spans[VAR_11 + VAR_13] - VAR_14));
        VAR_0.row_spans[VAR_11 + VAR_13] -= VAR_14;
      }

    VAR_13 --;

    VAR_16 = VAR_0.col_rights[VAR_11 + VAR_13] - VAR_0.col_lefts[VAR_11] +
            2 * VAR_0.cellpadding;

    if (VAR_1[VAR_2][VAR_11] == NULL || VAR_1[VAR_2][VAR_11]->child == NULL ||
        VAR_0.row_spans[VAR_11] > 0)
      continue;

    DEBUG_printf((""DRAWING BORDER+BACKGROUND: col=%d, row=%d, cell_page=%d, cell_y=%.1f\n""
                  ""                           cell_endpage=%d, cell_endy=%.1f\n"",
                  VAR_11, VAR_2, VAR_0.cell_page[VAR_11], VAR_0.cell_y[VAR_11],
                  VAR_0.cell_endpage[VAR_11], VAR_0.cell_endy[VAR_11]));

    if ((VAR_26 = htmlGetVariable(VAR_1[VAR_2][VAR_11],
                                   (uchar *)""BGCOLOR"")) != NULL)
    {
      memcpy(VAR_27, VAR_28, sizeof(VAR_27));

      get_color(VAR_26, VAR_27, 0);
    }

    VAR_0.border_left = VAR_0.col_lefts[VAR_11] - VAR_0.cellpadding;

    if (VAR_0.cell_page[VAR_11] != VAR_0.cell_endpage[VAR_11])
    {
     /* COMMENT_22 */
                                   
        

      if (VAR_0.border > 0)
      {
       /* COMMENT_25 */
                       
                       
          

        /* COMMENT_29 */
        new_render(VAR_0.cell_page[VAR_11], VAR_29, VAR_0.border_left,
                   VAR_0.cell_y[VAR_11] + VAR_0.cellpadding,
                   VAR_16 + VAR_0.border, VAR_0.border, VAR_0.border_rgb);
        /* COMMENT_30 */
        new_render(VAR_0.cell_page[VAR_11], VAR_29, VAR_0.border_left, VAR_6,
                   VAR_0.border, VAR_0.cell_y[VAR_11] - VAR_6 + VAR_0.cellpadding + VAR_0.border, VAR_0.border_rgb);
        /* COMMENT_31 */
        new_render(VAR_0.cell_page[VAR_11], VAR_29,
                   VAR_0.border_left + VAR_16, VAR_6,
                   VAR_0.border, VAR_0.cell_y[VAR_11] - VAR_6 + VAR_0.cellpadding + VAR_0.border, VAR_0.border_rgb);
      }

      if (VAR_26 != NULL)
      {
        VAR_0.cell_bg[VAR_11]->y      = VAR_6;
        VAR_0.cell_bg[VAR_11]->height = VAR_0.cell_y[VAR_11] - VAR_6 + VAR_0.cellpadding + VAR_0.border;
      }

      for (VAR_18 = VAR_0.cell_page[VAR_11] + 1; VAR_18 < VAR_0.cell_endpage[VAR_11]; VAR_18 ++)
      {
       /* COMMENT_32 */
                       
                       
          

        if (VAR_0.border > 0.0f)
        {
          /* COMMENT_30 */
          new_render(VAR_18, VAR_29, VAR_0.border_left, VAR_6,
                     VAR_0.border, VAR_7 - VAR_6, VAR_0.border_rgb);
          /* COMMENT_31 */
          new_render(VAR_18, VAR_29,
                     VAR_0.border_left + VAR_16, VAR_6,
                     VAR_0.border, VAR_7 - VAR_6, VAR_0.border_rgb);
        }

        if (VAR_26 != NULL)
          new_render(VAR_18, VAR_29, VAR_0.border_left, VAR_6,
                     VAR_16 + VAR_0.border, VAR_7 - VAR_6, VAR_27,
                     VAR_31[VAR_18].start);
      }

      if (VAR_0.border > 0.0f)
      {
       /* COMMENT_35 */
                       
                       
          

        /* COMMENT_30 */
        new_render(VAR_0.cell_endpage[VAR_11], VAR_29, VAR_0.border_left, VAR_22,
                   VAR_0.border, VAR_7 - VAR_22, VAR_0.border_rgb);
        /* COMMENT_31 */
        new_render(VAR_0.cell_endpage[VAR_11], VAR_29,
                   VAR_0.border_left + VAR_16, VAR_22,
                   VAR_0.border, VAR_7 - VAR_22, VAR_0.border_rgb);
        /* COMMENT_39 */
        new_render(VAR_0.cell_endpage[VAR_11], VAR_29, VAR_0.border_left, VAR_22,
                   VAR_16 + VAR_0.border, VAR_0.border, VAR_0.border_rgb);
      }

      if (VAR_26 != NULL)
      {
        check_pages(VAR_0.cell_endpage[VAR_11]);

        new_render(VAR_0.cell_endpage[VAR_11], VAR_29, VAR_0.border_left, VAR_22,
                   VAR_16 + VAR_0.border, VAR_7 - VAR_22, VAR_27,
                   VAR_31[VAR_0.cell_endpage[VAR_11]].start);
      }
    }
    else
    {
     /* COMMENT_40 */
                     
                     
                     
        

      if (VAR_0.border > 0.0f)
      {
        /* COMMENT_29 */
        new_render(VAR_0.cell_page[VAR_11], VAR_29, VAR_0.border_left,
                   VAR_0.cell_y[VAR_11] + VAR_0.cellpadding,
                   VAR_16 + VAR_0.border, VAR_0.border, VAR_0.border_rgb);
        /* COMMENT_30 */
        new_render(VAR_0.cell_page[VAR_11], VAR_29, VAR_0.border_left, VAR_22,
                   VAR_0.border, VAR_0.cell_y[VAR_11] - VAR_22 + VAR_0.cellpadding + VAR_0.border, VAR_0.border_rgb);
        /* COMMENT_31 */
        new_render(VAR_0.cell_page[VAR_11], VAR_29,
                   VAR_0.border_left + VAR_16, VAR_22,
                   VAR_0.border, VAR_0.cell_y[VAR_11] - VAR_22 + VAR_0.cellpadding + VAR_0.border, VAR_0.border_rgb);
        /* COMMENT_39 */
        new_render(VAR_0.cell_page[VAR_11], VAR_29, VAR_0.border_left, VAR_22,
                   VAR_16 + VAR_0.border, VAR_0.border, VAR_0.border_rgb);
      }

      if (VAR_26 != NULL)
      {
        VAR_0.cell_bg[VAR_11]->y      = VAR_22;
        VAR_0.cell_bg[VAR_11]->height = VAR_0.cell_y[VAR_11] - VAR_22 + VAR_0.cellpadding + VAR_0.border;
      }
    }
  }

  *VAR_10 = VAR_21;
  *VAR_9    = VAR_22;
}",michaelrsweet/htmldoc/ba61a3ece382389ae4482c7027af8b32e8ab4cc8/ps-pdf.cxx/vul/after/0.json,"--- func_before
+++ func_after
@@ -46,7 +46,7 @@
       if ((var = htmlGetVariable(cells[row][col], (uchar *)""ROWSPAN"")) != NULL)
         table.row_spans[col] = atoi((char *)var);
 
-      if (table.row_spans[col] == 1)
+      if (table.row_spans[col] <= 1)
         table.row_spans[col] = 0;
 
       if (table.row_spans[col] > (table.num_rows - row))","{'deleted_lines': ['      if (table.row_spans[col] == 1)'], 'added_lines': ['      if (table.row_spans[col] <= 1)']}",True,A flaw was found in htmldoc in v1.9.12 and prior. A stack buffer overflow in parse_table() in ps-pdf.cxx may lead to execute arbitrary code and denial of service.,7.8,HIGH,2,test,2021-04-01T12:21:57Z,3
CVE-2021-42523,['CWE-401'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N,1,hughsie/colord,"Fix a small memory leak in sqlite3_exec()

Fixes https://github.com/hughsie/colord/issues/110",adf41f36cf7214d7d6fa8d528b74eba47c377405,https://github.com/hughsie/colord/commit/adf41f36cf7214d7d6fa8d528b74eba47c377405,src/cd-device-db.c,cd_device_db_load,"gboolean  
cd_device_db_load (CdDeviceDb *ddb,
const gchar *filename,
GError  **error)
{
CdDeviceDbPrivate *priv = GET_PRIVATE (ddb);
const gchar *statement;
gchar *error_msg = NULL;
gint rc;
g_autofree gchar *path = NULL;
g_return_val_if_fail (CD_IS_DEVICE_DB (ddb), FALSE);
g_return_val_if_fail (priv->db == NULL, FALSE);
path = g_path_get_dirname (filename);
if (!cd_main_mkdir_with_parents (path, error))
return FALSE;
g_debug (""CdDeviceDb: trying to open database '%s'"", filename);
g_info (""Using device database file %s"", filename);
rc = sqlite3_open (filename, &priv->db);
if (rc != SQLITE_OK) {
g_set_error (error,
CD_CLIENT_ERROR,
CD_CLIENT_ERROR_INTERNAL,
""Can't open database: %s\n"",
sqlite3_errmsg (priv->db));
sqlite3_close (priv->db);
return FALSE;
}
sqlite3_exec (priv->db, ""PRAGMA synchronous=OFF"",
NULL, NULL, NULL);
rc = sqlite3_exec (priv->db, ""SELECT * FROM devices LIMIT 1"",
NULL, NULL, &error_msg);
if (rc != SQLITE_OK) {
g_debug (""CdDeviceDb: creating table to repair: %s"", error_msg);
sqlite3_free (error_msg);
statement = ""CREATE TABLE devices (""
""device_id TEXT PRIMARY KEY,""
""device TEXT);"";
sqlite3_exec (priv->db, statement, NULL, NULL, NULL);
}
rc = sqlite3_exec (priv->db, ""SELECT * FROM properties_v2 LIMIT 1"",
NULL, NULL, &error_msg);
if (rc != SQLITE_OK) {
statement = ""CREATE TABLE properties_v2 (""
""device_id TEXT,""
""property TEXT,""
""value TEXT,""
""PRIMARY KEY (device_id, property));"";
sqlite3_exec (priv->db, statement, NULL, NULL, NULL);
}
return TRUE;
}","gboolean  
cd_device_db_load (CdDeviceDb *VAR_0,
const gchar *VAR_1,
GError  **VAR_2)
{
CdDeviceDbPrivate *VAR_3 = GET_PRIVATE (VAR_0);
const gchar *VAR_4;
gchar *VAR_5 = NULL;
gint VAR_6;
g_autofree gchar *VAR_7 = NULL;
g_return_val_if_fail (CD_IS_DEVICE_DB (VAR_0), FALSE);
g_return_val_if_fail (VAR_3->db == NULL, FALSE);
VAR_7 = g_path_get_dirname (VAR_1);
if (!cd_main_mkdir_with_parents (VAR_7, VAR_2))
return FALSE;
g_debug (""CdDeviceDb: trying to open database '%s'"", VAR_1);
g_info (""Using device database file %s"", VAR_1);
VAR_6 = sqlite3_open (VAR_1, &VAR_3->db);
if (VAR_6 != VAR_8) {
g_set_error (VAR_2,
VAR_9,
VAR_10,
""Can't open database: %s\n"",
sqlite3_errmsg (VAR_3->db));
sqlite3_close (VAR_3->db);
return FALSE;
}
sqlite3_exec (VAR_3->db, ""PRAGMA synchronous=OFF"",
NULL, NULL, NULL);
VAR_6 = sqlite3_exec (VAR_3->db, ""SELECT * FROM devices LIMIT 1"",
NULL, NULL, &VAR_5);
if (VAR_6 != VAR_8) {
g_debug (""CdDeviceDb: creating table to repair: %s"", VAR_5);
sqlite3_free (VAR_5);
VAR_4 = ""CREATE TABLE devices (""
""device_id TEXT PRIMARY KEY,""
""device TEXT);"";
sqlite3_exec (VAR_3->db, VAR_4, NULL, NULL, NULL);
}
VAR_6 = sqlite3_exec (VAR_3->db, ""SELECT * FROM properties_v2 LIMIT 1"",
NULL, NULL, &VAR_5);
if (VAR_6 != VAR_8) {
VAR_4 = ""CREATE TABLE properties_v2 (""
""device_id TEXT,""
""property TEXT,""
""value TEXT,""
""PRIMARY KEY (device_id, property));"";
sqlite3_exec (VAR_3->db, VAR_4, NULL, NULL, NULL);
}
return TRUE;
}",hughsie/colord/adf41f36cf7214d7d6fa8d528b74eba47c377405/cd-device-db.c/vul/before/0.json,"gboolean  
cd_device_db_load (CdDeviceDb *ddb,
		    const gchar *filename,
		    GError  **error)
{
	CdDeviceDbPrivate *priv = GET_PRIVATE (ddb);
	const gchar *statement;
	gchar *error_msg = NULL;
	gint rc;
	g_autofree gchar *path = NULL;

	g_return_val_if_fail (CD_IS_DEVICE_DB (ddb), FALSE);
	g_return_val_if_fail (priv->db == NULL, FALSE);

	/* ensure the path exists */
	path = g_path_get_dirname (filename);
	if (!cd_main_mkdir_with_parents (path, error))
		return FALSE;

	g_debug (""CdDeviceDb: trying to open database '%s'"", filename);
	g_info (""Using device database file %s"", filename);
	rc = sqlite3_open (filename, &priv->db);
	if (rc != SQLITE_OK) {
		g_set_error (error,
			     CD_CLIENT_ERROR,
			     CD_CLIENT_ERROR_INTERNAL,
			     ""Can't open database: %s\n"",
			     sqlite3_errmsg (priv->db));
		sqlite3_close (priv->db);
		return FALSE;
	}

	/* we don't need to keep doing fsync */
	sqlite3_exec (priv->db, ""PRAGMA synchronous=OFF"",
		      NULL, NULL, NULL);

	/* check devices */
	rc = sqlite3_exec (priv->db, ""SELECT * FROM devices LIMIT 1"",
			   NULL, NULL, &error_msg);
	if (rc != SQLITE_OK) {
		g_debug (""CdDeviceDb: creating table to repair: %s"", error_msg);
		sqlite3_free (error_msg);
		statement = ""CREATE TABLE devices (""
			    ""device_id TEXT PRIMARY KEY,""
			    ""device TEXT);"";
		sqlite3_exec (priv->db, statement, NULL, NULL, NULL);
	}

	/* check properties version 2 */
	rc = sqlite3_exec (priv->db, ""SELECT * FROM properties_v2 LIMIT 1"",
			   NULL, NULL, NULL);
	if (rc != SQLITE_OK) {
		statement = ""CREATE TABLE properties_v2 (""
			    ""device_id TEXT,""
			    ""property TEXT,""
			    ""value TEXT,""
			    ""PRIMARY KEY (device_id, property));"";
		sqlite3_exec (priv->db, statement, NULL, NULL, NULL);
	}
	return TRUE;
}","gboolean  
cd_device_db_load (CdDeviceDb *VAR_0,
		    const gchar *VAR_1,
		    GError  **VAR_2)
{
	CdDeviceDbPrivate *VAR_3 = GET_PRIVATE (VAR_0);
	const gchar *VAR_4;
	gchar *VAR_5 = NULL;
	gint VAR_6;
	g_autofree gchar *VAR_7 = NULL;

	g_return_val_if_fail (CD_IS_DEVICE_DB (VAR_0), FALSE);
	g_return_val_if_fail (VAR_3->db == NULL, FALSE);

	/* COMMENT_0 */
	VAR_7 = g_path_get_dirname (VAR_1);
	if (!cd_main_mkdir_with_parents (VAR_7, VAR_2))
		return FALSE;

	g_debug (""CdDeviceDb: trying to open database '%s'"", VAR_1);
	g_info (""Using device database file %s"", VAR_1);
	VAR_6 = sqlite3_open (VAR_1, &VAR_3->db);
	if (VAR_6 != VAR_8) {
		g_set_error (VAR_2,
			     VAR_9,
			     VAR_10,
			     ""Can't open database: %s\n"",
			     sqlite3_errmsg (VAR_3->db));
		sqlite3_close (VAR_3->db);
		return FALSE;
	}

	/* COMMENT_1 */
	sqlite3_exec (VAR_3->db, ""PRAGMA synchronous=OFF"",
		      NULL, NULL, NULL);

	/* COMMENT_2 */
	VAR_6 = sqlite3_exec (VAR_3->db, ""SELECT * FROM devices LIMIT 1"",
			   NULL, NULL, &VAR_5);
	if (VAR_6 != VAR_8) {
		g_debug (""CdDeviceDb: creating table to repair: %s"", VAR_5);
		sqlite3_free (VAR_5);
		VAR_4 = ""CREATE TABLE devices (""
			    ""device_id TEXT PRIMARY KEY,""
			    ""device TEXT);"";
		sqlite3_exec (VAR_3->db, VAR_4, NULL, NULL, NULL);
	}

	/* COMMENT_3 */
	VAR_6 = sqlite3_exec (VAR_3->db, ""SELECT * FROM properties_v2 LIMIT 1"",
			   NULL, NULL, NULL);
	if (VAR_6 != VAR_8) {
		VAR_4 = ""CREATE TABLE properties_v2 (""
			    ""device_id TEXT,""
			    ""property TEXT,""
			    ""value TEXT,""
			    ""PRIMARY KEY (device_id, property));"";
		sqlite3_exec (VAR_3->db, VAR_4, NULL, NULL, NULL);
	}
	return TRUE;
}",hughsie/colord/adf41f36cf7214d7d6fa8d528b74eba47c377405/cd-device-db.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -48,7 +48,7 @@
 
 	/* check properties version 2 */
 	rc = sqlite3_exec (priv->db, ""SELECT * FROM properties_v2 LIMIT 1"",
-			   NULL, NULL, &error_msg);
+			   NULL, NULL, NULL);
 	if (rc != SQLITE_OK) {
 		statement = ""CREATE TABLE properties_v2 (""
 			    ""device_id TEXT,""","{'deleted_lines': ['\t\t\t   NULL, NULL, &error_msg);'], 'added_lines': ['\t\t\t   NULL, NULL, NULL);']}",True,"There are two Information Disclosure vulnerabilities in colord, and they lie in colord/src/cd-device-db.c and colord/src/cd-profile-db.c separately. They exist because the 'err_msg' of 'sqlite3_exec' is not releasing after use, while libxml2 emphasizes that the caller needs to release it.",7.5,HIGH,2,test,2021-04-02T08:45:56Z,3
CVE-2021-31255,['CWE-120'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,gpac,fixed #1733,758135e91e623d7dfe7f6aaad7aeb3f791b7a4e5,https://github.com/gpac/gpac/commit/758135e91e623d7dfe7f6aaad7aeb3f791b7a4e5,src/isomedia/box_code_adobe.c,abst_box_read,"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)
{
GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;
int i;
u32 tmp_strsize;
char *tmp_str;
GF_Err e;
ISOM_DECREASE_SIZE(ptr, 25)
ptr->bootstrapinfo_version = gf_bs_read_u32(bs);
ptr->profile = gf_bs_read_int(bs, 2);
ptr->live = gf_bs_read_int(bs, 1);
ptr->update = gf_bs_read_int(bs, 1);
ptr->reserved = gf_bs_read_int(bs, 4);
ptr->time_scale = gf_bs_read_u32(bs);
ptr->current_media_time = gf_bs_read_u64(bs);
ptr->smpte_time_code_offset = gf_bs_read_u64(bs);
i=0;
if (ptr->size<8) return GF_ISOM_INVALID_FILE;
tmp_strsize =(u32)ptr->size;
tmp_str = gf_malloc(sizeof(char)*tmp_strsize);
if (!tmp_str) return GF_OUT_OF_MEM;
memset(tmp_str, 0, sizeof(char)*tmp_strsize);
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->movie_identifier = gf_strdup(tmp_str);
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->server_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->server_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}
if (j) {
gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);
}
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->quality_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->quality_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}
if (j) {
gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);
}
}
i=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->drm_data = gf_strdup(tmp_str);
}
i=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->meta_data = gf_strdup(tmp_str);
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->segment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->segment_run_table_count; i++) {
GF_AdobeSegmentRunTableBox *asrt = NULL;
e = gf_isom_box_parse((GF_Box **)&asrt, bs);
if (e) {
if (asrt) gf_isom_box_del((GF_Box*)asrt);
gf_free(tmp_str);
return e;
}
gf_list_add(ptr->segment_run_table_entries, asrt);
}
ISOM_DECREASE_SIZE(ptr, 1)
ptr->fragment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->fragment_run_table_count; i++) {
GF_AdobeFragmentRunTableBox *afrt = NULL;
e = gf_isom_box_parse((GF_Box **)&afrt, bs);
if (e) {
if (afrt) gf_isom_box_del((GF_Box*)afrt);
gf_free(tmp_str);
return e;
}
gf_list_add(ptr->fragment_run_table_entries, afrt);
}
gf_free(tmp_str);
return GF_OK;
}","GF_Err abst_box_read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
GF_AdobeBootstrapInfoBox *VAR_2 = (GF_AdobeBootstrapInfoBox *)VAR_0;
int VAR_3;
u32 VAR_4;
char *VAR_5;
GF_Err VAR_6;
ISOM_DECREASE_SIZE(VAR_2, 25)
VAR_2->bootstrapinfo_version = gf_bs_read_u32(VAR_1);
VAR_2->profile = gf_bs_read_int(VAR_1, 2);
VAR_2->live = gf_bs_read_int(VAR_1, 1);
VAR_2->update = gf_bs_read_int(VAR_1, 1);
VAR_2->reserved = gf_bs_read_int(VAR_1, 4);
VAR_2->time_scale = gf_bs_read_u32(VAR_1);
VAR_2->current_media_time = gf_bs_read_u64(VAR_1);
VAR_2->smpte_time_code_offset = gf_bs_read_u64(VAR_1);
VAR_3=0;
if (VAR_2->size<8) return VAR_7;
VAR_4 =(u32)VAR_2->size;
VAR_5 = gf_malloc(sizeof(char)*VAR_4);
if (!VAR_5) return VAR_8;
memset(VAR_5, 0, sizeof(char)*VAR_4);
while (VAR_4) {
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_3])
break;
VAR_3++;
}
if (VAR_3) {
VAR_2->movie_identifier = gf_strdup(VAR_5);
}
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_2->server_entry_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->server_entry_count; VAR_3++) {
int VAR_9=0;
VAR_4=(u32)VAR_2->size;
while (VAR_4) {
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_5[VAR_9] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_9])
break;
VAR_9++;
}
if (VAR_9) {
gf_list_insert(VAR_2->server_entry_table, gf_strdup(VAR_5), VAR_3);
}
}
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_2->quality_entry_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->quality_entry_count; VAR_3++) {
int VAR_9=0;
VAR_4=(u32)VAR_2->size;
while (VAR_4) {
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_5[VAR_9] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_9])
break;
VAR_9++;
}
if (VAR_9) {
gf_list_insert(VAR_2->quality_entry_table, gf_strdup(VAR_5), VAR_3);
}
}
VAR_3=0;
VAR_4=(u32)VAR_2->size;
while (VAR_4) {
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_3])
break;
VAR_3++;
}
if (VAR_3) {
VAR_2->drm_data = gf_strdup(VAR_5);
}
VAR_3=0;
VAR_4=(u32)VAR_2->size;
while (VAR_4) {
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_3])
break;
VAR_3++;
}
if (VAR_3) {
VAR_2->meta_data = gf_strdup(VAR_5);
}
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_2->segment_run_table_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->segment_run_table_count; VAR_3++) {
GF_AdobeSegmentRunTableBox *VAR_10 = NULL;
VAR_6 = gf_isom_box_parse((GF_Box **)&VAR_10, VAR_1);
if (VAR_6) {
if (VAR_10) gf_isom_box_del((GF_Box*)VAR_10);
gf_free(VAR_5);
return VAR_6;
}
gf_list_add(VAR_2->segment_run_table_entries, VAR_10);
}
ISOM_DECREASE_SIZE(VAR_2, 1)
VAR_2->fragment_run_table_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->fragment_run_table_count; VAR_3++) {
GF_AdobeFragmentRunTableBox *VAR_11 = NULL;
VAR_6 = gf_isom_box_parse((GF_Box **)&VAR_11, VAR_1);
if (VAR_6) {
if (VAR_11) gf_isom_box_del((GF_Box*)VAR_11);
gf_free(VAR_5);
return VAR_6;
}
gf_list_add(VAR_2->fragment_run_table_entries, VAR_11);
}
gf_free(VAR_5);
return VAR_12;
}",gpac/758135e91e623d7dfe7f6aaad7aeb3f791b7a4e5/box_code_adobe.c/vul/before/0.json,"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;
	int i;
	u32 tmp_strsize;
	char *tmp_str;
	Bool zfound=GF_FALSE;
	GF_Err e;

	ISOM_DECREASE_SIZE(ptr, 25)
	ptr->bootstrapinfo_version = gf_bs_read_u32(bs);
	ptr->profile = gf_bs_read_int(bs, 2);
	ptr->live = gf_bs_read_int(bs, 1);
	ptr->update = gf_bs_read_int(bs, 1);
	ptr->reserved = gf_bs_read_int(bs, 4);
	ptr->time_scale = gf_bs_read_u32(bs);
	ptr->current_media_time = gf_bs_read_u64(bs);
	ptr->smpte_time_code_offset = gf_bs_read_u64(bs);

	i=0;
	if (ptr->size<8) return GF_ISOM_INVALID_FILE;
	tmp_strsize =(u32)ptr->size;
	tmp_str = gf_malloc(sizeof(char)*tmp_strsize);
	if (!tmp_str) return GF_OUT_OF_MEM;
	memset(tmp_str, 0, sizeof(char)*tmp_strsize);

	while (tmp_strsize) {
		ISOM_DECREASE_SIZE(ptr, 1)
		tmp_str[i] = gf_bs_read_u8(bs);
		tmp_strsize--;
		if (!tmp_str[i]) {
			zfound = GF_TRUE;
			break;
		}
		i++;
	}
	if (!zfound)
		return GF_ISOM_INVALID_FILE;
	if (i) {
		ptr->movie_identifier = gf_strdup(tmp_str);
	}

	ISOM_DECREASE_SIZE(ptr, 1)
	ptr->server_entry_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->server_entry_count; i++) {
		int j=0;
		zfound = GF_FALSE;
		tmp_strsize=(u32)ptr->size;
		while (tmp_strsize) {
			ISOM_DECREASE_SIZE(ptr, 1)
			tmp_str[j] = gf_bs_read_u8(bs);
			tmp_strsize--;
			if (!tmp_str[j]) {
				zfound = GF_TRUE;
				break;
			}
			j++;
		}
		if (!zfound)
			return GF_ISOM_INVALID_FILE;
		if (j) {
			gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);
		}
	}

	ISOM_DECREASE_SIZE(ptr, 1)
	ptr->quality_entry_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->quality_entry_count; i++) {
		int j=0;
		zfound = GF_FALSE;
		tmp_strsize=(u32)ptr->size;
		while (tmp_strsize) {
			ISOM_DECREASE_SIZE(ptr, 1)
			tmp_str[j] = gf_bs_read_u8(bs);
			tmp_strsize--;
			if (!tmp_str[j]) {
				zfound = GF_TRUE;
				break;
			}
			j++;
		}

		if (!zfound)
			return GF_ISOM_INVALID_FILE;
		if (j) {
			gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);
		}
	}

	i=0;
	tmp_strsize=(u32)ptr->size;
	zfound = GF_FALSE;
	while (tmp_strsize) {
		ISOM_DECREASE_SIZE(ptr, 1)
		tmp_str[i] = gf_bs_read_u8(bs);
		tmp_strsize--;
		if (!tmp_str[i]) {
			zfound = GF_TRUE;
			break;
		}
		i++;
	}
	if (!zfound)
		return GF_ISOM_INVALID_FILE;
	if (i) {
		ptr->drm_data = gf_strdup(tmp_str);
	}

	i=0;
	tmp_strsize=(u32)ptr->size;
	zfound = GF_FALSE;
	while (tmp_strsize) {
		ISOM_DECREASE_SIZE(ptr, 1)
		tmp_str[i] = gf_bs_read_u8(bs);
		tmp_strsize--;
		if (!tmp_str[i]) {
			zfound = GF_TRUE;
			break;
		}
		i++;
	}
	if (!zfound)
		return GF_ISOM_INVALID_FILE;
	if (i) {
		ptr->meta_data = gf_strdup(tmp_str);
	}

	ISOM_DECREASE_SIZE(ptr, 1)
	ptr->segment_run_table_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->segment_run_table_count; i++) {
		GF_AdobeSegmentRunTableBox *asrt = NULL;
		e = gf_isom_box_parse((GF_Box **)&asrt, bs);
		if (e) {
			if (asrt) gf_isom_box_del((GF_Box*)asrt);
			gf_free(tmp_str);
			return e;
		}
		gf_list_add(ptr->segment_run_table_entries, asrt);
	}

	ISOM_DECREASE_SIZE(ptr, 1)
	ptr->fragment_run_table_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->fragment_run_table_count; i++) {
		GF_AdobeFragmentRunTableBox *afrt = NULL;
		e = gf_isom_box_parse((GF_Box **)&afrt, bs);
		if (e) {
			if (afrt) gf_isom_box_del((GF_Box*)afrt);
			gf_free(tmp_str);
			return e;
		}
		gf_list_add(ptr->fragment_run_table_entries, afrt);
	}

	gf_free(tmp_str);

	return GF_OK;
}","GF_Err abst_box_read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
	GF_AdobeBootstrapInfoBox *VAR_2 = (GF_AdobeBootstrapInfoBox *)VAR_0;
	int VAR_3;
	u32 VAR_4;
	char *VAR_5;
	Bool VAR_6=VAR_7;
	GF_Err VAR_8;

	ISOM_DECREASE_SIZE(VAR_2, 25)
	VAR_2->bootstrapinfo_version = gf_bs_read_u32(VAR_1);
	VAR_2->profile = gf_bs_read_int(VAR_1, 2);
	VAR_2->live = gf_bs_read_int(VAR_1, 1);
	VAR_2->update = gf_bs_read_int(VAR_1, 1);
	VAR_2->reserved = gf_bs_read_int(VAR_1, 4);
	VAR_2->time_scale = gf_bs_read_u32(VAR_1);
	VAR_2->current_media_time = gf_bs_read_u64(VAR_1);
	VAR_2->smpte_time_code_offset = gf_bs_read_u64(VAR_1);

	VAR_3=0;
	if (VAR_2->size<8) return VAR_9;
	VAR_4 =(u32)VAR_2->size;
	VAR_5 = gf_malloc(sizeof(char)*VAR_4);
	if (!VAR_5) return VAR_10;
	memset(VAR_5, 0, sizeof(char)*VAR_4);

	while (VAR_4) {
		ISOM_DECREASE_SIZE(VAR_2, 1)
		VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
		VAR_4--;
		if (!VAR_5[VAR_3]) {
			VAR_6 = VAR_11;
			break;
		}
		VAR_3++;
	}
	if (!VAR_6)
		return VAR_9;
	if (VAR_3) {
		VAR_2->movie_identifier = gf_strdup(VAR_5);
	}

	ISOM_DECREASE_SIZE(VAR_2, 1)
	VAR_2->server_entry_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->server_entry_count; VAR_3++) {
		int VAR_12=0;
		VAR_6 = VAR_7;
		VAR_4=(u32)VAR_2->size;
		while (VAR_4) {
			ISOM_DECREASE_SIZE(VAR_2, 1)
			VAR_5[VAR_12] = gf_bs_read_u8(VAR_1);
			VAR_4--;
			if (!VAR_5[VAR_12]) {
				VAR_6 = VAR_11;
				break;
			}
			VAR_12++;
		}
		if (!VAR_6)
			return VAR_9;
		if (VAR_12) {
			gf_list_insert(VAR_2->server_entry_table, gf_strdup(VAR_5), VAR_3);
		}
	}

	ISOM_DECREASE_SIZE(VAR_2, 1)
	VAR_2->quality_entry_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->quality_entry_count; VAR_3++) {
		int VAR_12=0;
		VAR_6 = VAR_7;
		VAR_4=(u32)VAR_2->size;
		while (VAR_4) {
			ISOM_DECREASE_SIZE(VAR_2, 1)
			VAR_5[VAR_12] = gf_bs_read_u8(VAR_1);
			VAR_4--;
			if (!VAR_5[VAR_12]) {
				VAR_6 = VAR_11;
				break;
			}
			VAR_12++;
		}

		if (!VAR_6)
			return VAR_9;
		if (VAR_12) {
			gf_list_insert(VAR_2->quality_entry_table, gf_strdup(VAR_5), VAR_3);
		}
	}

	VAR_3=0;
	VAR_4=(u32)VAR_2->size;
	VAR_6 = VAR_7;
	while (VAR_4) {
		ISOM_DECREASE_SIZE(VAR_2, 1)
		VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
		VAR_4--;
		if (!VAR_5[VAR_3]) {
			VAR_6 = VAR_11;
			break;
		}
		VAR_3++;
	}
	if (!VAR_6)
		return VAR_9;
	if (VAR_3) {
		VAR_2->drm_data = gf_strdup(VAR_5);
	}

	VAR_3=0;
	VAR_4=(u32)VAR_2->size;
	VAR_6 = VAR_7;
	while (VAR_4) {
		ISOM_DECREASE_SIZE(VAR_2, 1)
		VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
		VAR_4--;
		if (!VAR_5[VAR_3]) {
			VAR_6 = VAR_11;
			break;
		}
		VAR_3++;
	}
	if (!VAR_6)
		return VAR_9;
	if (VAR_3) {
		VAR_2->meta_data = gf_strdup(VAR_5);
	}

	ISOM_DECREASE_SIZE(VAR_2, 1)
	VAR_2->segment_run_table_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->segment_run_table_count; VAR_3++) {
		GF_AdobeSegmentRunTableBox *VAR_13 = NULL;
		VAR_8 = gf_isom_box_parse((GF_Box **)&VAR_13, VAR_1);
		if (VAR_8) {
			if (VAR_13) gf_isom_box_del((GF_Box*)VAR_13);
			gf_free(VAR_5);
			return VAR_8;
		}
		gf_list_add(VAR_2->segment_run_table_entries, VAR_13);
	}

	ISOM_DECREASE_SIZE(VAR_2, 1)
	VAR_2->fragment_run_table_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->fragment_run_table_count; VAR_3++) {
		GF_AdobeFragmentRunTableBox *VAR_14 = NULL;
		VAR_8 = gf_isom_box_parse((GF_Box **)&VAR_14, VAR_1);
		if (VAR_8) {
			if (VAR_14) gf_isom_box_del((GF_Box*)VAR_14);
			gf_free(VAR_5);
			return VAR_8;
		}
		gf_list_add(VAR_2->fragment_run_table_entries, VAR_14);
	}

	gf_free(VAR_5);

	return VAR_15;
}",gpac/758135e91e623d7dfe7f6aaad7aeb3f791b7a4e5/box_code_adobe.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,7 @@
 	int i;
 	u32 tmp_strsize;
 	char *tmp_str;
+	Bool zfound=GF_FALSE;
 	GF_Err e;
 
 	ISOM_DECREASE_SIZE(ptr, 25)
@@ -27,10 +28,14 @@
 		ISOM_DECREASE_SIZE(ptr, 1)
 		tmp_str[i] = gf_bs_read_u8(bs);
 		tmp_strsize--;
-		if (!tmp_str[i])
+		if (!tmp_str[i]) {
+			zfound = GF_TRUE;
 			break;
+		}
 		i++;
 	}
+	if (!zfound)
+		return GF_ISOM_INVALID_FILE;
 	if (i) {
 		ptr->movie_identifier = gf_strdup(tmp_str);
 	}
@@ -39,15 +44,20 @@
 	ptr->server_entry_count = gf_bs_read_u8(bs);
 	for (i=0; i<ptr->server_entry_count; i++) {
 		int j=0;
+		zfound = GF_FALSE;
 		tmp_strsize=(u32)ptr->size;
 		while (tmp_strsize) {
 			ISOM_DECREASE_SIZE(ptr, 1)
 			tmp_str[j] = gf_bs_read_u8(bs);
 			tmp_strsize--;
-			if (!tmp_str[j])
+			if (!tmp_str[j]) {
+				zfound = GF_TRUE;
 				break;
+			}
 			j++;
 		}
+		if (!zfound)
+			return GF_ISOM_INVALID_FILE;
 		if (j) {
 			gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);
 		}
@@ -57,16 +67,21 @@
 	ptr->quality_entry_count = gf_bs_read_u8(bs);
 	for (i=0; i<ptr->quality_entry_count; i++) {
 		int j=0;
+		zfound = GF_FALSE;
 		tmp_strsize=(u32)ptr->size;
 		while (tmp_strsize) {
 			ISOM_DECREASE_SIZE(ptr, 1)
 			tmp_str[j] = gf_bs_read_u8(bs);
 			tmp_strsize--;
-			if (!tmp_str[j])
+			if (!tmp_str[j]) {
+				zfound = GF_TRUE;
 				break;
+			}
 			j++;
 		}
 
+		if (!zfound)
+			return GF_ISOM_INVALID_FILE;
 		if (j) {
 			gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);
 		}
@@ -74,28 +89,38 @@
 
 	i=0;
 	tmp_strsize=(u32)ptr->size;
+	zfound = GF_FALSE;
 	while (tmp_strsize) {
 		ISOM_DECREASE_SIZE(ptr, 1)
 		tmp_str[i] = gf_bs_read_u8(bs);
 		tmp_strsize--;
-		if (!tmp_str[i])
+		if (!tmp_str[i]) {
+			zfound = GF_TRUE;
 			break;
+		}
 		i++;
 	}
+	if (!zfound)
+		return GF_ISOM_INVALID_FILE;
 	if (i) {
 		ptr->drm_data = gf_strdup(tmp_str);
 	}
 
 	i=0;
 	tmp_strsize=(u32)ptr->size;
+	zfound = GF_FALSE;
 	while (tmp_strsize) {
 		ISOM_DECREASE_SIZE(ptr, 1)
 		tmp_str[i] = gf_bs_read_u8(bs);
 		tmp_strsize--;
-		if (!tmp_str[i])
+		if (!tmp_str[i]) {
+			zfound = GF_TRUE;
 			break;
+		}
 		i++;
 	}
+	if (!zfound)
+		return GF_ISOM_INVALID_FILE;
 	if (i) {
 		ptr->meta_data = gf_strdup(tmp_str);
 	}","{'deleted_lines': ['\t\tif (!tmp_str[i])', '\t\t\tif (!tmp_str[j])', '\t\t\tif (!tmp_str[j])', '\t\tif (!tmp_str[i])', '\t\tif (!tmp_str[i])'], 'added_lines': ['\tBool zfound=GF_FALSE;', '\t\tif (!tmp_str[i]) {', '\t\t\tzfound = GF_TRUE;', '\t\t}', '\tif (!zfound)', '\t\treturn GF_ISOM_INVALID_FILE;', '\t\tzfound = GF_FALSE;', '\t\t\tif (!tmp_str[j]) {', '\t\t\t\tzfound = GF_TRUE;', '\t\t\t}', '\t\tif (!zfound)', '\t\t\treturn GF_ISOM_INVALID_FILE;', '\t\tzfound = GF_FALSE;', '\t\t\tif (!tmp_str[j]) {', '\t\t\t\tzfound = GF_TRUE;', '\t\t\t}', '\t\tif (!zfound)', '\t\t\treturn GF_ISOM_INVALID_FILE;', '\tzfound = GF_FALSE;', '\t\tif (!tmp_str[i]) {', '\t\t\tzfound = GF_TRUE;', '\t\t}', '\tif (!zfound)', '\t\treturn GF_ISOM_INVALID_FILE;', '\tzfound = GF_FALSE;', '\t\tif (!tmp_str[i]) {', '\t\t\tzfound = GF_TRUE;', '\t\t}', '\tif (!zfound)', '\t\treturn GF_ISOM_INVALID_FILE;']}",True,Buffer overflow in the abst_box_read function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.,7.8,HIGH,2,test,2021-04-08T08:07:35Z,3
CVE-2021-38209,['CWE-203'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,torvalds/linux,"netfilter: conntrack: Make global sysctls readonly in non-init netns

These sysctls point to global variables:
- NF_SYSCTL_CT_MAX (&nf_conntrack_max)
- NF_SYSCTL_CT_EXPECT_MAX (&nf_ct_expect_max)
- NF_SYSCTL_CT_BUCKETS (&nf_conntrack_htable_size_user)

Because their data pointers are not updated to point to per-netns
structures, they must be marked read-only in a non-init_net ns.
Otherwise, changes in any net namespace are reflected in (leaked into)
all other net namespaces. This problem has existed since the
introduction of net namespaces.

The current logic marks them read-only only if the net namespace is
owned by an unprivileged user (other than init_user_ns).

Commit d0febd81ae77 (""netfilter: conntrack: re-visit sysctls in
unprivileged namespaces"") ""exposes all sysctls even if the namespace is
unpriviliged."" Since we need to mark them readonly in any case, we can
forego the unprivileged user check altogether.

Fixes: d0febd81ae77 (""netfilter: conntrack: re-visit sysctls in unprivileged namespaces"")
Signed-off-by: Jonathon Reinhart <Jonathon.Reinhart@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",2671fa4dc0109d3fb581bc3078fdf17b5d9080f6,https://github.com/torvalds/linux/commit/2671fa4dc0109d3fb581bc3078fdf17b5d9080f6,net/netfilter/nf_conntrack_standalone.c,nf_conntrack_standalone_init_sysctl,"static int nf_conntrack_standalone_init_sysctl(struct net *net)
{
struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
struct nf_udp_net *un = nf_udp_pernet(net);
struct ctl_table *table;
BUILD_BUG_ON(ARRAY_SIZE(nf_ct_sysctl_table) != NF_SYSCTL_CT_LAST_SYSCTL);
table = kmemdup(nf_ct_sysctl_table, sizeof(nf_ct_sysctl_table),
GFP_KERNEL);
if (!table)
return -ENOMEM;
table[NF_SYSCTL_CT_COUNT].data = &net->ct.count;
table[NF_SYSCTL_CT_CHECKSUM].data = &net->ct.sysctl_checksum;
table[NF_SYSCTL_CT_LOG_INVALID].data = &net->ct.sysctl_log_invalid;
table[NF_SYSCTL_CT_ACCT].data = &net->ct.sysctl_acct;
table[NF_SYSCTL_CT_HELPER].data = &net->ct.sysctl_auto_assign_helper;
#ifdef CONFIG_NF_CONNTRACK_EVENTS
table[NF_SYSCTL_CT_EVENTS].data = &net->ct.sysctl_events;
#endif
#ifdef CONFIG_NF_CONNTRACK_TIMESTAMP
table[NF_SYSCTL_CT_TIMESTAMP].data = &net->ct.sysctl_tstamp;
#endif
table[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC].data = &nf_generic_pernet(net)->timeout;
table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP].data = &nf_icmp_pernet(net)->timeout;
table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6].data = &nf_icmpv6_pernet(net)->timeout;
table[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP].data = &un->timeouts[UDP_CT_UNREPLIED];
table[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_STREAM].data = &un->timeouts[UDP_CT_REPLIED];
nf_conntrack_standalone_init_tcp_sysctl(net, table);
nf_conntrack_standalone_init_sctp_sysctl(net, table);
nf_conntrack_standalone_init_dccp_sysctl(net, table);
nf_conntrack_standalone_init_gre_sysctl(net, table);
if (net->user_ns != &init_user_ns) {
table[NF_SYSCTL_CT_MAX].mode = 0444;
table[NF_SYSCTL_CT_EXPECT_MAX].mode = 0444;
table[NF_SYSCTL_CT_HELPER].mode = 0444;
#ifdef CONFIG_NF_CONNTRACK_EVENTS
table[NF_SYSCTL_CT_EVENTS].mode = 0444;
#endif
table[NF_SYSCTL_CT_BUCKETS].mode = 0444;
} else if (!net_eq(&init_net, net)) {
table[NF_SYSCTL_CT_BUCKETS].mode = 0444;
}
cnet->sysctl_header = register_net_sysctl(net, ""net/netfilter"", table);
if (!cnet->sysctl_header)
goto out_unregister_netfilter;
return 0;
out_unregister_netfilter:
kfree(table);
return -ENOMEM;
}","static int nf_conntrack_standalone_init_sysctl(struct net *net)
{
struct nf_conntrack_net *VAR_0 = net_generic(net, VAR_1);
struct nf_udp_net *VAR_2 = nf_udp_pernet(net);
struct ctl_table *VAR_3;
BUILD_BUG_ON(ARRAY_SIZE(VAR_4) != VAR_5);
VAR_3 = kmemdup(VAR_4, sizeof(VAR_4),
VAR_6);
if (!VAR_3)
return -VAR_7;
VAR_3[VAR_8].data = &net->ct.count;
VAR_3[VAR_9].data = &net->ct.sysctl_checksum;
VAR_3[VAR_10].data = &net->ct.sysctl_log_invalid;
VAR_3[VAR_11].data = &net->ct.sysctl_acct;
VAR_3[VAR_12].data = &net->ct.sysctl_auto_assign_helper;
#ifdef VAR_13
VAR_3[VAR_14].data = &net->ct.sysctl_events;
#endif
#ifdef VAR_15
VAR_3[VAR_16].data = &net->ct.sysctl_tstamp;
#endif
VAR_3[VAR_17].data = &nf_generic_pernet(net)->timeout;
VAR_3[VAR_18].data = &nf_icmp_pernet(net)->timeout;
VAR_3[VAR_19].data = &nf_icmpv6_pernet(net)->timeout;
VAR_3[VAR_20].data = &VAR_2->timeouts[VAR_21];
VAR_3[VAR_22].data = &VAR_2->timeouts[VAR_23];
nf_conntrack_standalone_init_tcp_sysctl(net, VAR_3);
nf_conntrack_standalone_init_sctp_sysctl(net, VAR_3);
nf_conntrack_standalone_init_dccp_sysctl(net, VAR_3);
nf_conntrack_standalone_init_gre_sysctl(net, VAR_3);
if (net->user_ns != &VAR_24) {
VAR_3[VAR_25].mode = 0444;
VAR_3[VAR_26].mode = 0444;
VAR_3[VAR_12].mode = 0444;
#ifdef VAR_13
VAR_3[VAR_14].mode = 0444;
#endif
VAR_3[VAR_27].mode = 0444;
} else if (!net_eq(&VAR_28, net)) {
VAR_3[VAR_27].mode = 0444;
}
VAR_0->sysctl_header = register_net_sysctl(net, ""net/netfilter"", VAR_3);
if (!VAR_0->sysctl_header)
goto out_unregister_netfilter;
return 0;
out_unregister_netfilter:
kfree(VAR_3);
return -VAR_7;
}",torvalds/linux/2671fa4dc0109d3fb581bc3078fdf17b5d9080f6/nf_conntrack_standalone.c/vul/before/0.json,"static int nf_conntrack_standalone_init_sysctl(struct net *net)
{
	struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
	struct nf_udp_net *un = nf_udp_pernet(net);
	struct ctl_table *table;

	BUILD_BUG_ON(ARRAY_SIZE(nf_ct_sysctl_table) != NF_SYSCTL_CT_LAST_SYSCTL);

	table = kmemdup(nf_ct_sysctl_table, sizeof(nf_ct_sysctl_table),
			GFP_KERNEL);
	if (!table)
		return -ENOMEM;

	table[NF_SYSCTL_CT_COUNT].data = &net->ct.count;
	table[NF_SYSCTL_CT_CHECKSUM].data = &net->ct.sysctl_checksum;
	table[NF_SYSCTL_CT_LOG_INVALID].data = &net->ct.sysctl_log_invalid;
	table[NF_SYSCTL_CT_ACCT].data = &net->ct.sysctl_acct;
	table[NF_SYSCTL_CT_HELPER].data = &net->ct.sysctl_auto_assign_helper;
#ifdef CONFIG_NF_CONNTRACK_EVENTS
	table[NF_SYSCTL_CT_EVENTS].data = &net->ct.sysctl_events;
#endif
#ifdef CONFIG_NF_CONNTRACK_TIMESTAMP
	table[NF_SYSCTL_CT_TIMESTAMP].data = &net->ct.sysctl_tstamp;
#endif
	table[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC].data = &nf_generic_pernet(net)->timeout;
	table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP].data = &nf_icmp_pernet(net)->timeout;
	table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6].data = &nf_icmpv6_pernet(net)->timeout;
	table[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP].data = &un->timeouts[UDP_CT_UNREPLIED];
	table[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_STREAM].data = &un->timeouts[UDP_CT_REPLIED];

	nf_conntrack_standalone_init_tcp_sysctl(net, table);
	nf_conntrack_standalone_init_sctp_sysctl(net, table);
	nf_conntrack_standalone_init_dccp_sysctl(net, table);
	nf_conntrack_standalone_init_gre_sysctl(net, table);

	/* Don't allow non-init_net ns to alter global sysctls */
	if (!net_eq(&init_net, net)) {
		table[NF_SYSCTL_CT_MAX].mode = 0444;
		table[NF_SYSCTL_CT_EXPECT_MAX].mode = 0444;
		table[NF_SYSCTL_CT_BUCKETS].mode = 0444;
	}

	cnet->sysctl_header = register_net_sysctl(net, ""net/netfilter"", table);
	if (!cnet->sysctl_header)
		goto out_unregister_netfilter;

	return 0;

out_unregister_netfilter:
	kfree(table);
	return -ENOMEM;
}","static int nf_conntrack_standalone_init_sysctl(struct net *net)
{
	struct nf_conntrack_net *VAR_0 = net_generic(net, VAR_1);
	struct nf_udp_net *VAR_2 = nf_udp_pernet(net);
	struct ctl_table *VAR_3;

	BUILD_BUG_ON(ARRAY_SIZE(VAR_4) != VAR_5);

	VAR_3 = kmemdup(VAR_4, sizeof(VAR_4),
			VAR_6);
	if (!VAR_3)
		return -VAR_7;

	VAR_3[VAR_8].data = &net->ct.count;
	VAR_3[VAR_9].data = &net->ct.sysctl_checksum;
	VAR_3[VAR_10].data = &net->ct.sysctl_log_invalid;
	VAR_3[VAR_11].data = &net->ct.sysctl_acct;
	VAR_3[VAR_12].data = &net->ct.sysctl_auto_assign_helper;
#ifdef VAR_13
	VAR_3[VAR_14].data = &net->ct.sysctl_events;
#endif
#ifdef VAR_15
	VAR_3[VAR_16].data = &net->ct.sysctl_tstamp;
#endif
	VAR_3[VAR_17].data = &nf_generic_pernet(net)->timeout;
	VAR_3[VAR_18].data = &nf_icmp_pernet(net)->timeout;
	VAR_3[VAR_19].data = &nf_icmpv6_pernet(net)->timeout;
	VAR_3[VAR_20].data = &VAR_2->timeouts[VAR_21];
	VAR_3[VAR_22].data = &VAR_2->timeouts[VAR_23];

	nf_conntrack_standalone_init_tcp_sysctl(net, VAR_3);
	nf_conntrack_standalone_init_sctp_sysctl(net, VAR_3);
	nf_conntrack_standalone_init_dccp_sysctl(net, VAR_3);
	nf_conntrack_standalone_init_gre_sysctl(net, VAR_3);

	/* COMMENT_0 */
	if (!net_eq(&VAR_24, net)) {
		VAR_3[VAR_25].mode = 0444;
		VAR_3[VAR_26].mode = 0444;
		VAR_3[VAR_27].mode = 0444;
	}

	VAR_0->sysctl_header = register_net_sysctl(net, ""net/netfilter"", VAR_3);
	if (!VAR_0->sysctl_header)
		goto out_unregister_netfilter;

	return 0;

out_unregister_netfilter:
	kfree(VAR_3);
	return -VAR_7;
}",torvalds/linux/2671fa4dc0109d3fb581bc3078fdf17b5d9080f6/nf_conntrack_standalone.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -33,16 +33,10 @@
 	nf_conntrack_standalone_init_dccp_sysctl(net, table);
 	nf_conntrack_standalone_init_gre_sysctl(net, table);
 
-	/* Don't allow unprivileged users to alter certain sysctls */
-	if (net->user_ns != &init_user_ns) {
+	/* Don't allow non-init_net ns to alter global sysctls */
+	if (!net_eq(&init_net, net)) {
 		table[NF_SYSCTL_CT_MAX].mode = 0444;
 		table[NF_SYSCTL_CT_EXPECT_MAX].mode = 0444;
-		table[NF_SYSCTL_CT_HELPER].mode = 0444;
-#ifdef CONFIG_NF_CONNTRACK_EVENTS
-		table[NF_SYSCTL_CT_EVENTS].mode = 0444;
-#endif
-		table[NF_SYSCTL_CT_BUCKETS].mode = 0444;
-	} else if (!net_eq(&init_net, net)) {
 		table[NF_SYSCTL_CT_BUCKETS].mode = 0444;
 	}
 ","{'deleted_lines': [""\t/* Don't allow unprivileged users to alter certain sysctls */"", '\tif (net->user_ns != &init_user_ns) {', '\t\ttable[NF_SYSCTL_CT_HELPER].mode = 0444;', '#ifdef CONFIG_NF_CONNTRACK_EVENTS', '\t\ttable[NF_SYSCTL_CT_EVENTS].mode = 0444;', '#endif', '\t\ttable[NF_SYSCTL_CT_BUCKETS].mode = 0444;', '\t} else if (!net_eq(&init_net, net)) {'], 'added_lines': [""\t/* Don't allow non-init_net ns to alter global sysctls */"", '\tif (!net_eq(&init_net, net)) {']}",True,"net/netfilter/nf_conntrack_standalone.c in the Linux kernel before 5.12.2 allows observation of changes in any net namespace because these changes are leaked into all other net namespaces. This is related to the NF_SYSCTL_CT_MAX, NF_SYSCTL_CT_EXPECT_MAX, and NF_SYSCTL_CT_BUCKETS sysctls.",3.3,LOW,0,test,2021-04-12T04:24:53Z,3
CVE-2021-29512,['CWE-787'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Fix an invalid address vulnerability in `tf.raw_ops.RaggedBincount`.

PiperOrigin-RevId: 368293153
Change-Id: I4b4e493d3fd05e7dc55a55de3a041a80a4f275c3",eebb96c2830d48597d055d247c0e9aebaea94cd5,https://github.com/tensorflow/tensorflow/commit/eebb96c2830d48597d055d247c0e9aebaea94cd5,tensorflow/core/kernels/bincount_op.cc,Compute,"void Compute(OpKernelContext* ctx) override {
const auto splits = ctx->input(0).flat<int64>();
const auto values = ctx->input(1).flat<Tidx>();
const Tensor& size_t = ctx->input(2);
const auto weights = ctx->input(3).flat<T>();
const int64 weights_size = weights.size();
Tidx size = size_t.scalar<Tidx>()();
OP_REQUIRES(
ctx, size >= 0,
errors::InvalidArgument(""size ("", size, "") must be non-negative""));
int num_rows = splits.size() - 1;
int num_values = values.size();
int batch_idx = 0;
Tensor* out_t;
OP_REQUIRES_OK(
ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));
functor::SetZeroFunctor<Device, T> fill;
fill(ctx->eigen_device<Device>(), out_t->flat<T>());
const auto out = out_t->matrix<T>();
for (int idx = 0; idx < num_values; ++idx) {
while (idx >= splits(batch_idx)) {
batch_idx++;
}
Tidx bin = values(idx);
OP_REQUIRES(ctx, bin >= 0,
errors::InvalidArgument(""Input must be non-negative""));
if (bin < size) {
if (binary_output_) {
out(batch_idx - 1, bin) = T(1);
} else {
T value = (weights_size > 0) ? weights(idx) : T(1);
out(batch_idx - 1, bin) += value;
}
}
}
}","void Compute(OpKernelContext* VAR_0) override {
const auto VAR_1 = VAR_0->input(0).flat<int64>();
const auto VAR_2 = VAR_0->input(1).flat<Tidx>();
const Tensor& VAR_3 = VAR_0->input(2);
const auto VAR_4 = VAR_0->input(3).flat<T>();
const int64 VAR_5 = VAR_4.size();
Tidx VAR_6 = size_t.scalar<Tidx>()();
OP_REQUIRES(
VAR_0, VAR_6 >= 0,
errors::InvalidArgument(""size ("", VAR_6, "") must be non-negative""));
int VAR_7 = VAR_1.size() - 1;
int VAR_8 = VAR_2.size();
int VAR_9 = 0;
Tensor* VAR_10;
OP_REQUIRES_OK(
VAR_0, VAR_0->allocate_output(0, TensorShape({VAR_7, VAR_6}), &VAR_10));
functor::SetZeroFunctor<Device, T> VAR_11;
VAR_11(VAR_0->eigen_device<Device>(), VAR_10->flat<T>());
const auto VAR_12 = VAR_10->matrix<T>();
for (int VAR_13 = 0; VAR_13 < VAR_8; ++VAR_13) {
while (VAR_13 >= VAR_1(VAR_9)) {
VAR_9++;
}
Tidx VAR_14 = VAR_2(VAR_13);
OP_REQUIRES(VAR_0, VAR_14 >= 0,
errors::InvalidArgument(""Input must be non-negative""));
if (VAR_14 < VAR_6) {
if (VAR_15) {
VAR_12(VAR_9 - 1, VAR_14) = T(1);
} else {
T VAR_16 = (VAR_5 > 0) ? VAR_4(VAR_13) : T(1);
VAR_12(VAR_9 - 1, VAR_14) += VAR_16;
}
}
}
}",,"void Compute(OpKernelContext* ctx) override {
    const auto splits = ctx->input(0).flat<int64>();
    const auto values = ctx->input(1).flat<Tidx>();
    const Tensor& size_t = ctx->input(2);
    const auto weights = ctx->input(3).flat<T>();
    const int64 weights_size = weights.size();

    Tidx size = size_t.scalar<Tidx>()();
    OP_REQUIRES(
        ctx, size >= 0,
        errors::InvalidArgument(""size ("", size, "") must be non-negative""));

    int num_rows = splits.size() - 1;
    int num_values = values.size();
    int batch_idx = 0;

    OP_REQUIRES(ctx, splits(0) == 0,
                errors::InvalidArgument(""Splits must start with 0, not with "",
                                        splits(0)));

    OP_REQUIRES(ctx, splits(num_rows) == num_values,
                errors::InvalidArgument(
                    ""Splits must end with the number of values, got "",
                    splits(num_rows), "" instead of "", num_values));

    Tensor* out_t;
    OP_REQUIRES_OK(
        ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));
    functor::SetZeroFunctor<Device, T> fill;
    fill(ctx->eigen_device<Device>(), out_t->flat<T>());
    const auto out = out_t->matrix<T>();

    for (int idx = 0; idx < num_values; ++idx) {
      while (idx >= splits(batch_idx)) {
        batch_idx++;
      }
      Tidx bin = values(idx);
      OP_REQUIRES(ctx, bin >= 0,
                  errors::InvalidArgument(""Input must be non-negative""));
      if (bin < size) {
        if (binary_output_) {
          out(batch_idx - 1, bin) = T(1);
        } else {
          T value = (weights_size > 0) ? weights(idx) : T(1);
          out(batch_idx - 1, bin) += value;
        }
      }
    }
  }","void Compute(OpKernelContext* VAR_0) override {
    const auto VAR_1 = VAR_0->input(0).flat<int64>();
    const auto VAR_2 = VAR_0->input(1).flat<Tidx>();
    const Tensor& VAR_3 = VAR_0->input(2);
    const auto VAR_4 = VAR_0->input(3).flat<T>();
    const int64 VAR_5 = VAR_4.size();

    Tidx VAR_6 = size_t.scalar<Tidx>()();
    OP_REQUIRES(
        VAR_0, VAR_6 >= 0,
        errors::InvalidArgument(""size ("", VAR_6, "") must be non-negative""));

    int VAR_7 = VAR_1.size() - 1;
    int VAR_8 = VAR_2.size();
    int VAR_9 = 0;

    OP_REQUIRES(VAR_0, VAR_1(0) == 0,
                errors::InvalidArgument(""Splits must start with 0, not with "",
                                        VAR_1(0)));

    OP_REQUIRES(VAR_0, VAR_1(VAR_7) == VAR_8,
                errors::InvalidArgument(
                    ""Splits must end with the number of values, got "",
                    VAR_1(VAR_7), "" instead of "", VAR_8));

    Tensor* VAR_10;
    OP_REQUIRES_OK(
        VAR_0, VAR_0->allocate_output(0, TensorShape({VAR_7, VAR_6}), &VAR_10));
    functor::SetZeroFunctor<Device, T> VAR_11;
    VAR_11(VAR_0->eigen_device<Device>(), VAR_10->flat<T>());
    const auto VAR_12 = VAR_10->matrix<T>();

    for (int VAR_13 = 0; VAR_13 < VAR_8; ++VAR_13) {
      while (VAR_13 >= VAR_1(VAR_9)) {
        VAR_9++;
      }
      Tidx VAR_14 = VAR_2(VAR_13);
      OP_REQUIRES(VAR_0, VAR_14 >= 0,
                  errors::InvalidArgument(""Input must be non-negative""));
      if (VAR_14 < VAR_6) {
        if (VAR_15) {
          VAR_12(VAR_9 - 1, VAR_14) = T(1);
        } else {
          T VAR_16 = (VAR_5 > 0) ? VAR_4(VAR_13) : T(1);
          VAR_12(VAR_9 - 1, VAR_14) += VAR_16;
        }
      }
    }
  }",,"--- func_before
+++ func_after
@@ -13,6 +13,15 @@
     int num_rows = splits.size() - 1;
     int num_values = values.size();
     int batch_idx = 0;
+
+    OP_REQUIRES(ctx, splits(0) == 0,
+                errors::InvalidArgument(""Splits must start with 0, not with "",
+                                        splits(0)));
+
+    OP_REQUIRES(ctx, splits(num_rows) == num_values,
+                errors::InvalidArgument(
+                    ""Splits must end with the number of values, got "",
+                    splits(num_rows), "" instead of "", num_values));
 
     Tensor* out_t;
     OP_REQUIRES_OK(","{'deleted_lines': [], 'added_lines': ['', '    OP_REQUIRES(ctx, splits(0) == 0,', '                errors::InvalidArgument(""Splits must start with 0, not with "",', '                                        splits(0)));', '', '    OP_REQUIRES(ctx, splits(num_rows) == num_values,', '                errors::InvalidArgument(', '                    ""Splits must end with the number of values, got "",', '                    splits(num_rows), "" instead of "", num_values));']}",True,"TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L433). Before the `for` loop, `batch_idx` is set to 0. The user controls the `splits` array, making it contain only one element, 0. Thus, the code in the `while` loop would increment `batch_idx` and then try to read `splits(1)`, which is outside of bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.",2.5,LOW,0,test,2021-04-13T21:18:51Z,3
CVE-2021-29515,['CWE-476'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Validate `MatrixDiagV{2,3}` arguments to prevent breakage.

PiperOrigin-RevId: 369056033
Change-Id: Ic2018c297d3dd6f252dc1dd3667f1ed5cb1eaa42",a7116dd3913c4a4afd2a3a938573aa7c785fdfc6,https://github.com/tensorflow/tensorflow/commit/a7116dd3913c4a4afd2a3a938573aa7c785fdfc6,tensorflow/core/kernels/linalg/matrix_diag_op.cc,Compute,"void Compute(OpKernelContext* context) override {
const Tensor& diagonal = context->input(0);
int32 lower_diag_index = 0;
int32 upper_diag_index = 0;
int32 num_rows = -1;
int32 num_cols = -1;
T padding_value(0);
if (context->num_inputs() > kNumV1Inputs) {
auto& diag_index = context->input(1);
OP_REQUIRES(context,
TensorShapeUtils::IsScalar(diag_index.shape()) ||
TensorShapeUtils::IsVector(diag_index.shape()),
errors::InvalidArgument(
""diag_index must be a scalar or vector, received shape: "",
diag_index.shape().DebugString()));
lower_diag_index = diag_index.flat<int32>()(0);
upper_diag_index = lower_diag_index;
if (TensorShapeUtils::IsVector(diag_index.shape())) {
auto diag_index_size = diag_index.dim_size(0);
OP_REQUIRES(
context, 0 < diag_index_size && diag_index_size <= 2,
errors::InvalidArgument(
""diag_index must have only one or two elements, received "",
diag_index_size, "" elements.""));
if (diag_index_size > 1) {
upper_diag_index = diag_index.flat<int32>()(1);
}
}
num_rows = context->input(2).flat<int32>()(0);
num_cols = context->input(3).flat<int32>()(0);
padding_value = context->input(4).flat<T>()(0);
}
const TensorShape& diagonal_shape = diagonal.shape();
const int diag_rank = diagonal_shape.dims();
const Eigen::Index num_diags = upper_diag_index - lower_diag_index + 1;
OP_REQUIRES(context, TensorShapeUtils::IsVectorOrHigher(diagonal_shape),
errors::InvalidArgument(
""diagonal must be at least 1-dim, received shape: "",
diagonal.shape().DebugString()));
OP_REQUIRES(
context, lower_diag_index <= upper_diag_index,
errors::InvalidArgument(
""lower_diag_index must not be larger than upper_diag_index: "",
lower_diag_index, "" > "", upper_diag_index));
OP_REQUIRES(context,
lower_diag_index == upper_diag_index ||
diagonal_shape.dim_size(diag_rank - 2) == num_diags,
errors::InvalidArgument(
""The number of diagonals provided in the input does not ""
""match the lower_diag_index and upper_diag_index range.""));
const Eigen::Index max_diag_len = diagonal_shape.dim_size(diag_rank - 1);
const int32 min_num_rows = max_diag_len - std::min(upper_diag_index, 0);
const int32 min_num_cols = max_diag_len + std::max(lower_diag_index, 0);
OP_REQUIRES(context, num_rows == -1 || num_rows >= min_num_rows,
errors::InvalidArgument(""The number of rows is too small.""));
OP_REQUIRES(context, num_cols == -1 || num_cols >= min_num_cols,
errors::InvalidArgument(""The number of columns is too small.""));
if (num_rows == -1 && num_cols == -1) {
num_rows = std::max(min_num_rows, min_num_cols);
num_cols = num_rows;
} else if (num_rows == -1) {
num_rows = min_num_rows;
} else if (num_cols == -1) {
num_cols = min_num_cols;
}
OP_REQUIRES(context, num_rows == min_num_rows || num_cols == min_num_cols,
errors::InvalidArgument(
""The number of rows or columns is not consistent with ""
""the specified d_lower, d_upper, and diagonal.""));
TensorShape output_shape = diagonal_shape;
if (num_diags == 1) {        output_shape.set_dim(diag_rank - 1, num_rows);
output_shape.AddDim(num_cols);
} else {        output_shape.set_dim(diag_rank - 2, num_rows);
output_shape.set_dim(diag_rank - 1, num_cols);
}
Tensor* output = nullptr;
OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));
auto output_reshaped = output->flat_inner_dims<T, 3>();
auto diag_reshaped = diagonal.flat<T>();
functor::MatrixDiag<Device, T>::Compute(
context, context->eigen_device<Device>(), diag_reshaped,
output_reshaped, lower_diag_index, upper_diag_index, max_diag_len,
padding_value, left_align_superdiagonal_, left_align_subdiagonal_);
}","void Compute(OpKernelContext* VAR_0) override {
const Tensor& VAR_1 = VAR_0->input(0);
int32 VAR_2 = 0;
int32 VAR_3 = 0;
int32 VAR_4 = -1;
int32 VAR_5 = -1;
T VAR_6(0);
if (VAR_0->num_inputs() > VAR_7) {
auto& VAR_8 = VAR_0->input(1);
OP_REQUIRES(VAR_0,
TensorShapeUtils::IsScalar(VAR_8.shape()) ||
TensorShapeUtils::IsVector(VAR_8.shape()),
errors::InvalidArgument(
""diag_index must be a scalar or vector, received shape: "",
VAR_8.shape().DebugString()));
VAR_2 = VAR_8.flat<int32>()(0);
VAR_3 = VAR_2;
if (TensorShapeUtils::IsVector(VAR_8.shape())) {
auto VAR_9 = VAR_8.dim_size(0);
OP_REQUIRES(
VAR_0, 0 < VAR_9 && VAR_9 <= 2,
errors::InvalidArgument(
""diag_index must have only one or two elements, received "",
VAR_9, "" elements.""));
if (VAR_9 > 1) {
VAR_3 = VAR_8.flat<int32>()(1);
}
}
VAR_4 = VAR_0->input(2).flat<int32>()(0);
VAR_5 = VAR_0->input(3).flat<int32>()(0);
VAR_6 = VAR_0->input(4).flat<T>()(0);
}
const TensorShape& VAR_10 = VAR_1.shape();
const int VAR_11 = VAR_10.dims();
const Eigen::Index VAR_12 = VAR_3 - VAR_2 + 1;
OP_REQUIRES(VAR_0, TensorShapeUtils::IsVectorOrHigher(VAR_10),
errors::InvalidArgument(
""diagonal must be at least 1-dim, received shape: "",
VAR_1.shape().DebugString()));
OP_REQUIRES(
VAR_0, VAR_2 <= VAR_3,
errors::InvalidArgument(
""lower_diag_index must not be larger than upper_diag_index: "",
VAR_2, "" > "", VAR_3));
OP_REQUIRES(VAR_0,
VAR_2 == VAR_3 ||
VAR_10.dim_size(VAR_11 - 2) == VAR_12,
errors::InvalidArgument(
""The number of diagonals provided in the input does not ""
""match the lower_diag_index and upper_diag_index range.""));
const Eigen::Index VAR_13 = VAR_10.dim_size(VAR_11 - 1);
const int32 VAR_14 = VAR_13 - std::min(VAR_3, 0);
const int32 VAR_15 = VAR_13 + std::max(VAR_2, 0);
OP_REQUIRES(VAR_0, VAR_4 == -1 || VAR_4 >= VAR_14,
errors::InvalidArgument(""The number of rows is too small.""));
OP_REQUIRES(VAR_0, VAR_5 == -1 || VAR_5 >= VAR_15,
errors::InvalidArgument(""The number of columns is too small.""));
if (VAR_4 == -1 && VAR_5 == -1) {
VAR_4 = std::max(VAR_14, VAR_15);
VAR_5 = VAR_4;
} else if (VAR_4 == -1) {
VAR_4 = VAR_14;
} else if (VAR_5 == -1) {
VAR_5 = VAR_15;
}
OP_REQUIRES(VAR_0, VAR_4 == VAR_14 || VAR_5 == VAR_15,
errors::InvalidArgument(
""The number of rows or columns is not consistent with ""
""the specified d_lower, d_upper, and diagonal.""));
TensorShape VAR_16 = VAR_10;
if (VAR_12 == 1) {  
VAR_16.set_dim(VAR_11 - 1, VAR_4);
VAR_16.AddDim(VAR_5);
} else {  
VAR_16.set_dim(VAR_11 - 2, VAR_4);
VAR_16.set_dim(VAR_11 - 1, VAR_5);
}
Tensor* VAR_17 = nullptr;
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(0, VAR_16, &VAR_17));
auto VAR_18 = VAR_17->flat_inner_dims<T, 3>();
auto VAR_19 = VAR_1.flat<T>();
functor::MatrixDiag<Device, T>::Compute(
VAR_0, VAR_0->eigen_device<Device>(), VAR_19,
VAR_18, VAR_2, VAR_3, VAR_13,
VAR_6, VAR_20, VAR_21);
}",,"void Compute(OpKernelContext* context) override {
    const Tensor& diagonal = context->input(0);

    // MatrixDiag and MatrixDiagV2 both use this OpKernel. MatrixDiag only has
    // one input, so we have to check the number of inputs before reading
    // additional parameters in MatrixDiagV2.
    int32 lower_diag_index = 0;
    int32 upper_diag_index = 0;
    int32 num_rows = -1;
    int32 num_cols = -1;
    T padding_value(0);

    // MatrixDiagOpV2-specific.
    if (context->num_inputs() > kNumV1Inputs) {
      auto& diag_index = context->input(1);
      OP_REQUIRES(context,
                  TensorShapeUtils::IsScalar(diag_index.shape()) ||
                      TensorShapeUtils::IsVector(diag_index.shape()),
                  errors::InvalidArgument(
                      ""diag_index must be a scalar or vector, received shape: "",
                      diag_index.shape().DebugString()));
      lower_diag_index = diag_index.flat<int32>()(0);
      upper_diag_index = lower_diag_index;
      if (TensorShapeUtils::IsVector(diag_index.shape())) {
        auto diag_index_size = diag_index.dim_size(0);
        OP_REQUIRES(
            context, 0 < diag_index_size && diag_index_size <= 2,
            errors::InvalidArgument(
                ""diag_index must have only one or two elements, received "",
                diag_index_size, "" elements.""));
        if (diag_index_size > 1) {
          upper_diag_index = diag_index.flat<int32>()(1);
        }
      }

      auto& num_rows_tensor = context->input(2);
      OP_REQUIRES(context, TensorShapeUtils::IsScalar(num_rows_tensor.shape()),
                  errors::InvalidArgument(""num_rows must be a scalar""));
      num_rows = num_rows_tensor.flat<int32>()(0);

      auto& num_cols_tensor = context->input(3);
      OP_REQUIRES(context, TensorShapeUtils::IsScalar(num_cols_tensor.shape()),
                  errors::InvalidArgument(""num_cols must be a scalar""));
      num_cols = num_cols_tensor.flat<int32>()(0);

      auto& padding_value_tensor = context->input(4);
      OP_REQUIRES(context,
                  TensorShapeUtils::IsScalar(padding_value_tensor.shape()),
                  errors::InvalidArgument(""padding_value must be a scalar""));
      padding_value = padding_value_tensor.flat<T>()(0);
    }

    // Size validations.
    const TensorShape& diagonal_shape = diagonal.shape();
    const int diag_rank = diagonal_shape.dims();
    const Eigen::Index num_diags = upper_diag_index - lower_diag_index + 1;
    OP_REQUIRES(context, TensorShapeUtils::IsVectorOrHigher(diagonal_shape),
                errors::InvalidArgument(
                    ""diagonal must be at least 1-dim, received shape: "",
                    diagonal.shape().DebugString()));
    OP_REQUIRES(
        context, lower_diag_index <= upper_diag_index,
        errors::InvalidArgument(
            ""lower_diag_index must not be larger than upper_diag_index: "",
            lower_diag_index, "" > "", upper_diag_index));
    OP_REQUIRES(context,
                lower_diag_index == upper_diag_index ||
                    diagonal_shape.dim_size(diag_rank - 2) == num_diags,
                errors::InvalidArgument(
                    ""The number of diagonals provided in the input does not ""
                    ""match the lower_diag_index and upper_diag_index range.""));

    const Eigen::Index max_diag_len = diagonal_shape.dim_size(diag_rank - 1);
    const int32 min_num_rows = max_diag_len - std::min(upper_diag_index, 0);
    const int32 min_num_cols = max_diag_len + std::max(lower_diag_index, 0);
    OP_REQUIRES(context, num_rows == -1 || num_rows >= min_num_rows,
                errors::InvalidArgument(""The number of rows is too small.""));
    OP_REQUIRES(context, num_cols == -1 || num_cols >= min_num_cols,
                errors::InvalidArgument(""The number of columns is too small.""));

    // If both num_rows and num_cols are unknown, assume that output is square.
    // Otherwise, use smallest possible values.
    if (num_rows == -1 && num_cols == -1) {
      num_rows = std::max(min_num_rows, min_num_cols);
      num_cols = num_rows;
    } else if (num_rows == -1) {
      num_rows = min_num_rows;
    } else if (num_cols == -1) {
      num_cols = min_num_cols;
    }
    OP_REQUIRES(context, num_rows == min_num_rows || num_cols == min_num_cols,
                errors::InvalidArgument(
                    ""The number of rows or columns is not consistent with ""
                    ""the specified d_lower, d_upper, and diagonal.""));

    TensorShape output_shape = diagonal_shape;
    if (num_diags == 1) {  // Output has rank `rank+1`.
      output_shape.set_dim(diag_rank - 1, num_rows);
      output_shape.AddDim(num_cols);
    } else {  // Output has rank `rank`.
      output_shape.set_dim(diag_rank - 2, num_rows);
      output_shape.set_dim(diag_rank - 1, num_cols);
    }

    Tensor* output = nullptr;
    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));
    auto output_reshaped = output->flat_inner_dims<T, 3>();
    auto diag_reshaped = diagonal.flat<T>();
    functor::MatrixDiag<Device, T>::Compute(
        context, context->eigen_device<Device>(), diag_reshaped,
        output_reshaped, lower_diag_index, upper_diag_index, max_diag_len,
        padding_value, left_align_superdiagonal_, left_align_subdiagonal_);
  }","void Compute(OpKernelContext* VAR_0) override {
    const Tensor& VAR_1 = VAR_0->input(0);

    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    int32 VAR_2 = 0;
    int32 VAR_3 = 0;
    int32 VAR_4 = -1;
    int32 VAR_5 = -1;
    T VAR_6(0);

    /* COMMENT_3 */
    if (VAR_0->num_inputs() > VAR_7) {
      auto& VAR_8 = VAR_0->input(1);
      OP_REQUIRES(VAR_0,
                  TensorShapeUtils::IsScalar(VAR_8.shape()) ||
                      TensorShapeUtils::IsVector(VAR_8.shape()),
                  errors::InvalidArgument(
                      ""diag_index must be a scalar or vector, received shape: "",
                      VAR_8.shape().DebugString()));
      VAR_2 = VAR_8.flat<int32>()(0);
      VAR_3 = VAR_2;
      if (TensorShapeUtils::IsVector(VAR_8.shape())) {
        auto VAR_9 = VAR_8.dim_size(0);
        OP_REQUIRES(
            VAR_0, 0 < VAR_9 && VAR_9 <= 2,
            errors::InvalidArgument(
                ""diag_index must have only one or two elements, received "",
                VAR_9, "" elements.""));
        if (VAR_9 > 1) {
          VAR_3 = VAR_8.flat<int32>()(1);
        }
      }

      auto& VAR_10 = VAR_0->input(2);
      OP_REQUIRES(VAR_0, TensorShapeUtils::IsScalar(VAR_10.shape()),
                  errors::InvalidArgument(""num_rows must be a scalar""));
      VAR_4 = VAR_10.flat<int32>()(0);

      auto& VAR_11 = VAR_0->input(3);
      OP_REQUIRES(VAR_0, TensorShapeUtils::IsScalar(VAR_11.shape()),
                  errors::InvalidArgument(""num_cols must be a scalar""));
      VAR_5 = VAR_11.flat<int32>()(0);

      auto& VAR_12 = VAR_0->input(4);
      OP_REQUIRES(VAR_0,
                  TensorShapeUtils::IsScalar(VAR_12.shape()),
                  errors::InvalidArgument(""padding_value must be a scalar""));
      VAR_6 = VAR_12.flat<T>()(0);
    }

    /* COMMENT_4 */
    const TensorShape& VAR_13 = VAR_1.shape();
    const int VAR_14 = VAR_13.dims();
    const Eigen::Index VAR_15 = VAR_3 - VAR_2 + 1;
    OP_REQUIRES(VAR_0, TensorShapeUtils::IsVectorOrHigher(VAR_13),
                errors::InvalidArgument(
                    ""diagonal must be at least 1-dim, received shape: "",
                    VAR_1.shape().DebugString()));
    OP_REQUIRES(
        VAR_0, VAR_2 <= VAR_3,
        errors::InvalidArgument(
            ""lower_diag_index must not be larger than upper_diag_index: "",
            VAR_2, "" > "", VAR_3));
    OP_REQUIRES(VAR_0,
                VAR_2 == VAR_3 ||
                    VAR_13.dim_size(VAR_14 - 2) == VAR_15,
                errors::InvalidArgument(
                    ""The number of diagonals provided in the input does not ""
                    ""match the lower_diag_index and upper_diag_index range.""));

    const Eigen::Index VAR_16 = VAR_13.dim_size(VAR_14 - 1);
    const int32 VAR_17 = VAR_16 - std::min(VAR_3, 0);
    const int32 VAR_18 = VAR_16 + std::max(VAR_2, 0);
    OP_REQUIRES(VAR_0, VAR_4 == -1 || VAR_4 >= VAR_17,
                errors::InvalidArgument(""The number of rows is too small.""));
    OP_REQUIRES(VAR_0, VAR_5 == -1 || VAR_5 >= VAR_18,
                errors::InvalidArgument(""The number of columns is too small.""));

    /* COMMENT_5 */
    /* COMMENT_6 */
    if (VAR_4 == -1 && VAR_5 == -1) {
      VAR_4 = std::max(VAR_17, VAR_18);
      VAR_5 = VAR_4;
    } else if (VAR_4 == -1) {
      VAR_4 = VAR_17;
    } else if (VAR_5 == -1) {
      VAR_5 = VAR_18;
    }
    OP_REQUIRES(VAR_0, VAR_4 == VAR_17 || VAR_5 == VAR_18,
                errors::InvalidArgument(
                    ""The number of rows or columns is not consistent with ""
                    ""the specified d_lower, d_upper, and diagonal.""));

    TensorShape VAR_19 = VAR_13;
    if (VAR_15 == 1) {  /* COMMENT_7 */
      VAR_19.set_dim(VAR_14 - 1, VAR_4);
      VAR_19.AddDim(VAR_5);
    } else {  /* COMMENT_8 */
      VAR_19.set_dim(VAR_14 - 2, VAR_4);
      VAR_19.set_dim(VAR_14 - 1, VAR_5);
    }

    Tensor* VAR_20 = nullptr;
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(0, VAR_19, &VAR_20));
    auto VAR_21 = VAR_20->flat_inner_dims<T, 3>();
    auto VAR_22 = VAR_1.flat<T>();
    functor::MatrixDiag<Device, T>::Compute(
        VAR_0, VAR_0->eigen_device<Device>(), VAR_22,
        VAR_21, VAR_2, VAR_3, VAR_16,
        VAR_6, VAR_23, VAR_24);
  }",,"--- func_before
+++ func_after
@@ -32,9 +32,22 @@
           upper_diag_index = diag_index.flat<int32>()(1);
         }
       }
-      num_rows = context->input(2).flat<int32>()(0);
-      num_cols = context->input(3).flat<int32>()(0);
-      padding_value = context->input(4).flat<T>()(0);
+
+      auto& num_rows_tensor = context->input(2);
+      OP_REQUIRES(context, TensorShapeUtils::IsScalar(num_rows_tensor.shape()),
+                  errors::InvalidArgument(""num_rows must be a scalar""));
+      num_rows = num_rows_tensor.flat<int32>()(0);
+
+      auto& num_cols_tensor = context->input(3);
+      OP_REQUIRES(context, TensorShapeUtils::IsScalar(num_cols_tensor.shape()),
+                  errors::InvalidArgument(""num_cols must be a scalar""));
+      num_cols = num_cols_tensor.flat<int32>()(0);
+
+      auto& padding_value_tensor = context->input(4);
+      OP_REQUIRES(context,
+                  TensorShapeUtils::IsScalar(padding_value_tensor.shape()),
+                  errors::InvalidArgument(""padding_value must be a scalar""));
+      padding_value = padding_value_tensor.flat<T>()(0);
     }
 
     // Size validations.","{'deleted_lines': ['      num_rows = context->input(2).flat<int32>()(0);', '      num_cols = context->input(3).flat<int32>()(0);', '      padding_value = context->input(4).flat<T>()(0);'], 'added_lines': ['', '      auto& num_rows_tensor = context->input(2);', '      OP_REQUIRES(context, TensorShapeUtils::IsScalar(num_rows_tensor.shape()),', '                  errors::InvalidArgument(""num_rows must be a scalar""));', '      num_rows = num_rows_tensor.flat<int32>()(0);', '', '      auto& num_cols_tensor = context->input(3);', '      OP_REQUIRES(context, TensorShapeUtils::IsScalar(num_cols_tensor.shape()),', '                  errors::InvalidArgument(""num_cols must be a scalar""));', '      num_cols = num_cols_tensor.flat<int32>()(0);', '', '      auto& padding_value_tensor = context->input(4);', '      OP_REQUIRES(context,', '                  TensorShapeUtils::IsScalar(padding_value_tensor.shape()),', '                  errors::InvalidArgument(""padding_value must be a scalar""));', '      padding_value = padding_value_tensor.flat<T>()(0);']}",True,"TensorFlow is an end-to-end open source platform for machine learning. The implementation of `MatrixDiag*` operations(https://github.com/tensorflow/tensorflow/blob/4c4f420e68f1cfaf8f4b6e8e3eb857e9e4c3ff33/tensorflow/core/kernels/linalg/matrix_diag_op.cc#L195-L197) does not validate that the tensor arguments are non-empty. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",2.5,LOW,0,test,2021-04-18T03:55:53Z,3
CVE-2021-33797,['CWE-190'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,ccxvii/mujs,"Issue #148: Check for overflow when reading floating point exponent.

GCC with -O2 optimizes away the if(exp<-maxExponent) branch completely,
so we don't end up with the expected '512' value for overflowing
exponents. Limit the exponent parsing to MAX_INT instead to prevent
signed overflow from tripping up over-eager optimizing compilers.",833b6f1672b4f2991a63c4d05318f0b84ef4d550,https://github.com/ccxvii/mujs/commit/833b6f1672b4f2991a63c4d05318f0b84ef4d550,jsdtoa.c,js_strtod,"double
js_strtod(const char *string, char **endPtr)
{
int sign, expSign = FALSE;
double fraction, dblExp, *d;
register const char *p;
register int c;
int exp = 0;
int fracExp = 0;
int mantSize;
int decPt;
const char *pExp;
p = string;
while (*p == ' ' || *p == '\t' || *p == '\n' || *p == '\r') {
p += 1;
}
if (*p == '-') {
sign = TRUE;
p += 1;
} else {
if (*p == '+') {
p += 1;
}
sign = FALSE;
}
decPt = -1;
for (mantSize = 0; ; mantSize += 1)
{
c = *p;
if (!(c>='0'&&c<='9')) {
if ((c != '.') || (decPt >= 0)) {
break;
}
decPt = mantSize;
}
p += 1;
}
pExp = p;
p -= mantSize;
if (decPt < 0) {
decPt = mantSize;
} else {
mantSize -= 1;
}
if (mantSize > 18) {
fracExp = decPt - 18;
mantSize = 18;
} else {
fracExp = decPt - mantSize;
}
if (mantSize == 0) {
fraction = 0.0;
p = string;
goto done;
} else {
int frac1, frac2;
frac1 = 0;
for ( ; mantSize > 9; mantSize -= 1)
{
c = *p;
p += 1;
if (c == '.') {
c = *p;
p += 1;
}
frac1 = 10*frac1 + (c - '0');
}
frac2 = 0;
for (; mantSize > 0; mantSize -= 1)
{
c = *p;
p += 1;
if (c == '.') {
c = *p;
p += 1;
}
frac2 = 10*frac2 + (c - '0');
}
fraction = (1.0e9 * frac1) + frac2;
}
p = pExp;
if ((*p == 'E') || (*p == 'e')) {
p += 1;
if (*p == '-') {
expSign = TRUE;
p += 1;
} else {
if (*p == '+') {
p += 1;
}
expSign = FALSE;
}
while ((*p >= '0') && (*p <= '9')) {
exp = exp * 10 + (*p - '0');
p += 1;
}
}
if (expSign) {
exp = fracExp - exp;
} else {
exp = fracExp + exp;
}
if (exp < -maxExponent) {
exp = maxExponent;
expSign = TRUE;
errno = ERANGE;
} else if (exp > maxExponent) {
exp = maxExponent;
expSign = FALSE;
errno = ERANGE;
} else if (exp < 0) {
expSign = TRUE;
exp = -exp;
} else {
expSign = FALSE;
}
dblExp = 1.0;
for (d = powersOf10; exp != 0; exp >>= 1, d += 1) {
if (exp & 01) {
dblExp *= *d;
}
}
if (expSign) {
fraction /= dblExp;
} else {
fraction *= dblExp;
}
done:
if (endPtr != NULL) {
*endPtr = (char *) p;
}
if (sign) {
return -fraction;
}
return fraction;
}","double
js_strtod(const char *VAR_0, char **VAR_1)
{
int VAR_2, VAR_3 = FALSE;
double VAR_4, VAR_5, *VAR_6;
register const char *VAR_7;
register int VAR_8;
int VAR_9 = 0;
int VAR_10 = 0;
int VAR_11;
int VAR_12;
const char *VAR_13;
VAR_7 = VAR_0;
while (*VAR_7 == ' ' || *VAR_7 == '\t' || *VAR_7 == '\n' || *VAR_7 == '\r') {
VAR_7 += 1;
}
if (*VAR_7 == '-') {
VAR_2 = TRUE;
VAR_7 += 1;
} else {
if (*VAR_7 == '+') {
VAR_7 += 1;
}
VAR_2 = FALSE;
}
VAR_12 = -1;
for (VAR_11 = 0; ; VAR_11 += 1)
{
VAR_8 = *VAR_7;
if (!(VAR_8>='0'&&VAR_8<='9')) {
if ((VAR_8 != '.') || (VAR_12 >= 0)) {
break;
}
VAR_12 = VAR_11;
}
VAR_7 += 1;
}
VAR_13 = VAR_7;
VAR_7 -= VAR_11;
if (VAR_12 < 0) {
VAR_12 = VAR_11;
} else {
VAR_11 -= 1;
}
if (VAR_11 > 18) {
VAR_10 = VAR_12 - 18;
VAR_11 = 18;
} else {
VAR_10 = VAR_12 - VAR_11;
}
if (VAR_11 == 0) {
VAR_4 = 0.0;
VAR_7 = VAR_0;
goto done;
} else {
int VAR_14, VAR_15;
VAR_14 = 0;
for ( ; VAR_11 > 9; VAR_11 -= 1)
{
VAR_8 = *VAR_7;
VAR_7 += 1;
if (VAR_8 == '.') {
VAR_8 = *VAR_7;
VAR_7 += 1;
}
VAR_14 = 10*VAR_14 + (VAR_8 - '0');
}
VAR_15 = 0;
for (; VAR_11 > 0; VAR_11 -= 1)
{
VAR_8 = *VAR_7;
VAR_7 += 1;
if (VAR_8 == '.') {
VAR_8 = *VAR_7;
VAR_7 += 1;
}
VAR_15 = 10*VAR_15 + (VAR_8 - '0');
}
VAR_4 = (1.0e9 * VAR_14) + VAR_15;
}
VAR_7 = VAR_13;
if ((*VAR_7 == 'E') || (*VAR_7 == 'e')) {
VAR_7 += 1;
if (*VAR_7 == '-') {
VAR_3 = TRUE;
VAR_7 += 1;
} else {
if (*VAR_7 == '+') {
VAR_7 += 1;
}
VAR_3 = FALSE;
}
while ((*VAR_7 >= '0') && (*VAR_7 <= '9')) {
VAR_9 = VAR_9 * 10 + (*VAR_7 - '0');
VAR_7 += 1;
}
}
if (VAR_3) {
VAR_9 = VAR_10 - VAR_9;
} else {
VAR_9 = VAR_10 + VAR_9;
}
if (VAR_9 < -VAR_16) {
VAR_9 = VAR_16;
VAR_3 = TRUE;
VAR_17 = VAR_18;
} else if (VAR_9 > VAR_16) {
VAR_9 = VAR_16;
VAR_3 = FALSE;
VAR_17 = VAR_18;
} else if (VAR_9 < 0) {
VAR_3 = TRUE;
VAR_9 = -VAR_9;
} else {
VAR_3 = FALSE;
}
VAR_5 = 1.0;
for (VAR_6 = VAR_19; VAR_9 != 0; VAR_9 >>= 1, VAR_6 += 1) {
if (VAR_9 & 01) {
VAR_5 *= *VAR_6;
}
}
if (VAR_3) {
VAR_4 /= VAR_5;
} else {
VAR_4 *= VAR_5;
}
done:
if (VAR_1 != NULL) {
*VAR_1 = (char *) VAR_7;
}
if (VAR_2) {
return -VAR_4;
}
return VAR_4;
}",ccxvii/mujs/833b6f1672b4f2991a63c4d05318f0b84ef4d550/jsdtoa.c/vul/before/0.json,"double
js_strtod(const char *string, char **endPtr)
{
	int sign, expSign = FALSE;
	double fraction, dblExp, *d;
	register const char *p;
	register int c;

	/* Exponent read from ""EX"" field. */
	int exp = 0;

	/* Exponent that derives from the fractional part. Under normal
	 * circumstances, it is the negative of the number of digits in F.
	 * However, if I is very long, the last digits of I get dropped
	 * (otherwise a long I with a large negative exponent could cause an
	 * unnecessary overflow on I alone). In this case, fracExp is
	 * incremented one for each dropped digit.
	 */
	int fracExp = 0;

	/* Number of digits in mantissa. */
	int mantSize;

	/* Number of mantissa digits BEFORE decimal point. */
	int decPt;

	/* Temporarily holds location of exponent in string. */
	const char *pExp;

	/*
	 * Strip off leading blanks and check for a sign.
	 */

	p = string;
	while (*p == ' ' || *p == '\t' || *p == '\n' || *p == '\r') {
		p += 1;
	}
	if (*p == '-') {
		sign = TRUE;
		p += 1;
	} else {
		if (*p == '+') {
			p += 1;
		}
		sign = FALSE;
	}

	/*
	 * Count the number of digits in the mantissa (including the decimal
	 * point), and also locate the decimal point.
	 */

	decPt = -1;
	for (mantSize = 0; ; mantSize += 1)
	{
		c = *p;
		if (!(c>='0'&&c<='9')) {
			if ((c != '.') || (decPt >= 0)) {
				break;
			}
			decPt = mantSize;
		}
		p += 1;
	}

	/*
	 * Now suck up the digits in the mantissa. Use two integers to
	 * collect 9 digits each (this is faster than using floating-point).
	 * If the mantissa has more than 18 digits, ignore the extras, since
	 * they can't affect the value anyway.
	 */

	pExp = p;
	p -= mantSize;
	if (decPt < 0) {
		decPt = mantSize;
	} else {
		mantSize -= 1;			/* One of the digits was the point. */
	}
	if (mantSize > 18) {
		fracExp = decPt - 18;
		mantSize = 18;
	} else {
		fracExp = decPt - mantSize;
	}
	if (mantSize == 0) {
		fraction = 0.0;
		p = string;
		goto done;
	} else {
		int frac1, frac2;
		frac1 = 0;
		for ( ; mantSize > 9; mantSize -= 1)
		{
			c = *p;
			p += 1;
			if (c == '.') {
				c = *p;
				p += 1;
			}
			frac1 = 10*frac1 + (c - '0');
		}
		frac2 = 0;
		for (; mantSize > 0; mantSize -= 1)
		{
			c = *p;
			p += 1;
			if (c == '.') {
				c = *p;
				p += 1;
			}
			frac2 = 10*frac2 + (c - '0');
		}
		fraction = (1.0e9 * frac1) + frac2;
	}

	/*
	 * Skim off the exponent.
	 */

	p = pExp;
	if ((*p == 'E') || (*p == 'e')) {
		p += 1;
		if (*p == '-') {
			expSign = TRUE;
			p += 1;
		} else {
			if (*p == '+') {
				p += 1;
			}
			expSign = FALSE;
		}
		while ((*p >= '0') && (*p <= '9') && exp < INT_MAX/10) {
			exp = exp * 10 + (*p - '0');
			p += 1;
		}
		while ((*p >= '0') && (*p <= '9'))
			p += 1;
	}
	if (expSign) {
		exp = fracExp - exp;
	} else {
		exp = fracExp + exp;
	}

	/*
	 * Generate a floating-point number that represents the exponent.
	 * Do this by processing the exponent one bit at a time to combine
	 * many powers of 2 of 10. Then combine the exponent with the
	 * fraction.
	 */

	if (exp < -maxExponent) {
		exp = maxExponent;
		expSign = TRUE;
		errno = ERANGE;
	} else if (exp > maxExponent) {
		exp = maxExponent;
		expSign = FALSE;
		errno = ERANGE;
	} else if (exp < 0) {
		expSign = TRUE;
		exp = -exp;
	} else {
		expSign = FALSE;
	}
	dblExp = 1.0;
	for (d = powersOf10; exp != 0; exp >>= 1, d += 1) {
		if (exp & 01) {
			dblExp *= *d;
		}
	}
	if (expSign) {
		fraction /= dblExp;
	} else {
		fraction *= dblExp;
	}

done:
	if (endPtr != NULL) {
		*endPtr = (char *) p;
	}

	if (sign) {
		return -fraction;
	}
	return fraction;
}","double
js_strtod(const char *VAR_0, char **VAR_1)
{
	int VAR_2, VAR_3 = FALSE;
	double VAR_4, VAR_5, *VAR_6;
	register const char *VAR_7;
	register int VAR_8;

	/* COMMENT_0 */
	int VAR_9 = 0;

	/* COMMENT_1 */
                                                                   
                                                                
                                                                     
                                                              
                                           
    
	int VAR_10 = 0;

	/* COMMENT_8 */
	int VAR_11;

	/* COMMENT_9 */
	int VAR_12;

	/* COMMENT_10 */
	const char *VAR_13;

	/* COMMENT_11 */
                                                  
    

	VAR_7 = VAR_0;
	while (*VAR_7 == ' ' || *VAR_7 == '\t' || *VAR_7 == '\n' || *VAR_7 == '\r') {
		VAR_7 += 1;
	}
	if (*VAR_7 == '-') {
		VAR_2 = TRUE;
		VAR_7 += 1;
	} else {
		if (*VAR_7 == '+') {
			VAR_7 += 1;
		}
		VAR_2 = FALSE;
	}

	/* COMMENT_14 */
                                                                     
                                              
    

	VAR_12 = -1;
	for (VAR_11 = 0; ; VAR_11 += 1)
	{
		VAR_8 = *VAR_7;
		if (!(VAR_8>='0'&&VAR_8<='9')) {
			if ((VAR_8 != '.') || (VAR_12 >= 0)) {
				break;
			}
			VAR_12 = VAR_11;
		}
		VAR_7 += 1;
	}

	/* COMMENT_18 */
                                                               
                                                                     
                                                                     
                                       
    

	VAR_13 = VAR_7;
	VAR_7 -= VAR_11;
	if (VAR_12 < 0) {
		VAR_12 = VAR_11;
	} else {
		VAR_11 -= 1;			/* COMMENT_24 */
	}
	if (VAR_11 > 18) {
		VAR_10 = VAR_12 - 18;
		VAR_11 = 18;
	} else {
		VAR_10 = VAR_12 - VAR_11;
	}
	if (VAR_11 == 0) {
		VAR_4 = 0.0;
		VAR_7 = VAR_0;
		goto done;
	} else {
		int VAR_14, VAR_15;
		VAR_14 = 0;
		for ( ; VAR_11 > 9; VAR_11 -= 1)
		{
			VAR_8 = *VAR_7;
			VAR_7 += 1;
			if (VAR_8 == '.') {
				VAR_8 = *VAR_7;
				VAR_7 += 1;
			}
			VAR_14 = 10*VAR_14 + (VAR_8 - '0');
		}
		VAR_15 = 0;
		for (; VAR_11 > 0; VAR_11 -= 1)
		{
			VAR_8 = *VAR_7;
			VAR_7 += 1;
			if (VAR_8 == '.') {
				VAR_8 = *VAR_7;
				VAR_7 += 1;
			}
			VAR_15 = 10*VAR_15 + (VAR_8 - '0');
		}
		VAR_4 = (1.0e9 * VAR_14) + VAR_15;
	}

	/* COMMENT_25 */
                          
    

	VAR_7 = VAR_13;
	if ((*VAR_7 == 'E') || (*VAR_7 == 'e')) {
		VAR_7 += 1;
		if (*VAR_7 == '-') {
			VAR_3 = TRUE;
			VAR_7 += 1;
		} else {
			if (*VAR_7 == '+') {
				VAR_7 += 1;
			}
			VAR_3 = FALSE;
		}
		while ((*VAR_7 >= '0') && (*VAR_7 <= '9') && VAR_9 < VAR_16/10) {
			VAR_9 = VAR_9 * 10 + (*VAR_7 - '0');
			VAR_7 += 1;
		}
		while ((*VAR_7 >= '0') && (*VAR_7 <= '9'))
			VAR_7 += 1;
	}
	if (VAR_3) {
		VAR_9 = VAR_10 - VAR_9;
	} else {
		VAR_9 = VAR_10 + VAR_9;
	}

	/* COMMENT_28 */
                                                                  
                                                                   
                                                              
             
    

	if (VAR_9 < -VAR_17) {
		VAR_9 = VAR_17;
		VAR_3 = TRUE;
		VAR_18 = VAR_19;
	} else if (VAR_9 > VAR_17) {
		VAR_9 = VAR_17;
		VAR_3 = FALSE;
		VAR_18 = VAR_19;
	} else if (VAR_9 < 0) {
		VAR_3 = TRUE;
		VAR_9 = -VAR_9;
	} else {
		VAR_3 = FALSE;
	}
	VAR_5 = 1.0;
	for (VAR_6 = VAR_20; VAR_9 != 0; VAR_9 >>= 1, VAR_6 += 1) {
		if (VAR_9 & 01) {
			VAR_5 *= *VAR_6;
		}
	}
	if (VAR_3) {
		VAR_4 /= VAR_5;
	} else {
		VAR_4 *= VAR_5;
	}

done:
	if (VAR_1 != NULL) {
		*VAR_1 = (char *) VAR_7;
	}

	if (VAR_2) {
		return -VAR_4;
	}
	return VAR_4;
}",ccxvii/mujs/833b6f1672b4f2991a63c4d05318f0b84ef4d550/jsdtoa.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -130,10 +130,12 @@
 			}
 			expSign = FALSE;
 		}
-		while ((*p >= '0') && (*p <= '9')) {
+		while ((*p >= '0') && (*p <= '9') && exp < INT_MAX/10) {
 			exp = exp * 10 + (*p - '0');
 			p += 1;
 		}
+		while ((*p >= '0') && (*p <= '9'))
+			p += 1;
 	}
 	if (expSign) {
 		exp = fracExp - exp;","{'deleted_lines': [""\t\twhile ((*p >= '0') && (*p <= '9')) {""], 'added_lines': [""\t\twhile ((*p >= '0') && (*p <= '9') && exp < INT_MAX/10) {"", ""\t\twhile ((*p >= '0') && (*p <= '9'))"", '\t\t\tp += 1;']}",True,"Buffer-overflow in jsdtoa.c in Artifex MuJS in versions 1.0.1 to 1.1.1. An integer overflow happens when js_strtod() reads in floating point exponent, which leads to a buffer overflow in the pointer *d.",9.8,CRITICAL,3,test,2021-04-21T10:25:48Z,3
CVE-2021-29545,['CWE-131'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,tensorflow,"Fix crash in `SparseTensorToCSRSparseMatrixCPUFunctor`

PiperOrigin-RevId: 370110290
Change-Id: I4451e92661a55c2180f80d38b67a9b50bf5edec5",1e922ccdf6bf46a3a52641f99fd47d54c1decd13,https://github.com/tensorflow/tensorflow/commit/1e922ccdf6bf46a3a52641f99fd47d54c1decd13,tensorflow/core/kernels/sparse/kernels.cc,SparseTensorToCSRSparseMatrixCPUFunctor::operator(),"Status SparseTensorToCSRSparseMatrixCPUFunctor::operator()(
const int64 batch_size, const int num_rows,
TTypes<int64>::ConstMatrix indices, TTypes<int32>::Vec batch_ptr,
TTypes<int32>::Vec csr_row_ptr, TTypes<int32>::Vec csr_col_ind) {
if (batch_ptr.size() != batch_size + 1) {
return errors::InvalidArgument(
""Expected batch_ptr.size() == batch_size + 1. Got: "", batch_ptr.size(),
"" vs. "", batch_size + 1);
}
if (csr_row_ptr.size() != batch_size * (num_rows + 1)) {
return errors::InvalidArgument(
""Expected csr_row_ptr.size() == batch_size * (num_rows + 1). Got: "",
csr_row_ptr.size(), "" vs. "", batch_size * (num_rows + 1));
}
const int64 total_nnz = indices.dimension(0);
const int rank = indices.dimension(1);
if (rank == 2 && batch_size != 1) {
return errors::InvalidArgument(
""Expected batch_size == 1 when rank is 2. Got batch_size: "",
batch_size);
}
if (csr_col_ind.size() != total_nnz) {
return errors::InvalidArgument(
""Expected csr_col_ind.size() == total_nnz. Got: "", csr_col_ind.size(),
"" vs. "", total_nnz);
}
int prev_batch = -1;
if (rank == 2) {
batch_ptr(0) = 0;
++prev_batch;
for (int64 i = 0; i < total_nnz; ++i) {
csr_row_ptr(indices(i, 0) + 1) += 1;
csr_col_ind(i) = indices(i, 1);
}
} else {      for (int64 i = 0; i < total_nnz; ++i) {
const int cur_batch = indices(i, 0);
csr_row_ptr(cur_batch * (num_rows + 1) + indices(i, 1) + 1) += 1;
csr_col_ind(i) = indices(i, 2);
while (prev_batch < cur_batch) {
batch_ptr(prev_batch + 1) = i;
++prev_batch;
}
}
}
while (prev_batch < batch_size) {
batch_ptr(prev_batch + 1) = total_nnz;
++prev_batch;
}
for (int batch_idx = 0; batch_idx < batch_size; ++batch_idx) {
auto* row_ptr_batch = csr_row_ptr.data() + batch_idx * (num_rows + 1);
std::partial_sum(row_ptr_batch, row_ptr_batch + num_rows + 1,
row_ptr_batch);
}
return Status::OK();
}","Status SparseTensorToCSRSparseMatrixCPUFunctor::operator()(
const int64 VAR_0, const int VAR_1,
TTypes<int64>::ConstMatrix VAR_2, TTypes<int32>::Vec VAR_3,
TTypes<int32>::Vec VAR_4, TTypes<int32>::Vec VAR_5) {
if (VAR_3.size() != VAR_0 + 1) {
return errors::InvalidArgument(
""Expected batch_ptr.size() == batch_size + 1. Got: "", VAR_3.size(),
"" vs. "", VAR_0 + 1);
}
if (VAR_4.size() != VAR_0 * (VAR_1 + 1)) {
return errors::InvalidArgument(
""Expected csr_row_ptr.size() == batch_size * (num_rows + 1). Got: "",
VAR_4.size(), "" vs. "", VAR_0 * (VAR_1 + 1));
}
const int64 VAR_6 = VAR_2.dimension(0);
const int VAR_7 = VAR_2.dimension(1);
if (VAR_7 == 2 && VAR_0 != 1) {
return errors::InvalidArgument(
""Expected batch_size == 1 when rank is 2. Got batch_size: "",
VAR_0);
}
if (VAR_5.size() != VAR_6) {
return errors::InvalidArgument(
""Expected csr_col_ind.size() == total_nnz. Got: "", VAR_5.size(),
"" vs. "", VAR_6);
}
int VAR_8 = -1;
if (VAR_7 == 2) {
VAR_3(0) = 0;
++VAR_8;
for (int64 VAR_9 = 0; VAR_9 < VAR_6; ++VAR_9) {
VAR_4(VAR_2(VAR_9, 0) + 1) += 1;
VAR_5(VAR_9) = VAR_2(VAR_9, 1);
}
} else {  
for (int64 VAR_9 = 0; VAR_9 < VAR_6; ++VAR_9) {
const int VAR_10 = VAR_2(VAR_9, 0);
VAR_4(VAR_10 * (VAR_1 + 1) + VAR_2(VAR_9, 1) + 1) += 1;
VAR_5(VAR_9) = VAR_2(VAR_9, 2);
while (VAR_8 < VAR_10) {
VAR_3(VAR_8 + 1) = VAR_9;
++VAR_8;
}
}
}
while (VAR_8 < VAR_0) {
VAR_3(VAR_8 + 1) = VAR_6;
++VAR_8;
}
for (int VAR_11 = 0; VAR_11 < VAR_0; ++VAR_11) {
auto* VAR_12 = VAR_4.data() + VAR_11 * (VAR_1 + 1);
std::partial_sum(VAR_12, VAR_12 + VAR_1 + 1,
VAR_12);
}
return Status::OK();
}",tensorflow/1e922ccdf6bf46a3a52641f99fd47d54c1decd13/kernels.cc/vul/before/0.json,"Status SparseTensorToCSRSparseMatrixCPUFunctor::operator()(
    const int64 batch_size, const int num_rows,
    TTypes<int64>::ConstMatrix indices, TTypes<int32>::Vec batch_ptr,
    TTypes<int32>::Vec csr_row_ptr, TTypes<int32>::Vec csr_col_ind) {
  // Validate inputs.
  if (batch_ptr.size() != batch_size + 1) {
    return errors::InvalidArgument(
        ""Expected batch_ptr.size() == batch_size + 1. Got: "", batch_ptr.size(),
        "" vs. "", batch_size + 1);
  }
  if (csr_row_ptr.size() != batch_size * (num_rows + 1)) {
    return errors::InvalidArgument(
        ""Expected csr_row_ptr.size() == batch_size * (num_rows + 1). Got: "",
        csr_row_ptr.size(), "" vs. "", batch_size * (num_rows + 1));
  }

  const int64 total_nnz = indices.dimension(0);
  const int rank = indices.dimension(1);
  if (rank == 2 && batch_size != 1) {
    return errors::InvalidArgument(
        ""Expected batch_size == 1 when rank is 2. Got batch_size: "",
        batch_size);
  }
  if (csr_col_ind.size() != total_nnz) {
    return errors::InvalidArgument(
        ""Expected csr_col_ind.size() == total_nnz. Got: "", csr_col_ind.size(),
        "" vs. "", total_nnz);
  }

  int prev_batch = -1;
  if (rank == 2) {
    // For a single batch, the batch_ptrs are {0, total_nnz}.
    batch_ptr(0) = 0;
    ++prev_batch;

    for (int64 i = 0; i < total_nnz; ++i) {
      // For now, the rows pointers store the corresponding row counts.
      int64 ix = indices(i, 0) + 1;
      if (ix >= csr_row_ptr.size()) {
        return errors::InvalidArgument(""Got an index "", ix,
                                       "" that is outside of csr_row_ptr"");
      }
      csr_row_ptr(indices(i, 0) + 1) += 1;
      csr_col_ind(i) = indices(i, 1);
    }
  } else {  // rank == 3
    for (int64 i = 0; i < total_nnz; ++i) {
      const int cur_batch = indices(i, 0);
      // For now, the rows pointers store the corresponding row counts.
      csr_row_ptr(cur_batch * (num_rows + 1) + indices(i, 1) + 1) += 1;
      csr_col_ind(i) = indices(i, 2);

      // We're at a new batch and might have skipped over empty batches.
      while (prev_batch < cur_batch) {
        // The previous batch ends at position i.
        batch_ptr(prev_batch + 1) = i;
        ++prev_batch;
      }
    }
  }
  // Set the last element of batch_ptr and account for trailing empty batches.
  while (prev_batch < batch_size) {
    batch_ptr(prev_batch + 1) = total_nnz;
    ++prev_batch;
  }

  // Compute the cumulative row counts for each batch.
  for (int batch_idx = 0; batch_idx < batch_size; ++batch_idx) {
    auto* row_ptr_batch = csr_row_ptr.data() + batch_idx * (num_rows + 1);
    std::partial_sum(row_ptr_batch, row_ptr_batch + num_rows + 1,
                     row_ptr_batch);
  }
  return Status::OK();
}","Status SparseTensorToCSRSparseMatrixCPUFunctor::operator()(
    const int64 VAR_0, const int VAR_1,
    TTypes<int64>::ConstMatrix VAR_2, TTypes<int32>::Vec VAR_3,
    TTypes<int32>::Vec VAR_4, TTypes<int32>::Vec VAR_5) {
  /* COMMENT_0 */
  if (VAR_3.size() != VAR_0 + 1) {
    return errors::InvalidArgument(
        ""Expected batch_ptr.size() == batch_size + 1. Got: "", VAR_3.size(),
        "" vs. "", VAR_0 + 1);
  }
  if (VAR_4.size() != VAR_0 * (VAR_1 + 1)) {
    return errors::InvalidArgument(
        ""Expected csr_row_ptr.size() == batch_size * (num_rows + 1). Got: "",
        VAR_4.size(), "" vs. "", VAR_0 * (VAR_1 + 1));
  }

  const int64 VAR_6 = VAR_2.dimension(0);
  const int VAR_7 = VAR_2.dimension(1);
  if (VAR_7 == 2 && VAR_0 != 1) {
    return errors::InvalidArgument(
        ""Expected batch_size == 1 when rank is 2. Got batch_size: "",
        VAR_0);
  }
  if (VAR_5.size() != VAR_6) {
    return errors::InvalidArgument(
        ""Expected csr_col_ind.size() == total_nnz. Got: "", VAR_5.size(),
        "" vs. "", VAR_6);
  }

  int VAR_8 = -1;
  if (VAR_7 == 2) {
    /* COMMENT_1 */
    VAR_3(0) = 0;
    ++VAR_8;

    for (int64 VAR_9 = 0; VAR_9 < VAR_6; ++VAR_9) {
      /* COMMENT_2 */
      int64 VAR_10 = VAR_2(VAR_9, 0) + 1;
      if (VAR_10 >= VAR_4.size()) {
        return errors::InvalidArgument(""Got an index "", VAR_10,
                                       "" that is outside of csr_row_ptr"");
      }
      VAR_4(VAR_2(VAR_9, 0) + 1) += 1;
      VAR_5(VAR_9) = VAR_2(VAR_9, 1);
    }
  } else {  /* COMMENT_3 */
    for (int64 VAR_9 = 0; VAR_9 < VAR_6; ++VAR_9) {
      const int VAR_11 = VAR_2(VAR_9, 0);
      /* COMMENT_2 */
      VAR_4(VAR_11 * (VAR_1 + 1) + VAR_2(VAR_9, 1) + 1) += 1;
      VAR_5(VAR_9) = VAR_2(VAR_9, 2);

      /* COMMENT_4 */
      while (VAR_8 < VAR_11) {
        /* COMMENT_5 */
        VAR_3(VAR_8 + 1) = VAR_9;
        ++VAR_8;
      }
    }
  }
  /* COMMENT_6 */
  while (VAR_8 < VAR_0) {
    VAR_3(VAR_8 + 1) = VAR_6;
    ++VAR_8;
  }

  /* COMMENT_7 */
  for (int VAR_12 = 0; VAR_12 < VAR_0; ++VAR_12) {
    auto* VAR_13 = VAR_4.data() + VAR_12 * (VAR_1 + 1);
    std::partial_sum(VAR_13, VAR_13 + VAR_1 + 1,
                     VAR_13);
  }
  return Status::OK();
}",tensorflow/1e922ccdf6bf46a3a52641f99fd47d54c1decd13/kernels.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,6 +35,11 @@
 
     for (int64 i = 0; i < total_nnz; ++i) {
       // For now, the rows pointers store the corresponding row counts.
+      int64 ix = indices(i, 0) + 1;
+      if (ix >= csr_row_ptr.size()) {
+        return errors::InvalidArgument(""Got an index "", ix,
+                                       "" that is outside of csr_row_ptr"");
+      }
       csr_row_ptr(indices(i, 0) + 1) += 1;
       csr_col_ind(i) = indices(i, 1);
     }","{'deleted_lines': [], 'added_lines': ['      int64 ix = indices(i, 0) + 1;', '      if (ix >= csr_row_ptr.size()) {', '        return errors::InvalidArgument(""Got an index "", ix,', '                                       "" that is outside of csr_row_ptr"");', '      }']}",True,"TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in converting sparse tensors to CSR Sparse matrices. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/800346f2c03a27e182dd4fba48295f65e7790739/tensorflow/core/kernels/sparse/kernels.cc#L66) does a double redirection to access an element of an array allocated on the heap. If the value at `indices(i, 0)` is such that `indices(i, 0) + 1` is outside the bounds of `csr_row_ptr`, this results in writing outside of bounds of heap allocated data. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",2.5,LOW,0,test,2021-04-23T17:41:12Z,3
CVE-2021-29596,['CWE-369'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Prevent division by 0

PiperOrigin-RevId: 370966645
Change-Id: I831bfd96c7eb77b02d7ebb744335f59f6e5728cb",f61c57bd425878be108ec787f4d96390579fb83e,https://github.com/tensorflow/tensorflow/commit/f61c57bd425878be108ec787f4d96390579fb83e,tensorflow/lite/kernels/embedding_lookup.cc,EvalSimple,"TfLiteStatus EvalSimple(TfLiteContext* context, TfLiteNode* node,
const TfLiteTensor* lookup, const TfLiteTensor* value,
TfLiteTensor* output) {
const int row_size = SizeOfDimension(value, 0);
const int row_bytes = value->bytes / row_size;
char* output_raw = GetTensorData<char>(output);
const char* value_raw = GetTensorData<char>(value);
const int32_t* lookup_data = GetTensorData<int32_t>(lookup);
for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {
int idx = lookup_data[i];
if (idx >= row_size || idx < 0) {
context->ReportError(context,
""Embedding Lookup: index out of bounds. ""
""Got %d, and bounds are [0, %d]"",
idx, row_size - 1);
return kTfLiteError;
} else {
std::memcpy(output_raw + i * row_bytes, value_raw + idx * row_bytes,
row_bytes);
}
}
return kTfLiteOk;
}","TfLiteStatus EvalSimple(TfLiteContext* VAR_0, TfLiteNode* VAR_1,
const TfLiteTensor* VAR_2, const TfLiteTensor* VAR_3,
TfLiteTensor* VAR_4) {
const int VAR_5 = SizeOfDimension(VAR_3, 0);
const int VAR_6 = VAR_3->bytes / VAR_5;
char* VAR_7 = VAR_8<char>(VAR_4);
const char* VAR_9 = VAR_8<char>(VAR_3);
const int32_t* VAR_10 = VAR_8<int32_t>(VAR_2);
for (int VAR_11 = 0; VAR_11 < SizeOfDimension(VAR_2, 0); VAR_11++) {
int VAR_12 = VAR_10[VAR_11];
if (VAR_12 >= VAR_5 || VAR_12 < 0) {
VAR_0->ReportError(VAR_0,
""Embedding Lookup: index out of bounds. ""
""Got %d, and bounds are [0, %d]"",
VAR_12, VAR_5 - 1);
return VAR_13;
} else {
std::memcpy(VAR_7 + VAR_11 * VAR_6, VAR_9 + VAR_12 * VAR_6,
VAR_6);
}
}
return VAR_14;
}",tensorflow/f61c57bd425878be108ec787f4d96390579fb83e/embedding_lookup.cc/vul/before/0.json,"TfLiteStatus EvalSimple(TfLiteContext* context, TfLiteNode* node,
                        const TfLiteTensor* lookup, const TfLiteTensor* value,
                        TfLiteTensor* output) {
  const int row_size = SizeOfDimension(value, 0);
  if (row_size == 0) {
    // Propagate empty tensor if input is empty
    return kTfLiteOk;
  }
  const int row_bytes = value->bytes / row_size;

  char* output_raw = GetTensorData<char>(output);
  const char* value_raw = GetTensorData<char>(value);
  const int32_t* lookup_data = GetTensorData<int32_t>(lookup);
  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {
    int idx = lookup_data[i];
    if (idx >= row_size || idx < 0) {
      context->ReportError(context,
                           ""Embedding Lookup: index out of bounds. ""
                           ""Got %d, and bounds are [0, %d]"",
                           idx, row_size - 1);
      return kTfLiteError;
    } else {
      std::memcpy(output_raw + i * row_bytes, value_raw + idx * row_bytes,
                  row_bytes);
    }
  }

  return kTfLiteOk;
}","TfLiteStatus EvalSimple(TfLiteContext* VAR_0, TfLiteNode* VAR_1,
                        const TfLiteTensor* VAR_2, const TfLiteTensor* VAR_3,
                        TfLiteTensor* VAR_4) {
  const int VAR_5 = SizeOfDimension(VAR_3, 0);
  if (VAR_5 == 0) {
    /* COMMENT_0 */
    return VAR_6;
  }
  const int VAR_7 = VAR_3->bytes / VAR_5;

  char* VAR_8 = VAR_9<char>(VAR_4);
  const char* VAR_10 = VAR_9<char>(VAR_3);
  const int32_t* VAR_11 = VAR_9<int32_t>(VAR_2);
  for (int VAR_12 = 0; VAR_12 < SizeOfDimension(VAR_2, 0); VAR_12++) {
    int VAR_13 = VAR_11[VAR_12];
    if (VAR_13 >= VAR_5 || VAR_13 < 0) {
      VAR_0->ReportError(VAR_0,
                           ""Embedding Lookup: index out of bounds. ""
                           ""Got %d, and bounds are [0, %d]"",
                           VAR_13, VAR_5 - 1);
      return VAR_14;
    } else {
      std::memcpy(VAR_8 + VAR_12 * VAR_7, VAR_10 + VAR_13 * VAR_7,
                  VAR_7);
    }
  }

  return VAR_6;
}",tensorflow/f61c57bd425878be108ec787f4d96390579fb83e/embedding_lookup.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,6 +2,10 @@
                         const TfLiteTensor* lookup, const TfLiteTensor* value,
                         TfLiteTensor* output) {
   const int row_size = SizeOfDimension(value, 0);
+  if (row_size == 0) {
+    // Propagate empty tensor if input is empty
+    return kTfLiteOk;
+  }
   const int row_bytes = value->bytes / row_size;
 
   char* output_raw = GetTensorData<char>(output);","{'deleted_lines': [], 'added_lines': ['  if (row_size == 0) {', '    // Propagate empty tensor if input is empty', '    return kTfLiteOk;', '  }']}",True,"TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `EmbeddingLookup` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/e4b29809543b250bc9b19678ec4776299dd569ba/tensorflow/lite/kernels/embedding_lookup.cc#L73-L74). An attacker can craft a model such that the first dimension of the `value` input is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",2.5,LOW,0,test,2021-04-28T19:57:00Z,3
CVE-2021-29597,['CWE-369'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Prevent division by 0

PiperOrigin-RevId: 370984990
Change-Id: Ib324955bbeb1cbd97c82fd5d61a00a2697c9a2de",6d36ba65577006affb272335b7c1abd829010708,https://github.com/tensorflow/tensorflow/commit/6d36ba65577006affb272335b7c1abd829010708,tensorflow/lite/kernels/space_to_batch_nd.cc,ResizeOutputTensor,"TfLiteStatus ResizeOutputTensor(TfLiteContext* context,
SpaceToBatchNDContext* op_context) {
TfLiteIntArray* input_size = op_context->input->dims;
const int32* block_shape = GetTensorData<int32>(op_context->block_shape);
const int32* paddings_data = GetTensorData<int32>(op_context->paddings);
int spatial_dims_num = input_size->size - 2;
TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->block_shape), 1);
TF_LITE_ENSURE_EQ(context, op_context->block_shape->dims->data[0],
spatial_dims_num);
TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->paddings), 2);
TF_LITE_ENSURE_EQ(context, op_context->paddings->dims->data[0],
spatial_dims_num);
TF_LITE_ENSURE_EQ(context, op_context->paddings->dims->data[1], 2);
TfLiteIntArray* output_size = TfLiteIntArrayCopy(input_size);
int output_batch_size = input_size->data[0];
for (int dim = 0; dim < spatial_dims_num; ++dim) {
int final_dim_size = (input_size->data[dim + 1] + paddings_data[dim * 2] +
paddings_data[dim * 2 + 1]);
TF_LITE_ENSURE_EQ(context, final_dim_size % block_shape[dim], 0);
output_size->data[dim + 1] = final_dim_size / block_shape[dim];
output_batch_size *= block_shape[dim];
}
output_size->data[0] = output_batch_size;
output_size->data[input_size->size - 1] =
input_size->data[input_size->size - 1];
return context->ResizeTensor(context, op_context->output, output_size);
}","TfLiteStatus ResizeOutputTensor(TfLiteContext* VAR_0,
SpaceToBatchNDContext* VAR_1) {
TfLiteIntArray* VAR_2 = VAR_1->input->dims;
const int32* VAR_3 = VAR_4<int32>(VAR_1->block_shape);
const int32* VAR_5 = VAR_4<int32>(VAR_1->paddings);
int VAR_6 = VAR_2->size - 2;
TF_LITE_ENSURE_EQ(VAR_0, NumDimensions(VAR_1->block_shape), 1);
TF_LITE_ENSURE_EQ(VAR_0, VAR_1->block_shape->dims->data[0],
VAR_6);
TF_LITE_ENSURE_EQ(VAR_0, NumDimensions(VAR_1->paddings), 2);
TF_LITE_ENSURE_EQ(VAR_0, VAR_1->paddings->dims->data[0],
VAR_6);
TF_LITE_ENSURE_EQ(VAR_0, VAR_1->paddings->dims->data[1], 2);
TfLiteIntArray* VAR_7 = TfLiteIntArrayCopy(VAR_2);
int VAR_8 = VAR_2->data[0];
for (int VAR_9 = 0; VAR_9 < VAR_6; ++VAR_9) {
int VAR_10 = (VAR_2->data[VAR_9 + 1] + VAR_5[VAR_9 * 2] +
VAR_5[VAR_9 * 2 + 1]);
TF_LITE_ENSURE_EQ(VAR_0, VAR_10 % VAR_3[VAR_9], 0);
VAR_7->data[VAR_9 + 1] = VAR_10 / VAR_3[VAR_9];
VAR_8 *= VAR_3[VAR_9];
}
VAR_7->data[0] = VAR_8;
VAR_7->data[VAR_2->size - 1] =
VAR_2->data[VAR_2->size - 1];
return VAR_0->ResizeTensor(VAR_0, VAR_1->output, VAR_7);
}",tensorflow/6d36ba65577006affb272335b7c1abd829010708/space_to_batch_nd.cc/vul/before/0.json,"TfLiteStatus ResizeOutputTensor(TfLiteContext* context,
                                SpaceToBatchNDContext* op_context) {
  TfLiteIntArray* input_size = op_context->input->dims;
  const int32* block_shape = GetTensorData<int32>(op_context->block_shape);
  const int32* paddings_data = GetTensorData<int32>(op_context->paddings);

  int spatial_dims_num = input_size->size - 2;
  // Block_shape should be a 1D tensor with dimension [spatial_dims_num].
  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->block_shape), 1);
  TF_LITE_ENSURE_EQ(context, op_context->block_shape->dims->data[0],
                    spatial_dims_num);
  // Paddings should be a 2D tensor with dimension [spatial_dims_num, 2].
  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->paddings), 2);
  TF_LITE_ENSURE_EQ(context, op_context->paddings->dims->data[0],
                    spatial_dims_num);
  TF_LITE_ENSURE_EQ(context, op_context->paddings->dims->data[1], 2);

  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input_size);

  // Ensures the input height and width (with padding) is a multiple of block
  // shape height and width.
  int output_batch_size = input_size->data[0];
  for (int dim = 0; dim < spatial_dims_num; ++dim) {
    int final_dim_size = (input_size->data[dim + 1] + paddings_data[dim * 2] +
                          paddings_data[dim * 2 + 1]);
    TF_LITE_ENSURE(context, block_shape[dim] != 0);
    TF_LITE_ENSURE_EQ(context, final_dim_size % block_shape[dim], 0);
    output_size->data[dim + 1] = final_dim_size / block_shape[dim];
    output_batch_size *= block_shape[dim];
  }

  output_size->data[0] = output_batch_size;
  output_size->data[input_size->size - 1] =
      input_size->data[input_size->size - 1];

  return context->ResizeTensor(context, op_context->output, output_size);
}","TfLiteStatus ResizeOutputTensor(TfLiteContext* VAR_0,
                                SpaceToBatchNDContext* VAR_1) {
  TfLiteIntArray* VAR_2 = VAR_1->input->dims;
  const int32* VAR_3 = VAR_4<int32>(VAR_1->block_shape);
  const int32* VAR_5 = VAR_4<int32>(VAR_1->paddings);

  int VAR_6 = VAR_2->size - 2;
  /* COMMENT_0 */
  TF_LITE_ENSURE_EQ(VAR_0, NumDimensions(VAR_1->block_shape), 1);
  TF_LITE_ENSURE_EQ(VAR_0, VAR_1->block_shape->dims->data[0],
                    VAR_6);
  /* COMMENT_1 */
  TF_LITE_ENSURE_EQ(VAR_0, NumDimensions(VAR_1->paddings), 2);
  TF_LITE_ENSURE_EQ(VAR_0, VAR_1->paddings->dims->data[0],
                    VAR_6);
  TF_LITE_ENSURE_EQ(VAR_0, VAR_1->paddings->dims->data[1], 2);

  TfLiteIntArray* VAR_7 = TfLiteIntArrayCopy(VAR_2);

  /* COMMENT_2 */
  /* COMMENT_3 */
  int VAR_8 = VAR_2->data[0];
  for (int VAR_9 = 0; VAR_9 < VAR_6; ++VAR_9) {
    int VAR_10 = (VAR_2->data[VAR_9 + 1] + VAR_5[VAR_9 * 2] +
                          VAR_5[VAR_9 * 2 + 1]);
    TF_LITE_ENSURE(VAR_0, VAR_3[VAR_9] != 0);
    TF_LITE_ENSURE_EQ(VAR_0, VAR_10 % VAR_3[VAR_9], 0);
    VAR_7->data[VAR_9 + 1] = VAR_10 / VAR_3[VAR_9];
    VAR_8 *= VAR_3[VAR_9];
  }

  VAR_7->data[0] = VAR_8;
  VAR_7->data[VAR_2->size - 1] =
      VAR_2->data[VAR_2->size - 1];

  return VAR_0->ResizeTensor(VAR_0, VAR_1->output, VAR_7);
}",tensorflow/6d36ba65577006affb272335b7c1abd829010708/space_to_batch_nd.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -23,6 +23,7 @@
   for (int dim = 0; dim < spatial_dims_num; ++dim) {
     int final_dim_size = (input_size->data[dim + 1] + paddings_data[dim * 2] +
                           paddings_data[dim * 2 + 1]);
+    TF_LITE_ENSURE(context, block_shape[dim] != 0);
     TF_LITE_ENSURE_EQ(context, final_dim_size % block_shape[dim], 0);
     output_size->data[dim + 1] = final_dim_size / block_shape[dim];
     output_batch_size *= block_shape[dim];","{'deleted_lines': [], 'added_lines': ['    TF_LITE_ENSURE(context, block_shape[dim] != 0);']}",True,"TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `SpaceToBatchNd` TFLite operator is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/412c7d9bb8f8a762c5b266c9e73bfa165f29aac8/tensorflow/lite/kernels/space_to_batch_nd.cc#L82-L83). An attacker can craft a model such that one dimension of the `block` input is 0. Hence, the corresponding value in `block_shape` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",2.5,LOW,0,test,2021-04-28T21:22:30Z,3
CVE-2021-29558,['CWE-787'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Fix heap-buffer-overflow issue with `tf.raw_ops.SparseSplit`.

PiperOrigin-RevId: 371242872
Change-Id: I482bb3d12602c7c3cc9446f97fb9f584bb98e9a4",8ba6fa29cd8bf9cef9b718dc31c78c73081f5b31,https://github.com/tensorflow/tensorflow/commit/8ba6fa29cd8bf9cef9b718dc31c78c73081f5b31,tensorflow/core/util/sparse/sparse_tensor.h,SparseTensor::Split,"inline Status SparseTensor::Split(const SparseTensor& input_tensor,
const int split_dim, const int num_split,
std::vector<SparseTensor>* result) {
std::vector<Tensor> output_indices;
std::vector<Tensor> output_values;
std::vector<TensorShape> output_shapes;
output_indices.reserve(num_split);
output_values.reserve(num_split);
output_shapes.reserve(num_split);
std::vector<typename TTypes<int64>::Matrix> output_indices_t;
std::vector<typename TTypes<T>::Vec> output_values_t;
output_indices_t.reserve(num_split);
output_values_t.reserve(num_split);
auto input_values_t = input_tensor.values().vec<T>();
auto input_indices_t = input_tensor.indices().matrix<int64>();
std::vector<int> num_values(num_split, 0);
const int num_dim = input_tensor.shape().size();
const int split_dim_size = input_tensor.shape()[split_dim];
const int split_size = split_dim_size / num_split;
if (!(num_split > 0 && num_split <= split_dim_size)) {
return errors::InvalidArgument(""num_split must be in the interval (0, "",
split_dim_size, ""]"");
}
if (!(split_dim >= 0 && split_dim < num_dim)) {
return errors::InvalidArgument(""num_dim must be in the interval [0, "",
num_dim, "")"");
}
const int residual = split_dim_size % num_split;
for (int i = 0; i < input_tensor.indices().dim_size(0); ++i) {
const int dim = input_tensor.indices().matrix<int64>()(i, split_dim);
int slice_index = GetSliceIndex(dim, split_size, residual);
num_values[slice_index]++;
}
for (int i = 0; i < num_split; ++i) {
output_indices.emplace_back(DT_INT64,
TensorShape({num_values[i], num_dim}));
output_values.emplace_back(DataTypeToEnum<T>::v(),
TensorShape({num_values[i]}));
output_shapes.emplace_back(input_tensor.shape());
output_indices_t.emplace_back(output_indices[i].matrix<int64>());
output_values_t.emplace_back(output_values[i].vec<T>());
const int size = GetSliceShape(i, split_size, residual);
output_shapes[i].set_dim(split_dim, size);
}
std::vector<int> values_inserted_in_slice(num_split, 0);
for (int i = 0; i < input_tensor.indices().dim_size(0); ++i) {
const int dim = input_indices_t(i, split_dim);
const int slice_index = GetSliceIndex(dim, split_size, residual);
const int slice_dim = values_inserted_in_slice[slice_index]++;
output_values_t[slice_index](slice_dim) = input_values_t(i);
for (int j = 0; j < num_dim; ++j) {
const int64 original_dim = input_indices_t(i, j);
output_indices_t[slice_index](slice_dim, j) =
(j == split_dim)
? GetDimensionInSlice(original_dim, split_size, residual)
: original_dim;
}
}
result->clear();
result->reserve(num_split);
for (int i = 0; i < num_split; ++i) {
SparseTensor tensor;
Status create_status =
Create(output_indices[i], output_values[i], output_shapes[i], &tensor);
if (!create_status.ok()) {
return create_status;
}
result->push_back(std::move(tensor));
}
return Status::OK();
}","inline Status SparseTensor::Split(const SparseTensor& VAR_0,
const int VAR_1, const int VAR_2,
std::vector<SparseTensor>* VAR_3) {
std::vector<Tensor> VAR_4;
std::vector<Tensor> VAR_5;
std::vector<TensorShape> VAR_6;
VAR_4.reserve(VAR_2);
VAR_5.reserve(VAR_2);
VAR_6.reserve(VAR_2);
std::vector<typename TTypes<int64>::Matrix> VAR_7;
std::vector<typename TTypes<T>::Vec> VAR_8;
VAR_7.reserve(VAR_2);
VAR_8.reserve(VAR_2);
auto VAR_9 = VAR_0.values().vec<T>();
auto VAR_10 = VAR_0.indices().matrix<int64>();
std::vector<int> VAR_11(VAR_2, 0);
const int VAR_12 = VAR_0.shape().size();
const int VAR_13 = VAR_0.shape()[VAR_1];
const int VAR_14 = VAR_13 / VAR_2;
if (!(VAR_2 > 0 && VAR_2 <= VAR_13)) {
return errors::InvalidArgument(""num_split must be in the interval (0, "",
VAR_13, ""]"");
}
if (!(VAR_1 >= 0 && VAR_1 < VAR_12)) {
return errors::InvalidArgument(""num_dim must be in the interval [0, "",
VAR_12, "")"");
}
const int VAR_15 = VAR_13 % VAR_2;
for (int VAR_16 = 0; VAR_16 < VAR_0.indices().dim_size(0); ++VAR_16) {
const int VAR_17 = VAR_0.indices().matrix<int64>()(VAR_16, VAR_1);
int VAR_18 = GetSliceIndex(VAR_17, VAR_14, VAR_15);
VAR_11[VAR_18]++;
}
for (int VAR_16 = 0; VAR_16 < VAR_2; ++VAR_16) {
VAR_4.emplace_back(VAR_19,
TensorShape({VAR_11[VAR_16], VAR_12}));
VAR_5.emplace_back(DataTypeToEnum<T>::v(),
TensorShape({VAR_11[VAR_16]}));
VAR_6.emplace_back(VAR_0.shape());
VAR_7.emplace_back(VAR_4[VAR_16].matrix<int64>());
VAR_8.emplace_back(VAR_5[VAR_16].vec<T>());
const int VAR_20 = GetSliceShape(VAR_16, VAR_14, VAR_15);
VAR_6[VAR_16].set_dim(VAR_1, VAR_20);
}
std::vector<int> VAR_21(VAR_2, 0);
for (int VAR_16 = 0; VAR_16 < VAR_0.indices().dim_size(0); ++VAR_16) {
const int VAR_17 = VAR_10(VAR_16, VAR_1);
const int VAR_18 = GetSliceIndex(VAR_17, VAR_14, VAR_15);
const int VAR_22 = VAR_21[VAR_18]++;
VAR_8[VAR_18](VAR_22) = VAR_9(VAR_16);
for (int VAR_23 = 0; VAR_23 < VAR_12; ++VAR_23) {
const int64 VAR_24 = VAR_10(VAR_16, VAR_23);
VAR_7[VAR_18](VAR_22, VAR_23) =
(VAR_23 == VAR_1)
? GetDimensionInSlice(VAR_24, VAR_14, VAR_15)
: VAR_24;
}
}
VAR_3->clear();
VAR_3->reserve(VAR_2);
for (int VAR_16 = 0; VAR_16 < VAR_2; ++VAR_16) {
SparseTensor VAR_25;
Status VAR_26 =
Create(VAR_4[VAR_16], VAR_5[VAR_16], VAR_6[VAR_16], &VAR_25);
if (!VAR_26.ok()) {
return VAR_26;
}
VAR_3->push_back(std::move(VAR_25));
}
return Status::OK();
}",tensorflow/8ba6fa29cd8bf9cef9b718dc31c78c73081f5b31/sparse_tensor.h/vul/before/0.json,"inline Status SparseTensor::Split(const SparseTensor& input_tensor,
                                  const int split_dim, const int num_split,
                                  std::vector<SparseTensor>* result) {
  std::vector<Tensor> output_indices;
  std::vector<Tensor> output_values;
  std::vector<TensorShape> output_shapes;
  output_indices.reserve(num_split);
  output_values.reserve(num_split);
  output_shapes.reserve(num_split);

  std::vector<typename TTypes<int64>::Matrix> output_indices_t;
  std::vector<typename TTypes<T>::Vec> output_values_t;
  output_indices_t.reserve(num_split);
  output_values_t.reserve(num_split);
  auto input_values_t = input_tensor.values().vec<T>();
  auto input_indices_t = input_tensor.indices().matrix<int64>();

  std::vector<int> num_values(num_split, 0);
  const int num_dim = input_tensor.shape().size();
  const int split_dim_size = input_tensor.shape()[split_dim];
  const int split_size = split_dim_size / num_split;

  if (!(num_split > 0 && num_split <= split_dim_size)) {
    return errors::InvalidArgument(""num_split must be in the interval (0, "",
                                   split_dim_size, ""]"");
  }
  if (!(split_dim >= 0 && split_dim < num_dim)) {
    return errors::InvalidArgument(""num_dim must be in the interval [0, "",
                                   num_dim, "")"");
  }

  const int residual = split_dim_size % num_split;
  for (int i = 0; i < input_tensor.indices().dim_size(0); ++i) {
    const int dim = input_tensor.indices().matrix<int64>()(i, split_dim);
    int slice_index = GetSliceIndex(dim, split_size, residual);
    if (slice_index >= num_values.size()) {
      return errors::InvalidArgument(""Slice index "", slice_index,
                                     "" is larger than num_split."");
    }
    num_values[slice_index]++;
  }

  for (int i = 0; i < num_split; ++i) {
    // TODO(ataei): Pass an allocator to avoid allocating large memory buffer.
    output_indices.emplace_back(DT_INT64,
                                TensorShape({num_values[i], num_dim}));
    output_values.emplace_back(DataTypeToEnum<T>::v(),
                               TensorShape({num_values[i]}));
    output_shapes.emplace_back(input_tensor.shape());
    output_indices_t.emplace_back(output_indices[i].matrix<int64>());
    output_values_t.emplace_back(output_values[i].vec<T>());
    const int size = GetSliceShape(i, split_size, residual);
    output_shapes[i].set_dim(split_dim, size);
  }

  std::vector<int> values_inserted_in_slice(num_split, 0);
  for (int i = 0; i < input_tensor.indices().dim_size(0); ++i) {
    const int dim = input_indices_t(i, split_dim);
    const int slice_index = GetSliceIndex(dim, split_size, residual);
    const int slice_dim = values_inserted_in_slice[slice_index]++;
    output_values_t[slice_index](slice_dim) = input_values_t(i);
    for (int j = 0; j < num_dim; ++j) {
      const int64 original_dim = input_indices_t(i, j);
      output_indices_t[slice_index](slice_dim, j) =
          (j == split_dim)
              ? GetDimensionInSlice(original_dim, split_size, residual)
              : original_dim;
    }
  }

  result->clear();
  result->reserve(num_split);
  for (int i = 0; i < num_split; ++i) {
    SparseTensor tensor;
    Status create_status =
        Create(output_indices[i], output_values[i], output_shapes[i], &tensor);
    if (!create_status.ok()) {
      return create_status;
    }
    result->push_back(std::move(tensor));
  }
  return Status::OK();
}","inline Status SparseTensor::Split(const SparseTensor& VAR_0,
                                  const int VAR_1, const int VAR_2,
                                  std::vector<SparseTensor>* VAR_3) {
  std::vector<Tensor> VAR_4;
  std::vector<Tensor> VAR_5;
  std::vector<TensorShape> VAR_6;
  VAR_4.reserve(VAR_2);
  VAR_5.reserve(VAR_2);
  VAR_6.reserve(VAR_2);

  std::vector<typename TTypes<int64>::Matrix> VAR_7;
  std::vector<typename TTypes<T>::Vec> VAR_8;
  VAR_7.reserve(VAR_2);
  VAR_8.reserve(VAR_2);
  auto VAR_9 = VAR_0.values().vec<T>();
  auto VAR_10 = VAR_0.indices().matrix<int64>();

  std::vector<int> VAR_11(VAR_2, 0);
  const int VAR_12 = VAR_0.shape().size();
  const int VAR_13 = VAR_0.shape()[VAR_1];
  const int VAR_14 = VAR_13 / VAR_2;

  if (!(VAR_2 > 0 && VAR_2 <= VAR_13)) {
    return errors::InvalidArgument(""num_split must be in the interval (0, "",
                                   VAR_13, ""]"");
  }
  if (!(VAR_1 >= 0 && VAR_1 < VAR_12)) {
    return errors::InvalidArgument(""num_dim must be in the interval [0, "",
                                   VAR_12, "")"");
  }

  const int VAR_15 = VAR_13 % VAR_2;
  for (int VAR_16 = 0; VAR_16 < VAR_0.indices().dim_size(0); ++VAR_16) {
    const int VAR_17 = VAR_0.indices().matrix<int64>()(VAR_16, VAR_1);
    int VAR_18 = GetSliceIndex(VAR_17, VAR_14, VAR_15);
    if (VAR_18 >= VAR_11.size()) {
      return errors::InvalidArgument(""Slice index "", VAR_18,
                                     "" is larger than num_split."");
    }
    VAR_11[VAR_18]++;
  }

  for (int VAR_16 = 0; VAR_16 < VAR_2; ++VAR_16) {
    /* COMMENT_0 */
    VAR_4.emplace_back(VAR_19,
                                TensorShape({VAR_11[VAR_16], VAR_12}));
    VAR_5.emplace_back(DataTypeToEnum<T>::v(),
                               TensorShape({VAR_11[VAR_16]}));
    VAR_6.emplace_back(VAR_0.shape());
    VAR_7.emplace_back(VAR_4[VAR_16].matrix<int64>());
    VAR_8.emplace_back(VAR_5[VAR_16].vec<T>());
    const int VAR_20 = GetSliceShape(VAR_16, VAR_14, VAR_15);
    VAR_6[VAR_16].set_dim(VAR_1, VAR_20);
  }

  std::vector<int> VAR_21(VAR_2, 0);
  for (int VAR_16 = 0; VAR_16 < VAR_0.indices().dim_size(0); ++VAR_16) {
    const int VAR_17 = VAR_10(VAR_16, VAR_1);
    const int VAR_18 = GetSliceIndex(VAR_17, VAR_14, VAR_15);
    const int VAR_22 = VAR_21[VAR_18]++;
    VAR_8[VAR_18](VAR_22) = VAR_9(VAR_16);
    for (int VAR_23 = 0; VAR_23 < VAR_12; ++VAR_23) {
      const int64 VAR_24 = VAR_10(VAR_16, VAR_23);
      VAR_7[VAR_18](VAR_22, VAR_23) =
          (VAR_23 == VAR_1)
              ? GetDimensionInSlice(VAR_24, VAR_14, VAR_15)
              : VAR_24;
    }
  }

  VAR_3->clear();
  VAR_3->reserve(VAR_2);
  for (int VAR_16 = 0; VAR_16 < VAR_2; ++VAR_16) {
    SparseTensor VAR_25;
    Status VAR_26 =
        Create(VAR_4[VAR_16], VAR_5[VAR_16], VAR_6[VAR_16], &VAR_25);
    if (!VAR_26.ok()) {
      return VAR_26;
    }
    VAR_3->push_back(std::move(VAR_25));
  }
  return Status::OK();
}",tensorflow/8ba6fa29cd8bf9cef9b718dc31c78c73081f5b31/sparse_tensor.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -33,6 +33,10 @@
   for (int i = 0; i < input_tensor.indices().dim_size(0); ++i) {
     const int dim = input_tensor.indices().matrix<int64>()(i, split_dim);
     int slice_index = GetSliceIndex(dim, split_size, residual);
+    if (slice_index >= num_values.size()) {
+      return errors::InvalidArgument(""Slice index "", slice_index,
+                                     "" is larger than num_split."");
+    }
     num_values[slice_index]++;
   }
 ","{'deleted_lines': [], 'added_lines': ['    if (slice_index >= num_values.size()) {', '      return errors::InvalidArgument(""Slice index "", slice_index,', '                                     "" is larger than num_split."");', '    }']}",True,"TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.SparseSplit`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/699bff5d961f0abfde8fa3f876e6d241681fbef8/tensorflow/core/util/sparse/sparse_tensor.h#L528-L530) accesses an array element based on a user controlled offset. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",2.5,LOW,0,test,2021-04-30T00:58:08Z,3
CVE-2021-29563,['CWE-617'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,tensorflow,"Prevent check fail in FFT

PiperOrigin-RevId: 372031044
Change-Id: I50994e3e8a5d1342d01bde80256f6bf2730ca299",31bd5026304677faa8a0b77602c6154171b9aec1,https://github.com/tensorflow/tensorflow/commit/31bd5026304677faa8a0b77602c6154171b9aec1,tensorflow/core/kernels/fft_ops.cc,DoRealForwardFFT,"void DoRealForwardFFT(OpKernelContext* ctx, uint64* fft_shape,
const Tensor& in, Tensor* out) {
const auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);
auto device = ctx->eigen_device<CPUDevice>();
auto input = Tensor(in).flat_inner_dims<RealT, FFTRank + 1>();
const auto input_dims = input.dimensions();
Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes;
input_slice_sizes[0] = input_dims[0];
TensorShape temp_shape{input_dims[0]};
for (int i = 1; i <= FFTRank; ++i) {
input_slice_sizes[i] = fft_shape[i - 1];
temp_shape.AddDim(fft_shape[i - 1]);
}
auto output = out->flat_inner_dims<ComplexT, FFTRank + 1>();
const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> zero_start_indices;
Tensor temp;
OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(),
temp_shape, &temp));
auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>();
full_fft.device(device) =
input.slice(zero_start_indices, input_slice_sizes)
.template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes);
output.device(device) =
full_fft.slice(zero_start_indices, output.dimensions());
}","void DoRealForwardFFT(OpKernelContext* VAR_0, uint64* VAR_1,
const Tensor& VAR_2, Tensor* VAR_3) {
const auto VAR_4 = Eigen::ArrayXi::LinSpaced(VAR_5, 1, VAR_5);
auto VAR_6 = VAR_0->eigen_device<CPUDevice>();
auto VAR_7 = Tensor(VAR_2).flat_inner_dims<RealT, VAR_5 + 1>();
const auto VAR_8 = VAR_7.dimensions();
Eigen::DSizes<Eigen::DenseIndex, VAR_5 + 1> VAR_9;
VAR_9[0] = VAR_8[0];
TensorShape VAR_10{VAR_8[0]};
for (int VAR_11 = 1; VAR_11 <= VAR_5; ++VAR_11) {
VAR_9[VAR_11] = VAR_1[VAR_11 - 1];
VAR_10.AddDim(VAR_1[VAR_11 - 1]);
}
auto VAR_12 = VAR_3->flat_inner_dims<ComplexT, VAR_5 + 1>();
const Eigen::DSizes<Eigen::DenseIndex, VAR_5 + 1> VAR_13;
Tensor VAR_14;
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_temp(DataTypeToEnum<ComplexT>::v(),
VAR_10, &VAR_14));
auto VAR_15 = VAR_14.flat_inner_dims<ComplexT, VAR_5 + 1>();
VAR_15.device(VAR_6) =
VAR_7.slice(VAR_13, VAR_9)
.template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(VAR_4);
VAR_12.device(VAR_6) =
VAR_15.slice(VAR_13, VAR_12.dimensions());
}",tensorflow/31bd5026304677faa8a0b77602c6154171b9aec1/fft_ops.cc/vul/before/0.json,"void DoRealForwardFFT(OpKernelContext* ctx, uint64* fft_shape,
                        const Tensor& in, Tensor* out) {
    // Create the axes (which are always trailing).
    const auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);
    auto device = ctx->eigen_device<CPUDevice>();
    auto input = Tensor(in).flat_inner_dims<RealT, FFTRank + 1>();
    const auto input_dims = input.dimensions();

    // Slice input to fft_shape on its inner-most dimensions.
    Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes;
    input_slice_sizes[0] = input_dims[0];
    TensorShape temp_shape{input_dims[0]};
    for (int i = 1; i <= FFTRank; ++i) {
      input_slice_sizes[i] = fft_shape[i - 1];
      temp_shape.AddDim(fft_shape[i - 1]);
    }
    OP_REQUIRES(ctx, temp_shape.num_elements() > 0,
                errors::InvalidArgument(""Obtained a FFT shape of 0 elements: "",
                                        temp_shape.DebugString()));

    auto output = out->flat_inner_dims<ComplexT, FFTRank + 1>();
    const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> zero_start_indices;

    // Compute the full FFT using a temporary tensor.
    Tensor temp;
    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(),
                                           temp_shape, &temp));
    auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>();
    full_fft.device(device) =
        input.slice(zero_start_indices, input_slice_sizes)
            .template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes);

    // Slice away the negative frequency components.
    output.device(device) =
        full_fft.slice(zero_start_indices, output.dimensions());
  }","void DoRealForwardFFT(OpKernelContext* VAR_0, uint64* VAR_1,
                        const Tensor& VAR_2, Tensor* VAR_3) {
    /* COMMENT_0 */
    const auto VAR_4 = Eigen::ArrayXi::LinSpaced(VAR_5, 1, VAR_5);
    auto VAR_6 = VAR_0->eigen_device<CPUDevice>();
    auto VAR_7 = Tensor(VAR_2).flat_inner_dims<RealT, VAR_5 + 1>();
    const auto VAR_8 = VAR_7.dimensions();

    /* COMMENT_1 */
    Eigen::DSizes<Eigen::DenseIndex, VAR_5 + 1> VAR_9;
    VAR_9[0] = VAR_8[0];
    TensorShape VAR_10{VAR_8[0]};
    for (int VAR_11 = 1; VAR_11 <= VAR_5; ++VAR_11) {
      VAR_9[VAR_11] = VAR_1[VAR_11 - 1];
      VAR_10.AddDim(VAR_1[VAR_11 - 1]);
    }
    OP_REQUIRES(VAR_0, VAR_10.num_elements() > 0,
                errors::InvalidArgument(""Obtained a FFT shape of 0 elements: "",
                                        VAR_10.DebugString()));

    auto VAR_12 = VAR_3->flat_inner_dims<ComplexT, VAR_5 + 1>();
    const Eigen::DSizes<Eigen::DenseIndex, VAR_5 + 1> VAR_13;

    /* COMMENT_2 */
    Tensor VAR_14;
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_temp(DataTypeToEnum<ComplexT>::v(),
                                           VAR_10, &VAR_14));
    auto VAR_15 = VAR_14.flat_inner_dims<ComplexT, VAR_5 + 1>();
    VAR_15.device(VAR_6) =
        VAR_7.slice(VAR_13, VAR_9)
            .template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(VAR_4);

    /* COMMENT_3 */
    VAR_12.device(VAR_6) =
        VAR_15.slice(VAR_13, VAR_12.dimensions());
  }",tensorflow/31bd5026304677faa8a0b77602c6154171b9aec1/fft_ops.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,6 +14,9 @@
       input_slice_sizes[i] = fft_shape[i - 1];
       temp_shape.AddDim(fft_shape[i - 1]);
     }
+    OP_REQUIRES(ctx, temp_shape.num_elements() > 0,
+                errors::InvalidArgument(""Obtained a FFT shape of 0 elements: "",
+                                        temp_shape.DebugString()));
 
     auto output = out->flat_inner_dims<ComplexT, FFTRank + 1>();
     const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> zero_start_indices;","{'deleted_lines': [], 'added_lines': ['    OP_REQUIRES(ctx, temp_shape.num_elements() > 0,', '                errors::InvalidArgument(""Obtained a FFT shape of 0 elements: "",', '                                        temp_shape.DebugString()));']}",True,"TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from the implementation of `tf.raw_ops.RFFT`. Eigen code operating on an empty matrix can trigger on an assertion and will cause program termination. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",2.5,LOW,0,test,2021-05-05T00:42:54Z,3
CVE-2021-29572,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,tensorflow,"Add several missing validations in SDCA

PiperOrigin-RevId: 372172877
Change-Id: Id366da962432e18dcbfac847d11e98488bebb70a",f7cc8755ac6683131fdfa7a8a121f9d7a9dec6fb,https://github.com/tensorflow/tensorflow/commit/f7cc8755ac6683131fdfa7a8a121f9d7a9dec6fb,tensorflow/core/kernels/sdca_internal.cc,Examples::Initialize,"Status Examples::Initialize(OpKernelContext* const context,
const ModelWeights& weights,
const int num_sparse_features,
const int num_sparse_features_with_values,
const int num_dense_features) {
num_features_ = num_sparse_features + num_dense_features;
OpInputList sparse_example_indices_inputs;
TF_RETURN_IF_ERROR(context->input_list(""sparse_example_indices"",
&sparse_example_indices_inputs));
OpInputList sparse_feature_indices_inputs;
TF_RETURN_IF_ERROR(context->input_list(""sparse_feature_indices"",
&sparse_feature_indices_inputs));
OpInputList sparse_feature_values_inputs;
if (num_sparse_features_with_values > 0) {
TF_RETURN_IF_ERROR(context->input_list(""sparse_feature_values"",
&sparse_feature_values_inputs));
}
const Tensor* example_weights_t;
TF_RETURN_IF_ERROR(context->input(""example_weights"", &example_weights_t));
auto example_weights = example_weights_t->flat<float>();
if (example_weights.size() >= std::numeric_limits<int>::max()) {
return errors::InvalidArgument(strings::Printf(
""Too many examples in a mini-batch: %zu > %d"", example_weights.size(),
std::numeric_limits<int>::max()));
}
const int num_examples = static_cast<int>(example_weights.size());
const Tensor* example_labels_t;
TF_RETURN_IF_ERROR(context->input(""example_labels"", &example_labels_t));
auto example_labels = example_labels_t->flat<float>();
OpInputList dense_features_inputs;
TF_RETURN_IF_ERROR(
context->input_list(""dense_features"", &dense_features_inputs));
examples_.clear();
examples_.resize(num_examples);
probabilities_.resize(num_examples);
sampled_index_.resize(num_examples);
sampled_count_.resize(num_examples);
for (int example_id = 0; example_id < num_examples; ++example_id) {
Example* const example = &examples_[example_id];
example->sparse_features_.resize(num_sparse_features);
example->dense_vectors_.resize(num_dense_features);
example->example_weight_ = example_weights(example_id);
example->example_label_ = example_labels(example_id);
}
const DeviceBase::CpuWorkerThreads& worker_threads =
*context->device()->tensorflow_cpu_worker_threads();
TF_RETURN_IF_ERROR(CreateSparseFeatureRepresentation(
worker_threads, num_examples, num_sparse_features, weights,
sparse_example_indices_inputs, sparse_feature_indices_inputs,
sparse_feature_values_inputs, &examples_));
TF_RETURN_IF_ERROR(CreateDenseFeatureRepresentation(
worker_threads, num_examples, num_dense_features, weights,
dense_features_inputs, &examples_));
TF_RETURN_IF_ERROR(ComputeSquaredNormPerExample(
worker_threads, num_examples, num_sparse_features, num_dense_features,
&examples_));
return Status::OK();
}","Status Examples::Initialize(OpKernelContext* const VAR_0,
const ModelWeights& VAR_1,
const int VAR_2,
const int VAR_3,
const int VAR_4) {
VAR_5 = VAR_2 + VAR_4;
OpInputList VAR_6;
TF_RETURN_IF_ERROR(VAR_0->input_list(""sparse_example_indices"",
&VAR_6));
OpInputList VAR_7;
TF_RETURN_IF_ERROR(VAR_0->input_list(""sparse_feature_indices"",
&VAR_7));
OpInputList VAR_8;
if (VAR_3 > 0) {
TF_RETURN_IF_ERROR(VAR_0->input_list(""sparse_feature_values"",
&VAR_8));
}
const Tensor* VAR_9;
TF_RETURN_IF_ERROR(VAR_0->input(""example_weights"", &VAR_9));
auto VAR_10 = VAR_9->flat<float>();
if (VAR_10.size() >= std::numeric_limits<int>::max()) {
return errors::InvalidArgument(strings::Printf(
""Too many examples in a mini-batch: %zu > %d"", VAR_10.size(),
std::numeric_limits<int>::max()));
}
const int VAR_11 = VAR_12<int>(VAR_10.size());
const Tensor* VAR_13;
TF_RETURN_IF_ERROR(VAR_0->input(""example_labels"", &VAR_13));
auto VAR_14 = VAR_13->flat<float>();
OpInputList VAR_15;
TF_RETURN_IF_ERROR(
VAR_0->input_list(""dense_features"", &VAR_15));
VAR_16.clear();
VAR_16.resize(VAR_11);
VAR_17.resize(VAR_11);
VAR_18.resize(VAR_11);
VAR_19.resize(VAR_11);
for (int VAR_20 = 0; VAR_20 < VAR_11; ++VAR_20) {
Example* const VAR_21 = &VAR_16[VAR_20];
VAR_21->sparse_features_.resize(VAR_2);
VAR_21->dense_vectors_.resize(VAR_4);
VAR_21->example_weight_ = VAR_10(VAR_20);
VAR_21->example_label_ = VAR_14(VAR_20);
}
const DeviceBase::CpuWorkerThreads& VAR_22 =
*VAR_0->device()->tensorflow_cpu_worker_threads();
TF_RETURN_IF_ERROR(CreateSparseFeatureRepresentation(
VAR_22, VAR_11, VAR_2, VAR_1,
VAR_6, VAR_7,
VAR_8, &VAR_16));
TF_RETURN_IF_ERROR(CreateDenseFeatureRepresentation(
VAR_22, VAR_11, VAR_4, VAR_1,
VAR_15, &VAR_16));
TF_RETURN_IF_ERROR(ComputeSquaredNormPerExample(
VAR_22, VAR_11, VAR_2, VAR_4,
&VAR_16));
return Status::OK();
}",tensorflow/f7cc8755ac6683131fdfa7a8a121f9d7a9dec6fb/sdca_internal.cc/vul/before/1.json,"Status Examples::Initialize(OpKernelContext* const context,
                            const ModelWeights& weights,
                            const int num_sparse_features,
                            const int num_sparse_features_with_values,
                            const int num_dense_features) {
  num_features_ = num_sparse_features + num_dense_features;

  OpInputList sparse_example_indices_inputs;
  TF_RETURN_IF_ERROR(context->input_list(""sparse_example_indices"",
                                         &sparse_example_indices_inputs));
  if (sparse_example_indices_inputs.size() != num_sparse_features)
    return errors::InvalidArgument(
        ""Expected "", num_sparse_features,
        "" tensors in sparse_example_indices but got "",
        sparse_example_indices_inputs.size());
  OpInputList sparse_feature_indices_inputs;
  TF_RETURN_IF_ERROR(context->input_list(""sparse_feature_indices"",
                                         &sparse_feature_indices_inputs));
  if (sparse_feature_indices_inputs.size() != num_sparse_features)
    return errors::InvalidArgument(
        ""Expected "", num_sparse_features,
        "" tensors in sparse_feature_indices but got "",
        sparse_feature_indices_inputs.size());
  OpInputList sparse_feature_values_inputs;
  if (num_sparse_features_with_values > 0) {
    TF_RETURN_IF_ERROR(context->input_list(""sparse_feature_values"",
                                           &sparse_feature_values_inputs));
    if (sparse_feature_values_inputs.size() != num_sparse_features_with_values)
      return errors::InvalidArgument(
          ""Expected "", num_sparse_features_with_values,
          "" tensors in sparse_feature_values but got "",
          sparse_feature_values_inputs.size());
  }

  const Tensor* example_weights_t;
  TF_RETURN_IF_ERROR(context->input(""example_weights"", &example_weights_t));
  auto example_weights = example_weights_t->flat<float>();

  if (example_weights.size() >= std::numeric_limits<int>::max()) {
    return errors::InvalidArgument(strings::Printf(
        ""Too many examples in a mini-batch: %zu > %d"", example_weights.size(),
        std::numeric_limits<int>::max()));
  }

  // The static_cast here is safe since num_examples can be at max an int.
  const int num_examples = static_cast<int>(example_weights.size());
  const Tensor* example_labels_t;
  TF_RETURN_IF_ERROR(context->input(""example_labels"", &example_labels_t));
  auto example_labels = example_labels_t->flat<float>();

  OpInputList dense_features_inputs;
  TF_RETURN_IF_ERROR(
      context->input_list(""dense_features"", &dense_features_inputs));

  examples_.clear();
  examples_.resize(num_examples);
  probabilities_.resize(num_examples);
  sampled_index_.resize(num_examples);
  sampled_count_.resize(num_examples);
  for (int example_id = 0; example_id < num_examples; ++example_id) {
    Example* const example = &examples_[example_id];
    example->sparse_features_.resize(num_sparse_features);
    example->dense_vectors_.resize(num_dense_features);
    example->example_weight_ = example_weights(example_id);
    example->example_label_ = example_labels(example_id);
  }
  const DeviceBase::CpuWorkerThreads& worker_threads =
      *context->device()->tensorflow_cpu_worker_threads();
  TF_RETURN_IF_ERROR(CreateSparseFeatureRepresentation(
      worker_threads, num_examples, num_sparse_features, weights,
      sparse_example_indices_inputs, sparse_feature_indices_inputs,
      sparse_feature_values_inputs, &examples_));
  TF_RETURN_IF_ERROR(CreateDenseFeatureRepresentation(
      worker_threads, num_examples, num_dense_features, weights,
      dense_features_inputs, &examples_));
  TF_RETURN_IF_ERROR(ComputeSquaredNormPerExample(
      worker_threads, num_examples, num_sparse_features, num_dense_features,
      &examples_));
  return Status::OK();
}","Status Examples::Initialize(OpKernelContext* const VAR_0,
                            const ModelWeights& VAR_1,
                            const int VAR_2,
                            const int VAR_3,
                            const int VAR_4) {
  VAR_5 = VAR_2 + VAR_4;

  OpInputList VAR_6;
  TF_RETURN_IF_ERROR(VAR_0->input_list(""sparse_example_indices"",
                                         &VAR_6));
  if (VAR_6.size() != VAR_2)
    return errors::InvalidArgument(
        ""Expected "", VAR_2,
        "" tensors in sparse_example_indices but got "",
        VAR_6.size());
  OpInputList VAR_7;
  TF_RETURN_IF_ERROR(VAR_0->input_list(""sparse_feature_indices"",
                                         &VAR_7));
  if (VAR_7.size() != VAR_2)
    return errors::InvalidArgument(
        ""Expected "", VAR_2,
        "" tensors in sparse_feature_indices but got "",
        VAR_7.size());
  OpInputList VAR_8;
  if (VAR_3 > 0) {
    TF_RETURN_IF_ERROR(VAR_0->input_list(""sparse_feature_values"",
                                           &VAR_8));
    if (VAR_8.size() != VAR_3)
      return errors::InvalidArgument(
          ""Expected "", VAR_3,
          "" tensors in sparse_feature_values but got "",
          VAR_8.size());
  }

  const Tensor* VAR_9;
  TF_RETURN_IF_ERROR(VAR_0->input(""example_weights"", &VAR_9));
  auto VAR_10 = VAR_9->flat<float>();

  if (VAR_10.size() >= std::numeric_limits<int>::max()) {
    return errors::InvalidArgument(strings::Printf(
        ""Too many examples in a mini-batch: %zu > %d"", VAR_10.size(),
        std::numeric_limits<int>::max()));
  }

  /* COMMENT_0 */
  const int VAR_11 = VAR_12<int>(VAR_10.size());
  const Tensor* VAR_13;
  TF_RETURN_IF_ERROR(VAR_0->input(""example_labels"", &VAR_13));
  auto VAR_14 = VAR_13->flat<float>();

  OpInputList VAR_15;
  TF_RETURN_IF_ERROR(
      VAR_0->input_list(""dense_features"", &VAR_15));

  VAR_16.clear();
  VAR_16.resize(VAR_11);
  VAR_17.resize(VAR_11);
  VAR_18.resize(VAR_11);
  VAR_19.resize(VAR_11);
  for (int VAR_20 = 0; VAR_20 < VAR_11; ++VAR_20) {
    Example* const VAR_21 = &VAR_16[VAR_20];
    VAR_21->sparse_features_.resize(VAR_2);
    VAR_21->dense_vectors_.resize(VAR_4);
    VAR_21->example_weight_ = VAR_10(VAR_20);
    VAR_21->example_label_ = VAR_14(VAR_20);
  }
  const DeviceBase::CpuWorkerThreads& VAR_22 =
      *VAR_0->device()->tensorflow_cpu_worker_threads();
  TF_RETURN_IF_ERROR(CreateSparseFeatureRepresentation(
      VAR_22, VAR_11, VAR_2, VAR_1,
      VAR_6, VAR_7,
      VAR_8, &VAR_16));
  TF_RETURN_IF_ERROR(CreateDenseFeatureRepresentation(
      VAR_22, VAR_11, VAR_4, VAR_1,
      VAR_15, &VAR_16));
  TF_RETURN_IF_ERROR(ComputeSquaredNormPerExample(
      VAR_22, VAR_11, VAR_2, VAR_4,
      &VAR_16));
  return Status::OK();
}",tensorflow/f7cc8755ac6683131fdfa7a8a121f9d7a9dec6fb/sdca_internal.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -8,13 +8,28 @@
   OpInputList sparse_example_indices_inputs;
   TF_RETURN_IF_ERROR(context->input_list(""sparse_example_indices"",
                                          &sparse_example_indices_inputs));
+  if (sparse_example_indices_inputs.size() != num_sparse_features)
+    return errors::InvalidArgument(
+        ""Expected "", num_sparse_features,
+        "" tensors in sparse_example_indices but got "",
+        sparse_example_indices_inputs.size());
   OpInputList sparse_feature_indices_inputs;
   TF_RETURN_IF_ERROR(context->input_list(""sparse_feature_indices"",
                                          &sparse_feature_indices_inputs));
+  if (sparse_feature_indices_inputs.size() != num_sparse_features)
+    return errors::InvalidArgument(
+        ""Expected "", num_sparse_features,
+        "" tensors in sparse_feature_indices but got "",
+        sparse_feature_indices_inputs.size());
   OpInputList sparse_feature_values_inputs;
   if (num_sparse_features_with_values > 0) {
     TF_RETURN_IF_ERROR(context->input_list(""sparse_feature_values"",
                                            &sparse_feature_values_inputs));
+    if (sparse_feature_values_inputs.size() != num_sparse_features_with_values)
+      return errors::InvalidArgument(
+          ""Expected "", num_sparse_features_with_values,
+          "" tensors in sparse_feature_values but got "",
+          sparse_feature_values_inputs.size());
   }
 
   const Tensor* example_weights_t;","{'deleted_lines': [], 'added_lines': ['  if (sparse_example_indices_inputs.size() != num_sparse_features)', '    return errors::InvalidArgument(', '        ""Expected "", num_sparse_features,', '        "" tensors in sparse_example_indices but got "",', '        sparse_example_indices_inputs.size());', '  if (sparse_feature_indices_inputs.size() != num_sparse_features)', '    return errors::InvalidArgument(', '        ""Expected "", num_sparse_features,', '        "" tensors in sparse_feature_indices but got "",', '        sparse_feature_indices_inputs.size());', '    if (sparse_feature_values_inputs.size() != num_sparse_features_with_values)', '      return errors::InvalidArgument(', '          ""Expected "", num_sparse_features_with_values,', '          "" tensors in sparse_feature_values but got "",', '          sparse_feature_values_inputs.size());']}",True,"TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.SdcaOptimizer` triggers undefined behavior due to dereferencing a null pointer. The implementation(https://github.com/tensorflow/tensorflow/blob/60a45c8b6192a4699f2e2709a2645a751d435cc3/tensorflow/core/kernels/sdca_internal.cc) does not validate that the user supplied arguments satisfy all constraints expected by the op(https://www.tensorflow.org/api_docs/python/tf/raw_ops/SdcaOptimizer). The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",2.5,LOW,0,test,2021-05-05T18:40:50Z,3
CVE-2021-29572,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,tensorflow,"Add several missing validations in SDCA

PiperOrigin-RevId: 372172877
Change-Id: Id366da962432e18dcbfac847d11e98488bebb70a",f7cc8755ac6683131fdfa7a8a121f9d7a9dec6fb,https://github.com/tensorflow/tensorflow/commit/f7cc8755ac6683131fdfa7a8a121f9d7a9dec6fb,tensorflow/core/kernels/sdca_internal.cc,Examples::CreateSparseFeatureRepresentation,"Status Examples::CreateSparseFeatureRepresentation(
const DeviceBase::CpuWorkerThreads& worker_threads, const int num_examples,
const int num_sparse_features, const ModelWeights& weights,
const OpInputList& sparse_example_indices_inputs,
const OpInputList& sparse_feature_indices_inputs,
const OpInputList& sparse_feature_values_inputs,
std::vector<Example>* const examples) {
mutex mu;
Status result;    auto parse_partition = [&](const int64 begin, const int64 end) {
for (int i = static_cast<int>(begin); i < end; ++i) {
auto example_indices =
sparse_example_indices_inputs[i].template flat<int64>();
auto feature_indices =
sparse_feature_indices_inputs[i].template flat<int64>();
int start_id = -1;
int end_id = 0;
for (int example_id = 0; example_id < num_examples; ++example_id) {
start_id = end_id;
while (end_id < example_indices.size() &&
example_indices(end_id) == example_id) {
++end_id;
}
Example::SparseFeatures* const sparse_features =
&(*examples)[example_id].sparse_features_[i];
if (start_id < example_indices.size() &&
example_indices(start_id) == example_id) {
sparse_features->indices.reset(new UnalignedInt64Vector(
&(feature_indices(start_id)), end_id - start_id));
if (sparse_feature_values_inputs.size() > i) {
auto feature_weights =
sparse_feature_values_inputs[i].flat<float>();
sparse_features->values.reset(new UnalignedFloatVector(
&(feature_weights(start_id)), end_id - start_id));
}
if (end_id - start_id > 0) {
for (int64 k = 0; k < sparse_features->indices->size(); ++k) {
const int64 feature_index = (*sparse_features->indices)(k);
if (!weights.SparseIndexValid(i, feature_index)) {
mutex_lock l(mu);
result = errors::InvalidArgument(
""Found sparse feature indices out of valid range: "",
(*sparse_features->indices)(k));
return;
}
}
}
} else {
sparse_features->indices.reset(
new UnalignedInt64Vector(&(feature_indices(0)), 0));
if (sparse_feature_values_inputs.size() > i) {
auto feature_weights =
sparse_feature_values_inputs[i].flat<float>();
sparse_features->values.reset(
new UnalignedFloatVector(&(feature_weights(0)), 0));
}
}
}
}
};
const int64 kCostPerUnit = num_examples;
Shard(worker_threads.num_threads, worker_threads.workers, num_sparse_features,
kCostPerUnit, parse_partition);
return result;
}","Status Examples::CreateSparseFeatureRepresentation(
const DeviceBase::CpuWorkerThreads& VAR_0, const int VAR_1,
const int VAR_2, const ModelWeights& VAR_3,
const OpInputList& VAR_4,
const OpInputList& VAR_5,
const OpInputList& VAR_6,
std::vector<Example>* const VAR_7) {
mutex VAR_8;
Status VAR_9;  
auto VAR_10 = [&](const int64 VAR_11, const int64 VAR_12) {
for (int VAR_13 = VAR_14<int>(VAR_11); VAR_13 < VAR_12; ++VAR_13) {
auto VAR_15 =
VAR_4[VAR_13].template flat<int64>();
auto VAR_16 =
VAR_5[VAR_13].template flat<int64>();
int VAR_17 = -1;
int VAR_18 = 0;
for (int VAR_19 = 0; VAR_19 < VAR_1; ++VAR_19) {
VAR_17 = VAR_18;
while (VAR_18 < VAR_15.size() &&
VAR_15(VAR_18) == VAR_19) {
++VAR_18;
}
Example::SparseFeatures* const VAR_20 =
&(*VAR_7)[VAR_19].sparse_features_[VAR_13];
if (VAR_17 < VAR_15.size() &&
VAR_15(VAR_17) == VAR_19) {
VAR_20->indices.reset(new UnalignedInt64Vector(
&(VAR_16(VAR_17)), VAR_18 - VAR_17));
if (VAR_6.size() > VAR_13) {
auto VAR_21 =
VAR_6[VAR_13].flat<float>();
VAR_20->values.reset(new UnalignedFloatVector(
&(VAR_21(VAR_17)), VAR_18 - VAR_17));
}
if (VAR_18 - VAR_17 > 0) {
for (int64 VAR_22 = 0; VAR_22 < VAR_20->indices->size(); ++VAR_22) {
const int64 VAR_23 = (*VAR_20->indices)(VAR_22);
if (!VAR_3.SparseIndexValid(VAR_13, VAR_23)) {
mutex_lock l(mu);
VAR_9 = errors::InvalidArgument(
""Found sparse feature indices out of valid range: "",
(*VAR_20->indices)(VAR_22));
return;
}
}
}
} else {
VAR_20->indices.reset(
new UnalignedInt64Vector(&(VAR_16(0)), 0));
if (VAR_6.size() > VAR_13) {
auto VAR_21 =
VAR_6[VAR_13].flat<float>();
VAR_20->values.reset(
new UnalignedFloatVector(&(VAR_21(0)), 0));
}
}
}
}
};
const int64 VAR_24 = VAR_1;
Shard(VAR_0.num_threads, VAR_0.workers, VAR_2,
VAR_24, VAR_10);
return VAR_9;
}",tensorflow/f7cc8755ac6683131fdfa7a8a121f9d7a9dec6fb/sdca_internal.cc/vul/before/2.json,"Status Examples::CreateSparseFeatureRepresentation(
    const DeviceBase::CpuWorkerThreads& worker_threads, const int num_examples,
    const int num_sparse_features, const ModelWeights& weights,
    const OpInputList& sparse_example_indices_inputs,
    const OpInputList& sparse_feature_indices_inputs,
    const OpInputList& sparse_feature_values_inputs,
    std::vector<Example>* const examples) {
  mutex mu;
  Status result;  // Guarded by mu
  auto parse_partition = [&](const int64 begin, const int64 end) {
    // The static_cast here is safe since begin and end can be at most
    // num_examples which is an int.
    for (int i = static_cast<int>(begin); i < end; ++i) {
      auto example_indices =
          sparse_example_indices_inputs[i].template flat<int64>();
      auto feature_indices =
          sparse_feature_indices_inputs[i].template flat<int64>();
      if (example_indices.size() != feature_indices.size()) {
        mutex_lock l(mu);
        result = errors::InvalidArgument(
            ""Found mismatched example_indices and feature_indices ["",
            example_indices, ""] vs ["", feature_indices, ""]"");
        return;
      }

      // Parse features for each example. Features for a particular example
      // are at the offsets (start_id, end_id]
      int start_id = -1;
      int end_id = 0;
      for (int example_id = 0; example_id < num_examples; ++example_id) {
        start_id = end_id;
        while (end_id < example_indices.size() &&
               example_indices(end_id) == example_id) {
          ++end_id;
        }
        Example::SparseFeatures* const sparse_features =
            &(*examples)[example_id].sparse_features_[i];
        if (start_id < example_indices.size() &&
            example_indices(start_id) == example_id) {
          sparse_features->indices.reset(new UnalignedInt64Vector(
              &(feature_indices(start_id)), end_id - start_id));
          if (sparse_feature_values_inputs.size() > i) {
            auto feature_weights =
                sparse_feature_values_inputs[i].flat<float>();
            sparse_features->values.reset(new UnalignedFloatVector(
                &(feature_weights(start_id)), end_id - start_id));
          }
          // If features are non empty.
          if (end_id - start_id > 0) {
            // TODO(sibyl-Aix6ihai): Write this efficiently using vectorized
            // operations from eigen.
            for (int64 k = 0; k < sparse_features->indices->size(); ++k) {
              const int64 feature_index = (*sparse_features->indices)(k);
              if (!weights.SparseIndexValid(i, feature_index)) {
                mutex_lock l(mu);
                result = errors::InvalidArgument(
                    ""Found sparse feature indices out of valid range: "",
                    (*sparse_features->indices)(k));
                return;
              }
            }
          }
        } else {
          // Add a Tensor that has size 0.
          sparse_features->indices.reset(
              new UnalignedInt64Vector(&(feature_indices(0)), 0));
          // If values exist for this feature group.
          if (sparse_feature_values_inputs.size() > i) {
            auto feature_weights =
                sparse_feature_values_inputs[i].flat<float>();
            sparse_features->values.reset(
                new UnalignedFloatVector(&(feature_weights(0)), 0));
          }
        }
      }
    }
  };
  // For each column, the cost of parsing it is O(num_examples). We use
  // num_examples here, as empirically Shard() creates the right amount of
  // threads based on the problem size.
  // TODO(sibyl-Aix6ihai): Tune this as a function of dataset size.
  const int64 kCostPerUnit = num_examples;
  Shard(worker_threads.num_threads, worker_threads.workers, num_sparse_features,
        kCostPerUnit, parse_partition);
  return result;
}","Status Examples::CreateSparseFeatureRepresentation(
    const DeviceBase::CpuWorkerThreads& VAR_0, const int VAR_1,
    const int VAR_2, const ModelWeights& VAR_3,
    const OpInputList& VAR_4,
    const OpInputList& VAR_5,
    const OpInputList& VAR_6,
    std::vector<Example>* const VAR_7) {
  mutex VAR_8;
  Status VAR_9;  /* COMMENT_0 */
  auto VAR_10 = [&](const int64 VAR_11, const int64 VAR_12) {
    /* COMMENT_1 */
    /* COMMENT_2 */
    for (int VAR_13 = VAR_14<int>(VAR_11); VAR_13 < VAR_12; ++VAR_13) {
      auto VAR_15 =
          VAR_4[VAR_13].template flat<int64>();
      auto VAR_16 =
          VAR_5[VAR_13].template flat<int64>();
      if (VAR_15.size() != VAR_16.size()) {
        mutex_lock l(mu);
        VAR_9 = errors::InvalidArgument(
            ""Found mismatched example_indices and feature_indices ["",
            VAR_15, ""] vs ["", VAR_16, ""]"");
        return;
      }

      /* COMMENT_3 */
      /* COMMENT_4 */
      int VAR_17 = -1;
      int VAR_18 = 0;
      for (int VAR_19 = 0; VAR_19 < VAR_1; ++VAR_19) {
        VAR_17 = VAR_18;
        while (VAR_18 < VAR_15.size() &&
               VAR_15(VAR_18) == VAR_19) {
          ++VAR_18;
        }
        Example::SparseFeatures* const VAR_20 =
            &(*VAR_7)[VAR_19].sparse_features_[VAR_13];
        if (VAR_17 < VAR_15.size() &&
            VAR_15(VAR_17) == VAR_19) {
          VAR_20->indices.reset(new UnalignedInt64Vector(
              &(VAR_16(VAR_17)), VAR_18 - VAR_17));
          if (VAR_6.size() > VAR_13) {
            auto VAR_21 =
                VAR_6[VAR_13].flat<float>();
            VAR_20->values.reset(new UnalignedFloatVector(
                &(VAR_21(VAR_17)), VAR_18 - VAR_17));
          }
          /* COMMENT_5 */
          if (VAR_18 - VAR_17 > 0) {
            /* COMMENT_6 */
            /* COMMENT_7 */
            for (int64 VAR_22 = 0; VAR_22 < VAR_20->indices->size(); ++VAR_22) {
              const int64 VAR_23 = (*VAR_20->indices)(VAR_22);
              if (!VAR_3.SparseIndexValid(VAR_13, VAR_23)) {
                mutex_lock l(mu);
                VAR_9 = errors::InvalidArgument(
                    ""Found sparse feature indices out of valid range: "",
                    (*VAR_20->indices)(VAR_22));
                return;
              }
            }
          }
        } else {
          /* COMMENT_8 */
          VAR_20->indices.reset(
              new UnalignedInt64Vector(&(VAR_16(0)), 0));
          /* COMMENT_9 */
          if (VAR_6.size() > VAR_13) {
            auto VAR_21 =
                VAR_6[VAR_13].flat<float>();
            VAR_20->values.reset(
                new UnalignedFloatVector(&(VAR_21(0)), 0));
          }
        }
      }
    }
  };
  /* COMMENT_10 */
  /* COMMENT_11 */
  /* COMMENT_12 */
  /* COMMENT_13 */
  const int64 VAR_24 = VAR_1;
  Shard(VAR_0.num_threads, VAR_0.workers, VAR_2,
        VAR_24, VAR_10);
  return VAR_9;
}",tensorflow/f7cc8755ac6683131fdfa7a8a121f9d7a9dec6fb/sdca_internal.cc/vul/after/2.json,"--- func_before
+++ func_after
@@ -15,6 +15,13 @@
           sparse_example_indices_inputs[i].template flat<int64>();
       auto feature_indices =
           sparse_feature_indices_inputs[i].template flat<int64>();
+      if (example_indices.size() != feature_indices.size()) {
+        mutex_lock l(mu);
+        result = errors::InvalidArgument(
+            ""Found mismatched example_indices and feature_indices ["",
+            example_indices, ""] vs ["", feature_indices, ""]"");
+        return;
+      }
 
       // Parse features for each example. Features for a particular example
       // are at the offsets (start_id, end_id]","{'deleted_lines': [], 'added_lines': ['      if (example_indices.size() != feature_indices.size()) {', '        mutex_lock l(mu);', '        result = errors::InvalidArgument(', '            ""Found mismatched example_indices and feature_indices ["",', '            example_indices, ""] vs ["", feature_indices, ""]"");', '        return;', '      }']}",True,"TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.SdcaOptimizer` triggers undefined behavior due to dereferencing a null pointer. The implementation(https://github.com/tensorflow/tensorflow/blob/60a45c8b6192a4699f2e2709a2645a751d435cc3/tensorflow/core/kernels/sdca_internal.cc) does not validate that the user supplied arguments satisfy all constraints expected by the op(https://www.tensorflow.org/api_docs/python/tf/raw_ops/SdcaOptimizer). The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",2.5,LOW,0,test,2021-05-05T18:40:50Z,3
CVE-2021-29572,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,tensorflow,"Add several missing validations in SDCA

PiperOrigin-RevId: 372172877
Change-Id: Id366da962432e18dcbfac847d11e98488bebb70a",f7cc8755ac6683131fdfa7a8a121f9d7a9dec6fb,https://github.com/tensorflow/tensorflow/commit/f7cc8755ac6683131fdfa7a8a121f9d7a9dec6fb,tensorflow/core/kernels/sdca_internal.cc,ModelWeights::Initialize,"Status ModelWeights::Initialize(OpKernelContext* const context) {
OpInputList sparse_indices_inputs;
TF_RETURN_IF_ERROR(
context->input_list(""sparse_indices"", &sparse_indices_inputs));
OpInputList sparse_weights_inputs;
TF_RETURN_IF_ERROR(
context->input_list(""sparse_weights"", &sparse_weights_inputs));
OpInputList dense_weights_inputs;
TF_RETURN_IF_ERROR(
context->input_list(""dense_weights"", &dense_weights_inputs));
OpOutputList sparse_weights_outputs;
TF_RETURN_IF_ERROR(context->output_list(""out_delta_sparse_weights"",
&sparse_weights_outputs));
OpOutputList dense_weights_outputs;
TF_RETURN_IF_ERROR(
context->output_list(""out_delta_dense_weights"", &dense_weights_outputs));
for (int i = 0; i < sparse_weights_inputs.size(); ++i) {
Tensor* delta_t;
TF_RETURN_IF_ERROR(sparse_weights_outputs.allocate(
i, sparse_weights_inputs[i].shape(), &delta_t));
auto deltas = delta_t->shaped<float, 2>({1, delta_t->NumElements()});
deltas.setZero();
sparse_weights_.emplace_back(FeatureWeightsSparseStorage{
sparse_indices_inputs[i].flat<int64>(),
sparse_weights_inputs[i].shaped<float, 2>(
{1, sparse_weights_inputs[i].NumElements()}),
deltas});
}
const auto initialize_weights =
[&](const OpInputList& weight_inputs, OpOutputList* const weight_outputs,
std::vector<FeatureWeightsDenseStorage>* const feature_weights) {
for (int i = 0; i < weight_inputs.size(); ++i) {
Tensor* delta_t;
TF_RETURN_IF_ERROR(
weight_outputs->allocate(i, weight_inputs[i].shape(), &delta_t));
auto deltas = delta_t->shaped<float, 2>({1, delta_t->NumElements()});
deltas.setZero();
feature_weights->emplace_back(FeatureWeightsDenseStorage{
weight_inputs[i].shaped<float, 2>(
{1, weight_inputs[i].NumElements()}),
deltas});
}
return Status::OK();
};
return initialize_weights(dense_weights_inputs, &dense_weights_outputs,
&dense_weights_);
}","Status ModelWeights::Initialize(OpKernelContext* const VAR_0) {
OpInputList VAR_1;
TF_RETURN_IF_ERROR(
VAR_0->input_list(""sparse_indices"", &VAR_1));
OpInputList VAR_2;
TF_RETURN_IF_ERROR(
VAR_0->input_list(""sparse_weights"", &VAR_2));
OpInputList VAR_3;
TF_RETURN_IF_ERROR(
VAR_0->input_list(""dense_weights"", &VAR_3));
OpOutputList VAR_4;
TF_RETURN_IF_ERROR(VAR_0->output_list(""out_delta_sparse_weights"",
&VAR_4));
OpOutputList VAR_5;
TF_RETURN_IF_ERROR(
VAR_0->output_list(""out_delta_dense_weights"", &VAR_5));
for (int VAR_6 = 0; VAR_6 < VAR_2.size(); ++VAR_6) {
Tensor* VAR_7;
TF_RETURN_IF_ERROR(VAR_4.allocate(
VAR_6, VAR_2[VAR_6].shape(), &VAR_7));
auto VAR_8 = VAR_7->shaped<float, 2>({1, VAR_7->NumElements()});
VAR_8.setZero();
VAR_9.emplace_back(FeatureWeightsSparseStorage{
VAR_1[VAR_6].flat<int64>(),
VAR_2[VAR_6].shaped<float, 2>(
{1, VAR_2[VAR_6].NumElements()}),
VAR_8});
}
const auto VAR_10 =
[&](const OpInputList& VAR_11, OpOutputList* const VAR_12,
std::vector<FeatureWeightsDenseStorage>* const VAR_13) {
for (int VAR_6 = 0; VAR_6 < VAR_11.size(); ++VAR_6) {
Tensor* VAR_7;
TF_RETURN_IF_ERROR(
VAR_12->allocate(VAR_6, VAR_11[VAR_6].shape(), &VAR_7));
auto VAR_8 = VAR_7->shaped<float, 2>({1, VAR_7->NumElements()});
VAR_8.setZero();
VAR_13->emplace_back(FeatureWeightsDenseStorage{
VAR_11[VAR_6].shaped<float, 2>(
{1, VAR_11[VAR_6].NumElements()}),
VAR_8});
}
return Status::OK();
};
return VAR_10(VAR_3, &VAR_5,
&VAR_14);
}",tensorflow/f7cc8755ac6683131fdfa7a8a121f9d7a9dec6fb/sdca_internal.cc/vul/before/0.json,"Status ModelWeights::Initialize(OpKernelContext* const context) {
  OpInputList sparse_indices_inputs;
  TF_RETURN_IF_ERROR(
      context->input_list(""sparse_indices"", &sparse_indices_inputs));
  OpInputList sparse_weights_inputs;
  TF_RETURN_IF_ERROR(
      context->input_list(""sparse_weights"", &sparse_weights_inputs));
  if (sparse_indices_inputs.size() != sparse_weights_inputs.size())
    return errors::InvalidArgument(
        ""sparse_indices and sparse_weights must have the same length, got "",
        sparse_indices_inputs.size(), "" and "", sparse_weights_inputs.size());
  OpInputList dense_weights_inputs;
  TF_RETURN_IF_ERROR(
      context->input_list(""dense_weights"", &dense_weights_inputs));

  OpOutputList sparse_weights_outputs;
  TF_RETURN_IF_ERROR(context->output_list(""out_delta_sparse_weights"",
                                          &sparse_weights_outputs));
  if (sparse_weights_outputs.size() != sparse_weights_inputs.size())
    return errors::InvalidArgument(
        ""out_delta_sparse_weights and sparse_weights must have the same ""
        ""length, got "",
        sparse_weights_outputs.size(), "" and "", sparse_weights_inputs.size());

  OpOutputList dense_weights_outputs;
  TF_RETURN_IF_ERROR(
      context->output_list(""out_delta_dense_weights"", &dense_weights_outputs));
  if (dense_weights_outputs.size() != dense_weights_inputs.size())
    return errors::InvalidArgument(
        ""out_delta_dense_weights and dense_weights must have the same length, ""
        ""got "",
        dense_weights_outputs.size(), "" and "", dense_weights_inputs.size());

  for (int i = 0; i < sparse_weights_inputs.size(); ++i) {
    Tensor* delta_t;
    TF_RETURN_IF_ERROR(sparse_weights_outputs.allocate(
        i, sparse_weights_inputs[i].shape(), &delta_t));
    // Convert the input vector to a row matrix in internal representation.
    auto deltas = delta_t->shaped<float, 2>({1, delta_t->NumElements()});
    deltas.setZero();
    sparse_weights_.emplace_back(FeatureWeightsSparseStorage{
        sparse_indices_inputs[i].flat<int64>(),
        sparse_weights_inputs[i].shaped<float, 2>(
            {1, sparse_weights_inputs[i].NumElements()}),
        deltas});
  }

  // Reads in the weights, and allocates and initializes the delta weights.
  const auto initialize_weights =
      [&](const OpInputList& weight_inputs, OpOutputList* const weight_outputs,
          std::vector<FeatureWeightsDenseStorage>* const feature_weights) {
        for (int i = 0; i < weight_inputs.size(); ++i) {
          Tensor* delta_t;
          TF_RETURN_IF_ERROR(
              weight_outputs->allocate(i, weight_inputs[i].shape(), &delta_t));
          // Convert the input vector to a row matrix in internal
          // representation.
          auto deltas = delta_t->shaped<float, 2>({1, delta_t->NumElements()});
          deltas.setZero();
          feature_weights->emplace_back(FeatureWeightsDenseStorage{
              weight_inputs[i].shaped<float, 2>(
                  {1, weight_inputs[i].NumElements()}),
              deltas});
        }
        return Status::OK();
      };

  return initialize_weights(dense_weights_inputs, &dense_weights_outputs,
                            &dense_weights_);
}","Status ModelWeights::Initialize(OpKernelContext* const VAR_0) {
  OpInputList VAR_1;
  TF_RETURN_IF_ERROR(
      VAR_0->input_list(""sparse_indices"", &VAR_1));
  OpInputList VAR_2;
  TF_RETURN_IF_ERROR(
      VAR_0->input_list(""sparse_weights"", &VAR_2));
  if (VAR_1.size() != VAR_2.size())
    return errors::InvalidArgument(
        ""sparse_indices and sparse_weights must have the same length, got "",
        VAR_1.size(), "" and "", VAR_2.size());
  OpInputList VAR_3;
  TF_RETURN_IF_ERROR(
      VAR_0->input_list(""dense_weights"", &VAR_3));

  OpOutputList VAR_4;
  TF_RETURN_IF_ERROR(VAR_0->output_list(""out_delta_sparse_weights"",
                                          &VAR_4));
  if (VAR_4.size() != VAR_2.size())
    return errors::InvalidArgument(
        ""out_delta_sparse_weights and sparse_weights must have the same ""
        ""length, got "",
        VAR_4.size(), "" and "", VAR_2.size());

  OpOutputList VAR_5;
  TF_RETURN_IF_ERROR(
      VAR_0->output_list(""out_delta_dense_weights"", &VAR_5));
  if (VAR_5.size() != VAR_3.size())
    return errors::InvalidArgument(
        ""out_delta_dense_weights and dense_weights must have the same length, ""
        ""got "",
        VAR_5.size(), "" and "", VAR_3.size());

  for (int VAR_6 = 0; VAR_6 < VAR_2.size(); ++VAR_6) {
    Tensor* VAR_7;
    TF_RETURN_IF_ERROR(VAR_4.allocate(
        VAR_6, VAR_2[VAR_6].shape(), &VAR_7));
    /* COMMENT_0 */
    auto VAR_8 = VAR_7->shaped<float, 2>({1, VAR_7->NumElements()});
    VAR_8.setZero();
    VAR_9.emplace_back(FeatureWeightsSparseStorage{
        VAR_1[VAR_6].flat<int64>(),
        VAR_2[VAR_6].shaped<float, 2>(
            {1, VAR_2[VAR_6].NumElements()}),
        VAR_8});
  }

  /* COMMENT_1 */
  const auto VAR_10 =
      [&](const OpInputList& VAR_11, OpOutputList* const VAR_12,
          std::vector<FeatureWeightsDenseStorage>* const VAR_13) {
        for (int VAR_6 = 0; VAR_6 < VAR_11.size(); ++VAR_6) {
          Tensor* VAR_7;
          TF_RETURN_IF_ERROR(
              VAR_12->allocate(VAR_6, VAR_11[VAR_6].shape(), &VAR_7));
          /* COMMENT_2 */
          /* COMMENT_3 */
          auto VAR_8 = VAR_7->shaped<float, 2>({1, VAR_7->NumElements()});
          VAR_8.setZero();
          VAR_13->emplace_back(FeatureWeightsDenseStorage{
              VAR_11[VAR_6].shaped<float, 2>(
                  {1, VAR_11[VAR_6].NumElements()}),
              VAR_8});
        }
        return Status::OK();
      };

  return VAR_10(VAR_3, &VAR_5,
                            &VAR_14);
}",tensorflow/f7cc8755ac6683131fdfa7a8a121f9d7a9dec6fb/sdca_internal.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,10 @@
   OpInputList sparse_weights_inputs;
   TF_RETURN_IF_ERROR(
       context->input_list(""sparse_weights"", &sparse_weights_inputs));
+  if (sparse_indices_inputs.size() != sparse_weights_inputs.size())
+    return errors::InvalidArgument(
+        ""sparse_indices and sparse_weights must have the same length, got "",
+        sparse_indices_inputs.size(), "" and "", sparse_weights_inputs.size());
   OpInputList dense_weights_inputs;
   TF_RETURN_IF_ERROR(
       context->input_list(""dense_weights"", &dense_weights_inputs));
@@ -12,10 +16,20 @@
   OpOutputList sparse_weights_outputs;
   TF_RETURN_IF_ERROR(context->output_list(""out_delta_sparse_weights"",
                                           &sparse_weights_outputs));
+  if (sparse_weights_outputs.size() != sparse_weights_inputs.size())
+    return errors::InvalidArgument(
+        ""out_delta_sparse_weights and sparse_weights must have the same ""
+        ""length, got "",
+        sparse_weights_outputs.size(), "" and "", sparse_weights_inputs.size());
 
   OpOutputList dense_weights_outputs;
   TF_RETURN_IF_ERROR(
       context->output_list(""out_delta_dense_weights"", &dense_weights_outputs));
+  if (dense_weights_outputs.size() != dense_weights_inputs.size())
+    return errors::InvalidArgument(
+        ""out_delta_dense_weights and dense_weights must have the same length, ""
+        ""got "",
+        dense_weights_outputs.size(), "" and "", dense_weights_inputs.size());
 
   for (int i = 0; i < sparse_weights_inputs.size(); ++i) {
     Tensor* delta_t;","{'deleted_lines': [], 'added_lines': ['  if (sparse_indices_inputs.size() != sparse_weights_inputs.size())', '    return errors::InvalidArgument(', '        ""sparse_indices and sparse_weights must have the same length, got "",', '        sparse_indices_inputs.size(), "" and "", sparse_weights_inputs.size());', '  if (sparse_weights_outputs.size() != sparse_weights_inputs.size())', '    return errors::InvalidArgument(', '        ""out_delta_sparse_weights and sparse_weights must have the same ""', '        ""length, got "",', '        sparse_weights_outputs.size(), "" and "", sparse_weights_inputs.size());', '  if (dense_weights_outputs.size() != dense_weights_inputs.size())', '    return errors::InvalidArgument(', '        ""out_delta_dense_weights and dense_weights must have the same length, ""', '        ""got "",', '        dense_weights_outputs.size(), "" and "", dense_weights_inputs.size());']}",True,"TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.SdcaOptimizer` triggers undefined behavior due to dereferencing a null pointer. The implementation(https://github.com/tensorflow/tensorflow/blob/60a45c8b6192a4699f2e2709a2645a751d435cc3/tensorflow/core/kernels/sdca_internal.cc) does not validate that the user supplied arguments satisfy all constraints expected by the op(https://www.tensorflow.org/api_docs/python/tf/raw_ops/SdcaOptimizer). The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",2.5,LOW,0,test,2021-05-05T18:40:50Z,3
CVE-2021-29577,['CWE-787'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Fix assertion failure in pooling_ops_3d

PiperOrigin-RevId: 372364504
Change-Id: Iecde4fe26b47a8fa935d6e2611b5585ed5777781",6fc9141f42f6a72180ecd24021c3e6b36165fe0d,https://github.com/tensorflow/tensorflow/commit/6fc9141f42f6a72180ecd24021c3e6b36165fe0d,tensorflow/core/kernels/pooling_ops_3d.cc,launch,"static void launch(OpKernelContext* context,
const TensorShape& tensor_in_shape,
const Tensor& out_backprop,
const std::array<int64, 3>& window,
const std::array<int64, 3>& stride,
const std::array<int64, 3>& output_shape,
const std::array<int64, 3>& padding,
TensorFormat data_format, Tensor* output) {
output->flat<T>().setZero();
std::array<int64, 3> input_size = {{tensor_in_shape.dim_size(3),
tensor_in_shape.dim_size(2),
tensor_in_shape.dim_size(1)}};
for (int64 p = 0; p < out_backprop.dim_size(3); ++p) {
int pindex, psize;
OP_REQUIRES_OK(context,
GetBroadcastSize(p, input_size[0], window[0], stride[0],
padding[0], &pindex, &psize));
for (int64 r = 0; r < out_backprop.dim_size(2); ++r) {
int rindex, rsize;
OP_REQUIRES_OK(context,
GetBroadcastSize(r, input_size[1], window[1], stride[1],
padding[1], &rindex, &rsize));
for (int64 c = 0; c < out_backprop.dim_size(1); ++c) {
int cindex, csize;
OP_REQUIRES_OK(
context, GetBroadcastSize(c, input_size[2], window[2], stride[2],
padding[2], &cindex, &csize));
TensorSlice src{{0, -1}, {c, 1}, {r, 1}, {p, 1}, {0, -1}};
TensorSlice dst{{0, -1},
{cindex, csize},
{rindex, rsize},
{pindex, psize},
{0, -1}};
Eigen::DSizes<Eigen::DenseIndex, 5> src_indices;
Eigen::DSizes<Eigen::DenseIndex, 5> src_sizes;
Eigen::DSizes<Eigen::DenseIndex, 5> dst_indices;
Eigen::DSizes<Eigen::DenseIndex, 5> dst_sizes;
src.FillIndicesAndSizes<5>(out_backprop.shape(), &src_indices,
&src_sizes);
dst.FillIndicesAndSizes<5>(tensor_in_shape, &dst_indices, &dst_sizes);
#if !defined(EIGEN_HAS_INDEX_LIST)
Eigen::array<int, 5> bcast = {1, csize, rsize, psize, 1};
#else
Eigen::IndexList<Eigen::type2index<1>, int, int, int,
Eigen::type2index<1>>
bcast;
bcast.set(1, csize);
bcast.set(2, rsize);
bcast.set(3, psize);
#endif
Eigen::Tensor<T, 5, Eigen::RowMajor> slices(src_sizes);
slices.device(context->eigen_cpu_device()) =
out_backprop.tensor<T, 5>().slice(src_indices, src_sizes);
float divide_size = rsize * csize * psize * 1.0f;
slices *= slices.constant(1.0f / divide_size);
output->tensor<T, 5>()
.slice(dst_indices, dst_sizes)
.device(context->eigen_cpu_device()) += slices.broadcast(bcast);
}
}
}
}","static void launch(OpKernelContext* VAR_0,
const TensorShape& VAR_1,
const Tensor& VAR_2,
const std::array<int64, 3>& VAR_3,
const std::array<int64, 3>& VAR_4,
const std::array<int64, 3>& VAR_5,
const std::array<int64, 3>& VAR_6,
TensorFormat VAR_7, Tensor* VAR_8) {
VAR_8->flat<T>().setZero();
std::array<int64, 3> VAR_9 = {{VAR_1.dim_size(3),
VAR_1.dim_size(2),
VAR_1.dim_size(1)}};
for (int64 VAR_10 = 0; VAR_10 < VAR_2.dim_size(3); ++VAR_10) {
int VAR_11, VAR_12;
OP_REQUIRES_OK(VAR_0,
GetBroadcastSize(VAR_10, VAR_9[0], VAR_3[0], VAR_4[0],
VAR_6[0], &VAR_11, &VAR_12));
for (int64 VAR_13 = 0; VAR_13 < VAR_2.dim_size(2); ++VAR_13) {
int VAR_14, VAR_15;
OP_REQUIRES_OK(VAR_0,
GetBroadcastSize(VAR_13, VAR_9[1], VAR_3[1], VAR_4[1],
VAR_6[1], &VAR_14, &VAR_15));
for (int64 VAR_16 = 0; VAR_16 < VAR_2.dim_size(1); ++VAR_16) {
int VAR_17, VAR_18;
OP_REQUIRES_OK(
VAR_0, GetBroadcastSize(VAR_16, VAR_9[2], VAR_3[2], VAR_4[2],
VAR_6[2], &VAR_17, &VAR_18));
TensorSlice VAR_19{{0, -1}, {VAR_16, 1}, {VAR_13, 1}, {VAR_10, 1}, {0, -1}};
TensorSlice VAR_20{{0, -1},
{VAR_17, VAR_18},
{VAR_14, VAR_15},
{VAR_11, VAR_12},
{0, -1}};
Eigen::DSizes<Eigen::DenseIndex, 5> VAR_21;
Eigen::DSizes<Eigen::DenseIndex, 5> VAR_22;
Eigen::DSizes<Eigen::DenseIndex, 5> VAR_23;
Eigen::DSizes<Eigen::DenseIndex, 5> VAR_24;
VAR_19.FillIndicesAndSizes<5>(VAR_2.shape(), &VAR_21,
&VAR_22);
VAR_20.FillIndicesAndSizes<5>(VAR_1, &VAR_23, &VAR_24);
#if !defined(VAR_25)
Eigen::array<int, 5> VAR_26 = {1, VAR_18, VAR_15, VAR_12, 1};
#else
Eigen::IndexList<Eigen::type2index<1>, int, int, int,
Eigen::type2index<1>>
VAR_26;
VAR_26.set(1, VAR_18);
VAR_26.set(2, VAR_15);
VAR_26.set(3, VAR_12);
#endif
Eigen::Tensor<T, 5, Eigen::RowMajor> slices(src_sizes);
VAR_27.device(VAR_0->eigen_cpu_device()) =
VAR_2.tensor<T, 5>().slice(VAR_21, src_sizes);
float VAR_28 = VAR_15 * VAR_18 * VAR_12 * 1.0f;
VAR_27 *= VAR_27.constant(1.0f / VAR_28);
VAR_8->tensor<T, 5>()
.slice(VAR_23, VAR_24)
.device(VAR_0->eigen_cpu_device()) += VAR_27.broadcast(VAR_26);
}
}
}
}",tensorflow/6fc9141f42f6a72180ecd24021c3e6b36165fe0d/pooling_ops_3d.cc/vul/before/0.json,"static void launch(OpKernelContext* context,
                     const TensorShape& tensor_in_shape,
                     const Tensor& out_backprop,
                     const std::array<int64, 3>& window,
                     const std::array<int64, 3>& stride,
                     const std::array<int64, 3>& output_shape,
                     const std::array<int64, 3>& padding,
                     TensorFormat data_format, Tensor* output) {
    OP_REQUIRES(
        context, tensor_in_shape.dim_size(0) == out_backprop.dim_size(0),
        errors::InvalidArgument(
            ""Expected first dimension of tensor_in_shape and ""
            ""out_backprop to match, got "",
            tensor_in_shape.dim_size(0), "" and "", out_backprop.dim_size(0)));
    OP_REQUIRES(
        context, tensor_in_shape.dim_size(4) == out_backprop.dim_size(4),
        errors::InvalidArgument(
            ""Expected last dimension of tensor_in_shape and ""
            ""out_backprop to match, got "",
            tensor_in_shape.dim_size(4), "" and "", out_backprop.dim_size(4)));

    output->flat<T>().setZero();
    std::array<int64, 3> input_size = {{tensor_in_shape.dim_size(3),
                                        tensor_in_shape.dim_size(2),
                                        tensor_in_shape.dim_size(1)}};
    for (int64 p = 0; p < out_backprop.dim_size(3); ++p) {
      // Calculate broadcast size for planes/rows/cols. For SAME padding,
      // current index could be in the padding area, and
      //   p * stride_planes + window_planes
      // could be beyond the input tensor's boundary. In such cases, change
      // the starting index and reduce the broadcast size.
      //
      // The same procedure is repeated for every spatial dimension in the
      // nested loops below.
      int pindex, psize;
      OP_REQUIRES_OK(context,
                     GetBroadcastSize(p, input_size[0], window[0], stride[0],
                                      padding[0], &pindex, &psize));
      for (int64 r = 0; r < out_backprop.dim_size(2); ++r) {
        int rindex, rsize;
        OP_REQUIRES_OK(context,
                       GetBroadcastSize(r, input_size[1], window[1], stride[1],
                                        padding[1], &rindex, &rsize));
        for (int64 c = 0; c < out_backprop.dim_size(1); ++c) {
          int cindex, csize;
          OP_REQUIRES_OK(
              context, GetBroadcastSize(c, input_size[2], window[2], stride[2],
                                        padding[2], &cindex, &csize));
          TensorSlice src{{0, -1}, {c, 1}, {r, 1}, {p, 1}, {0, -1}};
          TensorSlice dst{{0, -1},
                          {cindex, csize},
                          {rindex, rsize},
                          {pindex, psize},
                          {0, -1}};
          Eigen::DSizes<Eigen::DenseIndex, 5> src_indices;
          Eigen::DSizes<Eigen::DenseIndex, 5> src_sizes;
          Eigen::DSizes<Eigen::DenseIndex, 5> dst_indices;
          Eigen::DSizes<Eigen::DenseIndex, 5> dst_sizes;
          src.FillIndicesAndSizes<5>(out_backprop.shape(), &src_indices,
                                     &src_sizes);
          dst.FillIndicesAndSizes<5>(tensor_in_shape, &dst_indices, &dst_sizes);
#if !defined(EIGEN_HAS_INDEX_LIST)
          Eigen::array<int, 5> bcast = {1, csize, rsize, psize, 1};
#else
          Eigen::IndexList<Eigen::type2index<1>, int, int, int,
                           Eigen::type2index<1>>
              bcast;
          bcast.set(1, csize);
          bcast.set(2, rsize);
          bcast.set(3, psize);
#endif
          Eigen::Tensor<T, 5, Eigen::RowMajor> slices(src_sizes);
          slices.device(context->eigen_cpu_device()) =
              out_backprop.tensor<T, 5>().slice(src_indices, src_sizes);
          // Divide by the size of the actual patch (psize * rsize * csize).
          float divide_size = rsize * csize * psize * 1.0f;
          slices *= slices.constant(1.0f / divide_size);

          output->tensor<T, 5>()
              .slice(dst_indices, dst_sizes)
              .device(context->eigen_cpu_device()) += slices.broadcast(bcast);
        }
      }
    }
  }","static void launch(OpKernelContext* VAR_0,
                     const TensorShape& VAR_1,
                     const Tensor& VAR_2,
                     const std::array<int64, 3>& VAR_3,
                     const std::array<int64, 3>& VAR_4,
                     const std::array<int64, 3>& VAR_5,
                     const std::array<int64, 3>& VAR_6,
                     TensorFormat VAR_7, Tensor* VAR_8) {
    OP_REQUIRES(
        VAR_0, VAR_1.dim_size(0) == VAR_2.dim_size(0),
        errors::InvalidArgument(
            ""Expected first dimension of tensor_in_shape and ""
            ""out_backprop to match, got "",
            VAR_1.dim_size(0), "" and "", VAR_2.dim_size(0)));
    OP_REQUIRES(
        VAR_0, VAR_1.dim_size(4) == VAR_2.dim_size(4),
        errors::InvalidArgument(
            ""Expected last dimension of tensor_in_shape and ""
            ""out_backprop to match, got "",
            VAR_1.dim_size(4), "" and "", VAR_2.dim_size(4)));

    VAR_8->flat<T>().setZero();
    std::array<int64, 3> VAR_9 = {{VAR_1.dim_size(3),
                                        VAR_1.dim_size(2),
                                        VAR_1.dim_size(1)}};
    for (int64 VAR_10 = 0; VAR_10 < VAR_2.dim_size(3); ++VAR_10) {
      /* COMMENT_0 */
      /* COMMENT_1 */
      /* COMMENT_2 */
      /* COMMENT_3 */
      /* COMMENT_4 */
      /* COMMENT_5 */
      /* COMMENT_6 */
      /* COMMENT_7 */
      int VAR_11, VAR_12;
      OP_REQUIRES_OK(VAR_0,
                     GetBroadcastSize(VAR_10, VAR_9[0], VAR_3[0], VAR_4[0],
                                      VAR_6[0], &VAR_11, &VAR_12));
      for (int64 VAR_13 = 0; VAR_13 < VAR_2.dim_size(2); ++VAR_13) {
        int VAR_14, VAR_15;
        OP_REQUIRES_OK(VAR_0,
                       GetBroadcastSize(VAR_13, VAR_9[1], VAR_3[1], VAR_4[1],
                                        VAR_6[1], &VAR_14, &VAR_15));
        for (int64 VAR_16 = 0; VAR_16 < VAR_2.dim_size(1); ++VAR_16) {
          int VAR_17, VAR_18;
          OP_REQUIRES_OK(
              VAR_0, GetBroadcastSize(VAR_16, VAR_9[2], VAR_3[2], VAR_4[2],
                                        VAR_6[2], &VAR_17, &VAR_18));
          TensorSlice VAR_19{{0, -1}, {VAR_16, 1}, {VAR_13, 1}, {VAR_10, 1}, {0, -1}};
          TensorSlice VAR_20{{0, -1},
                          {VAR_17, VAR_18},
                          {VAR_14, VAR_15},
                          {VAR_11, VAR_12},
                          {0, -1}};
          Eigen::DSizes<Eigen::DenseIndex, 5> VAR_21;
          Eigen::DSizes<Eigen::DenseIndex, 5> VAR_22;
          Eigen::DSizes<Eigen::DenseIndex, 5> VAR_23;
          Eigen::DSizes<Eigen::DenseIndex, 5> VAR_24;
          VAR_19.FillIndicesAndSizes<5>(VAR_2.shape(), &VAR_21,
                                     &VAR_22);
          VAR_20.FillIndicesAndSizes<5>(VAR_1, &VAR_23, &VAR_24);
#if !defined(VAR_25)
          Eigen::array<int, 5> VAR_26 = {1, VAR_18, VAR_15, VAR_12, 1};
#else
          Eigen::IndexList<Eigen::type2index<1>, int, int, int,
                           Eigen::type2index<1>>
              VAR_26;
          VAR_26.set(1, VAR_18);
          VAR_26.set(2, VAR_15);
          VAR_26.set(3, VAR_12);
#endif
          Eigen::Tensor<T, 5, Eigen::RowMajor> slices(src_sizes);
          VAR_27.device(VAR_0->eigen_cpu_device()) =
              VAR_2.tensor<T, 5>().slice(VAR_21, src_sizes);
          /* COMMENT_8 */
          float VAR_28 = VAR_15 * VAR_18 * VAR_12 * 1.0f;
          VAR_27 *= VAR_27.constant(1.0f / VAR_28);

          VAR_8->tensor<T, 5>()
              .slice(VAR_23, VAR_24)
              .device(VAR_0->eigen_cpu_device()) += VAR_27.broadcast(VAR_26);
        }
      }
    }
  }",tensorflow/6fc9141f42f6a72180ecd24021c3e6b36165fe0d/pooling_ops_3d.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,19 @@
                      const std::array<int64, 3>& output_shape,
                      const std::array<int64, 3>& padding,
                      TensorFormat data_format, Tensor* output) {
+    OP_REQUIRES(
+        context, tensor_in_shape.dim_size(0) == out_backprop.dim_size(0),
+        errors::InvalidArgument(
+            ""Expected first dimension of tensor_in_shape and ""
+            ""out_backprop to match, got "",
+            tensor_in_shape.dim_size(0), "" and "", out_backprop.dim_size(0)));
+    OP_REQUIRES(
+        context, tensor_in_shape.dim_size(4) == out_backprop.dim_size(4),
+        errors::InvalidArgument(
+            ""Expected last dimension of tensor_in_shape and ""
+            ""out_backprop to match, got "",
+            tensor_in_shape.dim_size(4), "" and "", out_backprop.dim_size(4)));
+
     output->flat<T>().setZero();
     std::array<int64, 3> input_size = {{tensor_in_shape.dim_size(3),
                                         tensor_in_shape.dim_size(2),","{'deleted_lines': [], 'added_lines': ['    OP_REQUIRES(', '        context, tensor_in_shape.dim_size(0) == out_backprop.dim_size(0),', '        errors::InvalidArgument(', '            ""Expected first dimension of tensor_in_shape and ""', '            ""out_backprop to match, got "",', '            tensor_in_shape.dim_size(0), "" and "", out_backprop.dim_size(0)));', '    OP_REQUIRES(', '        context, tensor_in_shape.dim_size(4) == out_backprop.dim_size(4),', '        errors::InvalidArgument(', '            ""Expected last dimension of tensor_in_shape and ""', '            ""out_backprop to match, got "",', '            tensor_in_shape.dim_size(4), "" and "", out_backprop.dim_size(4)));', '']}",True,"TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.AvgPool3DGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/d80ffba9702dc19d1fac74fc4b766b3fa1ee976b/tensorflow/core/kernels/pooling_ops_3d.cc#L376-L450) assumes that the `orig_input_shape` and `grad` tensors have similar first and last dimensions but does not check that this assumption is validated. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",2.5,LOW,0,test,2021-05-06T16:51:26Z,3
CVE-2021-32559,['CWE-190'],AV:N/AC:L/Au:S/C:N/I:N/A:P,0,mhammond/pywin32,"PyACL - Fixing integer overflows that occur when resizing ACLs

Fixes #1700
CVE-2021-32559",b860822ad233304fceefc4644bd353087a5309ec,https://github.com/mhammond/pywin32/commit/b860822ad233304fceefc4644bd353087a5309ec,win32/src/PyACL.cpp,PyACL::AddAuditAccessAceEx,"PyObject *PyACL::AddAuditAccessAceEx(PyObject *self, PyObject *args)
{
DWORD accessmask, acerevision, aceflags;
BOOL bAuditSuccess, bAuditFailure;
PyObject *obSID;
PSID psid;
PACL psacl;
PyACL *This = (PyACL *)self;
psacl = This->GetACL();
PACL psacl_padded = NULL;
BOOL bsuccess;
if (addauditaccessaceex == NULL)
return PyErr_Format(PyExc_NotImplementedError, ""AddAuditAccessAceEx not supported by this version of Windows"");
if (!PyArg_ParseTuple(args, ""lllOii:AddAuditAccessAceEx"", &acerevision, &aceflags, &accessmask, &obSID,
&bAuditSuccess, &bAuditFailure))
return NULL;
if (!PyWinObject_AsSID(obSID, &psid, FALSE))
return NULL;
bsuccess = (*addauditaccessaceex)(psacl, acerevision, aceflags, accessmask, psid, bAuditSuccess, bAuditFailure);
if (!bsuccess) {
DWORD err = GetLastError();
if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
return PyWin_SetAPIError(""AddAuditAccessAceEx"", err);
unsigned short required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_ACE) + (unsigned short)GetLengthSid(psid);
psacl_padded = (ACL *)malloc(required_size);
if (psacl_padded == NULL)
return PyErr_Format(PyExc_MemoryError, ""AddAuditAccessAceEx: unable to allocated %d bytes"", required_size);
ZeroMemory(psacl_padded, required_size);
memcpy(psacl_padded, psacl, psacl->AclSize);
psacl_padded->AclSize = required_size;
bsuccess =
(*addauditaccessaceex)(psacl_padded, acerevision, aceflags, accessmask, psid, bAuditSuccess, bAuditFailure);
if (bsuccess)
bsuccess = This->SetACL(psacl_padded);
else
PyWin_SetAPIError(""AddAuditAccessAceEx"");
}
if (psacl_padded)
free(psacl_padded);
if (bsuccess) {
Py_INCREF(Py_None);
return Py_None;
}
return NULL;
}","PyObject *PyACL::AddAuditAccessAceEx(PyObject *VAR_0, PyObject *VAR_1)
{
DWORD VAR_2, VAR_3, VAR_4;
BOOL VAR_5, VAR_6;
PyObject *VAR_7;
PSID VAR_8;
PACL VAR_9;
PyACL *VAR_10 = (PyACL *)VAR_0;
VAR_9 = VAR_10->GetACL();
PACL VAR_11 = NULL;
BOOL VAR_12;
if (VAR_13 == NULL)
return PyErr_Format(VAR_14, ""AddAuditAccessAceEx not supported by this version of Windows"");
if (!PyArg_ParseTuple(VAR_1, ""lllOii:AddAuditAccessAceEx"", &VAR_3, &VAR_4, &VAR_2, &VAR_7,
&VAR_5, &VAR_6))
return NULL;
if (!PyWinObject_AsSID(VAR_7, &VAR_8, FALSE))
return NULL;
VAR_12 = (*VAR_13)(VAR_9, VAR_3, VAR_4, VAR_2, VAR_8, VAR_5, VAR_6);
if (!VAR_12) {
DWORD VAR_15 = GetLastError();
if (VAR_15 != VAR_16)
return PyWin_SetAPIError(""AddAuditAccessAceEx"", VAR_15);
unsigned short VAR_17 = VAR_9->AclSize + sizeof(VAR_18) + (unsigned short)GetLengthSid(VAR_8);
VAR_11 = (ACL *)malloc(VAR_17);
if (VAR_11 == NULL)
return PyErr_Format(VAR_19, ""AddAuditAccessAceEx: unable to allocated %d bytes"", VAR_17);
ZeroMemory(VAR_11, VAR_17);
memcpy(VAR_11, VAR_9, VAR_9->AclSize);
VAR_11->AclSize = VAR_17;
VAR_12 =
(*VAR_13)(VAR_11, VAR_3, VAR_4, VAR_2, VAR_8, VAR_5, VAR_6);
if (VAR_12)
VAR_12 = VAR_10->SetACL(VAR_11);
else
PyWin_SetAPIError(""AddAuditAccessAceEx"");
}
if (VAR_11)
free(VAR_11);
if (VAR_12) {
Py_INCREF(VAR_20);
return VAR_20;
}
return NULL;
}",mhammond/pywin32/b860822ad233304fceefc4644bd353087a5309ec/PyACL.cpp/vul/before/3.json,"PyObject *PyACL::AddAuditAccessAceEx(PyObject *self, PyObject *args)
{
    DWORD accessmask, acerevision, aceflags;
    BOOL bAuditSuccess, bAuditFailure;
    PyObject *obSID;
    PSID psid;
    PACL psacl;
    PyACL *This = (PyACL *)self;
    psacl = This->GetACL();
    PACL psacl_padded = NULL;
    BOOL bsuccess;
    if (addauditaccessaceex == NULL)
        return PyErr_Format(PyExc_NotImplementedError, ""AddAuditAccessAceEx not supported by this version of Windows"");

    // @pyparm int|dwAceRevision||Revision of ACL: Must be at least ACL_REVISION_DS
    // @pyparm int|AceFlags||Combination of
    // FAILED_ACCESS_ACE_FLAG,SUCCESSFUL_ACCESS_ACE_FLAG,CONTAINER_INHERIT_ACE,INHERIT_ONLY_ACE,INHERITED_ACE,NO_PROPAGATE_INHERIT_ACE
    // and OBJECT_INHERIT_ACE
    // @pyparm int|dwAccessMask||Bitmask of access types to be audited
    // @pyparm <o PySID>|sid||SID for whom system audit messages will be generated
    // @pyparm int|bAuditSuccess||Set to 1 if access success should be audited, else 0
    // @pyparm int|bAuditFailure||Set to 1 if access failure should be audited, else 0

    if (!PyArg_ParseTuple(args, ""lllOii:AddAuditAccessAceEx"", &acerevision, &aceflags, &accessmask, &obSID,
                          &bAuditSuccess, &bAuditFailure))
        return NULL;
    if (!PyWinObject_AsSID(obSID, &psid, FALSE))
        return NULL;
    bsuccess = (*addauditaccessaceex)(psacl, acerevision, aceflags, accessmask, psid, bAuditSuccess, bAuditFailure);
    if (!bsuccess) {
        DWORD err = GetLastError();
        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
            return PyWin_SetAPIError(""AddAuditAccessAceEx"", err);
        // resize if acl too small
        unsigned int required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_ACE) + GetLengthSid(psid);
        // max ACL size is USHRT_MAX
        if (required_size > USHRT_MAX)
            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", __FUNCTION__ );
        psacl_padded = (ACL *)malloc(required_size);
        if (psacl_padded == NULL)
            return PyErr_Format(PyExc_MemoryError, ""AddAuditAccessAceEx: unable to allocated %d bytes"", required_size);

        ZeroMemory(psacl_padded, required_size);
        memcpy(psacl_padded, psacl, psacl->AclSize);
        psacl_padded->AclSize = (unsigned short)required_size;
        bsuccess =
            (*addauditaccessaceex)(psacl_padded, acerevision, aceflags, accessmask, psid, bAuditSuccess, bAuditFailure);
        if (bsuccess)
            bsuccess = This->SetACL(psacl_padded);
        else
            PyWin_SetAPIError(""AddAuditAccessAceEx"");
    }

    if (psacl_padded)
        free(psacl_padded);
    if (bsuccess) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
}","PyObject *PyACL::AddAuditAccessAceEx(PyObject *VAR_0, PyObject *VAR_1)
{
    DWORD VAR_2, VAR_3, VAR_4;
    BOOL VAR_5, VAR_6;
    PyObject *VAR_7;
    PSID VAR_8;
    PACL VAR_9;
    PyACL *VAR_10 = (PyACL *)VAR_0;
    VAR_9 = VAR_10->GetACL();
    PACL VAR_11 = NULL;
    BOOL VAR_12;
    if (VAR_13 == NULL)
        return PyErr_Format(VAR_14, ""AddAuditAccessAceEx not supported by this version of Windows"");

    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    /* COMMENT_7 */

    if (!PyArg_ParseTuple(VAR_1, ""lllOii:AddAuditAccessAceEx"", &VAR_3, &VAR_4, &VAR_2, &VAR_7,
                          &VAR_5, &VAR_6))
        return NULL;
    if (!PyWinObject_AsSID(VAR_7, &VAR_8, FALSE))
        return NULL;
    VAR_12 = (*VAR_13)(VAR_9, VAR_3, VAR_4, VAR_2, VAR_8, VAR_5, VAR_6);
    if (!VAR_12) {
        DWORD VAR_15 = GetLastError();
        if (VAR_15 != VAR_16)
            return PyWin_SetAPIError(""AddAuditAccessAceEx"", VAR_15);
        /* COMMENT_8 */
        unsigned int VAR_17 = VAR_9->AclSize + sizeof(VAR_18) + GetLengthSid(VAR_8);
        /* COMMENT_9 */
        if (VAR_17 > VAR_19)
            return PyErr_Format(VAR_20, ""%s: adding ACE would put ACL over size limit"", VAR_21 );
        VAR_11 = (ACL *)malloc(VAR_17);
        if (VAR_11 == NULL)
            return PyErr_Format(VAR_22, ""AddAuditAccessAceEx: unable to allocated %d bytes"", VAR_17);

        ZeroMemory(VAR_11, VAR_17);
        memcpy(VAR_11, VAR_9, VAR_9->AclSize);
        VAR_11->AclSize = (unsigned short)VAR_17;
        VAR_12 =
            (*VAR_13)(VAR_11, VAR_3, VAR_4, VAR_2, VAR_8, VAR_5, VAR_6);
        if (VAR_12)
            VAR_12 = VAR_10->SetACL(VAR_11);
        else
            PyWin_SetAPIError(""AddAuditAccessAceEx"");
    }

    if (VAR_11)
        free(VAR_11);
    if (VAR_12) {
        Py_INCREF(VAR_23);
        return VAR_23;
    }
    return NULL;
}",mhammond/pywin32/b860822ad233304fceefc4644bd353087a5309ec/PyACL.cpp/vul/after/3.json,"--- func_before
+++ func_after
@@ -32,14 +32,17 @@
         if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
             return PyWin_SetAPIError(""AddAuditAccessAceEx"", err);
         // resize if acl too small
-        unsigned short required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_ACE) + (unsigned short)GetLengthSid(psid);
+        unsigned int required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_ACE) + GetLengthSid(psid);
+        // max ACL size is USHRT_MAX
+        if (required_size > USHRT_MAX)
+            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", __FUNCTION__ );
         psacl_padded = (ACL *)malloc(required_size);
         if (psacl_padded == NULL)
             return PyErr_Format(PyExc_MemoryError, ""AddAuditAccessAceEx: unable to allocated %d bytes"", required_size);
 
         ZeroMemory(psacl_padded, required_size);
         memcpy(psacl_padded, psacl, psacl->AclSize);
-        psacl_padded->AclSize = required_size;
+        psacl_padded->AclSize = (unsigned short)required_size;
         bsuccess =
             (*addauditaccessaceex)(psacl_padded, acerevision, aceflags, accessmask, psid, bAuditSuccess, bAuditFailure);
         if (bsuccess)","{'deleted_lines': ['        unsigned short required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_ACE) + (unsigned short)GetLengthSid(psid);', '        psacl_padded->AclSize = required_size;'], 'added_lines': ['        unsigned int required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_ACE) + GetLengthSid(psid);', '        // max ACL size is USHRT_MAX', '        if (required_size > USHRT_MAX)', '            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", __FUNCTION__ );', '        psacl_padded->AclSize = (unsigned short)required_size;']}",True,An integer overflow exists in pywin32 prior to version b301 when adding an access control entry (ACE) to an access control list (ACL) that would cause the size to be greater than 65535 bytes. An attacker who successfully exploited this vulnerability could crash the vulnerable process.,6.5,MEDIUM,1,test,2021-05-11T14:52:37Z,3
CVE-2021-32559,['CWE-190'],AV:N/AC:L/Au:S/C:N/I:N/A:P,0,mhammond/pywin32,"PyACL - Fixing integer overflows that occur when resizing ACLs

Fixes #1700
CVE-2021-32559",b860822ad233304fceefc4644bd353087a5309ec,https://github.com/mhammond/pywin32/commit/b860822ad233304fceefc4644bd353087a5309ec,win32/src/PyACL.cpp,addaceorig,"PyObject *addaceorig(addacefunc addfunc, CHAR *funcname, PyACL *This, DWORD revision, DWORD access, PyObject *obSID)
{
PACL pdacl = This->GetACL();
PACL pdacl_padded = NULL;
BOOL bsuccess;
PSID psid;
if (addfunc == NULL)
return PyErr_Format(PyExc_NotImplementedError, ""%s not supported by this version of Windows"", funcname);
if (!PyWinObject_AsSID(obSID, &psid, FALSE))
return NULL;
bsuccess = (*addfunc)(pdacl, revision, access, psid);
if (bsuccess)
bsuccess = _ReorderACL(pdacl);
else {
DWORD err = GetLastError();
if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
return PyWin_SetAPIError(funcname, err);
unsigned short required_size = pdacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + (unsigned short)GetLengthSid(psid);
pdacl_padded = (ACL *)malloc(required_size);
if (pdacl_padded == NULL)
return PyErr_Format(PyExc_MemoryError, ""%s: unable to allocated %d bytes"", funcname, required_size);
ZeroMemory(pdacl_padded, required_size);
memcpy(pdacl_padded, pdacl, pdacl->AclSize);
pdacl_padded->AclSize = required_size;
bsuccess = (*addfunc)(pdacl_padded, revision, access, psid);
if (bsuccess) {
bsuccess = _ReorderACL(pdacl_padded);
if (bsuccess)
bsuccess = This->SetACL(pdacl_padded);
}
else
PyWin_SetAPIError(funcname);
}
if (pdacl_padded)
free(pdacl_padded);
if (bsuccess) {
Py_INCREF(Py_None);
return Py_None;
}
return NULL;
}","PyObject *addaceorig(addacefunc VAR_0, CHAR *VAR_1, PyACL *VAR_2, DWORD VAR_3, DWORD VAR_4, PyObject *VAR_5)
{
PACL VAR_6 = VAR_2->GetACL();
PACL VAR_7 = NULL;
BOOL VAR_8;
PSID VAR_9;
if (VAR_0 == NULL)
return PyErr_Format(VAR_10, ""%s not supported by this version of Windows"", VAR_1);
if (!PyWinObject_AsSID(VAR_5, &VAR_9, FALSE))
return NULL;
VAR_8 = (*VAR_0)(VAR_6, VAR_3, VAR_4, VAR_9);
if (VAR_8)
VAR_8 = _ReorderACL(VAR_6);
else {
DWORD VAR_11 = GetLastError();
if (VAR_11 != VAR_12)
return PyWin_SetAPIError(VAR_1, VAR_11);
unsigned short VAR_13 = VAR_6->AclSize + sizeof(VAR_14) + (unsigned short)GetLengthSid(VAR_9);
VAR_7 = (ACL *)malloc(VAR_13);
if (VAR_7 == NULL)
return PyErr_Format(VAR_15, ""%s: unable to allocated %d bytes"", VAR_1, VAR_13);
ZeroMemory(VAR_7, VAR_13);
memcpy(VAR_7, VAR_6, VAR_6->AclSize);
VAR_7->AclSize = VAR_13;
VAR_8 = (*VAR_0)(VAR_7, VAR_3, VAR_4, VAR_9);
if (VAR_8) {
VAR_8 = _ReorderACL(VAR_7);
if (VAR_8)
VAR_8 = VAR_2->SetACL(VAR_7);
}
else
PyWin_SetAPIError(VAR_1);
}
if (VAR_7)
free(VAR_7);
if (VAR_8) {
Py_INCREF(VAR_16);
return VAR_16;
}
return NULL;
}",mhammond/pywin32/b860822ad233304fceefc4644bd353087a5309ec/PyACL.cpp/vul/before/4.json,"PyObject *addaceorig(addacefunc addfunc, CHAR *funcname, PyACL *This, DWORD revision, DWORD access, PyObject *obSID)
{
    /* AddAccessAllowedAce and AddAccessDeniedAce operate exactly the same */
    PACL pdacl = This->GetACL();
    PACL pdacl_padded = NULL;
    BOOL bsuccess;
    PSID psid;
    if (addfunc == NULL)
        return PyErr_Format(PyExc_NotImplementedError, ""%s not supported by this version of Windows"", funcname);
    if (!PyWinObject_AsSID(obSID, &psid, FALSE))
        return NULL;

    bsuccess = (*addfunc)(pdacl, revision, access, psid);
    if (bsuccess)
        bsuccess = _ReorderACL(pdacl);
    else {
        DWORD err = GetLastError();
        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
            return PyWin_SetAPIError(funcname, err);
        // resize if dacl too small
        unsigned int required_size = pdacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psid);
        // max ACL size is USHRT_MAX
        if (required_size > USHRT_MAX)
            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", funcname);
        pdacl_padded = (ACL *)malloc(required_size);
        if (pdacl_padded == NULL)
            return PyErr_Format(PyExc_MemoryError, ""%s: unable to allocated %d bytes"", funcname, required_size);

        ZeroMemory(pdacl_padded, required_size);
        memcpy(pdacl_padded, pdacl, pdacl->AclSize);
        pdacl_padded->AclSize = (unsigned short)required_size;
        bsuccess = (*addfunc)(pdacl_padded, revision, access, psid);
        if (bsuccess) {
            bsuccess = _ReorderACL(pdacl_padded);
            if (bsuccess)
                bsuccess = This->SetACL(pdacl_padded);
        }
        else
            PyWin_SetAPIError(funcname);
    }

    if (pdacl_padded)
        free(pdacl_padded);
    if (bsuccess) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
}","PyObject *addaceorig(addacefunc VAR_0, CHAR *VAR_1, PyACL *VAR_2, DWORD VAR_3, DWORD VAR_4, PyObject *VAR_5)
{
    /* COMMENT_0 */
    PACL VAR_6 = VAR_2->GetACL();
    PACL VAR_7 = NULL;
    BOOL VAR_8;
    PSID VAR_9;
    if (VAR_0 == NULL)
        return PyErr_Format(VAR_10, ""%s not supported by this version of Windows"", VAR_1);
    if (!PyWinObject_AsSID(VAR_5, &VAR_9, FALSE))
        return NULL;

    VAR_8 = (*VAR_0)(VAR_6, VAR_3, VAR_4, VAR_9);
    if (VAR_8)
        VAR_8 = _ReorderACL(VAR_6);
    else {
        DWORD VAR_11 = GetLastError();
        if (VAR_11 != VAR_12)
            return PyWin_SetAPIError(VAR_1, VAR_11);
        /* COMMENT_1 */
        unsigned int VAR_13 = VAR_6->AclSize + sizeof(VAR_14) + GetLengthSid(VAR_9);
        /* COMMENT_2 */
        if (VAR_13 > VAR_15)
            return PyErr_Format(VAR_16, ""%s: adding ACE would put ACL over size limit"", VAR_1);
        VAR_7 = (ACL *)malloc(VAR_13);
        if (VAR_7 == NULL)
            return PyErr_Format(VAR_17, ""%s: unable to allocated %d bytes"", VAR_1, VAR_13);

        ZeroMemory(VAR_7, VAR_13);
        memcpy(VAR_7, VAR_6, VAR_6->AclSize);
        VAR_7->AclSize = (unsigned short)VAR_13;
        VAR_8 = (*VAR_0)(VAR_7, VAR_3, VAR_4, VAR_9);
        if (VAR_8) {
            VAR_8 = _ReorderACL(VAR_7);
            if (VAR_8)
                VAR_8 = VAR_2->SetACL(VAR_7);
        }
        else
            PyWin_SetAPIError(VAR_1);
    }

    if (VAR_7)
        free(VAR_7);
    if (VAR_8) {
        Py_INCREF(VAR_18);
        return VAR_18;
    }
    return NULL;
}",mhammond/pywin32/b860822ad233304fceefc4644bd353087a5309ec/PyACL.cpp/vul/after/4.json,"--- func_before
+++ func_after
@@ -18,14 +18,17 @@
         if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
             return PyWin_SetAPIError(funcname, err);
         // resize if dacl too small
-        unsigned short required_size = pdacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + (unsigned short)GetLengthSid(psid);
+        unsigned int required_size = pdacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psid);
+        // max ACL size is USHRT_MAX
+        if (required_size > USHRT_MAX)
+            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", funcname);
         pdacl_padded = (ACL *)malloc(required_size);
         if (pdacl_padded == NULL)
             return PyErr_Format(PyExc_MemoryError, ""%s: unable to allocated %d bytes"", funcname, required_size);
 
         ZeroMemory(pdacl_padded, required_size);
         memcpy(pdacl_padded, pdacl, pdacl->AclSize);
-        pdacl_padded->AclSize = required_size;
+        pdacl_padded->AclSize = (unsigned short)required_size;
         bsuccess = (*addfunc)(pdacl_padded, revision, access, psid);
         if (bsuccess) {
             bsuccess = _ReorderACL(pdacl_padded);","{'deleted_lines': ['        unsigned short required_size = pdacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + (unsigned short)GetLengthSid(psid);', '        pdacl_padded->AclSize = required_size;'], 'added_lines': ['        unsigned int required_size = pdacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psid);', '        // max ACL size is USHRT_MAX', '        if (required_size > USHRT_MAX)', '            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", funcname);', '        pdacl_padded->AclSize = (unsigned short)required_size;']}",True,An integer overflow exists in pywin32 prior to version b301 when adding an access control entry (ACE) to an access control list (ACL) that would cause the size to be greater than 65535 bytes. An attacker who successfully exploited this vulnerability could crash the vulnerable process.,6.5,MEDIUM,1,test,2021-05-11T14:52:37Z,3
CVE-2021-32559,['CWE-190'],AV:N/AC:L/Au:S/C:N/I:N/A:P,0,mhammond/pywin32,"PyACL - Fixing integer overflows that occur when resizing ACLs

Fixes #1700
CVE-2021-32559",b860822ad233304fceefc4644bd353087a5309ec,https://github.com/mhammond/pywin32/commit/b860822ad233304fceefc4644bd353087a5309ec,win32/src/PyACL.cpp,PyACL::AddAuditAccessObjectAce,"PyObject *PyACL::AddAuditAccessObjectAce(PyObject *self, PyObject *args)
{
DWORD accessmask, acerevision, aceflags;
BOOL bAuditSuccess, bAuditFailure;
PyObject *obSID;
GUID ObjectTypeGuid, InheritedObjectTypeGuid;
GUID *pObjectTypeGuid = NULL, *pInheritedObjectTypeGuid = NULL;
PyObject *obObjectTypeGuid, *obInheritedObjectTypeGuid;
BOOL bsuccess;
PSID psid;
PACL psacl;
PyACL *This = (PyACL *)self;
psacl = This->GetACL();
PACL psacl_padded = NULL;
if (addauditaccessobjectace == NULL)
return PyErr_Format(PyExc_NotImplementedError,
""AddAuditAccessObjectAce not supported by this version of Windows"");
if (!PyArg_ParseTuple(args, ""lllOOOii:AddAuditAccessObjectAce"", &acerevision, &aceflags, &accessmask,
&obObjectTypeGuid, &obInheritedObjectTypeGuid, &obSID, &bAuditSuccess, &bAuditFailure))
return NULL;
if (obObjectTypeGuid != Py_None) {
if (!PyWinObject_AsIID(obObjectTypeGuid, &ObjectTypeGuid))
return NULL;
pObjectTypeGuid = &ObjectTypeGuid;
}
if (obInheritedObjectTypeGuid != Py_None) {
if (!PyWinObject_AsIID(obInheritedObjectTypeGuid, &InheritedObjectTypeGuid))
return NULL;
pInheritedObjectTypeGuid = &InheritedObjectTypeGuid;
}
if (!PyWinObject_AsSID(obSID, &psid, FALSE))
return NULL;
bsuccess = (*addauditaccessobjectace)(psacl, acerevision, aceflags, accessmask, pObjectTypeGuid,
pInheritedObjectTypeGuid, psid, bAuditSuccess, bAuditFailure);
if (!bsuccess) {
DWORD err = GetLastError();
if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
return PyWin_SetAPIError(""AddAuditAccessObjectAce"", err);
unsigned short required_size =
psacl->AclSize + sizeof(SYSTEM_AUDIT_OBJECT_ACE) + (unsigned short)GetLengthSid(psid);
psacl_padded = (ACL *)malloc(required_size);
if (psacl_padded == NULL)
return PyErr_Format(PyExc_MemoryError, ""AddAuditAccessObjectAce: unable to allocated %d bytes"",
required_size);
ZeroMemory(psacl_padded, required_size);
memcpy(psacl_padded, psacl, psacl->AclSize);
psacl_padded->AclSize = required_size;
bsuccess = (*addauditaccessobjectace)(psacl_padded, acerevision, aceflags, accessmask, pObjectTypeGuid,
pInheritedObjectTypeGuid, psid, bAuditSuccess, bAuditFailure);
if (bsuccess)
bsuccess = This->SetACL(psacl_padded);
else
PyWin_SetAPIError(""AddAuditAccessObjectAce"");
}
if (psacl_padded)
free(psacl_padded);
if (bsuccess) {
Py_INCREF(Py_None);
return Py_None;
}
return NULL;
}","PyObject *PyACL::AddAuditAccessObjectAce(PyObject *VAR_0, PyObject *VAR_1)
{
DWORD VAR_2, VAR_3, VAR_4;
BOOL VAR_5, VAR_6;
PyObject *VAR_7;
GUID VAR_8, VAR_9;
GUID *VAR_10 = NULL, *VAR_11 = NULL;
PyObject *VAR_12, *VAR_13;
BOOL VAR_14;
PSID VAR_15;
PACL VAR_16;
PyACL *VAR_17 = (PyACL *)VAR_0;
VAR_16 = VAR_17->GetACL();
PACL VAR_18 = NULL;
if (VAR_19 == NULL)
return PyErr_Format(VAR_20,
""AddAuditAccessObjectAce not supported by this version of Windows"");
if (!PyArg_ParseTuple(VAR_1, ""lllOOOii:AddAuditAccessObjectAce"", &VAR_3, &VAR_4, &VAR_2,
&VAR_12, &VAR_13, &VAR_7, &VAR_5, &VAR_6))
return NULL;
if (VAR_12 != VAR_21) {
if (!PyWinObject_AsIID(VAR_12, &VAR_8))
return NULL;
VAR_10 = &VAR_8;
}
if (VAR_13 != VAR_21) {
if (!PyWinObject_AsIID(VAR_13, &VAR_9))
return NULL;
VAR_11 = &VAR_9;
}
if (!PyWinObject_AsSID(VAR_7, &VAR_15, FALSE))
return NULL;
VAR_14 = (*VAR_19)(VAR_16, VAR_3, VAR_4, VAR_2, VAR_10,
VAR_11, VAR_15, VAR_5, VAR_6);
if (!VAR_14) {
DWORD VAR_22 = GetLastError();
if (VAR_22 != VAR_23)
return PyWin_SetAPIError(""AddAuditAccessObjectAce"", VAR_22);
unsigned short VAR_24 =
VAR_16->AclSize + sizeof(VAR_25) + (unsigned short)GetLengthSid(VAR_15);
VAR_18 = (ACL *)malloc(VAR_24);
if (VAR_18 == NULL)
return PyErr_Format(VAR_26, ""AddAuditAccessObjectAce: unable to allocated %d bytes"",
VAR_24);
ZeroMemory(VAR_18, VAR_24);
memcpy(VAR_18, VAR_16, VAR_16->AclSize);
VAR_18->AclSize = VAR_24;
VAR_14 = (*VAR_19)(VAR_18, VAR_3, VAR_4, VAR_2, VAR_10,
VAR_11, VAR_15, VAR_5, VAR_6);
if (VAR_14)
VAR_14 = VAR_17->SetACL(VAR_18);
else
PyWin_SetAPIError(""AddAuditAccessObjectAce"");
}
if (VAR_18)
free(VAR_18);
if (VAR_14) {
Py_INCREF(VAR_21);
return VAR_21;
}
return NULL;
}",mhammond/pywin32/b860822ad233304fceefc4644bd353087a5309ec/PyACL.cpp/vul/before/5.json,"PyObject *PyACL::AddAuditAccessObjectAce(PyObject *self, PyObject *args)
{
    DWORD accessmask, acerevision, aceflags;
    BOOL bAuditSuccess, bAuditFailure;
    PyObject *obSID;
    GUID ObjectTypeGuid, InheritedObjectTypeGuid;
    GUID *pObjectTypeGuid = NULL, *pInheritedObjectTypeGuid = NULL;
    PyObject *obObjectTypeGuid, *obInheritedObjectTypeGuid;
    BOOL bsuccess;
    PSID psid;
    PACL psacl;
    PyACL *This = (PyACL *)self;
    psacl = This->GetACL();
    PACL psacl_padded = NULL;
    if (addauditaccessobjectace == NULL)
        return PyErr_Format(PyExc_NotImplementedError,
                            ""AddAuditAccessObjectAce not supported by this version of Windows"");

    // @pyparm int|dwAceRevision||Revision of ACL: Must be at least ACL_REVISION_DS
    // @pyparm int|AceFlags||Combination of
    // FAILED_ACCESS_ACE_FLAG,SUCCESSFUL_ACCESS_ACE_FLAG,CONTAINER_INHERIT_ACE,INHERIT_ONLY_ACE,INHERITED_ACE,NO_PROPAGATE_INHERIT_ACE
    // and OBJECT_INHERIT_ACE
    // @pyparm int|dwAccessMask||Bitmask of access types to be audited
    // @pyparm <o PyIID>|ObjectTypeGuid||GUID of object type or property set to which ace applies, can be None
    // @pyparm <o PyIID>|InheritedObjectTypeGuid||GUID of object type or property that will inherit ACE, can be None
    // @pyparm <o PySID>|sid||SID for whom system audit messages will be generated
    // @pyparm int|bAuditSuccess||Set to 1 if access success should be audited, else 0
    // @pyparm int|bAuditFailure||Set to 1 if access failure should be audited, else 0

    if (!PyArg_ParseTuple(args, ""lllOOOii:AddAuditAccessObjectAce"", &acerevision, &aceflags, &accessmask,
                          &obObjectTypeGuid, &obInheritedObjectTypeGuid, &obSID, &bAuditSuccess, &bAuditFailure))
        return NULL;
    if (obObjectTypeGuid != Py_None) {
        if (!PyWinObject_AsIID(obObjectTypeGuid, &ObjectTypeGuid))
            return NULL;
        pObjectTypeGuid = &ObjectTypeGuid;
    }
    if (obInheritedObjectTypeGuid != Py_None) {
        if (!PyWinObject_AsIID(obInheritedObjectTypeGuid, &InheritedObjectTypeGuid))
            return NULL;
        pInheritedObjectTypeGuid = &InheritedObjectTypeGuid;
    }
    if (!PyWinObject_AsSID(obSID, &psid, FALSE))
        return NULL;

    bsuccess = (*addauditaccessobjectace)(psacl, acerevision, aceflags, accessmask, pObjectTypeGuid,
                                          pInheritedObjectTypeGuid, psid, bAuditSuccess, bAuditFailure);
    if (!bsuccess) {
        DWORD err = GetLastError();
        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
            return PyWin_SetAPIError(""AddAuditAccessObjectAce"", err);
        // resize if acl too small
       unsigned int required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_OBJECT_ACE) + GetLengthSid(psid);
        // max ACL size is USHRT_MAX
        if (required_size > USHRT_MAX)
            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", __FUNCTION__ );
        psacl_padded = (ACL *)malloc(required_size);
        if (psacl_padded == NULL)
            return PyErr_Format(PyExc_MemoryError, ""AddAuditAccessObjectAce: unable to allocated %d bytes"",
                                required_size);

        ZeroMemory(psacl_padded, required_size);
        memcpy(psacl_padded, psacl, psacl->AclSize);
        psacl_padded->AclSize = (unsigned short)required_size;
        bsuccess = (*addauditaccessobjectace)(psacl_padded, acerevision, aceflags, accessmask, pObjectTypeGuid,
                                              pInheritedObjectTypeGuid, psid, bAuditSuccess, bAuditFailure);
        if (bsuccess)
            bsuccess = This->SetACL(psacl_padded);
        else
            PyWin_SetAPIError(""AddAuditAccessObjectAce"");
    }
    if (psacl_padded)
        free(psacl_padded);
    if (bsuccess) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
}","PyObject *PyACL::AddAuditAccessObjectAce(PyObject *VAR_0, PyObject *VAR_1)
{
    DWORD VAR_2, VAR_3, VAR_4;
    BOOL VAR_5, VAR_6;
    PyObject *VAR_7;
    GUID VAR_8, VAR_9;
    GUID *VAR_10 = NULL, *VAR_11 = NULL;
    PyObject *VAR_12, *VAR_13;
    BOOL VAR_14;
    PSID VAR_15;
    PACL VAR_16;
    PyACL *VAR_17 = (PyACL *)VAR_0;
    VAR_16 = VAR_17->GetACL();
    PACL VAR_18 = NULL;
    if (VAR_19 == NULL)
        return PyErr_Format(VAR_20,
                            ""AddAuditAccessObjectAce not supported by this version of Windows"");

    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_8 */
    /* COMMENT_9 */

    if (!PyArg_ParseTuple(VAR_1, ""lllOOOii:AddAuditAccessObjectAce"", &VAR_3, &VAR_4, &VAR_2,
                          &VAR_12, &VAR_13, &VAR_7, &VAR_5, &VAR_6))
        return NULL;
    if (VAR_12 != VAR_21) {
        if (!PyWinObject_AsIID(VAR_12, &VAR_8))
            return NULL;
        VAR_10 = &VAR_8;
    }
    if (VAR_13 != VAR_21) {
        if (!PyWinObject_AsIID(VAR_13, &VAR_9))
            return NULL;
        VAR_11 = &VAR_9;
    }
    if (!PyWinObject_AsSID(VAR_7, &VAR_15, FALSE))
        return NULL;

    VAR_14 = (*VAR_19)(VAR_16, VAR_3, VAR_4, VAR_2, VAR_10,
                                          VAR_11, VAR_15, VAR_5, VAR_6);
    if (!VAR_14) {
        DWORD VAR_22 = GetLastError();
        if (VAR_22 != VAR_23)
            return PyWin_SetAPIError(""AddAuditAccessObjectAce"", VAR_22);
        /* COMMENT_10 */
       unsigned int VAR_24 = VAR_16->AclSize + sizeof(VAR_25) + GetLengthSid(VAR_15);
        /* COMMENT_11 */
        if (VAR_24 > VAR_26)
            return PyErr_Format(VAR_27, ""%s: adding ACE would put ACL over size limit"", VAR_28 );
        VAR_18 = (ACL *)malloc(VAR_24);
        if (VAR_18 == NULL)
            return PyErr_Format(VAR_29, ""AddAuditAccessObjectAce: unable to allocated %d bytes"",
                                VAR_24);

        ZeroMemory(VAR_18, VAR_24);
        memcpy(VAR_18, VAR_16, VAR_16->AclSize);
        VAR_18->AclSize = (unsigned short)VAR_24;
        VAR_14 = (*VAR_19)(VAR_18, VAR_3, VAR_4, VAR_2, VAR_10,
                                              VAR_11, VAR_15, VAR_5, VAR_6);
        if (VAR_14)
            VAR_14 = VAR_17->SetACL(VAR_18);
        else
            PyWin_SetAPIError(""AddAuditAccessObjectAce"");
    }
    if (VAR_18)
        free(VAR_18);
    if (VAR_14) {
        Py_INCREF(VAR_21);
        return VAR_21;
    }
    return NULL;
}",mhammond/pywin32/b860822ad233304fceefc4644bd353087a5309ec/PyACL.cpp/vul/after/5.json,"--- func_before
+++ func_after
@@ -50,8 +50,10 @@
         if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
             return PyWin_SetAPIError(""AddAuditAccessObjectAce"", err);
         // resize if acl too small
-        unsigned short required_size =
-            psacl->AclSize + sizeof(SYSTEM_AUDIT_OBJECT_ACE) + (unsigned short)GetLengthSid(psid);
+       unsigned int required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_OBJECT_ACE) + GetLengthSid(psid);
+        // max ACL size is USHRT_MAX
+        if (required_size > USHRT_MAX)
+            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", __FUNCTION__ );
         psacl_padded = (ACL *)malloc(required_size);
         if (psacl_padded == NULL)
             return PyErr_Format(PyExc_MemoryError, ""AddAuditAccessObjectAce: unable to allocated %d bytes"",
@@ -59,7 +61,7 @@
 
         ZeroMemory(psacl_padded, required_size);
         memcpy(psacl_padded, psacl, psacl->AclSize);
-        psacl_padded->AclSize = required_size;
+        psacl_padded->AclSize = (unsigned short)required_size;
         bsuccess = (*addauditaccessobjectace)(psacl_padded, acerevision, aceflags, accessmask, pObjectTypeGuid,
                                               pInheritedObjectTypeGuid, psid, bAuditSuccess, bAuditFailure);
         if (bsuccess)","{'deleted_lines': ['        unsigned short required_size =', '            psacl->AclSize + sizeof(SYSTEM_AUDIT_OBJECT_ACE) + (unsigned short)GetLengthSid(psid);', '        psacl_padded->AclSize = required_size;'], 'added_lines': ['       unsigned int required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_OBJECT_ACE) + GetLengthSid(psid);', '        // max ACL size is USHRT_MAX', '        if (required_size > USHRT_MAX)', '            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", __FUNCTION__ );', '        psacl_padded->AclSize = (unsigned short)required_size;']}",True,An integer overflow exists in pywin32 prior to version b301 when adding an access control entry (ACE) to an access control list (ACL) that would cause the size to be greater than 65535 bytes. An attacker who successfully exploited this vulnerability could crash the vulnerable process.,6.5,MEDIUM,1,test,2021-05-11T14:52:37Z,3
CVE-2021-32559,['CWE-190'],AV:N/AC:L/Au:S/C:N/I:N/A:P,0,mhammond/pywin32,"PyACL - Fixing integer overflows that occur when resizing ACLs

Fixes #1700
CVE-2021-32559",b860822ad233304fceefc4644bd353087a5309ec,https://github.com/mhammond/pywin32/commit/b860822ad233304fceefc4644bd353087a5309ec,win32/src/PyACL.cpp,addobjectace,"PyObject *addobjectace(addobjectacefunc addfunc, CHAR *funcname, PyACL *This, DWORD revision, DWORD aceflags,
DWORD access, PyObject *obObjectTypeGuid, PyObject *obInheritedObjectTypeGuid, PyObject *obSID)
{
BOOL bsuccess;
PACL pdacl = This->GetACL();
PACL pdacl_padded = NULL;
PSID psid;
GUID ObjectTypeGuid, InheritedObjectTypeGuid;
GUID *pObjectTypeGuid = NULL, *pInheritedObjectTypeGuid = NULL;
if (addfunc == NULL)
return PyErr_Format(PyExc_NotImplementedError, ""%s not supported by this version of Windows"", funcname);
if (obObjectTypeGuid != Py_None) {
if (!PyWinObject_AsIID(obObjectTypeGuid, &ObjectTypeGuid))
return NULL;
pObjectTypeGuid = &ObjectTypeGuid;
}
if (obInheritedObjectTypeGuid != Py_None) {
if (!PyWinObject_AsIID(obInheritedObjectTypeGuid, &InheritedObjectTypeGuid))
return NULL;
pInheritedObjectTypeGuid = &InheritedObjectTypeGuid;
}
if (!PyWinObject_AsSID(obSID, &psid, FALSE))
return NULL;
bsuccess = (*addfunc)(pdacl, revision, aceflags, access, pObjectTypeGuid, pInheritedObjectTypeGuid, psid);
if (bsuccess)
bsuccess = _ReorderACL(pdacl);
else {
DWORD err = GetLastError();
if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
return PyWin_SetAPIError(funcname, err);
unsigned short required_size =
pdacl->AclSize + sizeof(ACCESS_ALLOWED_OBJECT_ACE) + (unsigned short)GetLengthSid(psid);
pdacl_padded = (ACL *)malloc(required_size);
if (pdacl_padded == NULL)
return PyErr_Format(PyExc_MemoryError, ""%s: unable to allocated %d bytes"", funcname, required_size);
ZeroMemory(pdacl_padded, required_size);
memcpy(pdacl_padded, pdacl, pdacl->AclSize);
pdacl_padded->AclSize = required_size;
bsuccess =
(*addfunc)(pdacl_padded, revision, aceflags, access, pObjectTypeGuid, pInheritedObjectTypeGuid, psid);
if (bsuccess) {
bsuccess = _ReorderACL(pdacl_padded);
if (bsuccess)
bsuccess = This->SetACL(pdacl_padded);
}
else
PyWin_SetAPIError(funcname);
}
if (pdacl_padded)
free(pdacl_padded);
if (bsuccess) {
Py_INCREF(Py_None);
return Py_None;
}
return NULL;
}","PyObject *addobjectace(addobjectacefunc VAR_0, CHAR *VAR_1, PyACL *VAR_2, DWORD VAR_3, DWORD VAR_4,
DWORD VAR_5, PyObject *VAR_6, PyObject *VAR_7, PyObject *VAR_8)
{
BOOL VAR_9;
PACL VAR_10 = VAR_2->GetACL();
PACL VAR_11 = NULL;
PSID VAR_12;
GUID VAR_13, VAR_14;
GUID *VAR_15 = NULL, *VAR_16 = NULL;
if (VAR_0 == NULL)
return PyErr_Format(VAR_17, ""%s not supported by this version of Windows"", VAR_1);
if (VAR_6 != VAR_18) {
if (!PyWinObject_AsIID(VAR_6, &VAR_13))
return NULL;
VAR_15 = &VAR_13;
}
if (VAR_7 != VAR_18) {
if (!PyWinObject_AsIID(VAR_7, &VAR_14))
return NULL;
VAR_16 = &VAR_14;
}
if (!PyWinObject_AsSID(VAR_8, &VAR_12, FALSE))
return NULL;
VAR_9 = (*VAR_0)(VAR_10, VAR_3, VAR_4, VAR_5, VAR_15, VAR_16, VAR_12);
if (VAR_9)
VAR_9 = _ReorderACL(VAR_10);
else {
DWORD VAR_19 = GetLastError();
if (VAR_19 != VAR_20)
return PyWin_SetAPIError(VAR_1, VAR_19);
unsigned short VAR_21 =
VAR_10->AclSize + sizeof(VAR_22) + (unsigned short)GetLengthSid(VAR_12);
VAR_11 = (ACL *)malloc(VAR_21);
if (VAR_11 == NULL)
return PyErr_Format(VAR_23, ""%s: unable to allocated %d bytes"", VAR_1, VAR_21);
ZeroMemory(VAR_11, VAR_21);
memcpy(VAR_11, VAR_10, VAR_10->AclSize);
VAR_11->AclSize = VAR_21;
VAR_9 =
(*VAR_0)(VAR_11, VAR_3, VAR_4, VAR_5, VAR_15, VAR_16, VAR_12);
if (VAR_9) {
VAR_9 = _ReorderACL(VAR_11);
if (VAR_9)
VAR_9 = VAR_2->SetACL(VAR_11);
}
else
PyWin_SetAPIError(VAR_1);
}
if (VAR_11)
free(VAR_11);
if (VAR_9) {
Py_INCREF(VAR_18);
return VAR_18;
}
return NULL;
}",mhammond/pywin32/b860822ad233304fceefc4644bd353087a5309ec/PyACL.cpp/vul/before/0.json,"PyObject *addobjectace(addobjectacefunc addfunc, CHAR *funcname, PyACL *This, DWORD revision, DWORD aceflags,
                       DWORD access, PyObject *obObjectTypeGuid, PyObject *obInheritedObjectTypeGuid, PyObject *obSID)
{
    /* AddAccessAllowedObjectAce and AddAccessDeniedObjectAce have same parameters */
    BOOL bsuccess;
    PACL pdacl = This->GetACL();
    PACL pdacl_padded = NULL;
    PSID psid;
    GUID ObjectTypeGuid, InheritedObjectTypeGuid;
    GUID *pObjectTypeGuid = NULL, *pInheritedObjectTypeGuid = NULL;

    if (addfunc == NULL)
        return PyErr_Format(PyExc_NotImplementedError, ""%s not supported by this version of Windows"", funcname);
    if (obObjectTypeGuid != Py_None) {
        if (!PyWinObject_AsIID(obObjectTypeGuid, &ObjectTypeGuid))
            return NULL;
        pObjectTypeGuid = &ObjectTypeGuid;
    }
    if (obInheritedObjectTypeGuid != Py_None) {
        if (!PyWinObject_AsIID(obInheritedObjectTypeGuid, &InheritedObjectTypeGuid))
            return NULL;
        pInheritedObjectTypeGuid = &InheritedObjectTypeGuid;
    }

    if (!PyWinObject_AsSID(obSID, &psid, FALSE))
        return NULL;

    bsuccess = (*addfunc)(pdacl, revision, aceflags, access, pObjectTypeGuid, pInheritedObjectTypeGuid, psid);
    if (bsuccess)
        bsuccess = _ReorderACL(pdacl);
    else {
        DWORD err = GetLastError();
        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
            return PyWin_SetAPIError(funcname, err);
        // resize if dacl too small
        unsigned int required_size = pdacl->AclSize + sizeof(ACCESS_ALLOWED_OBJECT_ACE) + GetLengthSid(psid);
        // max ACL size is USHRT_MAX
        if (required_size > USHRT_MAX)
            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", funcname);
        pdacl_padded = (ACL *)malloc(required_size);
        if (pdacl_padded == NULL)
            return PyErr_Format(PyExc_MemoryError, ""%s: unable to allocated %d bytes"", funcname, required_size);

        ZeroMemory(pdacl_padded, required_size);
        memcpy(pdacl_padded, pdacl, pdacl->AclSize);
        pdacl_padded->AclSize = (unsigned short)required_size;
        bsuccess =
            (*addfunc)(pdacl_padded, revision, aceflags, access, pObjectTypeGuid, pInheritedObjectTypeGuid, psid);
        if (bsuccess) {
            bsuccess = _ReorderACL(pdacl_padded);
            if (bsuccess)
                bsuccess = This->SetACL(pdacl_padded);
        }
        else
            PyWin_SetAPIError(funcname);
    }
    if (pdacl_padded)
        free(pdacl_padded);
    if (bsuccess) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
}","PyObject *addobjectace(addobjectacefunc VAR_0, CHAR *VAR_1, PyACL *VAR_2, DWORD VAR_3, DWORD VAR_4,
                       DWORD VAR_5, PyObject *VAR_6, PyObject *VAR_7, PyObject *VAR_8)
{
    /* COMMENT_0 */
    BOOL VAR_9;
    PACL VAR_10 = VAR_2->GetACL();
    PACL VAR_11 = NULL;
    PSID VAR_12;
    GUID VAR_13, VAR_14;
    GUID *VAR_15 = NULL, *VAR_16 = NULL;

    if (VAR_0 == NULL)
        return PyErr_Format(VAR_17, ""%s not supported by this version of Windows"", VAR_1);
    if (VAR_6 != VAR_18) {
        if (!PyWinObject_AsIID(VAR_6, &VAR_13))
            return NULL;
        VAR_15 = &VAR_13;
    }
    if (VAR_7 != VAR_18) {
        if (!PyWinObject_AsIID(VAR_7, &VAR_14))
            return NULL;
        VAR_16 = &VAR_14;
    }

    if (!PyWinObject_AsSID(VAR_8, &VAR_12, FALSE))
        return NULL;

    VAR_9 = (*VAR_0)(VAR_10, VAR_3, VAR_4, VAR_5, VAR_15, VAR_16, VAR_12);
    if (VAR_9)
        VAR_9 = _ReorderACL(VAR_10);
    else {
        DWORD VAR_19 = GetLastError();
        if (VAR_19 != VAR_20)
            return PyWin_SetAPIError(VAR_1, VAR_19);
        /* COMMENT_1 */
        unsigned int VAR_21 = VAR_10->AclSize + sizeof(VAR_22) + GetLengthSid(VAR_12);
        /* COMMENT_2 */
        if (VAR_21 > VAR_23)
            return PyErr_Format(VAR_24, ""%s: adding ACE would put ACL over size limit"", VAR_1);
        VAR_11 = (ACL *)malloc(VAR_21);
        if (VAR_11 == NULL)
            return PyErr_Format(VAR_25, ""%s: unable to allocated %d bytes"", VAR_1, VAR_21);

        ZeroMemory(VAR_11, VAR_21);
        memcpy(VAR_11, VAR_10, VAR_10->AclSize);
        VAR_11->AclSize = (unsigned short)VAR_21;
        VAR_9 =
            (*VAR_0)(VAR_11, VAR_3, VAR_4, VAR_5, VAR_15, VAR_16, VAR_12);
        if (VAR_9) {
            VAR_9 = _ReorderACL(VAR_11);
            if (VAR_9)
                VAR_9 = VAR_2->SetACL(VAR_11);
        }
        else
            PyWin_SetAPIError(VAR_1);
    }
    if (VAR_11)
        free(VAR_11);
    if (VAR_9) {
        Py_INCREF(VAR_18);
        return VAR_18;
    }
    return NULL;
}",mhammond/pywin32/b860822ad233304fceefc4644bd353087a5309ec/PyACL.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -33,15 +33,17 @@
         if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
             return PyWin_SetAPIError(funcname, err);
         // resize if dacl too small
-        unsigned short required_size =
-            pdacl->AclSize + sizeof(ACCESS_ALLOWED_OBJECT_ACE) + (unsigned short)GetLengthSid(psid);
+        unsigned int required_size = pdacl->AclSize + sizeof(ACCESS_ALLOWED_OBJECT_ACE) + GetLengthSid(psid);
+        // max ACL size is USHRT_MAX
+        if (required_size > USHRT_MAX)
+            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", funcname);
         pdacl_padded = (ACL *)malloc(required_size);
         if (pdacl_padded == NULL)
             return PyErr_Format(PyExc_MemoryError, ""%s: unable to allocated %d bytes"", funcname, required_size);
 
         ZeroMemory(pdacl_padded, required_size);
         memcpy(pdacl_padded, pdacl, pdacl->AclSize);
-        pdacl_padded->AclSize = required_size;
+        pdacl_padded->AclSize = (unsigned short)required_size;
         bsuccess =
             (*addfunc)(pdacl_padded, revision, aceflags, access, pObjectTypeGuid, pInheritedObjectTypeGuid, psid);
         if (bsuccess) {","{'deleted_lines': ['        unsigned short required_size =', '            pdacl->AclSize + sizeof(ACCESS_ALLOWED_OBJECT_ACE) + (unsigned short)GetLengthSid(psid);', '        pdacl_padded->AclSize = required_size;'], 'added_lines': ['        unsigned int required_size = pdacl->AclSize + sizeof(ACCESS_ALLOWED_OBJECT_ACE) + GetLengthSid(psid);', '        // max ACL size is USHRT_MAX', '        if (required_size > USHRT_MAX)', '            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", funcname);', '        pdacl_padded->AclSize = (unsigned short)required_size;']}",True,An integer overflow exists in pywin32 prior to version b301 when adding an access control entry (ACE) to an access control list (ACL) that would cause the size to be greater than 65535 bytes. An attacker who successfully exploited this vulnerability could crash the vulnerable process.,6.5,MEDIUM,1,test,2021-05-11T14:52:37Z,3
CVE-2021-32559,['CWE-190'],AV:N/AC:L/Au:S/C:N/I:N/A:P,0,mhammond/pywin32,"PyACL - Fixing integer overflows that occur when resizing ACLs

Fixes #1700
CVE-2021-32559",b860822ad233304fceefc4644bd353087a5309ec,https://github.com/mhammond/pywin32/commit/b860822ad233304fceefc4644bd353087a5309ec,win32/src/PyACL.cpp,addaceex,"PyObject *addaceex(addaceexfunc addfunc, CHAR *funcname, PyACL *This, DWORD revision, DWORD aceflags, DWORD access,
PyObject *obSID)
{
if (addfunc == NULL)
return PyErr_Format(PyExc_NotImplementedError, ""%s not supported by this version of Windows"", funcname);
PSID psid;
BOOL bsuccess;
PACL pacl = This->GetACL();
PACL pacl_padded = NULL;
if (!PyWinObject_AsSID(obSID, &psid, FALSE))
return NULL;
bsuccess = (*addfunc)(pacl, revision, aceflags, access, psid);
if (bsuccess)
bsuccess = _ReorderACL(pacl);
else {
DWORD err = GetLastError();
if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
return PyWin_SetAPIError(funcname, err);
unsigned short required_size = pacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + (unsigned short)GetLengthSid(psid);
pacl_padded = (ACL *)malloc(required_size);
if (pacl_padded == NULL)
return PyErr_Format(PyExc_MemoryError, ""%s: unable to allocated %d bytes"", funcname, required_size);
ZeroMemory(pacl_padded, required_size);
memcpy(pacl_padded, pacl, pacl->AclSize);
pacl_padded->AclSize = required_size;
bsuccess = (*addfunc)(pacl_padded, revision, aceflags, access, psid);
if (bsuccess) {
bsuccess = _ReorderACL(pacl_padded);
if (bsuccess)
bsuccess = This->SetACL(pacl_padded);
}
else
PyWin_SetAPIError(funcname);
}
if (pacl_padded)
free(pacl_padded);
if (bsuccess) {
Py_INCREF(Py_None);
return Py_None;
}
return NULL;
}","PyObject *addaceex(addaceexfunc VAR_0, CHAR *VAR_1, PyACL *VAR_2, DWORD VAR_3, DWORD VAR_4, DWORD VAR_5,
PyObject *VAR_6)
{
if (VAR_0 == NULL)
return PyErr_Format(VAR_7, ""%s not supported by this version of Windows"", VAR_1);
PSID VAR_8;
BOOL VAR_9;
PACL VAR_10 = VAR_2->GetACL();
PACL VAR_11 = NULL;
if (!PyWinObject_AsSID(VAR_6, &VAR_8, FALSE))
return NULL;
VAR_9 = (*VAR_0)(VAR_10, VAR_3, VAR_4, VAR_5, VAR_8);
if (VAR_9)
VAR_9 = _ReorderACL(VAR_10);
else {
DWORD VAR_12 = GetLastError();
if (VAR_12 != VAR_13)
return PyWin_SetAPIError(VAR_1, VAR_12);
unsigned short VAR_14 = VAR_10->AclSize + sizeof(VAR_15) + (unsigned short)GetLengthSid(VAR_8);
VAR_11 = (ACL *)malloc(VAR_14);
if (VAR_11 == NULL)
return PyErr_Format(VAR_16, ""%s: unable to allocated %d bytes"", VAR_1, VAR_14);
ZeroMemory(VAR_11, VAR_14);
memcpy(VAR_11, VAR_10, VAR_10->AclSize);
VAR_11->AclSize = VAR_14;
VAR_9 = (*VAR_0)(VAR_11, VAR_3, VAR_4, VAR_5, VAR_8);
if (VAR_9) {
VAR_9 = _ReorderACL(VAR_11);
if (VAR_9)
VAR_9 = VAR_2->SetACL(VAR_11);
}
else
PyWin_SetAPIError(VAR_1);
}
if (VAR_11)
free(VAR_11);
if (VAR_9) {
Py_INCREF(VAR_17);
return VAR_17;
}
return NULL;
}",mhammond/pywin32/b860822ad233304fceefc4644bd353087a5309ec/PyACL.cpp/vul/before/2.json,"PyObject *addaceex(addaceexfunc addfunc, CHAR *funcname, PyACL *This, DWORD revision, DWORD aceflags, DWORD access,
                   PyObject *obSID)
{
    /* AddAccessAllowedAceEx and AddAccessDeniedAceEx have the same signature and semantics */
    if (addfunc == NULL)
        return PyErr_Format(PyExc_NotImplementedError, ""%s not supported by this version of Windows"", funcname);
    PSID psid;
    BOOL bsuccess;
    PACL pacl = This->GetACL();
    PACL pacl_padded = NULL;
    if (!PyWinObject_AsSID(obSID, &psid, FALSE))
        return NULL;

    bsuccess = (*addfunc)(pacl, revision, aceflags, access, psid);
    if (bsuccess)
        bsuccess = _ReorderACL(pacl);
    else {
        DWORD err = GetLastError();
        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
            return PyWin_SetAPIError(funcname, err);
        // resize if dacl too small
        unsigned int required_size = pacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psid);
        // max ACL size is USHRT_MAX
        if (required_size > USHRT_MAX)
            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", funcname);
        pacl_padded = (ACL *)malloc(required_size);
        if (pacl_padded == NULL)
            return PyErr_Format(PyExc_MemoryError, ""%s: unable to allocated %d bytes"", funcname, required_size);

        ZeroMemory(pacl_padded, required_size);
        memcpy(pacl_padded, pacl, pacl->AclSize);
        pacl_padded->AclSize = (unsigned short)required_size;
        bsuccess = (*addfunc)(pacl_padded, revision, aceflags, access, psid);
        if (bsuccess) {
            bsuccess = _ReorderACL(pacl_padded);
            if (bsuccess)
                bsuccess = This->SetACL(pacl_padded);
        }
        else
            PyWin_SetAPIError(funcname);
    }
    if (pacl_padded)
        free(pacl_padded);
    if (bsuccess) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
}","PyObject *addaceex(addaceexfunc VAR_0, CHAR *VAR_1, PyACL *VAR_2, DWORD VAR_3, DWORD VAR_4, DWORD VAR_5,
                   PyObject *VAR_6)
{
    /* COMMENT_0 */
    if (VAR_0 == NULL)
        return PyErr_Format(VAR_7, ""%s not supported by this version of Windows"", VAR_1);
    PSID VAR_8;
    BOOL VAR_9;
    PACL VAR_10 = VAR_2->GetACL();
    PACL VAR_11 = NULL;
    if (!PyWinObject_AsSID(VAR_6, &VAR_8, FALSE))
        return NULL;

    VAR_9 = (*VAR_0)(VAR_10, VAR_3, VAR_4, VAR_5, VAR_8);
    if (VAR_9)
        VAR_9 = _ReorderACL(VAR_10);
    else {
        DWORD VAR_12 = GetLastError();
        if (VAR_12 != VAR_13)
            return PyWin_SetAPIError(VAR_1, VAR_12);
        /* COMMENT_1 */
        unsigned int VAR_14 = VAR_10->AclSize + sizeof(VAR_15) + GetLengthSid(VAR_8);
        /* COMMENT_2 */
        if (VAR_14 > VAR_16)
            return PyErr_Format(VAR_17, ""%s: adding ACE would put ACL over size limit"", VAR_1);
        VAR_11 = (ACL *)malloc(VAR_14);
        if (VAR_11 == NULL)
            return PyErr_Format(VAR_18, ""%s: unable to allocated %d bytes"", VAR_1, VAR_14);

        ZeroMemory(VAR_11, VAR_14);
        memcpy(VAR_11, VAR_10, VAR_10->AclSize);
        VAR_11->AclSize = (unsigned short)VAR_14;
        VAR_9 = (*VAR_0)(VAR_11, VAR_3, VAR_4, VAR_5, VAR_8);
        if (VAR_9) {
            VAR_9 = _ReorderACL(VAR_11);
            if (VAR_9)
                VAR_9 = VAR_2->SetACL(VAR_11);
        }
        else
            PyWin_SetAPIError(VAR_1);
    }
    if (VAR_11)
        free(VAR_11);
    if (VAR_9) {
        Py_INCREF(VAR_19);
        return VAR_19;
    }
    return NULL;
}",mhammond/pywin32/b860822ad233304fceefc4644bd353087a5309ec/PyACL.cpp/vul/after/2.json,"--- func_before
+++ func_after
@@ -19,14 +19,17 @@
         if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
             return PyWin_SetAPIError(funcname, err);
         // resize if dacl too small
-        unsigned short required_size = pacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + (unsigned short)GetLengthSid(psid);
+        unsigned int required_size = pacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psid);
+        // max ACL size is USHRT_MAX
+        if (required_size > USHRT_MAX)
+            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", funcname);
         pacl_padded = (ACL *)malloc(required_size);
         if (pacl_padded == NULL)
             return PyErr_Format(PyExc_MemoryError, ""%s: unable to allocated %d bytes"", funcname, required_size);
 
         ZeroMemory(pacl_padded, required_size);
         memcpy(pacl_padded, pacl, pacl->AclSize);
-        pacl_padded->AclSize = required_size;
+        pacl_padded->AclSize = (unsigned short)required_size;
         bsuccess = (*addfunc)(pacl_padded, revision, aceflags, access, psid);
         if (bsuccess) {
             bsuccess = _ReorderACL(pacl_padded);","{'deleted_lines': ['        unsigned short required_size = pacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + (unsigned short)GetLengthSid(psid);', '        pacl_padded->AclSize = required_size;'], 'added_lines': ['        unsigned int required_size = pacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psid);', '        // max ACL size is USHRT_MAX', '        if (required_size > USHRT_MAX)', '            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", funcname);', '        pacl_padded->AclSize = (unsigned short)required_size;']}",True,An integer overflow exists in pywin32 prior to version b301 when adding an access control entry (ACE) to an access control list (ACL) that would cause the size to be greater than 65535 bytes. An attacker who successfully exploited this vulnerability could crash the vulnerable process.,6.5,MEDIUM,1,test,2021-05-11T14:52:37Z,3
CVE-2021-32559,['CWE-190'],AV:N/AC:L/Au:S/C:N/I:N/A:P,0,mhammond/pywin32,"PyACL - Fixing integer overflows that occur when resizing ACLs

Fixes #1700
CVE-2021-32559",b860822ad233304fceefc4644bd353087a5309ec,https://github.com/mhammond/pywin32/commit/b860822ad233304fceefc4644bd353087a5309ec,win32/src/PyACL.cpp,PyACL::AddAuditAccessAce,"PyObject *PyACL::AddAuditAccessAce(PyObject *self, PyObject *args)
{
DWORD accessmask, acerevision;
BOOL bAuditSuccess, bAuditFailure;
PyObject *obSID;
PSID psid;
PACL psacl;
PyACL *This = (PyACL *)self;
psacl = This->GetACL();
PACL psacl_padded = NULL;
BOOL bsuccess;
if (!PyArg_ParseTuple(args, ""llOii:AddAuditAccessAce"", &acerevision, &accessmask, &obSID, &bAuditSuccess,
&bAuditFailure))
return NULL;
if (!PyWinObject_AsSID(obSID, &psid, FALSE))
return NULL;
bsuccess = ::AddAuditAccessAce(psacl, acerevision, accessmask, psid, bAuditSuccess, bAuditFailure);
if (!bsuccess) {
DWORD err = GetLastError();
if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
return PyWin_SetAPIError(""AddAuditAccessAce"", err);
unsigned short required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_ACE) + (unsigned short)GetLengthSid(psid);
psacl_padded = (ACL *)malloc(required_size);
if (psacl_padded == NULL)
return PyErr_Format(PyExc_MemoryError, ""AddAuditAccessAce: unable to allocated %d bytes"", required_size);
ZeroMemory(psacl_padded, required_size);
memcpy(psacl_padded, psacl, psacl->AclSize);
psacl_padded->AclSize = required_size;
bsuccess = ::AddAuditAccessAce(psacl_padded, acerevision, accessmask, psid, bAuditSuccess, bAuditFailure);
if (bsuccess)
bsuccess = This->SetACL(psacl_padded);
else
PyWin_SetAPIError(""AddAuditAccessAce"");
}
if (psacl_padded)
free(psacl_padded);
if (bsuccess) {
Py_INCREF(Py_None);
return Py_None;
}
return NULL;
}","PyObject *PyACL::AddAuditAccessAce(PyObject *VAR_0, PyObject *VAR_1)
{
DWORD VAR_2, VAR_3;
BOOL VAR_4, VAR_5;
PyObject *VAR_6;
PSID VAR_7;
PACL VAR_8;
PyACL *VAR_9 = (PyACL *)VAR_0;
VAR_8 = VAR_9->GetACL();
PACL VAR_10 = NULL;
BOOL VAR_11;
if (!PyArg_ParseTuple(VAR_1, ""llOii:AddAuditAccessAce"", &VAR_3, &VAR_2, &VAR_6, &VAR_4,
&VAR_5))
return NULL;
if (!PyWinObject_AsSID(VAR_6, &VAR_7, FALSE))
return NULL;
VAR_11 = ::AddAuditAccessAce(VAR_8, VAR_3, VAR_2, VAR_7, VAR_4, VAR_5);
if (!VAR_11) {
DWORD VAR_12 = GetLastError();
if (VAR_12 != VAR_13)
return PyWin_SetAPIError(""AddAuditAccessAce"", VAR_12);
unsigned short VAR_14 = VAR_8->AclSize + sizeof(VAR_15) + (unsigned short)GetLengthSid(VAR_7);
VAR_10 = (ACL *)malloc(VAR_14);
if (VAR_10 == NULL)
return PyErr_Format(VAR_16, ""AddAuditAccessAce: unable to allocated %d bytes"", VAR_14);
ZeroMemory(VAR_10, VAR_14);
memcpy(VAR_10, VAR_8, VAR_8->AclSize);
VAR_10->AclSize = VAR_14;
VAR_11 = ::AddAuditAccessAce(VAR_10, VAR_3, VAR_2, VAR_7, VAR_4, VAR_5);
if (VAR_11)
VAR_11 = VAR_9->SetACL(VAR_10);
else
PyWin_SetAPIError(""AddAuditAccessAce"");
}
if (VAR_10)
free(VAR_10);
if (VAR_11) {
Py_INCREF(VAR_17);
return VAR_17;
}
return NULL;
}",mhammond/pywin32/b860822ad233304fceefc4644bd353087a5309ec/PyACL.cpp/vul/before/1.json,"PyObject *PyACL::AddAuditAccessAce(PyObject *self, PyObject *args)
{
    DWORD accessmask, acerevision;
    BOOL bAuditSuccess, bAuditFailure;
    PyObject *obSID;
    PSID psid;
    PACL psacl;
    PyACL *This = (PyACL *)self;
    psacl = This->GetACL();
    PACL psacl_padded = NULL;
    BOOL bsuccess;
    // @pyparm int|dwAceRevision||Revision of ACL: Pre-Win2k, must be ACL_REVISION. Win2K on up, can also be
    // ACL_REVISION_DS
    // @pyparm int|dwAccessMask||Bitmask of access types to be audited
    // @pyparm <o PySID>|sid||SID for whom system audit messages will be generated
    // @pyparm int|bAuditSuccess||Set to 1 if access success should be audited, else 0
    // @pyparm int|bAuditFailure||Set to 1 if access failure should be audited, else 0

    if (!PyArg_ParseTuple(args, ""llOii:AddAuditAccessAce"", &acerevision, &accessmask, &obSID, &bAuditSuccess,
                          &bAuditFailure))
        return NULL;
    if (!PyWinObject_AsSID(obSID, &psid, FALSE))
        return NULL;
    bsuccess = ::AddAuditAccessAce(psacl, acerevision, accessmask, psid, bAuditSuccess, bAuditFailure);
    if (!bsuccess) {
        DWORD err = GetLastError();
        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
            return PyWin_SetAPIError(""AddAuditAccessAce"", err);
        // resize if acl too small
        unsigned int required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_ACE) + GetLengthSid(psid);
        // max ACL size is USHRT_MAX
        if (required_size > USHRT_MAX)
            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", __FUNCTION__ );
        ZeroMemory(psacl_padded, required_size);
        memcpy(psacl_padded, psacl, psacl->AclSize);
        psacl_padded->AclSize = (unsigned short)required_size;
        bsuccess = ::AddAuditAccessAce(psacl_padded, acerevision, accessmask, psid, bAuditSuccess, bAuditFailure);
        if (bsuccess)
            bsuccess = This->SetACL(psacl_padded);
        else
            PyWin_SetAPIError(""AddAuditAccessAce"");
    }

    if (psacl_padded)
        free(psacl_padded);
    if (bsuccess) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
}","PyObject *PyACL::AddAuditAccessAce(PyObject *VAR_0, PyObject *VAR_1)
{
    DWORD VAR_2, VAR_3;
    BOOL VAR_4, VAR_5;
    PyObject *VAR_6;
    PSID VAR_7;
    PACL VAR_8;
    PyACL *VAR_9 = (PyACL *)VAR_0;
    VAR_8 = VAR_9->GetACL();
    PACL VAR_10 = NULL;
    BOOL VAR_11;
    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_5 */

    if (!PyArg_ParseTuple(VAR_1, ""llOii:AddAuditAccessAce"", &VAR_3, &VAR_2, &VAR_6, &VAR_4,
                          &VAR_5))
        return NULL;
    if (!PyWinObject_AsSID(VAR_6, &VAR_7, FALSE))
        return NULL;
    VAR_11 = ::AddAuditAccessAce(VAR_8, VAR_3, VAR_2, VAR_7, VAR_4, VAR_5);
    if (!VAR_11) {
        DWORD VAR_12 = GetLastError();
        if (VAR_12 != VAR_13)
            return PyWin_SetAPIError(""AddAuditAccessAce"", VAR_12);
        /* COMMENT_6 */
        unsigned int VAR_14 = VAR_8->AclSize + sizeof(VAR_15) + GetLengthSid(VAR_7);
        /* COMMENT_7 */
        if (VAR_14 > VAR_16)
            return PyErr_Format(VAR_17, ""%s: adding ACE would put ACL over size limit"", VAR_18 );
        ZeroMemory(VAR_10, VAR_14);
        memcpy(VAR_10, VAR_8, VAR_8->AclSize);
        VAR_10->AclSize = (unsigned short)VAR_14;
        VAR_11 = ::AddAuditAccessAce(VAR_10, VAR_3, VAR_2, VAR_7, VAR_4, VAR_5);
        if (VAR_11)
            VAR_11 = VAR_9->SetACL(VAR_10);
        else
            PyWin_SetAPIError(""AddAuditAccessAce"");
    }

    if (VAR_10)
        free(VAR_10);
    if (VAR_11) {
        Py_INCREF(VAR_19);
        return VAR_19;
    }
    return NULL;
}",mhammond/pywin32/b860822ad233304fceefc4644bd353087a5309ec/PyACL.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -27,14 +27,13 @@
         if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)
             return PyWin_SetAPIError(""AddAuditAccessAce"", err);
         // resize if acl too small
-        unsigned short required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_ACE) + (unsigned short)GetLengthSid(psid);
-        psacl_padded = (ACL *)malloc(required_size);
-        if (psacl_padded == NULL)
-            return PyErr_Format(PyExc_MemoryError, ""AddAuditAccessAce: unable to allocated %d bytes"", required_size);
-
+        unsigned int required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_ACE) + GetLengthSid(psid);
+        // max ACL size is USHRT_MAX
+        if (required_size > USHRT_MAX)
+            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", __FUNCTION__ );
         ZeroMemory(psacl_padded, required_size);
         memcpy(psacl_padded, psacl, psacl->AclSize);
-        psacl_padded->AclSize = required_size;
+        psacl_padded->AclSize = (unsigned short)required_size;
         bsuccess = ::AddAuditAccessAce(psacl_padded, acerevision, accessmask, psid, bAuditSuccess, bAuditFailure);
         if (bsuccess)
             bsuccess = This->SetACL(psacl_padded);","{'deleted_lines': ['        unsigned short required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_ACE) + (unsigned short)GetLengthSid(psid);', '        psacl_padded = (ACL *)malloc(required_size);', '        if (psacl_padded == NULL)', '            return PyErr_Format(PyExc_MemoryError, ""AddAuditAccessAce: unable to allocated %d bytes"", required_size);', '', '        psacl_padded->AclSize = required_size;'], 'added_lines': ['        unsigned int required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_ACE) + GetLengthSid(psid);', '        // max ACL size is USHRT_MAX', '        if (required_size > USHRT_MAX)', '            return PyErr_Format(PyExc_OverflowError, ""%s: adding ACE would put ACL over size limit"", __FUNCTION__ );', '        psacl_padded->AclSize = (unsigned short)required_size;']}",True,An integer overflow exists in pywin32 prior to version b301 when adding an access control entry (ACE) to an access control list (ACL) that would cause the size to be greater than 65535 bytes. An attacker who successfully exploited this vulnerability could crash the vulnerable process.,6.5,MEDIUM,1,test,2021-05-11T14:52:37Z,3
CVE-2021-33586,['CWE-732'],AV:N/AC:L/Au:S/C:P/I:N/A:N,0,inspircd,Fix sending malformed pong messages in some cases.,4350a11c663b0d75f8119743bffb7736d87abd4d,https://github.com/inspircd/inspircd/commit/4350a11c663b0d75f8119743bffb7736d87abd4d,include/clientprotocolmsg.h,Pong,"Pong(const std::string& cookie, const std::string& server = """")
: ClientProtocol::Message(""PONG"", ServerInstance->Config->GetServerName())
{
PushParamRef(ServerInstance->Config->GetServerName());
if (!server.empty())
PushParamRef(server);
PushParamRef(cookie);
}","Pong(const std::string& VAR_0, const std::string& VAR_1 = """")
: ClientProtocol::Message(""PONG"", VAR_2->Config->GetServerName())
{
PushParamRef(VAR_2->Config->GetServerName());
if (!VAR_1.empty())
PushParamRef(VAR_1);
PushParamRef(VAR_0);
}",,"Pong(const std::string& cookie, const std::string& server = """")
		: ClientProtocol::Message(""PONG"", ServerInstance->Config->GetServerName())
	{
		if (server.empty())
			PushParamRef(ServerInstance->Config->GetServerName());
		else
			PushParam(server);
		PushParamRef(cookie);
	}","Pong(const std::string& VAR_0, const std::string& VAR_1 = """")
		: ClientProtocol::Message(""PONG"", VAR_2->Config->GetServerName())
	{
		if (VAR_1.empty())
			PushParamRef(VAR_2->Config->GetServerName());
		else
			PushParam(VAR_1);
		PushParamRef(VAR_0);
	}",,"--- func_before
+++ func_after
@@ -1,8 +1,9 @@
 Pong(const std::string& cookie, const std::string& server = """")
 		: ClientProtocol::Message(""PONG"", ServerInstance->Config->GetServerName())
 	{
-		PushParamRef(ServerInstance->Config->GetServerName());
-		if (!server.empty())
-			PushParamRef(server);
+		if (server.empty())
+			PushParamRef(ServerInstance->Config->GetServerName());
+		else
+			PushParam(server);
 		PushParamRef(cookie);
 	}","{'deleted_lines': ['\t\tPushParamRef(ServerInstance->Config->GetServerName());', '\t\tif (!server.empty())', '\t\t\tPushParamRef(server);'], 'added_lines': ['\t\tif (server.empty())', '\t\t\tPushParamRef(ServerInstance->Config->GetServerName());', '\t\telse', '\t\t\tPushParam(server);']}",True,"InspIRCd 3.8.0 through 3.9.x before 3.10.0 allows any user (able to connect to the server) to access recently deallocated memory, aka the ""malformed PONG"" issue.",4.3,MEDIUM,1,test,2021-05-14T12:56:32Z,3
CVE-2021-33586,['CWE-732'],AV:N/AC:L/Au:S/C:P/I:N/A:N,0,inspircd,Fix sending malformed pong messages in some cases.,4350a11c663b0d75f8119743bffb7736d87abd4d,https://github.com/inspircd/inspircd/commit/4350a11c663b0d75f8119743bffb7736d87abd4d,src/coremods/core_user/core_user.cpp,HandleLocal,"CmdResult HandleLocal(LocalUser* user, const Params& parameters) CXX11_OVERRIDE
{
size_t origin = parameters.size() > 1 ? 1 : 0;
if (parameters[origin].empty())
{
user->WriteNumeric(ERR_NOORIGIN, ""No origin specified"");
return CMD_FAILURE;
}
ClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : """");
user->Send(ServerInstance->GetRFCEvents().pong, pong);
return CMD_SUCCESS;
}","CmdResult HandleLocal(LocalUser* VAR_0, const Params& VAR_1) VAR_2
{
size_t VAR_3 = VAR_1.size() > 1 ? 1 : 0;
if (VAR_1[VAR_3].empty())
{
VAR_0->WriteNumeric(VAR_4, ""No origin specified"");
return VAR_5;
}
ClientProtocol::Messages::Pong VAR_6(VAR_1[0], VAR_3 ? VAR_1[1] : """");
VAR_0->Send(VAR_7->GetRFCEvents().pong, VAR_6);
return VAR_8;
}",,"CmdResult HandleLocal(LocalUser* user, const Params& parameters) CXX11_OVERRIDE
	{
		size_t origin = parameters.size() > 1 ? 1 : 0;
		if (parameters[origin].empty())
		{
			user->WriteNumeric(ERR_NOORIGIN, ""No origin specified"");
			return CMD_FAILURE;
		}

		ClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : ServerInstance->Config->GetServerName());
		user->Send(ServerInstance->GetRFCEvents().pong, pong);
		return CMD_SUCCESS;
	}","CmdResult HandleLocal(LocalUser* VAR_0, const Params& VAR_1) VAR_2
	{
		size_t VAR_3 = VAR_1.size() > 1 ? 1 : 0;
		if (VAR_1[VAR_3].empty())
		{
			VAR_0->WriteNumeric(VAR_4, ""No origin specified"");
			return VAR_5;
		}

		ClientProtocol::Messages::Pong VAR_6(VAR_1[0], VAR_3 ? VAR_1[1] : VAR_7->Config->GetServerName());
		VAR_0->Send(VAR_7->GetRFCEvents().pong, VAR_6);
		return VAR_8;
	}",,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
 			return CMD_FAILURE;
 		}
 
-		ClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : """");
+		ClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : ServerInstance->Config->GetServerName());
 		user->Send(ServerInstance->GetRFCEvents().pong, pong);
 		return CMD_SUCCESS;
 	}","{'deleted_lines': ['\t\tClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : """");'], 'added_lines': ['\t\tClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : ServerInstance->Config->GetServerName());']}",True,"InspIRCd 3.8.0 through 3.9.x before 3.10.0 allows any user (able to connect to the server) to access recently deallocated memory, aka the ""malformed PONG"" issue.",4.3,MEDIUM,1,test,2021-05-14T12:56:32Z,3
CVE-2021-33035,['CWE-120'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,apache/openoffice,add useful checks,efddaef0151af3be16078cc4d88c6bae0f911e56,https://github.com/apache/openoffice/commit/efddaef0151af3be16078cc4d88c6bae0f911e56,main/connectivity/source/drivers/dbase/DTable.cxx,ODbaseTable::UpdateBuffer,"sal_Bool ODbaseTable::UpdateBuffer(OValueRefVector& rRow, OValueRefRow pOrgRow,const Reference<XIndexAccess>& _xCols)
{
RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, ""dbase"", ""Ocke.Janssen@sun.com"", ""ODbaseTable::UpdateBuffer"" );
OSL_ENSURE(m_pBuffer,""Buffer is NULL!"");
if ( !m_pBuffer )
return sal_False;
sal_Int32 nByteOffset  = 1;
Reference<XPropertySet> xCol;
Reference<XPropertySet> xIndex;
sal_uInt16 i;
::rtl::OUString aColName;
const sal_Int32 nColumnCount = m_pColumns->getCount();
::std::vector< Reference<XPropertySet> > aIndexedCols(nColumnCount);
::comphelper::UStringMixEqual aCase(isCaseSensitive());
Reference<XIndexAccess> xColumns = m_pColumns;
for (i = 0; i < nColumnCount; ++i)
{
sal_Int32 nPos = i;
if(_xCols != xColumns)
{
m_pColumns->getByIndex(i) >>= xCol;
OSL_ENSURE(xCol.is(),""ODbaseTable::UpdateBuffer column is null!"");
xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;
for(nPos = 0;nPos<_xCols->getCount();++nPos)
{
Reference<XPropertySet> xFindCol;
::cppu::extractInterface(xFindCol,_xCols->getByIndex(nPos));
OSL_ENSURE(xFindCol.is(),""ODbaseTable::UpdateBuffer column is null!"");
if(aCase(getString(xFindCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME))),aColName))
break;
}
if (nPos >= _xCols->getCount())
continue;
}
++nPos;
xIndex = isUniqueByColumnName(i);
aIndexedCols[i] = xIndex;
if (xIndex.is())
{
if(pOrgRow.isValid() && (rRow.get()[nPos]->getValue().isNull() || rRow.get()[nPos] == (pOrgRow->get())[nPos]))
continue;
else
{
Reference<XUnoTunnel> xTunnel(xIndex,UNO_QUERY);
OSL_ENSURE(xTunnel.is(),""No TunnelImplementation!"");
ODbaseIndex* pIndex = reinterpret_cast< ODbaseIndex* >( xTunnel->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) );
OSL_ENSURE(pIndex,""ODbaseTable::UpdateBuffer: No Index returned!"");
if (pIndex->Find(0,*rRow.get()[nPos]))
{
if ( !aColName.getLength() )
{
m_pColumns->getByIndex(i) >>= xCol;
OSL_ENSURE(xCol.is(),""ODbaseTable::UpdateBuffer column is null!"");
xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;
xCol.clear();
}                     const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(
STR_DUPLICATE_VALUE_IN_COLUMN
,""$columnname$"", aColName
) );
::dbtools::throwGenericSQLException( sError, *this );
}
}
}
}
for (i = 0; i < nColumnCount && nByteOffset <= m_nBufferSize ; ++i)
{
OSL_ENSURE(i < m_aPrecisions.size(),""Illegal index!"");
sal_Int32 nLen = 0;
sal_Int32 nType = 0;
sal_Int32 nScale = 0;
if ( i < m_aPrecisions.size() )
{
nLen= m_aPrecisions[i];
nType= m_aTypes[i];
nScale= m_aScales[i];
}
else
{
m_pColumns->getByIndex(i) >>= xCol;
if ( xCol.is() )
{
xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_PRECISION))>>= nLen;
xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_TYPE))>>= nType;
xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_SCALE))>>= nScale;
}
}
bool bSetZero = false;
switch (nType)
{
case DataType::INTEGER:
case DataType::DOUBLE:
case DataType::TIMESTAMP:
bSetZero = true;
case DataType::LONGVARBINARY:
case DataType::DATE:
case DataType::BIT:
case DataType::LONGVARCHAR:
nLen = m_aRealFieldLengths[i]; 
break;
case DataType::DECIMAL:
nLen = SvDbaseConverter::ConvertPrecisionToDbase(nLen,nScale);
break;default:
break;
} 
sal_Int32 nPos = i;
if(_xCols != xColumns)
{
m_pColumns->getByIndex(i) >>= xCol;
OSL_ENSURE(xCol.is(),""ODbaseTable::UpdateBuffer column is null!"");
xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;
for(nPos = 0;nPos<_xCols->getCount();++nPos)
{
Reference<XPropertySet> xFindCol;
::cppu::extractInterface(xFindCol,_xCols->getByIndex(nPos));
if(aCase(getString(xFindCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME))),aColName))
break;
}
if (nPos >= _xCols->getCount())
{
nByteOffset += nLen;
continue;
}
}
++nPos; if ( !rRow.get()[nPos]->isBound() )
{
nByteOffset += nLen;
continue;
}
if (aIndexedCols[i].is())
{
Reference<XUnoTunnel> xTunnel(aIndexedCols[i],UNO_QUERY);
OSL_ENSURE(xTunnel.is(),""No TunnelImplementation!"");
ODbaseIndex* pIndex = reinterpret_cast< ODbaseIndex* >( xTunnel->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) );
OSL_ENSURE(pIndex,""ODbaseTable::UpdateBuffer: No Index returned!"");
if (pOrgRow.isValid() && !rRow.get()[nPos]->getValue().isNull() )pIndex->Update(m_nFilePos,*(pOrgRow->get())[nPos],*rRow.get()[nPos]);
else
pIndex->Insert(m_nFilePos,*rRow.get()[nPos]);
}
char* pData = (char *)(m_pBuffer + nByteOffset);
if (rRow.get()[nPos]->getValue().isNull())
{
if ( bSetZero )
memset(pData,0,nLen);            else
memset(pData,' ',nLen);nByteOffset += nLen;
OSL_ENSURE( nByteOffset <= m_nBufferSize ,""ByteOffset > m_nBufferSize!"");
continue;
}
sal_Bool bHadError = sal_False;
try
{
switch (nType)
{
case DataType::TIMESTAMP:
{
sal_Int32 nJulianDate = 0, nJulianTime = 0;
lcl_CalcJulDate(nJulianDate,nJulianTime,rRow.get()[nPos]->getValue());
memcpy(pData,&nJulianDate,4);
memcpy(pData+4,&nJulianTime,4);
}
break;
case DataType::DATE:
{
::com::sun::star::util::Date aDate;
if(rRow.get()[nPos]->getValue().getTypeKind() == DataType::DOUBLE)
aDate = ::dbtools::DBTypeConversion::toDate(rRow.get()[nPos]->getValue().getDouble());
else
aDate = rRow.get()[nPos]->getValue();
char s[9];
snprintf(s,
sizeof(s),
""%04d%02d%02d"",
(int)aDate.Year,
(int)aDate.Month,
(int)aDate.Day);
strncpy(pData,s,sizeof s - 1);
} break;
case DataType::INTEGER:
{
sal_Int32 nValue = rRow.get()[nPos]->getValue();
memcpy(pData,&nValue,nLen);
}
break;
case DataType::DOUBLE:
{
const double d = rRow.get()[nPos]->getValue();
m_pColumns->getByIndex(i) >>= xCol;
if (getBOOL(xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY))))                         {
sal_Int64 nValue = 0;
if ( m_aScales[i] )
nValue = (sal_Int64)(d * pow(10.0,(int)m_aScales[i]));
else
nValue = (sal_Int64)(d);
memcpy(pData,&nValue,nLen);
}                         else
memcpy(pData,&d,nLen);
}
break;
case DataType::DECIMAL:
{
memset(pData,' ',nLen);
const double n = rRow.get()[nPos]->getValue();
const ByteString aDefaultValue( ::rtl::math::doubleToString( n, rtl_math_StringFormat_F, nScale, '.', NULL, 0));
sal_Bool bValidLength  = aDefaultValue.Len() <= nLen;
if ( bValidLength )
{
strncpy(pData,aDefaultValue.GetBuffer(),nLen);
*rRow.get()[nPos] = toDouble(aDefaultValue);
}
else
{
m_pColumns->getByIndex(i) >>= xCol;
OSL_ENSURE(xCol.is(),""ODbaseTable::UpdateBuffer column is null!"");
xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;
::std::list< ::std::pair<const sal_Char* , ::rtl::OUString > > aStringToSubstitutes;
aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$columnname$"", aColName));
aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$precision$"", String::CreateFromInt32(nLen)));
aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$scale$"", String::CreateFromInt32(nScale)));
aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$value$"", ::rtl::OStringToOUString(aDefaultValue,RTL_TEXTENCODING_UTF8)));
const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(
STR_INVALID_COLUMN_DECIMAL_VALUE
,aStringToSubstitutes
) );
::dbtools::throwGenericSQLException( sError, *this );
}
} break;
case DataType::BIT:
*pData = rRow.get()[nPos]->getValue().getBool() ? 'T' : 'F';
break;
case DataType::LONGVARBINARY:
case DataType::LONGVARCHAR:
{
char cNext = pData[nLen]; pData[nLen] = '\0';  
sal_uIntPtr nBlockNo = strtol((const char *)pData,NULL,10);
pData[nLen] = cNext;
if (!m_pMemoStream || !WriteMemo(rRow.get()[nPos]->get(), nBlockNo))
break;
ByteString aStr;
ByteString aBlock(ByteString::CreateFromInt32(nBlockNo));
aStr.Expand(static_cast<sal_uInt16>(nLen - aBlock.Len()), '0' );
aStr += aBlock;
memset(pData,' ',nLen);memcpy(pData, aStr.GetBuffer(), nLen);
}break;
default:
{
memset(pData,' ',nLen);
::rtl::OUString sStringToWrite( rRow.get()[nPos]->getValue().getString() );
::rtl::OString sEncoded;
DBTypeConversion::convertUnicodeStringToLength( sStringToWrite, sEncoded, nLen, m_eEncoding );
memcpy( pData, sEncoded.getStr(), sEncoded.getLength() );
}
break;
}
}
catch( SQLException&  )
{
throw;
}
catch ( Exception& ) { bHadError = sal_True; }
if ( bHadError )
{
m_pColumns->getByIndex(i) >>= xCol;
OSL_ENSURE( xCol.is(), ""ODbaseTable::UpdateBuffer column is null!"" );
if ( xCol.is() )
xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;
const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(
STR_INVALID_COLUMN_VALUE,
""$columnname$"", aColName
) );
::dbtools::throwGenericSQLException( sError, *this );
}
nByteOffset += nLen;
OSL_ENSURE( nByteOffset <= m_nBufferSize ,""ByteOffset > m_nBufferSize!"");
}
return sal_True;
}","sal_Bool ODbaseTable::UpdateBuffer(OValueRefVector& VAR_0, OValueRefRow VAR_1,const Reference<XIndexAccess>& VAR_2)
{
RTL_LOGFILE_CONTEXT_AUTHOR( VAR_3, ""dbase"", ""Ocke.Janssen@sun.com"", ""ODbaseTable::UpdateBuffer"" );
OSL_ENSURE(VAR_4,""Buffer is NULL!"");
if ( !VAR_4 )
return VAR_5;
sal_Int32 VAR_6  = 1;
Reference<XPropertySet> VAR_7;
Reference<XPropertySet> VAR_8;
sal_uInt16 VAR_9;
::rtl::OUString VAR_10;
const sal_Int32 VAR_11 = VAR_12->getCount();
::std::vector< Reference<XPropertySet> > aIndexedCols(nColumnCount);
::comphelper::UStringMixEqual aCase(isCaseSensitive());
Reference<XIndexAccess> VAR_13 = VAR_12;
for (VAR_9 = 0; VAR_9 < nColumnCount; ++VAR_9)
{
sal_Int32 VAR_14 = VAR_9;
if(VAR_2 != VAR_13)
{
VAR_12->getByIndex(VAR_9) >>= VAR_7;
OSL_ENSURE(VAR_7.is(),""ODbaseTable::UpdateBuffer column is null!"");
VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_15)) >>= VAR_10;
for(VAR_14 = 0;VAR_14<VAR_2->getCount();++VAR_14)
{
Reference<XPropertySet> VAR_16;
::cppu::extractInterface(VAR_16,VAR_2->getByIndex(VAR_14));
OSL_ENSURE(VAR_16.is(),""ODbaseTable::UpdateBuffer column is null!"");
if(aCase(getString(VAR_16->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_15))),VAR_10))
break;
}
if (VAR_14 >= VAR_2->getCount())
continue;
}
++VAR_14;
VAR_8 = isUniqueByColumnName(VAR_9);
VAR_17[VAR_9] = VAR_8;
if (VAR_8.is())
{
if(VAR_1.isValid() && (VAR_0.get()[VAR_14]->getValue().isNull() || VAR_0.get()[VAR_14] == (VAR_1->get())[VAR_14]))
continue;
else
{
Reference<XUnoTunnel> xTunnel(xIndex,UNO_QUERY);
OSL_ENSURE(VAR_18.is(),""No TunnelImplementation!"");
ODbaseIndex* VAR_19 = VAR_20< ODbaseIndex* >( VAR_18->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) );
OSL_ENSURE(VAR_19,""ODbaseTable::UpdateBuffer: No Index returned!"");
if (VAR_19->Find(0,*VAR_0.get()[VAR_14]))
{
if ( !VAR_10.getLength() )
{
VAR_12->getByIndex(VAR_9) >>= VAR_7;
OSL_ENSURE(VAR_7.is(),""ODbaseTable::UpdateBuffer column is null!"");
VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_15)) >>= VAR_10;
VAR_7.clear();
} 
const ::rtl::OUString VAR_21( getConnection()->getResources().getResourceStringWithSubstitution(
VAR_22
,""$columnname$"", VAR_10
) );
::dbtools::throwGenericSQLException( VAR_21, *this );
}
}
}
}
for (VAR_9 = 0; VAR_9 < nColumnCount && VAR_6 <= VAR_23 ; ++VAR_9)
{
OSL_ENSURE(VAR_9 < VAR_24.size(),""Illegal index!"");
sal_Int32 VAR_25 = 0;
sal_Int32 VAR_26 = 0;
sal_Int32 VAR_27 = 0;
if ( VAR_9 < VAR_24.size() )
{
VAR_25= VAR_24[VAR_9];
VAR_26= VAR_28[VAR_9];
VAR_27= VAR_29[VAR_9];
}
else
{
VAR_12->getByIndex(VAR_9) >>= VAR_7;
if ( VAR_7.is() )
{
VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_30))>>= VAR_25;
VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_31))>>= VAR_26;
VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_32))>>= VAR_27;
}
}
bool VAR_33 = false;
switch (VAR_26)
{
case DataType::INTEGER:
case DataType::DOUBLE:
case DataType::TIMESTAMP:
VAR_33 = true;
case DataType::LONGVARBINARY:
case DataType::DATE:
case DataType::BIT:
case DataType::LONGVARCHAR:
VAR_25 = VAR_34[VAR_9]; 
break;
case DataType::DECIMAL:
VAR_25 = SvDbaseConverter::ConvertPrecisionToDbase(VAR_25,VAR_27);
break;
default:
break;
} 
sal_Int32 VAR_14 = VAR_9;
if(VAR_2 != VAR_13)
{
VAR_12->getByIndex(VAR_9) >>= VAR_7;
OSL_ENSURE(VAR_7.is(),""ODbaseTable::UpdateBuffer column is null!"");
VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_15)) >>= VAR_10;
for(VAR_14 = 0;VAR_14<VAR_2->getCount();++VAR_14)
{
Reference<XPropertySet> VAR_16;
::cppu::extractInterface(VAR_16,VAR_2->getByIndex(VAR_14));
if(aCase(getString(VAR_16->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_15))),VAR_10))
break;
}
if (VAR_14 >= VAR_2->getCount())
{
VAR_6 += VAR_25;
continue;
}
}
++VAR_14; 
if ( !VAR_0.get()[VAR_14]->isBound() )
{
VAR_6 += VAR_25;
continue;
}
if (VAR_17[VAR_9].is())
{
Reference<XUnoTunnel> xTunnel(aIndexedCols[VAR_9],UNO_QUERY);
OSL_ENSURE(VAR_18.is(),""No TunnelImplementation!"");
ODbaseIndex* VAR_19 = VAR_20< ODbaseIndex* >( VAR_18->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) );
OSL_ENSURE(VAR_19,""ODbaseTable::UpdateBuffer: No Index returned!"");
if (VAR_1.isValid() && !VAR_0.get()[VAR_14]->getValue().isNull() )
VAR_19->Update(VAR_35,*(VAR_1->get())[VAR_14],*VAR_0.get()[VAR_14]);
else
VAR_19->Insert(VAR_35,*VAR_0.get()[VAR_14]);
}
char* VAR_36 = (char *)(VAR_4 + VAR_6);
if (VAR_0.get()[VAR_14]->getValue().isNull())
{
if ( VAR_33 )
memset(VAR_36,0,VAR_25);
else
memset(VAR_36,' ',VAR_25);
VAR_6 += VAR_25;
OSL_ENSURE( VAR_6 <= VAR_23 ,""ByteOffset > m_nBufferSize!"");
continue;
}
sal_Bool VAR_37 = VAR_5;
try
{
switch (VAR_26)
{
case DataType::TIMESTAMP:
{
sal_Int32 VAR_38 = 0, VAR_39 = 0;
lcl_CalcJulDate(VAR_38,VAR_39,VAR_0.get()[VAR_14]->getValue());
memcpy(VAR_36,&VAR_38,4);
memcpy(VAR_36+4,&VAR_39,4);
}
break;
case DataType::DATE:
{
::com::sun::star::util::Date VAR_40;
if(VAR_0.get()[VAR_14]->getValue().getTypeKind() == DataType::DOUBLE)
VAR_40 = ::dbtools::DBTypeConversion::toDate(VAR_0.get()[VAR_14]->getValue().getDouble());
else
VAR_40 = VAR_0.get()[VAR_14]->getValue();
char VAR_41[9];
snprintf(VAR_41,
sizeof(VAR_41),
""%04d%02d%02d"",
(int)VAR_40.Year,
(int)VAR_40.Month,
(int)VAR_40.Day);
strncpy(VAR_36,VAR_41,sizeof VAR_41 - 1);
} break;
case DataType::INTEGER:
{
sal_Int32 VAR_42 = VAR_0.get()[VAR_14]->getValue();
memcpy(VAR_36,&VAR_42,VAR_25);
}
break;
case DataType::DOUBLE:
{
const double VAR_43 = VAR_0.get()[VAR_14]->getValue();
VAR_12->getByIndex(VAR_9) >>= VAR_7;
if (getBOOL(VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_44)))) 
{
sal_Int64 VAR_42 = 0;
if ( VAR_29[VAR_9] )
VAR_42 = (sal_Int64)(VAR_43 * pow(10.0,(int)VAR_29[VAR_9]));
else
VAR_42 = (sal_Int64)(VAR_43);
memcpy(VAR_36,&VAR_42,VAR_25);
} 
else
memcpy(VAR_36,&VAR_43,VAR_25);
}
break;
case DataType::DECIMAL:
{
memset(VAR_36,' ',VAR_25);
const double VAR_45 = VAR_0.get()[VAR_14]->getValue();
const ByteString VAR_46( ::rtl::math::doubleToString( VAR_45, VAR_47, VAR_27, '.', NULL, 0));
sal_Bool VAR_48  = VAR_46.Len() <= VAR_25;
if ( VAR_48 )
{
strncpy(VAR_36,VAR_46.GetBuffer(),VAR_25);
*VAR_0.get()[VAR_14] = toDouble(VAR_46);
}
else
{
VAR_12->getByIndex(VAR_9) >>= VAR_7;
OSL_ENSURE(VAR_7.is(),""ODbaseTable::UpdateBuffer column is null!"");
VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_15)) >>= VAR_10;
::std::list< ::std::pair<const sal_Char* , ::rtl::OUString > > VAR_49;
VAR_49.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$columnname$"", VAR_10));
VAR_49.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$precision$"", String::CreateFromInt32(VAR_25)));
VAR_49.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$scale$"", String::CreateFromInt32(VAR_27)));
VAR_49.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$value$"", ::rtl::OStringToOUString(VAR_46,VAR_50)));
const ::rtl::OUString VAR_21( getConnection()->getResources().getResourceStringWithSubstitution(
VAR_51
,VAR_49
) );
::dbtools::throwGenericSQLException( VAR_21, *this );
}
} break;
case DataType::BIT:
*VAR_36 = VAR_0.get()[VAR_14]->getValue().getBool() ? 'T' : 'F';
break;
case DataType::LONGVARBINARY:
case DataType::LONGVARCHAR:
{
char VAR_52 = VAR_36[VAR_25]; 
VAR_36[VAR_25] = '\0';  
sal_uIntPtr VAR_53 = strtol((const char *)VAR_36,NULL,10);
VAR_36[VAR_25] = VAR_52;
if (!VAR_54 || !WriteMemo(VAR_0.get()[VAR_14]->get(), VAR_53))
break;
ByteString VAR_55;
ByteString aBlock(ByteString::CreateFromInt32(nBlockNo));
VAR_55.Expand(VAR_56<sal_uInt16>(VAR_25 - VAR_57.Len()), '0' );
VAR_55 += VAR_57;
memset(VAR_36,' ',VAR_25);
memcpy(VAR_36, VAR_55.GetBuffer(), VAR_25);
}break;
default:
{
memset(VAR_36,' ',VAR_25);
::rtl::OUString VAR_58( VAR_0.get()[VAR_14]->getValue().getString() );
::rtl::OString VAR_59;
DBTypeConversion::convertUnicodeStringToLength( VAR_58, VAR_59, VAR_25, VAR_60 );
memcpy( VAR_36, VAR_59.getStr(), VAR_59.getLength() );
}
break;
}
}
catch( SQLException&  )
{
throw;
}
catch ( Exception& ) { VAR_37 = VAR_61; }
if ( VAR_37 )
{
VAR_12->getByIndex(VAR_9) >>= VAR_7;
OSL_ENSURE( VAR_7.is(), ""ODbaseTable::UpdateBuffer column is null!"" );
if ( VAR_7.is() )
VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_15)) >>= VAR_10;
const ::rtl::OUString VAR_21( getConnection()->getResources().getResourceStringWithSubstitution(
VAR_62,
""$columnname$"", VAR_10
) );
::dbtools::throwGenericSQLException( VAR_21, *this );
}
VAR_6 += VAR_25;
OSL_ENSURE( VAR_6 <= VAR_23 ,""ByteOffset > m_nBufferSize!"");
}
return VAR_61;
}",apache/openoffice/efddaef0151af3be16078cc4d88c6bae0f911e56/DTable.cxx/vul/before/1.json,"sal_Bool ODbaseTable::UpdateBuffer(OValueRefVector& rRow, OValueRefRow pOrgRow,const Reference<XIndexAccess>& _xCols)
{
    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, ""dbase"", ""Ocke.Janssen@sun.com"", ""ODbaseTable::UpdateBuffer"" );
	OSL_ENSURE(m_pBuffer,""Buffer is NULL!"");
	if ( !m_pBuffer )
		return sal_False;
	sal_Int32 nByteOffset  = 1;

	// Felder aktualisieren:
	Reference<XPropertySet> xCol;
	Reference<XPropertySet> xIndex;
	sal_uInt16 i;
	::rtl::OUString aColName;
	const sal_Int32 nColumnCount = m_pColumns->getCount();
	::std::vector< Reference<XPropertySet> > aIndexedCols(nColumnCount);

	::comphelper::UStringMixEqual aCase(isCaseSensitive());

	Reference<XIndexAccess> xColumns = m_pColumns;
	// first search a key that exist already in the table
	for (i = 0; i < nColumnCount; ++i)
	{
		sal_Int32 nPos = i;
		if(_xCols != xColumns)
		{
			m_pColumns->getByIndex(i) >>= xCol;
			OSL_ENSURE(xCol.is(),""ODbaseTable::UpdateBuffer column is null!"");
			xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;

			for(nPos = 0;nPos<_xCols->getCount();++nPos)
			{
				Reference<XPropertySet> xFindCol;
				::cppu::extractInterface(xFindCol,_xCols->getByIndex(nPos));
				OSL_ENSURE(xFindCol.is(),""ODbaseTable::UpdateBuffer column is null!"");
				if(aCase(getString(xFindCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME))),aColName))
					break;
			}
			if (nPos >= _xCols->getCount())
				continue;
		}

		++nPos;
		xIndex = isUniqueByColumnName(i);
		aIndexedCols[i] = xIndex;
		if (xIndex.is())
		{
			// first check if the value is different to the old one and when if it conform to the index
			if(pOrgRow.isValid() && (rRow.get()[nPos]->getValue().isNull() || rRow.get()[nPos] == (pOrgRow->get())[nPos]))
				continue;
			else
			{
				//	ODbVariantRef xVar = (pVal == NULL) ? new ODbVariant() : pVal;
				Reference<XUnoTunnel> xTunnel(xIndex,UNO_QUERY);
				OSL_ENSURE(xTunnel.is(),""No TunnelImplementation!"");
				ODbaseIndex* pIndex = reinterpret_cast< ODbaseIndex* >( xTunnel->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) );
				OSL_ENSURE(pIndex,""ODbaseTable::UpdateBuffer: No Index returned!"");

				if (pIndex->Find(0,*rRow.get()[nPos]))
				{
					// es existiert kein eindeutiger Wert
					if ( !aColName.getLength() )
					{
						m_pColumns->getByIndex(i) >>= xCol;
						OSL_ENSURE(xCol.is(),""ODbaseTable::UpdateBuffer column is null!"");
						xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;
						xCol.clear();
					} // if ( !aColName.getLength() )
                    const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(
                            STR_DUPLICATE_VALUE_IN_COLUMN
                            ,""$columnname$"", aColName
                         ) );
                    ::dbtools::throwGenericSQLException( sError, *this );
				}
			}
		}
	}

	// when we are here there is no double key in the table

	for (i = 0; i < nColumnCount && nByteOffset <= m_nBufferSize ; ++i)
	{
		// Laengen je nach Datentyp:
		OSL_ENSURE(i < m_aPrecisions.size(),""Illegal index!"");
		sal_Int32 nLen = 0;
		sal_Int32 nType = 0;
		sal_Int32 nScale = 0;
		if ( i < m_aPrecisions.size() )
		{
			nLen	= m_aPrecisions[i];
			nType	= m_aTypes[i];
			nScale	= m_aScales[i];
		}
		else
		{
			m_pColumns->getByIndex(i) >>= xCol;
			if ( xCol.is() )
			{
				xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_PRECISION))	>>= nLen;
				xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_TYPE))		>>= nType;
				xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_SCALE))		>>= nScale;
			}
		}

        bool bSetZero = false;
		switch (nType)
		{
            case DataType::INTEGER:
            case DataType::DOUBLE:
            case DataType::TIMESTAMP:
                bSetZero = true;
            case DataType::LONGVARBINARY:
			case DataType::DATE:
            case DataType::BIT:			
			case DataType::LONGVARCHAR:
                nLen = m_aRealFieldLengths[i]; 
                break;
			case DataType::DECIMAL:
				nLen = SvDbaseConverter::ConvertPrecisionToDbase(nLen,nScale);
				break;	// das Vorzeichen und das Komma
			default:					
                break;

		} // switch (nType)

		sal_Int32 nPos = i;
		if(_xCols != xColumns)
		{
			m_pColumns->getByIndex(i) >>= xCol;
			OSL_ENSURE(xCol.is(),""ODbaseTable::UpdateBuffer column is null!"");
			xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;
			for(nPos = 0;nPos<_xCols->getCount();++nPos)
			{
				Reference<XPropertySet> xFindCol;
				::cppu::extractInterface(xFindCol,_xCols->getByIndex(nPos));
				if(aCase(getString(xFindCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME))),aColName))
					break;
			}
			if (nPos >= _xCols->getCount())
			{
				nByteOffset += nLen;
				continue;
			}
		}



		++nPos; // the row values start at 1
		// Ist die Variable ueberhaupt gebunden?
		if ( !rRow.get()[nPos]->isBound() )
		{
			// Nein - naechstes Feld.
			nByteOffset += nLen;
			continue;
		}
		if (aIndexedCols[i].is())
		{
			Reference<XUnoTunnel> xTunnel(aIndexedCols[i],UNO_QUERY);
			OSL_ENSURE(xTunnel.is(),""No TunnelImplementation!"");
			ODbaseIndex* pIndex = reinterpret_cast< ODbaseIndex* >( xTunnel->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) );
			OSL_ENSURE(pIndex,""ODbaseTable::UpdateBuffer: No Index returned!"");
			// Update !!
			if (pOrgRow.isValid() && !rRow.get()[nPos]->getValue().isNull() )//&& pVal->isModified())
				pIndex->Update(m_nFilePos,*(pOrgRow->get())[nPos],*rRow.get()[nPos]);
			else
				pIndex->Insert(m_nFilePos,*rRow.get()[nPos]);
		}

		char* pData = (char *)(m_pBuffer + nByteOffset);
		if (rRow.get()[nPos]->getValue().isNull())
		{
            if ( bSetZero )
                memset(pData,0,nLen);	// Zuruecksetzen auf NULL
            else
			    memset(pData,' ',nLen);	// Zuruecksetzen auf NULL
			nByteOffset += nLen;
			OSL_ENSURE( nByteOffset <= m_nBufferSize ,""ByteOffset > m_nBufferSize!"");
			continue;
		}

        sal_Bool bHadError = sal_False;
		try
		{
			switch (nType)
			{
                case DataType::TIMESTAMP:
                    {
                        OSL_ENSURE(nLen == 8, ""Invalid length for timestamp field"");
                        if (nLen != 8) {
                            bHadError = true;
                            break;
                        }
                        sal_Int32 nJulianDate = 0, nJulianTime = 0;
                        lcl_CalcJulDate(nJulianDate,nJulianTime,rRow.get()[nPos]->getValue());
                        // Genau 8 Byte kopieren:
					    memcpy(pData,&nJulianDate,4);
                        memcpy(pData+4,&nJulianTime,4);
                    }
                    break;
				case DataType::DATE:
				{
                    OSL_ENSURE(nLen == 8, ""Invalid length for date field"");
                    if (nLen != 8) {
                        bHadError = true;
                        break;
                    }
					::com::sun::star::util::Date aDate;
					if(rRow.get()[nPos]->getValue().getTypeKind() == DataType::DOUBLE)
						aDate = ::dbtools::DBTypeConversion::toDate(rRow.get()[nPos]->getValue().getDouble());
					else
						aDate = rRow.get()[nPos]->getValue();
					char s[9];
					snprintf(s,
						sizeof(s),
						""%04d%02d%02d"",
						(int)aDate.Year,
						(int)aDate.Month,
						(int)aDate.Day);

					// Genau 8 Byte kopieren:
					strncpy(pData,s,sizeof s - 1);
				} break;
                case DataType::INTEGER:
                    {
                        OSL_ENSURE(nLen == 4, ""Invalid length for integer field"");
                        if (nLen != 4) {
                            bHadError = true;
                            break;
                        }
                        sal_Int32 nValue = rRow.get()[nPos]->getValue();
                        memcpy(pData,&nValue,nLen);
                    }
                    break;
                case DataType::DOUBLE:
                    {
                        OSL_ENSURE(nLen == 8, ""Invalid length for double field"");
                        if (nLen != 8) {
                            bHadError = true;
                            break;
                        }
                        const double d = rRow.get()[nPos]->getValue();
                        m_pColumns->getByIndex(i) >>= xCol;
                        
                        if (getBOOL(xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY)))) // Currency wird gesondert behandelt
                        {
                            sal_Int64 nValue = 0;
                            if ( m_aScales[i] )
                                nValue = (sal_Int64)(d * pow(10.0,(int)m_aScales[i]));
                            else
                                nValue = (sal_Int64)(d);
                            memcpy(pData,&nValue,nLen);
                        } // if (getBOOL(xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY)))) // Currency wird gesondert behandelt
                        else
                            memcpy(pData,&d,nLen);
                    }
                    break;
				case DataType::DECIMAL:
				{
					memset(pData,' ',nLen);	// Zuruecksetzen auf NULL

					const double n = rRow.get()[nPos]->getValue();

					// ein const_cast, da GetFormatPrecision am SvNumberFormat nicht const ist, obwohl es das eigentlich
					// sein koennte und muesste

					const ByteString aDefaultValue( ::rtl::math::doubleToString( n, rtl_math_StringFormat_F, nScale, '.', NULL, 0));
                    sal_Bool bValidLength  = aDefaultValue.Len() <= nLen;
                    if ( bValidLength )
                    {
					    strncpy(pData,aDefaultValue.GetBuffer(),nLen);
					    // write the resulting double back
					    *rRow.get()[nPos] = toDouble(aDefaultValue);
                    }
                    else
					{
						m_pColumns->getByIndex(i) >>= xCol;
						OSL_ENSURE(xCol.is(),""ODbaseTable::UpdateBuffer column is null!"");
						xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;
                        ::std::list< ::std::pair<const sal_Char* , ::rtl::OUString > > aStringToSubstitutes;
                        aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$columnname$"", aColName));
                        aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$precision$"", String::CreateFromInt32(nLen)));
                        aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$scale$"", String::CreateFromInt32(nScale)));
                        aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$value$"", ::rtl::OStringToOUString(aDefaultValue,RTL_TEXTENCODING_UTF8)));

                        const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(
                                STR_INVALID_COLUMN_DECIMAL_VALUE
                                ,aStringToSubstitutes
                             ) );
                        ::dbtools::throwGenericSQLException( sError, *this );
					}
				} break;
				case DataType::BIT:
                    OSL_ENSURE(nLen == 1, ""Invalid length for bit field"");
                    if (nLen != 1) {
                        bHadError = true;
                        break;
                    }
					*pData = rRow.get()[nPos]->getValue().getBool() ? 'T' : 'F';
					break;
                case DataType::LONGVARBINARY:
				case DataType::LONGVARCHAR:
				{
					char cNext = pData[nLen]; // merken und temporaer durch 0 ersetzen
					pData[nLen] = '\0';		  // das geht, da der Puffer immer ein Zeichen groesser ist ...

					sal_uIntPtr nBlockNo = strtol((const char *)pData,NULL,10);	// Blocknummer lesen

					// Naechstes Anfangszeichen wieder restaurieren:
					pData[nLen] = cNext;
					if (!m_pMemoStream || !WriteMemo(rRow.get()[nPos]->get(), nBlockNo))
						break;

					ByteString aStr;
					ByteString aBlock(ByteString::CreateFromInt32(nBlockNo));
					aStr.Expand(static_cast<sal_uInt16>(nLen - aBlock.Len()), '0' );
					aStr += aBlock;
					// Zeichen kopieren:
					memset(pData,' ',nLen);	// Zuruecksetzen auf NULL
					memcpy(pData, aStr.GetBuffer(), nLen);
				}	break;
				default:
				{
					memset(pData,' ',nLen);	// Zuruecksetzen auf NULL

                    ::rtl::OUString sStringToWrite( rRow.get()[nPos]->getValue().getString() );

                    // convert the string, using the connection's encoding
                    ::rtl::OString sEncoded;
                   
                    DBTypeConversion::convertUnicodeStringToLength( sStringToWrite, sEncoded, nLen, m_eEncoding );
                    memcpy( pData, sEncoded.getStr(), sEncoded.getLength() );

				}
                break;
			}
		}
		catch( SQLException&  )
        {
            throw;
        }
		catch ( Exception& ) { bHadError = sal_True; }

		if ( bHadError )
		{
			m_pColumns->getByIndex(i) >>= xCol;
			OSL_ENSURE( xCol.is(), ""ODbaseTable::UpdateBuffer column is null!"" );
            if ( xCol.is() )
			    xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;

			const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(
                    STR_INVALID_COLUMN_VALUE,
                    ""$columnname$"", aColName
                 ) );
            ::dbtools::throwGenericSQLException( sError, *this );
		}
		// Und weiter ...
		nByteOffset += nLen;
		OSL_ENSURE( nByteOffset <= m_nBufferSize ,""ByteOffset > m_nBufferSize!"");
	}
	return sal_True;
}","sal_Bool ODbaseTable::UpdateBuffer(OValueRefVector& VAR_0, OValueRefRow VAR_1,const Reference<XIndexAccess>& VAR_2)
{
    RTL_LOGFILE_CONTEXT_AUTHOR( VAR_3, ""dbase"", ""Ocke.Janssen@sun.com"", ""ODbaseTable::UpdateBuffer"" );
	OSL_ENSURE(VAR_4,""Buffer is NULL!"");
	if ( !VAR_4 )
		return VAR_5;
	sal_Int32 VAR_6  = 1;

	/* COMMENT_0 */
	Reference<XPropertySet> VAR_7;
	Reference<XPropertySet> VAR_8;
	sal_uInt16 VAR_9;
	::rtl::OUString VAR_10;
	const sal_Int32 VAR_11 = VAR_12->getCount();
	::std::vector< Reference<XPropertySet> > aIndexedCols(nColumnCount);

	::comphelper::UStringMixEqual aCase(isCaseSensitive());

	Reference<XIndexAccess> VAR_13 = VAR_12;
	/* COMMENT_1 */
	for (VAR_9 = 0; VAR_9 < nColumnCount; ++VAR_9)
	{
		sal_Int32 VAR_14 = VAR_9;
		if(VAR_2 != VAR_13)
		{
			VAR_12->getByIndex(VAR_9) >>= VAR_7;
			OSL_ENSURE(VAR_7.is(),""ODbaseTable::UpdateBuffer column is null!"");
			VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_15)) >>= VAR_10;

			for(VAR_14 = 0;VAR_14<VAR_2->getCount();++VAR_14)
			{
				Reference<XPropertySet> VAR_16;
				::cppu::extractInterface(VAR_16,VAR_2->getByIndex(VAR_14));
				OSL_ENSURE(VAR_16.is(),""ODbaseTable::UpdateBuffer column is null!"");
				if(aCase(getString(VAR_16->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_15))),VAR_10))
					break;
			}
			if (VAR_14 >= VAR_2->getCount())
				continue;
		}

		++VAR_14;
		VAR_8 = isUniqueByColumnName(VAR_9);
		VAR_17[VAR_9] = VAR_8;
		if (VAR_8.is())
		{
			/* COMMENT_2 */
			if(VAR_1.isValid() && (VAR_0.get()[VAR_14]->getValue().isNull() || VAR_0.get()[VAR_14] == (VAR_1->get())[VAR_14]))
				continue;
			else
			{
				/* COMMENT_3 */
				Reference<XUnoTunnel> xTunnel(xIndex,UNO_QUERY);
				OSL_ENSURE(VAR_18.is(),""No TunnelImplementation!"");
				ODbaseIndex* VAR_19 = VAR_20< ODbaseIndex* >( VAR_18->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) );
				OSL_ENSURE(VAR_19,""ODbaseTable::UpdateBuffer: No Index returned!"");

				if (VAR_19->Find(0,*VAR_0.get()[VAR_14]))
				{
					/* COMMENT_4 */
					if ( !VAR_10.getLength() )
					{
						VAR_12->getByIndex(VAR_9) >>= VAR_7;
						OSL_ENSURE(VAR_7.is(),""ODbaseTable::UpdateBuffer column is null!"");
						VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_15)) >>= VAR_10;
						VAR_7.clear();
					} /* COMMENT_5 */
                    const ::rtl::OUString VAR_21( getConnection()->getResources().getResourceStringWithSubstitution(
                            VAR_22
                            ,""$columnname$"", VAR_10
                         ) );
                    ::dbtools::throwGenericSQLException( VAR_21, *this );
				}
			}
		}
	}

	/* COMMENT_6 */

	for (VAR_9 = 0; VAR_9 < nColumnCount && VAR_6 <= VAR_23 ; ++VAR_9)
	{
		/* COMMENT_7 */
		OSL_ENSURE(VAR_9 < VAR_24.size(),""Illegal index!"");
		sal_Int32 VAR_25 = 0;
		sal_Int32 VAR_26 = 0;
		sal_Int32 VAR_27 = 0;
		if ( VAR_9 < VAR_24.size() )
		{
			VAR_25	= VAR_24[VAR_9];
			VAR_26	= VAR_28[VAR_9];
			VAR_27	= VAR_29[VAR_9];
		}
		else
		{
			VAR_12->getByIndex(VAR_9) >>= VAR_7;
			if ( VAR_7.is() )
			{
				VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_30))	>>= VAR_25;
				VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_31))		>>= VAR_26;
				VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_32))		>>= VAR_27;
			}
		}

        bool VAR_33 = false;
		switch (VAR_26)
		{
            case DataType::INTEGER:
            case DataType::DOUBLE:
            case DataType::TIMESTAMP:
                VAR_33 = true;
            case DataType::LONGVARBINARY:
			case DataType::DATE:
            case DataType::BIT:			
			case DataType::LONGVARCHAR:
                VAR_25 = VAR_34[VAR_9]; 
                break;
			case DataType::DECIMAL:
				VAR_25 = SvDbaseConverter::ConvertPrecisionToDbase(VAR_25,VAR_27);
				break;	/* COMMENT_8 */
			default:					
                break;

		} /* COMMENT_9 */

		sal_Int32 VAR_14 = VAR_9;
		if(VAR_2 != VAR_13)
		{
			VAR_12->getByIndex(VAR_9) >>= VAR_7;
			OSL_ENSURE(VAR_7.is(),""ODbaseTable::UpdateBuffer column is null!"");
			VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_15)) >>= VAR_10;
			for(VAR_14 = 0;VAR_14<VAR_2->getCount();++VAR_14)
			{
				Reference<XPropertySet> VAR_16;
				::cppu::extractInterface(VAR_16,VAR_2->getByIndex(VAR_14));
				if(aCase(getString(VAR_16->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_15))),VAR_10))
					break;
			}
			if (VAR_14 >= VAR_2->getCount())
			{
				VAR_6 += VAR_25;
				continue;
			}
		}



		++VAR_14; /* COMMENT_10 */
		/* COMMENT_11 */
		if ( !VAR_0.get()[VAR_14]->isBound() )
		{
			/* COMMENT_12 */
			VAR_6 += VAR_25;
			continue;
		}
		if (VAR_17[VAR_9].is())
		{
			Reference<XUnoTunnel> xTunnel(aIndexedCols[VAR_9],UNO_QUERY);
			OSL_ENSURE(VAR_18.is(),""No TunnelImplementation!"");
			ODbaseIndex* VAR_19 = VAR_20< ODbaseIndex* >( VAR_18->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) );
			OSL_ENSURE(VAR_19,""ODbaseTable::UpdateBuffer: No Index returned!"");
			/* COMMENT_13 */
			if (VAR_1.isValid() && !VAR_0.get()[VAR_14]->getValue().isNull() )/* COMMENT_14 */
				VAR_19->Update(VAR_35,*(VAR_1->get())[VAR_14],*VAR_0.get()[VAR_14]);
			else
				VAR_19->Insert(VAR_35,*VAR_0.get()[VAR_14]);
		}

		char* VAR_36 = (char *)(VAR_4 + VAR_6);
		if (VAR_0.get()[VAR_14]->getValue().isNull())
		{
            if ( VAR_33 )
                memset(VAR_36,0,VAR_25);	/* COMMENT_15 */
            else
			    memset(VAR_36,' ',VAR_25);	/* COMMENT_15 */
			VAR_6 += VAR_25;
			OSL_ENSURE( VAR_6 <= VAR_23 ,""ByteOffset > m_nBufferSize!"");
			continue;
		}

        sal_Bool VAR_37 = VAR_5;
		try
		{
			switch (VAR_26)
			{
                case DataType::TIMESTAMP:
                    {
                        OSL_ENSURE(VAR_25 == 8, ""Invalid length for timestamp field"");
                        if (VAR_25 != 8) {
                            VAR_37 = true;
                            break;
                        }
                        sal_Int32 VAR_38 = 0, VAR_39 = 0;
                        lcl_CalcJulDate(VAR_38,VAR_39,VAR_0.get()[VAR_14]->getValue());
                        /* COMMENT_16 */
					    memcpy(VAR_36,&VAR_38,4);
                        memcpy(VAR_36+4,&VAR_39,4);
                    }
                    break;
				case DataType::DATE:
				{
                    OSL_ENSURE(VAR_25 == 8, ""Invalid length for date field"");
                    if (VAR_25 != 8) {
                        VAR_37 = true;
                        break;
                    }
					::com::sun::star::util::Date VAR_40;
					if(VAR_0.get()[VAR_14]->getValue().getTypeKind() == DataType::DOUBLE)
						VAR_40 = ::dbtools::DBTypeConversion::toDate(VAR_0.get()[VAR_14]->getValue().getDouble());
					else
						VAR_40 = VAR_0.get()[VAR_14]->getValue();
					char VAR_41[9];
					snprintf(VAR_41,
						sizeof(VAR_41),
						""%04d%02d%02d"",
						(int)VAR_40.Year,
						(int)VAR_40.Month,
						(int)VAR_40.Day);

					/* COMMENT_16 */
					strncpy(VAR_36,VAR_41,sizeof VAR_41 - 1);
				} break;
                case DataType::INTEGER:
                    {
                        OSL_ENSURE(VAR_25 == 4, ""Invalid length for integer field"");
                        if (VAR_25 != 4) {
                            VAR_37 = true;
                            break;
                        }
                        sal_Int32 VAR_42 = VAR_0.get()[VAR_14]->getValue();
                        memcpy(VAR_36,&VAR_42,VAR_25);
                    }
                    break;
                case DataType::DOUBLE:
                    {
                        OSL_ENSURE(VAR_25 == 8, ""Invalid length for double field"");
                        if (VAR_25 != 8) {
                            VAR_37 = true;
                            break;
                        }
                        const double VAR_43 = VAR_0.get()[VAR_14]->getValue();
                        VAR_12->getByIndex(VAR_9) >>= VAR_7;
                        
                        if (getBOOL(VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_44)))) /* COMMENT_17 */
                        {
                            sal_Int64 VAR_42 = 0;
                            if ( VAR_29[VAR_9] )
                                VAR_42 = (sal_Int64)(VAR_43 * pow(10.0,(int)VAR_29[VAR_9]));
                            else
                                VAR_42 = (sal_Int64)(VAR_43);
                            memcpy(VAR_36,&VAR_42,VAR_25);
                        } /* COMMENT_18 */
                        else
                            memcpy(VAR_36,&VAR_43,VAR_25);
                    }
                    break;
				case DataType::DECIMAL:
				{
					memset(VAR_36,' ',VAR_25);	/* COMMENT_15 */

					const double VAR_45 = VAR_0.get()[VAR_14]->getValue();

					/* COMMENT_19 */
					/* COMMENT_20 */

					const ByteString VAR_46( ::rtl::math::doubleToString( VAR_45, VAR_47, VAR_27, '.', NULL, 0));
                    sal_Bool VAR_48  = VAR_46.Len() <= VAR_25;
                    if ( VAR_48 )
                    {
					    strncpy(VAR_36,VAR_46.GetBuffer(),VAR_25);
					    /* COMMENT_21 */
					    *VAR_0.get()[VAR_14] = toDouble(VAR_46);
                    }
                    else
					{
						VAR_12->getByIndex(VAR_9) >>= VAR_7;
						OSL_ENSURE(VAR_7.is(),""ODbaseTable::UpdateBuffer column is null!"");
						VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_15)) >>= VAR_10;
                        ::std::list< ::std::pair<const sal_Char* , ::rtl::OUString > > VAR_49;
                        VAR_49.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$columnname$"", VAR_10));
                        VAR_49.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$precision$"", String::CreateFromInt32(VAR_25)));
                        VAR_49.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$scale$"", String::CreateFromInt32(VAR_27)));
                        VAR_49.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$value$"", ::rtl::OStringToOUString(VAR_46,VAR_50)));

                        const ::rtl::OUString VAR_21( getConnection()->getResources().getResourceStringWithSubstitution(
                                VAR_51
                                ,VAR_49
                             ) );
                        ::dbtools::throwGenericSQLException( VAR_21, *this );
					}
				} break;
				case DataType::BIT:
                    OSL_ENSURE(VAR_25 == 1, ""Invalid length for bit field"");
                    if (VAR_25 != 1) {
                        VAR_37 = true;
                        break;
                    }
					*VAR_36 = VAR_0.get()[VAR_14]->getValue().getBool() ? 'T' : 'F';
					break;
                case DataType::LONGVARBINARY:
				case DataType::LONGVARCHAR:
				{
					char VAR_52 = VAR_36[VAR_25]; /* COMMENT_22 */
					VAR_36[VAR_25] = '\0';		  /* COMMENT_23 */

					sal_uIntPtr VAR_53 = strtol((const char *)VAR_36,NULL,10);	/* COMMENT_24 */

					/* COMMENT_25 */
					VAR_36[VAR_25] = VAR_52;
					if (!VAR_54 || !WriteMemo(VAR_0.get()[VAR_14]->get(), VAR_53))
						break;

					ByteString VAR_55;
					ByteString aBlock(ByteString::CreateFromInt32(nBlockNo));
					VAR_55.Expand(VAR_56<sal_uInt16>(VAR_25 - VAR_57.Len()), '0' );
					VAR_55 += VAR_57;
					/* COMMENT_26 */
					memset(VAR_36,' ',VAR_25);	/* COMMENT_15 */
					memcpy(VAR_36, VAR_55.GetBuffer(), VAR_25);
				}	break;
				default:
				{
					memset(VAR_36,' ',VAR_25);	/* COMMENT_15 */

                    ::rtl::OUString VAR_58( VAR_0.get()[VAR_14]->getValue().getString() );

                    /* COMMENT_27 */
                    ::rtl::OString VAR_59;
                   
                    DBTypeConversion::convertUnicodeStringToLength( VAR_58, VAR_59, VAR_25, VAR_60 );
                    memcpy( VAR_36, VAR_59.getStr(), VAR_59.getLength() );

				}
                break;
			}
		}
		catch( SQLException&  )
        {
            throw;
        }
		catch ( Exception& ) { VAR_37 = VAR_61; }

		if ( VAR_37 )
		{
			VAR_12->getByIndex(VAR_9) >>= VAR_7;
			OSL_ENSURE( VAR_7.is(), ""ODbaseTable::UpdateBuffer column is null!"" );
            if ( VAR_7.is() )
			    VAR_7->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_15)) >>= VAR_10;

			const ::rtl::OUString VAR_21( getConnection()->getResources().getResourceStringWithSubstitution(
                    VAR_62,
                    ""$columnname$"", VAR_10
                 ) );
            ::dbtools::throwGenericSQLException( VAR_21, *this );
		}
		/* COMMENT_28 */
		VAR_6 += VAR_25;
		OSL_ENSURE( VAR_6 <= VAR_23 ,""ByteOffset > m_nBufferSize!"");
	}
	return VAR_61;
}",apache/openoffice/efddaef0151af3be16078cc4d88c6bae0f911e56/DTable.cxx/vul/after/1.json,"--- func_before
+++ func_after
@@ -184,6 +184,11 @@
 			{
                 case DataType::TIMESTAMP:
                     {
+                        OSL_ENSURE(nLen == 8, ""Invalid length for timestamp field"");
+                        if (nLen != 8) {
+                            bHadError = true;
+                            break;
+                        }
                         sal_Int32 nJulianDate = 0, nJulianTime = 0;
                         lcl_CalcJulDate(nJulianDate,nJulianTime,rRow.get()[nPos]->getValue());
                         // Genau 8 Byte kopieren:
@@ -193,6 +198,11 @@
                     break;
 				case DataType::DATE:
 				{
+                    OSL_ENSURE(nLen == 8, ""Invalid length for date field"");
+                    if (nLen != 8) {
+                        bHadError = true;
+                        break;
+                    }
 					::com::sun::star::util::Date aDate;
 					if(rRow.get()[nPos]->getValue().getTypeKind() == DataType::DOUBLE)
 						aDate = ::dbtools::DBTypeConversion::toDate(rRow.get()[nPos]->getValue().getDouble());
@@ -211,12 +221,22 @@
 				} break;
                 case DataType::INTEGER:
                     {
+                        OSL_ENSURE(nLen == 4, ""Invalid length for integer field"");
+                        if (nLen != 4) {
+                            bHadError = true;
+                            break;
+                        }
                         sal_Int32 nValue = rRow.get()[nPos]->getValue();
                         memcpy(pData,&nValue,nLen);
                     }
                     break;
                 case DataType::DOUBLE:
                     {
+                        OSL_ENSURE(nLen == 8, ""Invalid length for double field"");
+                        if (nLen != 8) {
+                            bHadError = true;
+                            break;
+                        }
                         const double d = rRow.get()[nPos]->getValue();
                         m_pColumns->getByIndex(i) >>= xCol;
                         
@@ -269,6 +289,11 @@
 					}
 				} break;
 				case DataType::BIT:
+                    OSL_ENSURE(nLen == 1, ""Invalid length for bit field"");
+                    if (nLen != 1) {
+                        bHadError = true;
+                        break;
+                    }
 					*pData = rRow.get()[nPos]->getValue().getBool() ? 'T' : 'F';
 					break;
                 case DataType::LONGVARBINARY:","{'deleted_lines': [], 'added_lines': ['                        OSL_ENSURE(nLen == 8, ""Invalid length for timestamp field"");', '                        if (nLen != 8) {', '                            bHadError = true;', '                            break;', '                        }', '                    OSL_ENSURE(nLen == 8, ""Invalid length for date field"");', '                    if (nLen != 8) {', '                        bHadError = true;', '                        break;', '                    }', '                        OSL_ENSURE(nLen == 4, ""Invalid length for integer field"");', '                        if (nLen != 4) {', '                            bHadError = true;', '                            break;', '                        }', '                        OSL_ENSURE(nLen == 8, ""Invalid length for double field"");', '                        if (nLen != 8) {', '                            bHadError = true;', '                            break;', '                        }', '                    OSL_ENSURE(nLen == 1, ""Invalid length for bit field"");', '                    if (nLen != 1) {', '                        bHadError = true;', '                        break;', '                    }']}",True,"Apache OpenOffice opens dBase/DBF documents and shows the contents as spreadsheets. DBF are database files with data organized in fields. When reading DBF data the size of certain fields is not checked: the data is just copied into local variables. A carefully crafted document could overflow the allocated space, leading to the execution of arbitrary code by altering the contents of the program stack. This issue affects Apache OpenOffice up to and including version 4.1.10",7.8,HIGH,2,test,2021-05-15T19:27:35Z,3
CVE-2021-33035,['CWE-120'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,apache/openoffice,add useful checks,efddaef0151af3be16078cc4d88c6bae0f911e56,https://github.com/apache/openoffice/commit/efddaef0151af3be16078cc4d88c6bae0f911e56,main/connectivity/source/drivers/dbase/DTable.cxx,ODbaseTable::fetchRow,"sal_Bool ODbaseTable::fetchRow(OValueRefRow& _rRow,const OSQLColumns & _rCols, sal_Bool _bUseTableDefs,sal_Bool bRetrieveData)
{
RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, ""dbase"", ""Ocke.Janssen@sun.com"", ""ODbaseTable::fetchRow"" );
sal_Bool bIsCurRecordDeleted = ((char)m_pBuffer[0] == '*') ? sal_True : sal_False;
_rRow->setDeleted(bIsCurRecordDeleted);
*(_rRow->get())[0] = m_nFilePos;
if (!bRetrieveData)
return sal_True;
sal_Size nByteOffset = 1;
OSQLColumns::Vector::const_iterator aIter = _rCols.get().begin();
OSQLColumns::Vector::const_iterator aEnd  = _rCols.get().end();
const sal_Size nCount = _rRow->get().size();
for (sal_Size i = 1; aIter != aEnd && nByteOffset <= m_nBufferSize && i < nCount;++aIter, i++)
{
sal_Int32 nLen = 0;
sal_Int32 nType = 0;
if(_bUseTableDefs)
{
nLen= m_aPrecisions[i-1];
nType= m_aTypes[i-1];
}
else
{
(*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_PRECISION))>>= nLen;
(*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_TYPE))>>= nType;
}
switch(nType)
{
case DataType::INTEGER:
case DataType::DOUBLE:
case DataType::TIMESTAMP:
case DataType::DATE:
case DataType::BIT:
case DataType::LONGVARCHAR:
case DataType::LONGVARBINARY:   
nLen = m_aRealFieldLengths[i-1]; 
break;
case DataType::DECIMAL:
if(_bUseTableDefs)
nLen = SvDbaseConverter::ConvertPrecisionToDbase(nLen,m_aScales[i-1]);
else
nLen = SvDbaseConverter::ConvertPrecisionToDbase(nLen,getINT32((*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_SCALE))));
break;
case DataType::BINARY:
case DataType::OTHER:
nByteOffset += nLen;
continue;
}
if ( !(_rRow->get())[i]->isBound() )
{
nByteOffset += nLen;
OSL_ENSURE( nByteOffset <= m_nBufferSize ,""ByteOffset > m_nBufferSize!"");
continue;
}         if ( ( nByteOffset + nLen) > m_nBufferSize )
break; 
char *pData = (char *) (m_pBuffer + nByteOffset);
if (nType == DataType::CHAR || nType == DataType::VARCHAR)
{
char cLast = pData[nLen];
pData[nLen] = 0;
String aStr(pData,(xub_StrLen)nLen,m_eEncoding);
aStr.EraseTrailingChars();
if ( aStr.Len() )
*(_rRow->get())[i] = ::rtl::OUString(aStr);
else                (_rRow->get())[i]->setNull();
pData[nLen] = cLast;
}         else if ( DataType::TIMESTAMP == nType )
{
sal_Int32 nDate = 0,nTime = 0;
memcpy(&nDate, pData, 4);
memcpy(&nTime, pData+ 4, 4);
if ( !nDate && !nTime )
{
(_rRow->get())[i]->setNull();
}
else
{
::com::sun::star::util::DateTime aDateTime;
lcl_CalDate(nDate,nTime,aDateTime);
*(_rRow->get())[i] = aDateTime;
}
}
else if ( DataType::INTEGER == nType )
{
sal_Int32 nValue = 0;
memcpy(&nValue, pData, nLen);
*(_rRow->get())[i] = nValue;
}
else if ( DataType::DOUBLE == nType )
{
double d = 0.0;
if (getBOOL((*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY))))             {
sal_Int64 nValue = 0;
memcpy(&nValue, pData, nLen);
if ( m_aScales[i-1] )
d = (double)(nValue / pow(10.0,(int)m_aScales[i-1]));
else
d = (double)(nValue);
}
else
{
memcpy(&d, pData, nLen);
}
*(_rRow->get())[i] = d;
}
else
{
for (sal_Int32 k = 0; k < nLen; k++)
{
if (pData[k] == '\0')
pData[k] = ' ';
}
String aStr(pData, (xub_StrLen)nLen,m_eEncoding);aStr.EraseLeadingChars();
aStr.EraseTrailingChars();
if (!aStr.Len())
{
nByteOffset += nLen;
(_rRow->get())[i]->setNull();continue;
}
switch (nType)
{
case DataType::DATE:
{
if (aStr.Len() != nLen)
{
(_rRow->get())[i]->setNull();
break;
}
const sal_uInt16  nYear   = (sal_uInt16)aStr.Copy( 0, 4 ).ToInt32();
const sal_uInt16  nMonth  = (sal_uInt16)aStr.Copy( 4, 2 ).ToInt32();
const sal_uInt16  nDay    = (sal_uInt16)aStr.Copy( 6, 2 ).ToInt32();
const ::com::sun::star::util::Date aDate(nDay,nMonth,nYear);
*(_rRow->get())[i] = aDate;
}
break;
case DataType::DECIMAL:
*(_rRow->get())[i] = ORowSetValue(aStr);
break;
case DataType::BIT:
{
sal_Bool b;
switch (* ((const char *)pData))
{
case 'T':
case 'Y':
case 'J':b = sal_True; break;
default: b = sal_False; break;
}
*(_rRow->get())[i] = b;
}
break;
case DataType::LONGVARBINARY:
case DataType::BINARY:
case DataType::LONGVARCHAR:
{
const long nBlockNo = aStr.ToInt32();if (nBlockNo > 0 && m_pMemoStream) {
if ( !ReadMemo(nBlockNo, (_rRow->get())[i]->get()) )
break;
}
else
(_rRow->get())[i]->setNull();
}break;
default:
OSL_ASSERT(""Falscher Type"");
}
(_rRow->get())[i]->setTypeKind(nType);
}
nByteOffset += nLen;
OSL_ENSURE( nByteOffset <= m_nBufferSize ,""ByteOffset > m_nBufferSize!"");
}
return sal_True;
}","sal_Bool ODbaseTable::fetchRow(OValueRefRow& VAR_0,const OSQLColumns & VAR_1, sal_Bool VAR_2,sal_Bool VAR_3)
{
RTL_LOGFILE_CONTEXT_AUTHOR( VAR_4, ""dbase"", ""Ocke.Janssen@sun.com"", ""ODbaseTable::fetchRow"" );
sal_Bool VAR_5 = ((char)VAR_6[0] == '*') ? VAR_7 : VAR_8;
VAR_0->setDeleted(VAR_5);
*(VAR_0->get())[0] = VAR_9;
if (!VAR_3)
return VAR_7;
sal_Size VAR_10 = 1;
OSQLColumns::Vector::const_iterator VAR_11 = VAR_1.get().begin();
OSQLColumns::Vector::const_iterator VAR_12  = VAR_1.get().end();
const sal_Size VAR_13 = VAR_0->get().size();
for (sal_Size VAR_14 = 1; VAR_11 != VAR_12 && VAR_10 <= VAR_15 && VAR_14 < VAR_13;++VAR_11, VAR_14++)
{
sal_Int32 VAR_16 = 0;
sal_Int32 VAR_17 = 0;
if(VAR_2)
{
VAR_16= VAR_18[VAR_14-1];
VAR_17= VAR_19[VAR_14-1];
}
else
{
(*VAR_11)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_20))>>= VAR_16;
(*VAR_11)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_21))>>= VAR_17;
}
switch(VAR_17)
{
case DataType::INTEGER:
case DataType::DOUBLE:
case DataType::TIMESTAMP:
case DataType::DATE:
case DataType::BIT:
case DataType::LONGVARCHAR:
case DataType::LONGVARBINARY:   
VAR_16 = VAR_22[VAR_14-1]; 
break;
case DataType::DECIMAL:
if(VAR_2)
VAR_16 = SvDbaseConverter::ConvertPrecisionToDbase(VAR_16,VAR_23[VAR_14-1]);
else
VAR_16 = SvDbaseConverter::ConvertPrecisionToDbase(VAR_16,getINT32((*VAR_11)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_24))));
break;
case DataType::BINARY:
case DataType::OTHER:
VAR_10 += VAR_16;
continue;
}
if ( !(VAR_0->get())[VAR_14]->isBound() )
{
VAR_10 += VAR_16;
OSL_ENSURE( VAR_10 <= VAR_15 ,""ByteOffset > m_nBufferSize!"");
continue;
} 
if ( ( VAR_10 + VAR_16) > VAR_15 )
break; 
char *VAR_25 = (char *) (VAR_6 + VAR_10);
if (VAR_17 == DataType::CHAR || VAR_17 == DataType::VARCHAR)
{
char VAR_26 = VAR_25[VAR_16];
VAR_25[VAR_16] = 0;
String VAR_27(VAR_25,(xub_StrLen)VAR_16,VAR_28);
VAR_27.EraseTrailingChars();
if ( VAR_27.Len() )
*(VAR_0->get())[VAR_14] = ::rtl::OUString(VAR_27);
else
(VAR_0->get())[VAR_14]->setNull();
VAR_25[VAR_16] = VAR_26;
} 
else if ( DataType::TIMESTAMP == VAR_17 )
{
sal_Int32 VAR_29 = 0,VAR_30 = 0;
memcpy(&VAR_29, VAR_25, 4);
memcpy(&VAR_30, VAR_25+ 4, 4);
if ( !VAR_29 && !VAR_30 )
{
(VAR_0->get())[VAR_14]->setNull();
}
else
{
::com::sun::star::util::DateTime VAR_31;
lcl_CalDate(VAR_29,VAR_30,VAR_31);
*(VAR_0->get())[VAR_14] = VAR_31;
}
}
else if ( DataType::INTEGER == VAR_17 )
{
sal_Int32 VAR_32 = 0;
memcpy(&VAR_32, VAR_25, VAR_16);
*(VAR_0->get())[VAR_14] = VAR_32;
}
else if ( DataType::DOUBLE == VAR_17 )
{
double VAR_33 = 0.0;
if (getBOOL((*VAR_11)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_34)))) 
{
sal_Int64 VAR_32 = 0;
memcpy(&VAR_32, VAR_25, VAR_16);
if ( VAR_23[VAR_14-1] )
VAR_33 = (double)(VAR_32 / pow(10.0,(int)VAR_23[VAR_14-1]));
else
VAR_33 = (double)(VAR_32);
}
else
{
memcpy(&VAR_33, VAR_25, VAR_16);
}
*(VAR_0->get())[VAR_14] = VAR_33;
}
else
{
for (sal_Int32 VAR_35 = 0; VAR_35 < VAR_16; VAR_35++)
{
if (VAR_25[VAR_35] == '\0')
VAR_25[VAR_35] = ' ';
}
String VAR_27(VAR_25, (xub_StrLen)VAR_16,VAR_28);
VAR_27.EraseLeadingChars();
VAR_27.EraseTrailingChars();
if (!VAR_27.Len())
{
VAR_10 += VAR_16;
(VAR_0->get())[VAR_14]->setNull();
continue;
}
switch (VAR_17)
{
case DataType::DATE:
{
if (VAR_27.Len() != VAR_16)
{
(VAR_0->get())[VAR_14]->setNull();
break;
}
const sal_uInt16  VAR_36   = (sal_uInt16)VAR_27.Copy( 0, 4 ).ToInt32();
const sal_uInt16  VAR_37  = (sal_uInt16)VAR_27.Copy( 4, 2 ).ToInt32();
const sal_uInt16  VAR_38    = (sal_uInt16)VAR_27.Copy( 6, 2 ).ToInt32();
const ::com::sun::star::util::Date aDate(nDay,nMonth,nYear);
*(VAR_0->get())[VAR_14] = VAR_39;
}
break;
case DataType::DECIMAL:
*(VAR_0->get())[VAR_14] = ORowSetValue(VAR_27);
break;
case DataType::BIT:
{
sal_Bool VAR_40;
switch (* ((const char *)VAR_25))
{
case 'T':
case 'Y':
case 'J':VAR_40 = VAR_7; break;
default: VAR_40 = VAR_8; break;
}
*(VAR_0->get())[VAR_14] = VAR_40;
}
break;
case DataType::LONGVARBINARY:
case DataType::BINARY:
case DataType::LONGVARCHAR:
{
const long VAR_41 = VAR_27.ToInt32();
if (VAR_41 > 0 && VAR_42) 
{
if ( !ReadMemo(VAR_41, (VAR_0->get())[VAR_14]->get()) )
break;
}
else
(VAR_0->get())[VAR_14]->setNull();
}break;
default:
OSL_ASSERT(""Falscher Type"");
}
(VAR_0->get())[VAR_14]->setTypeKind(VAR_17);
}
VAR_10 += VAR_16;
OSL_ENSURE( VAR_10 <= VAR_15 ,""ByteOffset > m_nBufferSize!"");
}
return VAR_7;
}",apache/openoffice/efddaef0151af3be16078cc4d88c6bae0f911e56/DTable.cxx/vul/before/0.json,"sal_Bool ODbaseTable::fetchRow(OValueRefRow& _rRow,const OSQLColumns & _rCols, sal_Bool _bUseTableDefs,sal_Bool bRetrieveData)
{
    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, ""dbase"", ""Ocke.Janssen@sun.com"", ""ODbaseTable::fetchRow"" );
	// Einlesen der Daten
	sal_Bool bIsCurRecordDeleted = ((char)m_pBuffer[0] == '*') ? sal_True : sal_False;

	// only read the bookmark

	// Satz als geloescht markieren
	//	rRow.setState(bIsCurRecordDeleted ? ROW_DELETED : ROW_CLEAN );
	_rRow->setDeleted(bIsCurRecordDeleted);
	*(_rRow->get())[0] = m_nFilePos;

	if (!bRetrieveData)
		return sal_True;

	sal_Size nByteOffset = 1;
	// Felder:
	OSQLColumns::Vector::const_iterator aIter = _rCols.get().begin();
    OSQLColumns::Vector::const_iterator aEnd  = _rCols.get().end();
    const sal_Size nCount = _rRow->get().size();
	for (sal_Size i = 1; aIter != aEnd && nByteOffset <= m_nBufferSize && i < nCount;++aIter, i++)
	{
		// Laengen je nach Datentyp:
		sal_Int32 nLen = 0;
		sal_Int32 nType = 0;
		if(_bUseTableDefs)
		{
			nLen	= m_aPrecisions[i-1];
			nType	= m_aTypes[i-1];
		}
		else
		{
			(*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_PRECISION))	>>= nLen;
			(*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_TYPE))		>>= nType;
		}
		switch(nType)
		{
            case DataType::INTEGER:		
            case DataType::DOUBLE:
            case DataType::TIMESTAMP:
			case DataType::DATE:		
            case DataType::BIT:			
			case DataType::LONGVARCHAR:	
            case DataType::LONGVARBINARY:   
                nLen = m_aRealFieldLengths[i-1]; 
                break;
			case DataType::DECIMAL:
				if(_bUseTableDefs)
					nLen = SvDbaseConverter::ConvertPrecisionToDbase(nLen,m_aScales[i-1]);
				else
					nLen = SvDbaseConverter::ConvertPrecisionToDbase(nLen,getINT32((*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_SCALE))));
				break;	// das Vorzeichen und das Komma
			
            case DataType::BINARY:
			case DataType::OTHER:
				nByteOffset += nLen;
				continue;
		}

		// Ist die Variable ueberhaupt gebunden?
		if ( !(_rRow->get())[i]->isBound() )
		{
			// Nein - naechstes Feld.
			nByteOffset += nLen;
			OSL_ENSURE( nByteOffset <= m_nBufferSize ,""ByteOffset > m_nBufferSize!"");
			continue;
		} // if ( !(_rRow->get())[i]->isBound() )
        if ( ( nByteOffset + nLen) > m_nBufferSize )
            break; // length doesn't match buffer size.

		char *pData = (char *) (m_pBuffer + nByteOffset);

		//	(*_rRow)[i].setType(nType);

		if (nType == DataType::CHAR || nType == DataType::VARCHAR)
		{
			char cLast = pData[nLen];
			pData[nLen] = 0;
			String aStr(pData,(xub_StrLen)nLen,m_eEncoding);
			aStr.EraseTrailingChars();

			if ( aStr.Len() )
                *(_rRow->get())[i] = ::rtl::OUString(aStr);
			else// keine StringLaenge, dann NULL
                (_rRow->get())[i]->setNull();
				
			pData[nLen] = cLast;
		} // if (nType == DataType::CHAR || nType == DataType::VARCHAR)
        else if ( DataType::TIMESTAMP == nType )
        {
            sal_Int32 nDate = 0,nTime = 0;
            OSL_ENSURE(nLen == 8, ""Invalid length for date field"");
            if (nLen != 8) {
                return false;
            }
			memcpy(&nDate, pData, 4);
            memcpy(&nTime, pData+ 4, 4);
            if ( !nDate && !nTime )
            {
                (_rRow->get())[i]->setNull();
            }
            else
            {
                ::com::sun::star::util::DateTime aDateTime;
                lcl_CalDate(nDate,nTime,aDateTime);
                *(_rRow->get())[i] = aDateTime;
            }
        }
        else if ( DataType::INTEGER == nType )
        {
            OSL_ENSURE(nLen == 4, ""Invalid length for integer field"");
            if (nLen != 4) {
                return false;
            }
            sal_Int32 nValue = 0;
			memcpy(&nValue, pData, nLen);
            *(_rRow->get())[i] = nValue;
        }
        else if ( DataType::DOUBLE == nType )
        {
            double d = 0.0;
            OSL_ENSURE(nLen == 8, ""Invalid length for double field"");
            if (nLen != 8) {
                return false;
            }
            if (getBOOL((*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY)))) // Currency wird gesondert behandelt
            {
                sal_Int64 nValue = 0;
			    memcpy(&nValue, pData, nLen);
            
                if ( m_aScales[i-1] )
                    d = (double)(nValue / pow(10.0,(int)m_aScales[i-1]));
                else
                    d = (double)(nValue);
            }
            else
            {
                memcpy(&d, pData, nLen);
            }
            
            *(_rRow->get())[i] = d;
        }
		else
		{
			// Falls Nul-Zeichen im String enthalten sind, in Blanks umwandeln!
			for (sal_Int32 k = 0; k < nLen; k++)
			{
				if (pData[k] == '\0')
					pData[k] = ' ';
			}

			String aStr(pData, (xub_StrLen)nLen,m_eEncoding);		// Spaces am Anfang und am Ende entfernen:
			aStr.EraseLeadingChars();
			aStr.EraseTrailingChars();

			if (!aStr.Len())
			{
				nByteOffset += nLen;
				(_rRow->get())[i]->setNull();	// keine Werte -> fertig
				continue;
			}

			switch (nType)
			{
				case DataType::DATE:
				{
                    OSL_ENSURE(nLen == 8, ""Invalid length for date field"");
                    if (nLen != 8) {
                        return false;
                    }
					if (aStr.Len() != nLen)
					{
						(_rRow->get())[i]->setNull();
						break;
					}
					const sal_uInt16  nYear   = (sal_uInt16)aStr.Copy( 0, 4 ).ToInt32();
					const sal_uInt16  nMonth  = (sal_uInt16)aStr.Copy( 4, 2 ).ToInt32();
					const sal_uInt16  nDay    = (sal_uInt16)aStr.Copy( 6, 2 ).ToInt32();

					const ::com::sun::star::util::Date aDate(nDay,nMonth,nYear);
					*(_rRow->get())[i] = aDate;
				}
				break;
				case DataType::DECIMAL:
					*(_rRow->get())[i] = ORowSetValue(aStr);
					//	pVal->setDouble(SdbTools::ToDouble(aStr));
				break;
				case DataType::BIT:
				{
                    OSL_ENSURE(nLen == 1, ""Invalid length for bit field"");
                    if (nLen != 1) {
                        return false;
                    }
					sal_Bool b;
					switch (* ((const char *)pData))
					{
						case 'T':
						case 'Y':
						case 'J':	b = sal_True; break;
						default: 	b = sal_False; break;
					}
					*(_rRow->get())[i] = b;
					//	pVal->setDouble(b);
				}
				break;
                case DataType::LONGVARBINARY:
                case DataType::BINARY:
				case DataType::LONGVARCHAR:
				{
					const long nBlockNo = aStr.ToInt32();	// Blocknummer lesen
					if (nBlockNo > 0 && m_pMemoStream) // Daten aus Memo-Datei lesen, nur wenn
					{
						if ( !ReadMemo(nBlockNo, (_rRow->get())[i]->get()) )
							break;
					}
					else
						(_rRow->get())[i]->setNull();
				}	break;
				default:
					OSL_ASSERT(""Falscher Type"");
			}
			(_rRow->get())[i]->setTypeKind(nType);
		}

		nByteOffset += nLen;
		OSL_ENSURE( nByteOffset <= m_nBufferSize ,""ByteOffset > m_nBufferSize!"");
	}
	return sal_True;
}","sal_Bool ODbaseTable::fetchRow(OValueRefRow& VAR_0,const OSQLColumns & VAR_1, sal_Bool VAR_2,sal_Bool VAR_3)
{
    RTL_LOGFILE_CONTEXT_AUTHOR( VAR_4, ""dbase"", ""Ocke.Janssen@sun.com"", ""ODbaseTable::fetchRow"" );
	/* COMMENT_0 */
	sal_Bool VAR_5 = ((char)VAR_6[0] == '*') ? VAR_7 : VAR_8;

	/* COMMENT_1 */

	/* COMMENT_2 */
	/* COMMENT_3 */
	VAR_0->setDeleted(VAR_5);
	*(VAR_0->get())[0] = VAR_9;

	if (!VAR_3)
		return VAR_7;

	sal_Size VAR_10 = 1;
	/* COMMENT_4 */
	OSQLColumns::Vector::const_iterator VAR_11 = VAR_1.get().begin();
    OSQLColumns::Vector::const_iterator VAR_12  = VAR_1.get().end();
    const sal_Size VAR_13 = VAR_0->get().size();
	for (sal_Size VAR_14 = 1; VAR_11 != VAR_12 && VAR_10 <= VAR_15 && VAR_14 < VAR_13;++VAR_11, VAR_14++)
	{
		/* COMMENT_5 */
		sal_Int32 VAR_16 = 0;
		sal_Int32 VAR_17 = 0;
		if(VAR_2)
		{
			VAR_16	= VAR_18[VAR_14-1];
			VAR_17	= VAR_19[VAR_14-1];
		}
		else
		{
			(*VAR_11)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_20))	>>= VAR_16;
			(*VAR_11)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_21))		>>= VAR_17;
		}
		switch(VAR_17)
		{
            case DataType::INTEGER:		
            case DataType::DOUBLE:
            case DataType::TIMESTAMP:
			case DataType::DATE:		
            case DataType::BIT:			
			case DataType::LONGVARCHAR:	
            case DataType::LONGVARBINARY:   
                VAR_16 = VAR_22[VAR_14-1]; 
                break;
			case DataType::DECIMAL:
				if(VAR_2)
					VAR_16 = SvDbaseConverter::ConvertPrecisionToDbase(VAR_16,VAR_23[VAR_14-1]);
				else
					VAR_16 = SvDbaseConverter::ConvertPrecisionToDbase(VAR_16,getINT32((*VAR_11)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_24))));
				break;	/* COMMENT_6 */
			
            case DataType::BINARY:
			case DataType::OTHER:
				VAR_10 += VAR_16;
				continue;
		}

		/* COMMENT_7 */
		if ( !(VAR_0->get())[VAR_14]->isBound() )
		{
			/* COMMENT_8 */
			VAR_10 += VAR_16;
			OSL_ENSURE( VAR_10 <= VAR_15 ,""ByteOffset > m_nBufferSize!"");
			continue;
		} /* COMMENT_9 */
        if ( ( VAR_10 + VAR_16) > VAR_15 )
            break; /* COMMENT_10 */

		char *VAR_25 = (char *) (VAR_6 + VAR_10);

		/* COMMENT_11 */

		if (VAR_17 == DataType::CHAR || VAR_17 == DataType::VARCHAR)
		{
			char VAR_26 = VAR_25[VAR_16];
			VAR_25[VAR_16] = 0;
			String VAR_27(VAR_25,(xub_StrLen)VAR_16,VAR_28);
			VAR_27.EraseTrailingChars();

			if ( VAR_27.Len() )
                *(VAR_0->get())[VAR_14] = ::rtl::OUString(VAR_27);
			else/* COMMENT_12 */
                (VAR_0->get())[VAR_14]->setNull();
				
			VAR_25[VAR_16] = VAR_26;
		} /* COMMENT_13 */
        else if ( DataType::TIMESTAMP == VAR_17 )
        {
            sal_Int32 VAR_29 = 0,VAR_30 = 0;
            OSL_ENSURE(VAR_16 == 8, ""Invalid length for date field"");
            if (VAR_16 != 8) {
                return false;
            }
			memcpy(&VAR_29, VAR_25, 4);
            memcpy(&VAR_30, VAR_25+ 4, 4);
            if ( !VAR_29 && !VAR_30 )
            {
                (VAR_0->get())[VAR_14]->setNull();
            }
            else
            {
                ::com::sun::star::util::DateTime VAR_31;
                lcl_CalDate(VAR_29,VAR_30,VAR_31);
                *(VAR_0->get())[VAR_14] = VAR_31;
            }
        }
        else if ( DataType::INTEGER == VAR_17 )
        {
            OSL_ENSURE(VAR_16 == 4, ""Invalid length for integer field"");
            if (VAR_16 != 4) {
                return false;
            }
            sal_Int32 VAR_32 = 0;
			memcpy(&VAR_32, VAR_25, VAR_16);
            *(VAR_0->get())[VAR_14] = VAR_32;
        }
        else if ( DataType::DOUBLE == VAR_17 )
        {
            double VAR_33 = 0.0;
            OSL_ENSURE(VAR_16 == 8, ""Invalid length for double field"");
            if (VAR_16 != 8) {
                return false;
            }
            if (getBOOL((*VAR_11)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(VAR_34)))) /* COMMENT_14 */
            {
                sal_Int64 VAR_32 = 0;
			    memcpy(&VAR_32, VAR_25, VAR_16);
            
                if ( VAR_23[VAR_14-1] )
                    VAR_33 = (double)(VAR_32 / pow(10.0,(int)VAR_23[VAR_14-1]));
                else
                    VAR_33 = (double)(VAR_32);
            }
            else
            {
                memcpy(&VAR_33, VAR_25, VAR_16);
            }
            
            *(VAR_0->get())[VAR_14] = VAR_33;
        }
		else
		{
			/* COMMENT_15 */
			for (sal_Int32 VAR_35 = 0; VAR_35 < VAR_16; VAR_35++)
			{
				if (VAR_25[VAR_35] == '\0')
					VAR_25[VAR_35] = ' ';
			}

			String VAR_27(VAR_25, (xub_StrLen)VAR_16,VAR_28);		/* COMMENT_16 */
			VAR_27.EraseLeadingChars();
			VAR_27.EraseTrailingChars();

			if (!VAR_27.Len())
			{
				VAR_10 += VAR_16;
				(VAR_0->get())[VAR_14]->setNull();	/* COMMENT_17 */
				continue;
			}

			switch (VAR_17)
			{
				case DataType::DATE:
				{
                    OSL_ENSURE(VAR_16 == 8, ""Invalid length for date field"");
                    if (VAR_16 != 8) {
                        return false;
                    }
					if (VAR_27.Len() != VAR_16)
					{
						(VAR_0->get())[VAR_14]->setNull();
						break;
					}
					const sal_uInt16  VAR_36   = (sal_uInt16)VAR_27.Copy( 0, 4 ).ToInt32();
					const sal_uInt16  VAR_37  = (sal_uInt16)VAR_27.Copy( 4, 2 ).ToInt32();
					const sal_uInt16  VAR_38    = (sal_uInt16)VAR_27.Copy( 6, 2 ).ToInt32();

					const ::com::sun::star::util::Date aDate(nDay,nMonth,nYear);
					*(VAR_0->get())[VAR_14] = VAR_39;
				}
				break;
				case DataType::DECIMAL:
					*(VAR_0->get())[VAR_14] = ORowSetValue(VAR_27);
					/* COMMENT_18 */
				break;
				case DataType::BIT:
				{
                    OSL_ENSURE(VAR_16 == 1, ""Invalid length for bit field"");
                    if (VAR_16 != 1) {
                        return false;
                    }
					sal_Bool VAR_40;
					switch (* ((const char *)VAR_25))
					{
						case 'T':
						case 'Y':
						case 'J':	VAR_40 = VAR_7; break;
						default: 	VAR_40 = VAR_8; break;
					}
					*(VAR_0->get())[VAR_14] = VAR_40;
					/* COMMENT_19 */
				}
				break;
                case DataType::LONGVARBINARY:
                case DataType::BINARY:
				case DataType::LONGVARCHAR:
				{
					const long VAR_41 = VAR_27.ToInt32();	/* COMMENT_20 */
					if (VAR_41 > 0 && VAR_42) /* COMMENT_21 */
					{
						if ( !ReadMemo(VAR_41, (VAR_0->get())[VAR_14]->get()) )
							break;
					}
					else
						(VAR_0->get())[VAR_14]->setNull();
				}	break;
				default:
					OSL_ASSERT(""Falscher Type"");
			}
			(VAR_0->get())[VAR_14]->setTypeKind(VAR_17);
		}

		VAR_10 += VAR_16;
		OSL_ENSURE( VAR_10 <= VAR_15 ,""ByteOffset > m_nBufferSize!"");
	}
	return VAR_7;
}",apache/openoffice/efddaef0151af3be16078cc4d88c6bae0f911e56/DTable.cxx/vul/after/0.json,"--- func_before
+++ func_after
@@ -90,6 +90,10 @@
         else if ( DataType::TIMESTAMP == nType )
         {
             sal_Int32 nDate = 0,nTime = 0;
+            OSL_ENSURE(nLen == 8, ""Invalid length for date field"");
+            if (nLen != 8) {
+                return false;
+            }
 			memcpy(&nDate, pData, 4);
             memcpy(&nTime, pData+ 4, 4);
             if ( !nDate && !nTime )
@@ -105,6 +109,10 @@
         }
         else if ( DataType::INTEGER == nType )
         {
+            OSL_ENSURE(nLen == 4, ""Invalid length for integer field"");
+            if (nLen != 4) {
+                return false;
+            }
             sal_Int32 nValue = 0;
 			memcpy(&nValue, pData, nLen);
             *(_rRow->get())[i] = nValue;
@@ -112,6 +120,10 @@
         else if ( DataType::DOUBLE == nType )
         {
             double d = 0.0;
+            OSL_ENSURE(nLen == 8, ""Invalid length for double field"");
+            if (nLen != 8) {
+                return false;
+            }
             if (getBOOL((*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY)))) // Currency wird gesondert behandelt
             {
                 sal_Int64 nValue = 0;
@@ -153,6 +165,10 @@
 			{
 				case DataType::DATE:
 				{
+                    OSL_ENSURE(nLen == 8, ""Invalid length for date field"");
+                    if (nLen != 8) {
+                        return false;
+                    }
 					if (aStr.Len() != nLen)
 					{
 						(_rRow->get())[i]->setNull();
@@ -172,6 +188,10 @@
 				break;
 				case DataType::BIT:
 				{
+                    OSL_ENSURE(nLen == 1, ""Invalid length for bit field"");
+                    if (nLen != 1) {
+                        return false;
+                    }
 					sal_Bool b;
 					switch (* ((const char *)pData))
 					{","{'deleted_lines': [], 'added_lines': ['            OSL_ENSURE(nLen == 8, ""Invalid length for date field"");', '            if (nLen != 8) {', '                return false;', '            }', '            OSL_ENSURE(nLen == 4, ""Invalid length for integer field"");', '            if (nLen != 4) {', '                return false;', '            }', '            OSL_ENSURE(nLen == 8, ""Invalid length for double field"");', '            if (nLen != 8) {', '                return false;', '            }', '                    OSL_ENSURE(nLen == 8, ""Invalid length for date field"");', '                    if (nLen != 8) {', '                        return false;', '                    }', '                    OSL_ENSURE(nLen == 1, ""Invalid length for bit field"");', '                    if (nLen != 1) {', '                        return false;', '                    }']}",True,"Apache OpenOffice opens dBase/DBF documents and shows the contents as spreadsheets. DBF are database files with data organized in fields. When reading DBF data the size of certain fields is not checked: the data is just copied into local variables. A carefully crafted document could overflow the allocated space, leading to the execution of arbitrary code by altering the contents of the program stack. This issue affects Apache OpenOffice up to and including version 4.1.10",7.8,HIGH,2,test,2021-05-15T19:27:35Z,3
CVE-2021-44339,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,brackeen/ok-file-formats,ok_png: Disallow multiple IHDR chunks (#15),e49cdfb84fb5eca2a6261f3c51a3c793fab9f62e,https://github.com/brackeen/ok-file-formats/commit/e49cdfb84fb5eca2a6261f3c51a3c793fab9f62e,ok_png.c,ok_png_decode2,"static void ok_png_decode2(ok_png_decoder *decoder) {
ok_png *png = decoder->png;
uint8_t png_header[8];
if (!ok_read(decoder, png_header, sizeof(png_header))) {
return;
}
uint8_t png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
if (memcmp(png_header, png_signature, 8) != 0) {
ok_png_error(decoder->png, OK_PNG_ERROR_INVALID, ""Invalid signature (not a PNG file)"");
return;
}
bool info_only = (decoder->decode_flags & OK_PNG_INFO_ONLY) != 0;
bool hdr_found = false;
bool end_found = false;
while (!end_found) {
uint8_t chunk_header[8];
uint8_t chunk_footer[4];
if (!ok_read(decoder, chunk_header, sizeof(chunk_header))) {
return;
}
const uint32_t chunk_length = readBE32(chunk_header);
const uint32_t chunk_type = readBE32(chunk_header + 4);
bool success = false;
if (!hdr_found && chunk_type != OK_PNG_CHUNK_CGBI && chunk_type != OK_PNG_CHUNK_IHDR) {
ok_png_error(png, OK_PNG_ERROR_INVALID, ""IHDR chunk must appear first"");
return;
}
if (chunk_type == OK_PNG_CHUNK_IHDR) {
hdr_found = true;
success = ok_png_read_header(decoder, chunk_length);
if (success && info_only) {
if (png->has_alpha) {
return;
}
}
} else if (chunk_type == OK_PNG_CHUNK_CGBI) {
success = ok_seek(decoder, (long)chunk_length);
decoder->is_ios_format = true;
} else if (chunk_type == OK_PNG_CHUNK_PLTE && !info_only) {
success = ok_png_read_palette(decoder, chunk_length);
} else if (chunk_type == OK_PNG_CHUNK_TRNS) {
if (info_only) {
png->has_alpha = true;
return;
} else {
success = ok_png_read_transparency(decoder, chunk_length);
}
} else if (chunk_type == OK_PNG_CHUNK_IDAT) {
if (info_only) {
return;
}
success = ok_png_read_data(decoder, chunk_length);
} else if (chunk_type == OK_PNG_CHUNK_IEND) {
success = ok_seek(decoder, (long)chunk_length);
end_found = true;
} else {
success = ok_seek(decoder, (long)chunk_length);
}
if (!success) {
return;
}
if (!ok_read(decoder, chunk_footer, sizeof(chunk_footer))) {
return;
}
}
if (!decoder->decoding_completed) {
ok_png_error(png, OK_PNG_ERROR_INVALID, ""Missing imaga data"");
}
}","static void ok_png_decode2(ok_png_decoder *VAR_0) {
ok_png *VAR_1 = VAR_0->png;
uint8_t VAR_2[8];
if (!ok_read(VAR_0, VAR_2, sizeof(VAR_2))) {
return;
}
uint8_t VAR_3[8] = {137, 80, 78, 71, 13, 10, 26, 10};
if (memcmp(VAR_2, VAR_3, 8) != 0) {
ok_png_error(VAR_0->png, VAR_4, ""Invalid signature (not a PNG file)"");
return;
}
bool VAR_5 = (VAR_0->decode_flags & VAR_6) != 0;
bool VAR_7 = false;
bool VAR_8 = false;
while (!VAR_8) {
uint8_t VAR_9[8];
uint8_t VAR_10[4];
if (!ok_read(VAR_0, VAR_9, sizeof(VAR_9))) {
return;
}
const uint32_t VAR_11 = readBE32(VAR_9);
const uint32_t VAR_12 = readBE32(VAR_9 + 4);
bool VAR_13 = false;
if (!VAR_7 && VAR_12 != VAR_14 && VAR_12 != VAR_15) {
ok_png_error(VAR_1, VAR_4, ""IHDR chunk must appear first"");
return;
}
if (VAR_12 == VAR_15) {
VAR_7 = true;
VAR_13 = ok_png_read_header(VAR_0, VAR_11);
if (VAR_13 && VAR_5) {
if (VAR_1->has_alpha) {
return;
}
}
} else if (VAR_12 == VAR_14) {
VAR_13 = ok_seek(VAR_0, (long)VAR_11);
VAR_0->is_ios_format = true;
} else if (VAR_12 == VAR_16 && !VAR_5) {
VAR_13 = ok_png_read_palette(VAR_0, VAR_11);
} else if (VAR_12 == VAR_17) {
if (VAR_5) {
VAR_1->has_alpha = true;
return;
} else {
VAR_13 = ok_png_read_transparency(VAR_0, VAR_11);
}
} else if (VAR_12 == VAR_18) {
if (VAR_5) {
return;
}
VAR_13 = ok_png_read_data(VAR_0, VAR_11);
} else if (VAR_12 == VAR_19) {
VAR_13 = ok_seek(VAR_0, (long)VAR_11);
VAR_8 = true;
} else {
VAR_13 = ok_seek(VAR_0, (long)VAR_11);
}
if (!VAR_13) {
return;
}
if (!ok_read(VAR_0, VAR_10, sizeof(VAR_10))) {
return;
}
}
if (!VAR_0->decoding_completed) {
ok_png_error(VAR_1, VAR_4, ""Missing imaga data"");
}
}",brackeen/ok-file-formats/e49cdfb84fb5eca2a6261f3c51a3c793fab9f62e/ok_png.c/vul/before/0.json,"static void ok_png_decode2(ok_png_decoder *decoder) {
    ok_png *png = decoder->png;

    uint8_t png_header[8];
    if (!ok_read(decoder, png_header, sizeof(png_header))) {
        return;
    }
    uint8_t png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
    if (memcmp(png_header, png_signature, 8) != 0) {
        ok_png_error(decoder->png, OK_PNG_ERROR_INVALID, ""Invalid signature (not a PNG file)"");
        return;
    }

    // When info_only is true, we only care about the IHDR chunk and whether or not
    // the tRNS chunk exists.
    bool info_only = (decoder->decode_flags & OK_PNG_INFO_ONLY) != 0;
    bool hdr_found = false;
    bool end_found = false;
    while (!end_found) {
        uint8_t chunk_header[8];
        uint8_t chunk_footer[4];
        if (!ok_read(decoder, chunk_header, sizeof(chunk_header))) {
            return;
        }
        const uint32_t chunk_length = readBE32(chunk_header);
        const uint32_t chunk_type = readBE32(chunk_header + 4);
        bool success = false;

        if (!hdr_found && chunk_type != OK_PNG_CHUNK_CGBI && chunk_type != OK_PNG_CHUNK_IHDR) {
            ok_png_error(png, OK_PNG_ERROR_INVALID, ""IHDR chunk must appear first"");
            return;
        }
        if (chunk_type == OK_PNG_CHUNK_IHDR) {
            if (hdr_found) {
                ok_png_error(png, OK_PNG_ERROR_INVALID, ""Multiple IHDR chunks not allowed"");
                return;
            }
            hdr_found = true;
            success = ok_png_read_header(decoder, chunk_length);
            if (success && info_only) {
                // If the png has alpha, then we have all the info we need.
                // Otherwise, continue scanning to see if the tRNS chunk exists.
                if (png->has_alpha) {
                    return;
                }
            }
        } else if (chunk_type == OK_PNG_CHUNK_CGBI) {
            success = ok_seek(decoder, (long)chunk_length);
            decoder->is_ios_format = true;
        } else if (chunk_type == OK_PNG_CHUNK_PLTE && !info_only) {
            success = ok_png_read_palette(decoder, chunk_length);
        } else if (chunk_type == OK_PNG_CHUNK_TRNS) {
            if (info_only) {
                // No need to parse this chunk, we have all the info we need.
                png->has_alpha = true;
                return;
            } else {
                success = ok_png_read_transparency(decoder, chunk_length);
            }
        } else if (chunk_type == OK_PNG_CHUNK_IDAT) {
            if (info_only) {
                // Both IHDR and tRNS must come before IDAT, so we have all the info we need.
                return;
            }
            success = ok_png_read_data(decoder, chunk_length);
        } else if (chunk_type == OK_PNG_CHUNK_IEND) {
            success = ok_seek(decoder, (long)chunk_length);
            end_found = true;
        } else {
            // Ignore this chunk
            success = ok_seek(decoder, (long)chunk_length);
        }

        if (!success) {
            return;
        }

        // Read the footer (CRC) and ignore it
        if (!ok_read(decoder, chunk_footer, sizeof(chunk_footer))) {
            return;
        }
    }

    // Sanity check
    if (!decoder->decoding_completed) {
        ok_png_error(png, OK_PNG_ERROR_INVALID, ""Missing imaga data"");
    }
}","static void ok_png_decode2(ok_png_decoder *VAR_0) {
    ok_png *VAR_1 = VAR_0->png;

    uint8_t VAR_2[8];
    if (!ok_read(VAR_0, VAR_2, sizeof(VAR_2))) {
        return;
    }
    uint8_t VAR_3[8] = {137, 80, 78, 71, 13, 10, 26, 10};
    if (memcmp(VAR_2, VAR_3, 8) != 0) {
        ok_png_error(VAR_0->png, VAR_4, ""Invalid signature (not a PNG file)"");
        return;
    }

    /* COMMENT_0 */
    /* COMMENT_1 */
    bool VAR_5 = (VAR_0->decode_flags & VAR_6) != 0;
    bool VAR_7 = false;
    bool VAR_8 = false;
    while (!VAR_8) {
        uint8_t VAR_9[8];
        uint8_t VAR_10[4];
        if (!ok_read(VAR_0, VAR_9, sizeof(VAR_9))) {
            return;
        }
        const uint32_t VAR_11 = readBE32(VAR_9);
        const uint32_t VAR_12 = readBE32(VAR_9 + 4);
        bool VAR_13 = false;

        if (!VAR_7 && VAR_12 != VAR_14 && VAR_12 != VAR_15) {
            ok_png_error(VAR_1, VAR_4, ""IHDR chunk must appear first"");
            return;
        }
        if (VAR_12 == VAR_15) {
            if (VAR_7) {
                ok_png_error(VAR_1, VAR_4, ""Multiple IHDR chunks not allowed"");
                return;
            }
            VAR_7 = true;
            VAR_13 = ok_png_read_header(VAR_0, VAR_11);
            if (VAR_13 && VAR_5) {
                /* COMMENT_2 */
                /* COMMENT_3 */
                if (VAR_1->has_alpha) {
                    return;
                }
            }
        } else if (VAR_12 == VAR_14) {
            VAR_13 = ok_seek(VAR_0, (long)VAR_11);
            VAR_0->is_ios_format = true;
        } else if (VAR_12 == VAR_16 && !VAR_5) {
            VAR_13 = ok_png_read_palette(VAR_0, VAR_11);
        } else if (VAR_12 == VAR_17) {
            if (VAR_5) {
                /* COMMENT_4 */
                VAR_1->has_alpha = true;
                return;
            } else {
                VAR_13 = ok_png_read_transparency(VAR_0, VAR_11);
            }
        } else if (VAR_12 == VAR_18) {
            if (VAR_5) {
                /* COMMENT_5 */
                return;
            }
            VAR_13 = ok_png_read_data(VAR_0, VAR_11);
        } else if (VAR_12 == VAR_19) {
            VAR_13 = ok_seek(VAR_0, (long)VAR_11);
            VAR_8 = true;
        } else {
            /* COMMENT_6 */
            VAR_13 = ok_seek(VAR_0, (long)VAR_11);
        }

        if (!VAR_13) {
            return;
        }

        /* COMMENT_7 */
        if (!ok_read(VAR_0, VAR_10, sizeof(VAR_10))) {
            return;
        }
    }

    /* COMMENT_8 */
    if (!VAR_0->decoding_completed) {
        ok_png_error(VAR_1, VAR_4, ""Missing imaga data"");
    }
}",brackeen/ok-file-formats/e49cdfb84fb5eca2a6261f3c51a3c793fab9f62e/ok_png.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -31,6 +31,10 @@
             return;
         }
         if (chunk_type == OK_PNG_CHUNK_IHDR) {
+            if (hdr_found) {
+                ok_png_error(png, OK_PNG_ERROR_INVALID, ""Multiple IHDR chunks not allowed"");
+                return;
+            }
             hdr_found = true;
             success = ok_png_read_header(decoder, chunk_length);
             if (success && info_only) {","{'deleted_lines': [], 'added_lines': ['            if (hdr_found) {', '                ok_png_error(png, OK_PNG_ERROR_INVALID, ""Multiple IHDR chunks not allowed"");', '                return;', '            }']}",True,"David Brackeen ok-file-formats 203defd is vulnerable to Buffer Overflow. When the function of the ok-file-formats project is used, a heap-buffer-overflow occurred in function ok_png_transform_scanline() in ""/ok_png.c:712"".",7.8,HIGH,2,test,2021-06-08T12:45:28Z,3
CVE-2021-32672,['CWE-125'],AV:N/AC:L/Au:S/C:P/I:N/A:N,0,redis,"Fix protocol parsing on 'ldbReplParseCommand' (CVE-2021-32672)

The protocol parsing on 'ldbReplParseCommand' (LUA debugging)
Assumed protocol correctness. This means that if the following
is given:
*1
$100
test
The parser will try to read additional 94 unallocated bytes after
the client buffer.
This commit fixes this issue by validating that there are actually enough
bytes to read. It also limits the amount of data that can be sent by
the debugger client to 1M so the client will not be able to explode
the memory.",6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd,https://github.com/redis/redis/commit/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd,src/scripting.c,ldbReplParseCommand,"sds *ldbReplParseCommand(int *argcp) {
sds *argv = NULL;
int argc = 0;
if (sdslen(ldb.cbuf) == 0) return NULL;
sds copy = sdsdup(ldb.cbuf);
char *p = copy;
p = strchr(p,'*'); if (!p) goto protoerr;
char *plen = p+1; 
p = strstr(p,""\r\n""); if (!p) goto protoerr;
*p = '\0'; p += 2;
*argcp = atoi(plen);
if (*argcp <= 0 || *argcp > 1024) goto protoerr;
argv = zmalloc(sizeof(sds)*(*argcp));
argc = 0;
while(argc < *argcp) {
if (*p != '$') goto protoerr;
plen = p+1; 
p = strstr(p,""\r\n""); if (!p) goto protoerr;
*p = '\0'; p += 2;
int slen = atoi(plen); 
if (slen <= 0 || slen > 1024) goto protoerr;
argv[argc++] = sdsnewlen(p,slen);
p += slen; 
if (p[0] != '\r' || p[1] != '\n') goto protoerr;
p += 2; 
}
sdsfree(copy);
return argv;
protoerr:
sdsfreesplitres(argv,argc);
sdsfree(copy);
return NULL;
}","sds *ldbReplParseCommand(int *VAR_0) {
sds *VAR_1 = NULL;
int VAR_2 = 0;
if (sdslen(VAR_3.cbuf) == 0) return NULL;
sds VAR_4 = sdsdup(VAR_3.cbuf);
char *VAR_5 = VAR_4;
VAR_5 = strchr(VAR_5,'*'); if (!VAR_5) goto protoerr;
char *VAR_6 = VAR_5+1; 
VAR_5 = strstr(VAR_5,""\r\n""); if (!VAR_5) goto protoerr;
*VAR_5 = '\0'; VAR_5 += 2;
*VAR_0 = atoi(VAR_6);
if (*VAR_0 <= 0 || *VAR_0 > 1024) goto protoerr;
VAR_1 = zmalloc(sizeof(sds)*(*VAR_0));
VAR_2 = 0;
while(VAR_2 < *VAR_0) {
if (*VAR_5 != '$') goto protoerr;
VAR_6 = VAR_5+1; 
VAR_5 = strstr(VAR_5,""\r\n""); if (!VAR_5) goto protoerr;
*VAR_5 = '\0'; VAR_5 += 2;
int VAR_7 = atoi(VAR_6); 
if (VAR_7 <= 0 || VAR_7 > 1024) goto protoerr;
VAR_1[VAR_2++] = sdsnewlen(VAR_5,VAR_7);
VAR_5 += VAR_7; 
if (VAR_5[0] != '\r' || VAR_5[1] != '\n') goto protoerr;
VAR_5 += 2; 
}
sdsfree(VAR_4);
return VAR_1;
protoerr:
sdsfreesplitres(VAR_1,VAR_2);
sdsfree(VAR_4);
return NULL;
}",redis/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd/scripting.c/vul/before/0.json,"sds *ldbReplParseCommand(int *argcp, char** err) {
    static char* protocol_error = ""protocol error"";
    sds *argv = NULL;
    int argc = 0;
    if (sdslen(ldb.cbuf) == 0) return NULL;

    /* Working on a copy is simpler in this case. We can modify it freely
     * for the sake of simpler parsing. */
    sds copy = sdsdup(ldb.cbuf);
    char *p = copy;

    /* This Redis protocol parser is a joke... just the simplest thing that
     * works in this context. It is also very forgiving regarding broken
     * protocol. */

    /* Seek and parse *<count>\r\n. */
    p = strchr(p,'*'); if (!p) goto protoerr;
    char *plen = p+1; /* Multi bulk len pointer. */
    p = strstr(p,""\r\n""); if (!p) goto keep_reading;
    *p = '\0'; p += 2;
    *argcp = atoi(plen);
    if (*argcp <= 0 || *argcp > 1024) goto protoerr;

    /* Parse each argument. */
    argv = zmalloc(sizeof(sds)*(*argcp));
    argc = 0;
    while(argc < *argcp) {
        // reached the end but there should be more data to read
        if (*p == '\0') goto keep_reading;

        if (*p != '$') goto protoerr;
        plen = p+1; /* Bulk string len pointer. */
        p = strstr(p,""\r\n""); if (!p) goto keep_reading;
        *p = '\0'; p += 2;
        int slen = atoi(plen); /* Length of this arg. */
        if (slen <= 0 || slen > 1024) goto protoerr;
        if ((size_t)(p + slen + 2 - copy) > sdslen(copy) ) goto keep_reading;
        argv[argc++] = sdsnewlen(p,slen);
        p += slen; /* Skip the already parsed argument. */
        if (p[0] != '\r' || p[1] != '\n') goto protoerr;
        p += 2; /* Skip \r\n. */
    }
    sdsfree(copy);
    return argv;

protoerr:
    *err = protocol_error;
keep_reading:
    sdsfreesplitres(argv,argc);
    sdsfree(copy);
    return NULL;
}","sds *ldbReplParseCommand(int *VAR_0, char** VAR_1) {
    static char* VAR_2 = ""protocol error"";
    sds *VAR_3 = NULL;
    int VAR_4 = 0;
    if (sdslen(VAR_5.cbuf) == 0) return NULL;

    /* COMMENT_0 */
                                          
    sds VAR_6 = sdsdup(VAR_5.cbuf);
    char *VAR_7 = VAR_6;

    /* COMMENT_2 */
                                                                        
                   

    /* COMMENT_5 */
    VAR_7 = strchr(VAR_7,'*'); if (!VAR_7) goto protoerr;
    char *VAR_8 = VAR_7+1; /* COMMENT_6 */
    VAR_7 = strstr(VAR_7,""\r\n""); if (!VAR_7) goto keep_reading;
    *VAR_7 = '\0'; VAR_7 += 2;
    *VAR_0 = atoi(VAR_8);
    if (*VAR_0 <= 0 || *VAR_0 > 1024) goto protoerr;

    /* COMMENT_7 */
    VAR_3 = zmalloc(sizeof(sds)*(*VAR_0));
    VAR_4 = 0;
    while(VAR_4 < *VAR_0) {
        /* COMMENT_8 */
        if (*VAR_7 == '\0') goto keep_reading;

        if (*VAR_7 != '$') goto protoerr;
        VAR_8 = VAR_7+1; /* COMMENT_9 */
        VAR_7 = strstr(VAR_7,""\r\n""); if (!VAR_7) goto keep_reading;
        *VAR_7 = '\0'; VAR_7 += 2;
        int VAR_9 = atoi(VAR_8); /* COMMENT_10 */
        if (VAR_9 <= 0 || VAR_9 > 1024) goto protoerr;
        if ((size_t)(VAR_7 + VAR_9 + 2 - VAR_6) > sdslen(VAR_6) ) goto keep_reading;
        VAR_3[VAR_4++] = sdsnewlen(VAR_7,VAR_9);
        VAR_7 += VAR_9; /* COMMENT_11 */
        if (VAR_7[0] != '\r' || VAR_7[1] != '\n') goto protoerr;
        VAR_7 += 2; /* COMMENT_12 */
    }
    sdsfree(VAR_6);
    return VAR_3;

protoerr:
    *VAR_1 = VAR_2;
keep_reading:
    sdsfreesplitres(VAR_3,VAR_4);
    sdsfree(VAR_6);
    return NULL;
}",redis/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd/scripting.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,5 @@
-sds *ldbReplParseCommand(int *argcp) {
+sds *ldbReplParseCommand(int *argcp, char** err) {
+    static char* protocol_error = ""protocol error"";
     sds *argv = NULL;
     int argc = 0;
     if (sdslen(ldb.cbuf) == 0) return NULL;
@@ -15,7 +16,7 @@
     /* Seek and parse *<count>\r\n. */
     p = strchr(p,'*'); if (!p) goto protoerr;
     char *plen = p+1; /* Multi bulk len pointer. */
-    p = strstr(p,""\r\n""); if (!p) goto protoerr;
+    p = strstr(p,""\r\n""); if (!p) goto keep_reading;
     *p = '\0'; p += 2;
     *argcp = atoi(plen);
     if (*argcp <= 0 || *argcp > 1024) goto protoerr;
@@ -24,12 +25,16 @@
     argv = zmalloc(sizeof(sds)*(*argcp));
     argc = 0;
     while(argc < *argcp) {
+        // reached the end but there should be more data to read
+        if (*p == '\0') goto keep_reading;
+
         if (*p != '$') goto protoerr;
         plen = p+1; /* Bulk string len pointer. */
-        p = strstr(p,""\r\n""); if (!p) goto protoerr;
+        p = strstr(p,""\r\n""); if (!p) goto keep_reading;
         *p = '\0'; p += 2;
         int slen = atoi(plen); /* Length of this arg. */
         if (slen <= 0 || slen > 1024) goto protoerr;
+        if ((size_t)(p + slen + 2 - copy) > sdslen(copy) ) goto keep_reading;
         argv[argc++] = sdsnewlen(p,slen);
         p += slen; /* Skip the already parsed argument. */
         if (p[0] != '\r' || p[1] != '\n') goto protoerr;
@@ -39,6 +44,8 @@
     return argv;
 
 protoerr:
+    *err = protocol_error;
+keep_reading:
     sdsfreesplitres(argv,argc);
     sdsfree(copy);
     return NULL;","{'deleted_lines': ['sds *ldbReplParseCommand(int *argcp) {', '    p = strstr(p,""\\r\\n""); if (!p) goto protoerr;', '        p = strstr(p,""\\r\\n""); if (!p) goto protoerr;'], 'added_lines': ['sds *ldbReplParseCommand(int *argcp, char** err) {', '    static char* protocol_error = ""protocol error"";', '    p = strstr(p,""\\r\\n""); if (!p) goto keep_reading;', '        // reached the end but there should be more data to read', ""        if (*p == '\\0') goto keep_reading;"", '', '        p = strstr(p,""\\r\\n""); if (!p) goto keep_reading;', '        if ((size_t)(p + slen + 2 - copy) > sdslen(copy) ) goto keep_reading;', '    *err = protocol_error;', 'keep_reading:']}",True,"Redis is an open source, in-memory database that persists on disk. When using the Redis Lua Debugger, users can send malformed requests that cause the debugger’s protocol parser to read data beyond the actual buffer. This issue affects all versions of Redis with Lua debugging support (3.2 or newer). The problem is fixed in versions 6.2.6, 6.0.16 and 5.0.14.",5.3,MEDIUM,1,test,2021-06-13T11:29:20Z,3
CVE-2021-32672,['CWE-125'],AV:N/AC:L/Au:S/C:P/I:N/A:N,0,redis,"Fix protocol parsing on 'ldbReplParseCommand' (CVE-2021-32672)

The protocol parsing on 'ldbReplParseCommand' (LUA debugging)
Assumed protocol correctness. This means that if the following
is given:
*1
$100
test
The parser will try to read additional 94 unallocated bytes after
the client buffer.
This commit fixes this issue by validating that there are actually enough
bytes to read. It also limits the amount of data that can be sent by
the debugger client to 1M so the client will not be able to explode
the memory.",6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd,https://github.com/redis/redis/commit/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd,src/scripting.c,ldbRepl,"int ldbRepl(lua_State *lua) {
sds *argv;
int argc;
while(1) {
while((argv = ldbReplParseCommand(&argc)) == NULL) {
char buf[1024];
int nread = connRead(ldb.conn,buf,sizeof(buf));
if (nread <= 0) {
ldb.step = 0;
ldb.bpcount = 0;
return C_ERR;
}
ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);
}
sdsfree(ldb.cbuf);
ldb.cbuf = sdsempty();
if (!strcasecmp(argv[0],""h"") || !strcasecmp(argv[0],""help"")) {
ldbLog(sdsnew(""Redis Lua debugger help:""));
ldbLog(sdsnew(""[h]elp               Show this help.""));
ldbLog(sdsnew(""[s]tep               Run current line and stop again.""));
ldbLog(sdsnew(""[n]ext               Alias for step.""));
ldbLog(sdsnew(""[c]continue          Run till next breakpoint.""));
ldbLog(sdsnew(""[l]list              List source code around current line.""));
ldbLog(sdsnew(""[l]list [line]       List source code around [line].""));
ldbLog(sdsnew(""                     line = 0 means: current position.""));
ldbLog(sdsnew(""[l]list [line] [ctx] In this form [ctx] specifies how many lines""));
ldbLog(sdsnew(""                     to show before/after [line].""));
ldbLog(sdsnew(""[w]hole              List all source code. Alias for 'list 1 1000000'.""));
ldbLog(sdsnew(""[p]rint              Show all the local variables.""));
ldbLog(sdsnew(""[p]rint <var>        Show the value of the specified variable.""));
ldbLog(sdsnew(""                     Can also show global vars KEYS and ARGV.""));
ldbLog(sdsnew(""[b]reak              Show all breakpoints.""));
ldbLog(sdsnew(""[b]reak <line>       Add a breakpoint to the specified line.""));
ldbLog(sdsnew(""[b]reak -<line>      Remove breakpoint from the specified line.""));
ldbLog(sdsnew(""[b]reak 0            Remove all breakpoints.""));
ldbLog(sdsnew(""[t]race              Show a backtrace.""));
ldbLog(sdsnew(""[e]eval <code>       Execute some Lua code (in a different callframe).""));
ldbLog(sdsnew(""[r]edis <cmd>        Execute a Redis command.""));
ldbLog(sdsnew(""[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len.""));
ldbLog(sdsnew(""                     Specifying zero as <len> means unlimited.""));
ldbLog(sdsnew(""[a]bort              Stop the execution of the script. In sync""));
ldbLog(sdsnew(""                     mode dataset changes will be retained.""));
ldbLog(sdsnew(""""));
ldbLog(sdsnew(""Debugger functions you can call from Lua scripts:""));
ldbLog(sdsnew(""redis.debug()        Produce logs in the debugger console.""));
ldbLog(sdsnew(""redis.breakpoint()   Stop execution like if there was a breakpoint in the""));
ldbLog(sdsnew(""                     next line of code.""));
ldbSendLogs();
} else if (!strcasecmp(argv[0],""s"") || !strcasecmp(argv[0],""step"") ||
!strcasecmp(argv[0],""n"") || !strcasecmp(argv[0],""next"")) {
ldb.step = 1;
break;
} else if (!strcasecmp(argv[0],""c"") || !strcasecmp(argv[0],""continue"")){
break;
} else if (!strcasecmp(argv[0],""t"") || !strcasecmp(argv[0],""trace"")) {
ldbTrace(lua);
ldbSendLogs();
} else if (!strcasecmp(argv[0],""m"") || !strcasecmp(argv[0],""maxlen"")) {
ldbMaxlen(argv,argc);
ldbSendLogs();
} else if (!strcasecmp(argv[0],""b"") || !strcasecmp(argv[0],""break"")) {
ldbBreak(argv,argc);
ldbSendLogs();
} else if (!strcasecmp(argv[0],""e"") || !strcasecmp(argv[0],""eval"")) {
ldbEval(lua,argv,argc);
ldbSendLogs();
} else if (!strcasecmp(argv[0],""a"") || !strcasecmp(argv[0],""abort"")) {
lua_pushstring(lua, ""script aborted for user request"");
lua_error(lua);
} else if (argc > 1 &&
(!strcasecmp(argv[0],""r"") || !strcasecmp(argv[0],""redis""))) {
ldbRedis(lua,argv,argc);
ldbSendLogs();
} else if ((!strcasecmp(argv[0],""p"") || !strcasecmp(argv[0],""print""))) {
if (argc == 2)
ldbPrint(lua,argv[1]);
else
ldbPrintAll(lua);
ldbSendLogs();
} else if (!strcasecmp(argv[0],""l"") || !strcasecmp(argv[0],""list"")){
int around = ldb.currentline, ctx = 5;
if (argc > 1) {
int num = atoi(argv[1]);
if (num > 0) around = num;
}
if (argc > 2) ctx = atoi(argv[2]);
ldbList(around,ctx);
ldbSendLogs();
} else if (!strcasecmp(argv[0],""w"") || !strcasecmp(argv[0],""whole"")){
ldbList(1,1000000);
ldbSendLogs();
} else {
ldbLog(sdsnew(""<error> Unknown Redis Lua debugger command or ""
""wrong number of arguments.""));
ldbSendLogs();
}
sdsfreesplitres(argv,argc);
}
sdsfreesplitres(argv,argc);
return C_OK;
}","int ldbRepl(lua_State *VAR_0) {
sds *VAR_1;
int VAR_2;
while(1) {
while((VAR_1 = ldbReplParseCommand(&VAR_2)) == NULL) {
char VAR_3[1024];
int VAR_4 = connRead(VAR_5.conn,VAR_3,sizeof(VAR_3));
if (VAR_4 <= 0) {
VAR_5.step = 0;
VAR_5.bpcount = 0;
return VAR_6;
}
VAR_5.cbuf = sdscatlen(VAR_5.cbuf,VAR_3,VAR_4);
}
sdsfree(VAR_5.cbuf);
VAR_5.cbuf = sdsempty();
if (!strcasecmp(VAR_1[0],""h"") || !strcasecmp(VAR_1[0],""help"")) {
ldbLog(sdsnew(""Redis Lua debugger help:""));
ldbLog(sdsnew(""[h]elp               Show this help.""));
ldbLog(sdsnew(""[s]tep               Run current line and stop again.""));
ldbLog(sdsnew(""[n]ext               Alias for step.""));
ldbLog(sdsnew(""[c]continue          Run till next breakpoint.""));
ldbLog(sdsnew(""[l]list              List source code around current line.""));
ldbLog(sdsnew(""[l]list [line]       List source code around [line].""));
ldbLog(sdsnew(""                     line = 0 means: current position.""));
ldbLog(sdsnew(""[l]list [line] [ctx] In this form [ctx] specifies how many lines""));
ldbLog(sdsnew(""                     to show before/after [line].""));
ldbLog(sdsnew(""[w]hole              List all source code. Alias for 'list 1 1000000'.""));
ldbLog(sdsnew(""[p]rint              Show all the local variables.""));
ldbLog(sdsnew(""[p]rint <var>        Show the value of the specified variable.""));
ldbLog(sdsnew(""                     Can also show global vars KEYS and ARGV.""));
ldbLog(sdsnew(""[b]reak              Show all breakpoints.""));
ldbLog(sdsnew(""[b]reak <line>       Add a breakpoint to the specified line.""));
ldbLog(sdsnew(""[b]reak -<line>      Remove breakpoint from the specified line.""));
ldbLog(sdsnew(""[b]reak 0            Remove all breakpoints.""));
ldbLog(sdsnew(""[t]race              Show a backtrace.""));
ldbLog(sdsnew(""[e]eval <code>       Execute some Lua code (in a different callframe).""));
ldbLog(sdsnew(""[r]edis <cmd>        Execute a Redis command.""));
ldbLog(sdsnew(""[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len.""));
ldbLog(sdsnew(""                     Specifying zero as <len> means unlimited.""));
ldbLog(sdsnew(""[a]bort              Stop the execution of the script. In sync""));
ldbLog(sdsnew(""                     mode dataset changes will be retained.""));
ldbLog(sdsnew(""""));
ldbLog(sdsnew(""Debugger functions you can call from Lua scripts:""));
ldbLog(sdsnew(""redis.debug()        Produce logs in the debugger console.""));
ldbLog(sdsnew(""redis.breakpoint()   Stop execution like if there was a breakpoint in the""));
ldbLog(sdsnew(""                     next line of code.""));
ldbSendLogs();
} else if (!strcasecmp(VAR_1[0],""s"") || !strcasecmp(VAR_1[0],""step"") ||
!strcasecmp(VAR_1[0],""n"") || !strcasecmp(VAR_1[0],""next"")) {
VAR_5.step = 1;
break;
} else if (!strcasecmp(VAR_1[0],""c"") || !strcasecmp(VAR_1[0],""continue"")){
break;
} else if (!strcasecmp(VAR_1[0],""t"") || !strcasecmp(VAR_1[0],""trace"")) {
ldbTrace(VAR_0);
ldbSendLogs();
} else if (!strcasecmp(VAR_1[0],""m"") || !strcasecmp(VAR_1[0],""maxlen"")) {
ldbMaxlen(VAR_1,VAR_2);
ldbSendLogs();
} else if (!strcasecmp(VAR_1[0],""b"") || !strcasecmp(VAR_1[0],""break"")) {
ldbBreak(VAR_1,VAR_2);
ldbSendLogs();
} else if (!strcasecmp(VAR_1[0],""e"") || !strcasecmp(VAR_1[0],""eval"")) {
ldbEval(VAR_0,VAR_1,VAR_2);
ldbSendLogs();
} else if (!strcasecmp(VAR_1[0],""a"") || !strcasecmp(VAR_1[0],""abort"")) {
lua_pushstring(VAR_0, ""script aborted for user request"");
lua_error(VAR_0);
} else if (VAR_2 > 1 &&
(!strcasecmp(VAR_1[0],""r"") || !strcasecmp(VAR_1[0],""redis""))) {
ldbRedis(VAR_0,VAR_1,VAR_2);
ldbSendLogs();
} else if ((!strcasecmp(VAR_1[0],""p"") || !strcasecmp(VAR_1[0],""print""))) {
if (VAR_2 == 2)
ldbPrint(VAR_0,VAR_1[1]);
else
ldbPrintAll(VAR_0);
ldbSendLogs();
} else if (!strcasecmp(VAR_1[0],""l"") || !strcasecmp(VAR_1[0],""list"")){
int VAR_7 = VAR_5.currentline, VAR_8 = 5;
if (VAR_2 > 1) {
int VAR_9 = atoi(VAR_1[1]);
if (VAR_9 > 0) VAR_7 = VAR_9;
}
if (VAR_2 > 2) VAR_8 = atoi(VAR_1[2]);
ldbList(VAR_7,VAR_8);
ldbSendLogs();
} else if (!strcasecmp(VAR_1[0],""w"") || !strcasecmp(VAR_1[0],""whole"")){
ldbList(1,1000000);
ldbSendLogs();
} else {
ldbLog(sdsnew(""<error> Unknown Redis Lua debugger command or ""
""wrong number of arguments.""));
ldbSendLogs();
}
sdsfreesplitres(VAR_1,VAR_2);
}
sdsfreesplitres(VAR_1,VAR_2);
return VAR_10;
}",redis/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd/scripting.c/vul/before/1.json,"int ldbRepl(lua_State *lua) {
    sds *argv;
    int argc;
    char* err = NULL;

    /* We continue processing commands until a command that should return
     * to the Lua interpreter is found. */
    while(1) {
        while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {
            char buf[1024];
            if (err) {
                lua_pushstring(lua, err);
                lua_error(lua);
            }
            int nread = connRead(ldb.conn,buf,sizeof(buf));
            if (nread <= 0) {
                /* Make sure the script runs without user input since the
                 * client is no longer connected. */
                ldb.step = 0;
                ldb.bpcount = 0;
                return C_ERR;
            }
            ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);
            /* after 1M we will exit with an error
             * so that the client will not blow the memory
             */
            if (sdslen(ldb.cbuf) > 1<<20) {
                sdsfree(ldb.cbuf);
                ldb.cbuf = sdsempty();
                lua_pushstring(lua, ""max client buffer reached"");
                lua_error(lua);
            }
        }

        /* Flush the old buffer. */
        sdsfree(ldb.cbuf);
        ldb.cbuf = sdsempty();

        /* Execute the command. */
        if (!strcasecmp(argv[0],""h"") || !strcasecmp(argv[0],""help"")) {
ldbLog(sdsnew(""Redis Lua debugger help:""));
ldbLog(sdsnew(""[h]elp               Show this help.""));
ldbLog(sdsnew(""[s]tep               Run current line and stop again.""));
ldbLog(sdsnew(""[n]ext               Alias for step.""));
ldbLog(sdsnew(""[c]continue          Run till next breakpoint.""));
ldbLog(sdsnew(""[l]list              List source code around current line.""));
ldbLog(sdsnew(""[l]list [line]       List source code around [line].""));
ldbLog(sdsnew(""                     line = 0 means: current position.""));
ldbLog(sdsnew(""[l]list [line] [ctx] In this form [ctx] specifies how many lines""));
ldbLog(sdsnew(""                     to show before/after [line].""));
ldbLog(sdsnew(""[w]hole              List all source code. Alias for 'list 1 1000000'.""));
ldbLog(sdsnew(""[p]rint              Show all the local variables.""));
ldbLog(sdsnew(""[p]rint <var>        Show the value of the specified variable.""));
ldbLog(sdsnew(""                     Can also show global vars KEYS and ARGV.""));
ldbLog(sdsnew(""[b]reak              Show all breakpoints.""));
ldbLog(sdsnew(""[b]reak <line>       Add a breakpoint to the specified line.""));
ldbLog(sdsnew(""[b]reak -<line>      Remove breakpoint from the specified line.""));
ldbLog(sdsnew(""[b]reak 0            Remove all breakpoints.""));
ldbLog(sdsnew(""[t]race              Show a backtrace.""));
ldbLog(sdsnew(""[e]eval <code>       Execute some Lua code (in a different callframe).""));
ldbLog(sdsnew(""[r]edis <cmd>        Execute a Redis command.""));
ldbLog(sdsnew(""[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len.""));
ldbLog(sdsnew(""                     Specifying zero as <len> means unlimited.""));
ldbLog(sdsnew(""[a]bort              Stop the execution of the script. In sync""));
ldbLog(sdsnew(""                     mode dataset changes will be retained.""));
ldbLog(sdsnew(""""));
ldbLog(sdsnew(""Debugger functions you can call from Lua scripts:""));
ldbLog(sdsnew(""redis.debug()        Produce logs in the debugger console.""));
ldbLog(sdsnew(""redis.breakpoint()   Stop execution like if there was a breakpoint in the""));
ldbLog(sdsnew(""                     next line of code.""));
            ldbSendLogs();
        } else if (!strcasecmp(argv[0],""s"") || !strcasecmp(argv[0],""step"") ||
                   !strcasecmp(argv[0],""n"") || !strcasecmp(argv[0],""next"")) {
            ldb.step = 1;
            break;
        } else if (!strcasecmp(argv[0],""c"") || !strcasecmp(argv[0],""continue"")){
            break;
        } else if (!strcasecmp(argv[0],""t"") || !strcasecmp(argv[0],""trace"")) {
            ldbTrace(lua);
            ldbSendLogs();
        } else if (!strcasecmp(argv[0],""m"") || !strcasecmp(argv[0],""maxlen"")) {
            ldbMaxlen(argv,argc);
            ldbSendLogs();
        } else if (!strcasecmp(argv[0],""b"") || !strcasecmp(argv[0],""break"")) {
            ldbBreak(argv,argc);
            ldbSendLogs();
        } else if (!strcasecmp(argv[0],""e"") || !strcasecmp(argv[0],""eval"")) {
            ldbEval(lua,argv,argc);
            ldbSendLogs();
        } else if (!strcasecmp(argv[0],""a"") || !strcasecmp(argv[0],""abort"")) {
            lua_pushstring(lua, ""script aborted for user request"");
            lua_error(lua);
        } else if (argc > 1 &&
                   (!strcasecmp(argv[0],""r"") || !strcasecmp(argv[0],""redis""))) {
            ldbRedis(lua,argv,argc);
            ldbSendLogs();
        } else if ((!strcasecmp(argv[0],""p"") || !strcasecmp(argv[0],""print""))) {
            if (argc == 2)
                ldbPrint(lua,argv[1]);
            else
                ldbPrintAll(lua);
            ldbSendLogs();
        } else if (!strcasecmp(argv[0],""l"") || !strcasecmp(argv[0],""list"")){
            int around = ldb.currentline, ctx = 5;
            if (argc > 1) {
                int num = atoi(argv[1]);
                if (num > 0) around = num;
            }
            if (argc > 2) ctx = atoi(argv[2]);
            ldbList(around,ctx);
            ldbSendLogs();
        } else if (!strcasecmp(argv[0],""w"") || !strcasecmp(argv[0],""whole"")){
            ldbList(1,1000000);
            ldbSendLogs();
        } else {
            ldbLog(sdsnew(""<error> Unknown Redis Lua debugger command or ""
                          ""wrong number of arguments.""));
            ldbSendLogs();
        }

        /* Free the command vector. */
        sdsfreesplitres(argv,argc);
    }

    /* Free the current command argv if we break inside the while loop. */
    sdsfreesplitres(argv,argc);
    return C_OK;
}","int ldbRepl(lua_State *VAR_0) {
    sds *VAR_1;
    int VAR_2;
    char* VAR_3 = NULL;

    /* COMMENT_0 */
                                          
    while(1) {
        while((VAR_1 = ldbReplParseCommand(&VAR_2, &VAR_3)) == NULL) {
            char VAR_4[1024];
            if (VAR_3) {
                lua_pushstring(VAR_0, VAR_3);
                lua_error(VAR_0);
            }
            int VAR_5 = connRead(VAR_6.conn,VAR_4,sizeof(VAR_4));
            if (VAR_5 <= 0) {
                /* COMMENT_2 */
                                                    
                VAR_6.step = 0;
                VAR_6.bpcount = 0;
                return VAR_7;
            }
            VAR_6.cbuf = sdscatlen(VAR_6.cbuf,VAR_4,VAR_5);
            /* COMMENT_4 */
                                                          
               
            if (sdslen(VAR_6.cbuf) > 1<<20) {
                sdsfree(VAR_6.cbuf);
                VAR_6.cbuf = sdsempty();
                lua_pushstring(VAR_0, ""max client buffer reached"");
                lua_error(VAR_0);
            }
        }

        /* COMMENT_7 */
        sdsfree(VAR_6.cbuf);
        VAR_6.cbuf = sdsempty();

        /* COMMENT_8 */
        if (!strcasecmp(VAR_1[0],""h"") || !strcasecmp(VAR_1[0],""help"")) {
ldbLog(sdsnew(""Redis Lua debugger help:""));
ldbLog(sdsnew(""[h]elp               Show this help.""));
ldbLog(sdsnew(""[s]tep               Run current line and stop again.""));
ldbLog(sdsnew(""[n]ext               Alias for step.""));
ldbLog(sdsnew(""[c]continue          Run till next breakpoint.""));
ldbLog(sdsnew(""[l]list              List source code around current line.""));
ldbLog(sdsnew(""[l]list [line]       List source code around [line].""));
ldbLog(sdsnew(""                     line = 0 means: current position.""));
ldbLog(sdsnew(""[l]list [line] [ctx] In this form [ctx] specifies how many lines""));
ldbLog(sdsnew(""                     to show before/after [line].""));
ldbLog(sdsnew(""[w]hole              List all source code. Alias for 'list 1 1000000'.""));
ldbLog(sdsnew(""[p]rint              Show all the local variables.""));
ldbLog(sdsnew(""[p]rint <var>        Show the value of the specified variable.""));
ldbLog(sdsnew(""                     Can also show global vars KEYS and ARGV.""));
ldbLog(sdsnew(""[b]reak              Show all breakpoints.""));
ldbLog(sdsnew(""[b]reak <line>       Add a breakpoint to the specified line.""));
ldbLog(sdsnew(""[b]reak -<line>      Remove breakpoint from the specified line.""));
ldbLog(sdsnew(""[b]reak 0            Remove all breakpoints.""));
ldbLog(sdsnew(""[t]race              Show a backtrace.""));
ldbLog(sdsnew(""[e]eval <code>       Execute some Lua code (in a different callframe).""));
ldbLog(sdsnew(""[r]edis <cmd>        Execute a Redis command.""));
ldbLog(sdsnew(""[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len.""));
ldbLog(sdsnew(""                     Specifying zero as <len> means unlimited.""));
ldbLog(sdsnew(""[a]bort              Stop the execution of the script. In sync""));
ldbLog(sdsnew(""                     mode dataset changes will be retained.""));
ldbLog(sdsnew(""""));
ldbLog(sdsnew(""Debugger functions you can call from Lua scripts:""));
ldbLog(sdsnew(""redis.debug()        Produce logs in the debugger console.""));
ldbLog(sdsnew(""redis.breakpoint()   Stop execution like if there was a breakpoint in the""));
ldbLog(sdsnew(""                     next line of code.""));
            ldbSendLogs();
        } else if (!strcasecmp(VAR_1[0],""s"") || !strcasecmp(VAR_1[0],""step"") ||
                   !strcasecmp(VAR_1[0],""n"") || !strcasecmp(VAR_1[0],""next"")) {
            VAR_6.step = 1;
            break;
        } else if (!strcasecmp(VAR_1[0],""c"") || !strcasecmp(VAR_1[0],""continue"")){
            break;
        } else if (!strcasecmp(VAR_1[0],""t"") || !strcasecmp(VAR_1[0],""trace"")) {
            ldbTrace(VAR_0);
            ldbSendLogs();
        } else if (!strcasecmp(VAR_1[0],""m"") || !strcasecmp(VAR_1[0],""maxlen"")) {
            ldbMaxlen(VAR_1,VAR_2);
            ldbSendLogs();
        } else if (!strcasecmp(VAR_1[0],""b"") || !strcasecmp(VAR_1[0],""break"")) {
            ldbBreak(VAR_1,VAR_2);
            ldbSendLogs();
        } else if (!strcasecmp(VAR_1[0],""e"") || !strcasecmp(VAR_1[0],""eval"")) {
            ldbEval(VAR_0,VAR_1,VAR_2);
            ldbSendLogs();
        } else if (!strcasecmp(VAR_1[0],""a"") || !strcasecmp(VAR_1[0],""abort"")) {
            lua_pushstring(VAR_0, ""script aborted for user request"");
            lua_error(VAR_0);
        } else if (VAR_2 > 1 &&
                   (!strcasecmp(VAR_1[0],""r"") || !strcasecmp(VAR_1[0],""redis""))) {
            ldbRedis(VAR_0,VAR_1,VAR_2);
            ldbSendLogs();
        } else if ((!strcasecmp(VAR_1[0],""p"") || !strcasecmp(VAR_1[0],""print""))) {
            if (VAR_2 == 2)
                ldbPrint(VAR_0,VAR_1[1]);
            else
                ldbPrintAll(VAR_0);
            ldbSendLogs();
        } else if (!strcasecmp(VAR_1[0],""l"") || !strcasecmp(VAR_1[0],""list"")){
            int VAR_8 = VAR_6.currentline, VAR_9 = 5;
            if (VAR_2 > 1) {
                int VAR_10 = atoi(VAR_1[1]);
                if (VAR_10 > 0) VAR_8 = VAR_10;
            }
            if (VAR_2 > 2) VAR_9 = atoi(VAR_1[2]);
            ldbList(VAR_8,VAR_9);
            ldbSendLogs();
        } else if (!strcasecmp(VAR_1[0],""w"") || !strcasecmp(VAR_1[0],""whole"")){
            ldbList(1,1000000);
            ldbSendLogs();
        } else {
            ldbLog(sdsnew(""<error> Unknown Redis Lua debugger command or ""
                          ""wrong number of arguments.""));
            ldbSendLogs();
        }

        /* COMMENT_9 */
        sdsfreesplitres(VAR_1,VAR_2);
    }

    /* COMMENT_10 */
    sdsfreesplitres(VAR_1,VAR_2);
    return VAR_11;
}",redis/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd/scripting.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,12 +1,17 @@
 int ldbRepl(lua_State *lua) {
     sds *argv;
     int argc;
+    char* err = NULL;
 
     /* We continue processing commands until a command that should return
      * to the Lua interpreter is found. */
     while(1) {
-        while((argv = ldbReplParseCommand(&argc)) == NULL) {
+        while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {
             char buf[1024];
+            if (err) {
+                lua_pushstring(lua, err);
+                lua_error(lua);
+            }
             int nread = connRead(ldb.conn,buf,sizeof(buf));
             if (nread <= 0) {
                 /* Make sure the script runs without user input since the
@@ -16,6 +21,15 @@
                 return C_ERR;
             }
             ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);
+            /* after 1M we will exit with an error
+             * so that the client will not blow the memory
+             */
+            if (sdslen(ldb.cbuf) > 1<<20) {
+                sdsfree(ldb.cbuf);
+                ldb.cbuf = sdsempty();
+                lua_pushstring(lua, ""max client buffer reached"");
+                lua_error(lua);
+            }
         }
 
         /* Flush the old buffer. */","{'deleted_lines': ['        while((argv = ldbReplParseCommand(&argc)) == NULL) {'], 'added_lines': ['    char* err = NULL;', '        while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {', '            if (err) {', '                lua_pushstring(lua, err);', '                lua_error(lua);', '            }', '            /* after 1M we will exit with an error', '             * so that the client will not blow the memory', '             */', '            if (sdslen(ldb.cbuf) > 1<<20) {', '                sdsfree(ldb.cbuf);', '                ldb.cbuf = sdsempty();', '                lua_pushstring(lua, ""max client buffer reached"");', '                lua_error(lua);', '            }']}",True,"Redis is an open source, in-memory database that persists on disk. When using the Redis Lua Debugger, users can send malformed requests that cause the debugger’s protocol parser to read data beyond the actual buffer. This issue affects all versions of Redis with Lua debugging support (3.2 or newer). The problem is fixed in versions 6.2.6, 6.0.16 and 5.0.14.",5.3,MEDIUM,1,test,2021-06-13T11:29:20Z,3
CVE-2021-3609,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"can: bcm: delay release of struct bcm_op after synchronize_rcu()

can_rx_register() callbacks may be called concurrently to the call to
can_rx_unregister(). The callbacks and callback data, though, are
protected by RCU and the struct sock reference count.

So the callback data is really attached to the life of sk, meaning
that it should be released on sk_destruct. However, bcm_remove_op()
calls tasklet_kill(), and RCU callbacks may be called under RCU
softirq, so that cannot be used on kernels before the introduction of
HRTIMER_MODE_SOFT.

However, bcm_rx_handler() is called under RCU protection, so after
calling can_rx_unregister(), we may call synchronize_rcu() in order to
wait for any RCU read-side critical sections to finish. That is,
bcm_rx_handler() won't be called anymore for those ops. So, we only
free them, after we do that synchronize_rcu().

Fixes: ffd980f976e7 (""[CAN]: Add broadcast manager (bcm) protocol"")
Link: https://lore.kernel.org/r/20210619161813.2098382-1-cascardo@canonical.com
Cc: linux-stable <stable@vger.kernel.org>
Reported-by: syzbot+0f7e7e5e2f4f40fa89c0@syzkaller.appspotmail.com
Reported-by: Norbert Slusarek <nslusarek@gmx.net>
Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
Acked-by: Oliver Hartkopp <socketcan@hartkopp.net>
Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>",d5f9023fa61ee8b94f37a93f08e94b136cf1e463,https://github.com/torvalds/linux/commit/d5f9023fa61ee8b94f37a93f08e94b136cf1e463,net/can/bcm.c,bcm_delete_rx_op,"static int bcm_delete_rx_op(struct list_head *ops, struct bcm_msg_head *mh,
int ifindex)
{
struct bcm_op *op, *n;
list_for_each_entry_safe(op, n, ops, list) {
if ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&
(op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME)) {
if (op->ifindex) {
if (op->rx_reg_dev) {
struct net_device *dev;
dev = dev_get_by_index(sock_net(op->sk),
op->ifindex);
if (dev) {
bcm_rx_unreg(dev, op);
dev_put(dev);
}
}
} else
can_rx_unregister(sock_net(op->sk), NULL,
op->can_id,
REGMASK(op->can_id),
bcm_rx_handler, op);
list_del(&op->list);
bcm_remove_op(op);
return 1; 
}
}
return 0; 
}","static int bcm_delete_rx_op(struct list_head *VAR_0, struct bcm_msg_head *VAR_1,
int VAR_2)
{
struct bcm_op *VAR_3, *VAR_4;
list_for_each_entry_safe(VAR_3, VAR_4, VAR_0, VAR_5) {
if ((VAR_3->can_id == VAR_1->can_id) && (VAR_3->ifindex == VAR_2) &&
(VAR_3->flags & VAR_6) == (VAR_1->flags & VAR_6)) {
if (VAR_3->ifindex) {
if (VAR_3->rx_reg_dev) {
struct net_device *VAR_7;
VAR_7 = dev_get_by_index(sock_net(VAR_3->sk),
VAR_3->ifindex);
if (VAR_7) {
bcm_rx_unreg(VAR_7, VAR_3);
dev_put(VAR_7);
}
}
} else
can_rx_unregister(sock_net(VAR_3->sk), NULL,
VAR_3->can_id,
REGMASK(VAR_3->can_id),
VAR_8, VAR_3);
list_del(&VAR_3->list);
bcm_remove_op(VAR_3);
return 1; 
}
}
return 0; 
}",torvalds/linux/d5f9023fa61ee8b94f37a93f08e94b136cf1e463/bcm.c/vul/before/0.json,"static int bcm_delete_rx_op(struct list_head *ops, struct bcm_msg_head *mh,
			    int ifindex)
{
	struct bcm_op *op, *n;

	list_for_each_entry_safe(op, n, ops, list) {
		if ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&
		    (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME)) {

			/*
			 * Don't care if we're bound or not (due to netdev
			 * problems) can_rx_unregister() is always a save
			 * thing to do here.
			 */
			if (op->ifindex) {
				/*
				 * Only remove subscriptions that had not
				 * been removed due to NETDEV_UNREGISTER
				 * in bcm_notifier()
				 */
				if (op->rx_reg_dev) {
					struct net_device *dev;

					dev = dev_get_by_index(sock_net(op->sk),
							       op->ifindex);
					if (dev) {
						bcm_rx_unreg(dev, op);
						dev_put(dev);
					}
				}
			} else
				can_rx_unregister(sock_net(op->sk), NULL,
						  op->can_id,
						  REGMASK(op->can_id),
						  bcm_rx_handler, op);

			list_del(&op->list);
			synchronize_rcu();
			bcm_remove_op(op);
			return 1; /* done */
		}
	}

	return 0; /* not found */
}","static int bcm_delete_rx_op(struct list_head *VAR_0, struct bcm_msg_head *VAR_1,
			    int VAR_2)
{
	struct bcm_op *VAR_3, *VAR_4;

	list_for_each_entry_safe(VAR_3, VAR_4, VAR_0, VAR_5) {
		if ((VAR_3->can_id == VAR_1->can_id) && (VAR_3->ifindex == VAR_2) &&
		    (VAR_3->flags & VAR_6) == (VAR_1->flags & VAR_6)) {

			/* COMMENT_0 */
                                                     
                                                    
                       
      
			if (VAR_3->ifindex) {
				/* COMMENT_5 */
                                             
                                            
                        
       
				if (VAR_3->rx_reg_dev) {
					struct net_device *VAR_7;

					VAR_7 = dev_get_by_index(sock_net(VAR_3->sk),
							       VAR_3->ifindex);
					if (VAR_7) {
						bcm_rx_unreg(VAR_7, VAR_3);
						dev_put(VAR_7);
					}
				}
			} else
				can_rx_unregister(sock_net(VAR_3->sk), NULL,
						  VAR_3->can_id,
						  REGMASK(VAR_3->can_id),
						  VAR_8, VAR_3);

			list_del(&VAR_3->list);
			synchronize_rcu();
			bcm_remove_op(VAR_3);
			return 1; /* COMMENT_10 */
		}
	}

	return 0; /* COMMENT_11 */
}",torvalds/linux/d5f9023fa61ee8b94f37a93f08e94b136cf1e463/bcm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,6 +35,7 @@
 						  bcm_rx_handler, op);
 
 			list_del(&op->list);
+			synchronize_rcu();
 			bcm_remove_op(op);
 			return 1; /* done */
 		}","{'deleted_lines': [], 'added_lines': ['\t\t\tsynchronize_rcu();']}",True,".A flaw was found in the CAN BCM networking protocol in the Linux kernel, where a local attacker can abuse a flaw in the CAN subsystem to corrupt memory, crash the system or escalate privileges. This race condition in net/can/bcm.c in the Linux kernel allows for local privilege escalation to root.",7.0,HIGH,2,test,2021-06-19T16:18:13Z,3
CVE-2021-3609,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"can: bcm: delay release of struct bcm_op after synchronize_rcu()

can_rx_register() callbacks may be called concurrently to the call to
can_rx_unregister(). The callbacks and callback data, though, are
protected by RCU and the struct sock reference count.

So the callback data is really attached to the life of sk, meaning
that it should be released on sk_destruct. However, bcm_remove_op()
calls tasklet_kill(), and RCU callbacks may be called under RCU
softirq, so that cannot be used on kernels before the introduction of
HRTIMER_MODE_SOFT.

However, bcm_rx_handler() is called under RCU protection, so after
calling can_rx_unregister(), we may call synchronize_rcu() in order to
wait for any RCU read-side critical sections to finish. That is,
bcm_rx_handler() won't be called anymore for those ops. So, we only
free them, after we do that synchronize_rcu().

Fixes: ffd980f976e7 (""[CAN]: Add broadcast manager (bcm) protocol"")
Link: https://lore.kernel.org/r/20210619161813.2098382-1-cascardo@canonical.com
Cc: linux-stable <stable@vger.kernel.org>
Reported-by: syzbot+0f7e7e5e2f4f40fa89c0@syzkaller.appspotmail.com
Reported-by: Norbert Slusarek <nslusarek@gmx.net>
Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
Acked-by: Oliver Hartkopp <socketcan@hartkopp.net>
Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>",d5f9023fa61ee8b94f37a93f08e94b136cf1e463,https://github.com/torvalds/linux/commit/d5f9023fa61ee8b94f37a93f08e94b136cf1e463,net/can/bcm.c,bcm_release,"static int bcm_release(struct socket *sock)
{
struct sock *sk = sock->sk;
struct net *net;
struct bcm_sock *bo;
struct bcm_op *op, *next;
if (!sk)
return 0;
net = sock_net(sk);
bo = bcm_sk(sk);
spin_lock(&bcm_notifier_lock);
while (bcm_busy_notifier == bo) {
spin_unlock(&bcm_notifier_lock);
schedule_timeout_uninterruptible(1);
spin_lock(&bcm_notifier_lock);
}
list_del(&bo->notifier);
spin_unlock(&bcm_notifier_lock);
lock_sock(sk);
list_for_each_entry_safe(op, next, &bo->tx_ops, list)
bcm_remove_op(op);
list_for_each_entry_safe(op, next, &bo->rx_ops, list) {
if (op->ifindex) {
if (op->rx_reg_dev) {
struct net_device *dev;
dev = dev_get_by_index(net, op->ifindex);
if (dev) {
bcm_rx_unreg(dev, op);
dev_put(dev);
}
}
} else
can_rx_unregister(net, NULL, op->can_id,
REGMASK(op->can_id),
bcm_rx_handler, op);
bcm_remove_op(op);
}
#if IS_ENABLED(CONFIG_PROC_FS)
if (net->can.bcmproc_dir && bo->bcm_proc_read)
remove_proc_entry(bo->procname, net->can.bcmproc_dir);
#endif 
if (bo->bound) {
bo->bound   = 0;
bo->ifindex = 0;
}
sock_orphan(sk);
sock->sk = NULL;
release_sock(sk);
sock_put(sk);
return 0;
}","static int bcm_release(struct socket *VAR_0)
{
struct sock *VAR_1 = sock->sk;
struct net *net;
struct bcm_sock *VAR_2;
struct bcm_op *VAR_3, *VAR_4;
if (!VAR_1)
return 0;
net = sock_net(VAR_1);
VAR_2 = bcm_sk(VAR_1);
spin_lock(&VAR_5);
while (VAR_6 == VAR_2) {
spin_unlock(&VAR_5);
schedule_timeout_uninterruptible(1);
spin_lock(&VAR_5);
}
list_del(&VAR_2->notifier);
spin_unlock(&VAR_5);
lock_sock(VAR_1);
list_for_each_entry_safe(VAR_3, VAR_4, &VAR_2->tx_ops, VAR_7)
bcm_remove_op(VAR_3);
list_for_each_entry_safe(VAR_3, VAR_4, &VAR_2->rx_ops, VAR_7) {
if (VAR_3->ifindex) {
if (VAR_3->rx_reg_dev) {
struct net_device *VAR_8;
VAR_8 = dev_get_by_index(net, VAR_3->ifindex);
if (VAR_8) {
bcm_rx_unreg(VAR_8, VAR_3);
dev_put(VAR_8);
}
}
} else
can_rx_unregister(net, NULL, VAR_3->can_id,
REGMASK(VAR_3->can_id),
VAR_9, VAR_3);
bcm_remove_op(VAR_3);
}
#if IS_ENABLED(VAR_10)
if (net->can.bcmproc_dir && VAR_2->bcm_proc_read)
remove_proc_entry(VAR_2->procname, net->can.bcmproc_dir);
#endif 
if (VAR_2->bound) {
VAR_2->bound   = 0;
VAR_2->ifindex = 0;
}
sock_orphan(VAR_1);
sock->sk = NULL;
release_sock(VAR_1);
sock_put(VAR_1);
return 0;
}",torvalds/linux/d5f9023fa61ee8b94f37a93f08e94b136cf1e463/bcm.c/vul/before/1.json,"static int bcm_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct net *net;
	struct bcm_sock *bo;
	struct bcm_op *op, *next;

	if (!sk)
		return 0;

	net = sock_net(sk);
	bo = bcm_sk(sk);

	/* remove bcm_ops, timer, rx_unregister(), etc. */

	spin_lock(&bcm_notifier_lock);
	while (bcm_busy_notifier == bo) {
		spin_unlock(&bcm_notifier_lock);
		schedule_timeout_uninterruptible(1);
		spin_lock(&bcm_notifier_lock);
	}
	list_del(&bo->notifier);
	spin_unlock(&bcm_notifier_lock);

	lock_sock(sk);

	list_for_each_entry_safe(op, next, &bo->tx_ops, list)
		bcm_remove_op(op);

	list_for_each_entry_safe(op, next, &bo->rx_ops, list) {
		/*
		 * Don't care if we're bound or not (due to netdev problems)
		 * can_rx_unregister() is always a save thing to do here.
		 */
		if (op->ifindex) {
			/*
			 * Only remove subscriptions that had not
			 * been removed due to NETDEV_UNREGISTER
			 * in bcm_notifier()
			 */
			if (op->rx_reg_dev) {
				struct net_device *dev;

				dev = dev_get_by_index(net, op->ifindex);
				if (dev) {
					bcm_rx_unreg(dev, op);
					dev_put(dev);
				}
			}
		} else
			can_rx_unregister(net, NULL, op->can_id,
					  REGMASK(op->can_id),
					  bcm_rx_handler, op);

	}

	synchronize_rcu();

	list_for_each_entry_safe(op, next, &bo->rx_ops, list)
		bcm_remove_op(op);

#if IS_ENABLED(CONFIG_PROC_FS)
	/* remove procfs entry */
	if (net->can.bcmproc_dir && bo->bcm_proc_read)
		remove_proc_entry(bo->procname, net->can.bcmproc_dir);
#endif /* CONFIG_PROC_FS */

	/* remove device reference */
	if (bo->bound) {
		bo->bound   = 0;
		bo->ifindex = 0;
	}

	sock_orphan(sk);
	sock->sk = NULL;

	release_sock(sk);
	sock_put(sk);

	return 0;
}","static int bcm_release(struct socket *VAR_0)
{
	struct sock *VAR_1 = sock->sk;
	struct net *net;
	struct bcm_sock *VAR_2;
	struct bcm_op *VAR_3, *VAR_4;

	if (!VAR_1)
		return 0;

	net = sock_net(VAR_1);
	VAR_2 = bcm_sk(VAR_1);

	/* COMMENT_0 */

	spin_lock(&VAR_5);
	while (VAR_6 == VAR_2) {
		spin_unlock(&VAR_5);
		schedule_timeout_uninterruptible(1);
		spin_lock(&VAR_5);
	}
	list_del(&VAR_2->notifier);
	spin_unlock(&VAR_5);

	lock_sock(VAR_1);

	list_for_each_entry_safe(VAR_3, VAR_4, &VAR_2->tx_ops, VAR_7)
		bcm_remove_op(VAR_3);

	list_for_each_entry_safe(VAR_3, VAR_4, &VAR_2->rx_ops, VAR_7) {
		/* COMMENT_1 */
                                                              
                                                           
     
		if (VAR_3->ifindex) {
			/* COMMENT_5 */
                                            
                                           
                       
      
			if (VAR_3->rx_reg_dev) {
				struct net_device *VAR_8;

				VAR_8 = dev_get_by_index(net, VAR_3->ifindex);
				if (VAR_8) {
					bcm_rx_unreg(VAR_8, VAR_3);
					dev_put(VAR_8);
				}
			}
		} else
			can_rx_unregister(net, NULL, VAR_3->can_id,
					  REGMASK(VAR_3->can_id),
					  VAR_9, VAR_3);

	}

	synchronize_rcu();

	list_for_each_entry_safe(VAR_3, VAR_4, &VAR_2->rx_ops, VAR_7)
		bcm_remove_op(VAR_3);

#if IS_ENABLED(VAR_10)
	/* COMMENT_10 */
	if (net->can.bcmproc_dir && VAR_2->bcm_proc_read)
		remove_proc_entry(VAR_2->procname, net->can.bcmproc_dir);
#endif /* COMMENT_11 */

	/* COMMENT_12 */
	if (VAR_2->bound) {
		VAR_2->bound   = 0;
		VAR_2->ifindex = 0;
	}

	sock_orphan(VAR_1);
	sock->sk = NULL;

	release_sock(VAR_1);
	sock_put(VAR_1);

	return 0;
}",torvalds/linux/d5f9023fa61ee8b94f37a93f08e94b136cf1e463/bcm.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -52,8 +52,12 @@
 					  REGMASK(op->can_id),
 					  bcm_rx_handler, op);
 
+	}
+
+	synchronize_rcu();
+
+	list_for_each_entry_safe(op, next, &bo->rx_ops, list)
 		bcm_remove_op(op);
-	}
 
 #if IS_ENABLED(CONFIG_PROC_FS)
 	/* remove procfs entry */","{'deleted_lines': ['\t}'], 'added_lines': ['\t}', '', '\tsynchronize_rcu();', '', '\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list)']}",True,".A flaw was found in the CAN BCM networking protocol in the Linux kernel, where a local attacker can abuse a flaw in the CAN subsystem to corrupt memory, crash the system or escalate privileges. This race condition in net/can/bcm.c in the Linux kernel allows for local privilege escalation to root.",7.0,HIGH,2,test,2021-06-19T16:18:13Z,3
CVE-2021-39365,['CWE-295'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,GNOME/grilo,"net: Fix TLS cert validation not being done for any network call

The default SoupSessionAsync behaviour does not perform any TLS certificate
validation, unless the ssl-use-system-ca-file property is set to true.

See https://blogs.gnome.org/mcatanzaro/2021/05/25/reminder-soupsessionsync-and-soupsessionasync-default-to-no-tls-certificate-verification/

This mitigates CVE-2016-20011.

Closes: #146",cd2472e506dafb1bb8ae510e34ad4797f63e263e,https://github.com/GNOME/grilo/commit/cd2472e506dafb1bb8ae510e34ad4797f63e263e,libs/net/grl-net-wc.c,grl_net_wc_init,"static void
grl_net_wc_init (GrlNetWc *wc)
{
GRL_LOG_DOMAIN_INIT (wc_log_domain, ""wc"");
wc->priv = grl_net_wc_get_instance_private (wc);
wc->priv->session = soup_session_async_new ();
wc->priv->pending = g_queue_new ();
set_thread_context (wc);
init_mock_requester (wc);
init_requester (wc);
}","static void
grl_net_wc_init (GrlNetWc *VAR_0)
{
GRL_LOG_DOMAIN_INIT (VAR_1, ""wc"");
VAR_0->priv = grl_net_wc_get_instance_private (VAR_0);
VAR_0->priv->session = soup_session_async_new ();
VAR_0->priv->pending = g_queue_new ();
set_thread_context (VAR_0);
init_mock_requester (VAR_0);
init_requester (VAR_0);
}",GNOME/grilo/cd2472e506dafb1bb8ae510e34ad4797f63e263e/grl-net-wc.c/vul/before/0.json,"static void
grl_net_wc_init (GrlNetWc *wc)
{
  GRL_LOG_DOMAIN_INIT (wc_log_domain, ""wc"");

  wc->priv = grl_net_wc_get_instance_private (wc);

  wc->priv->session = soup_session_async_new ();
  g_object_set (G_OBJECT (wc->priv->session), ""ssl-use-system-ca-file"", TRUE, NULL);
  wc->priv->pending = g_queue_new ();

  set_thread_context (wc);
  init_mock_requester (wc);
  init_requester (wc);
}","static void
grl_net_wc_init (GrlNetWc *VAR_0)
{
  GRL_LOG_DOMAIN_INIT (VAR_1, ""wc"");

  VAR_0->priv = grl_net_wc_get_instance_private (VAR_0);

  VAR_0->priv->session = soup_session_async_new ();
  g_object_set (G_OBJECT (VAR_0->priv->session), ""ssl-use-system-ca-file"", TRUE, NULL);
  VAR_0->priv->pending = g_queue_new ();

  set_thread_context (VAR_0);
  init_mock_requester (VAR_0);
  init_requester (VAR_0);
}",GNOME/grilo/cd2472e506dafb1bb8ae510e34ad4797f63e263e/grl-net-wc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,7 @@
   wc->priv = grl_net_wc_get_instance_private (wc);
 
   wc->priv->session = soup_session_async_new ();
+  g_object_set (G_OBJECT (wc->priv->session), ""ssl-use-system-ca-file"", TRUE, NULL);
   wc->priv->pending = g_queue_new ();
 
   set_thread_context (wc);","{'deleted_lines': [], 'added_lines': ['  g_object_set (G_OBJECT (wc->priv->session), ""ssl-use-system-ca-file"", TRUE, NULL);']}",True,"In GNOME grilo though 0.3.13, grl-net-wc.c does not enable TLS certificate verification on the SoupSessionAsync objects it creates, leaving users vulnerable to network MITM attacks. NOTE: this is similar to CVE-2016-20011.",5.9,MEDIUM,1,test,2021-06-21T13:00:14Z,3
CVE-2021-35331,['CWE-134'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,tcltk/tcl,"Fix [bad6cc213d]: A format string vulnerability in Tcl nmakehelp.c allows code execution via a crated file.
Also change a memcpy() to a memmove(), because the range could be overlapping",4705dbdde2f32ff90420765cd93e7ac71d81a222,https://github.com/tcltk/tcl/commit/4705dbdde2f32ff90420765cd93e7ac71d81a222,win/nmakehlp.c,GetVersionFromFile,"static const char *
GetVersionFromFile(
const char *filename,
const char *match,
int numdots)
{
size_t cbBuffer = 100;
static char szBuffer[100];
char *szResult = NULL;
FILE *fp = fopen(filename, ""rt"");
if (fp != NULL) {
while (fgets(szBuffer, cbBuffer, fp) != NULL) {
LPSTR p, q;
p = strstr(szBuffer, match);
if (p != NULL) {
p += strlen(match);
while (*p && !isdigit(*p)) {
++p;
}
q = p;
while (*q && (strchr(""0123456789.ab"", *q)) && ((!strchr("".ab"", *q)
&& (!strchr(""ab"", q[-1])) || --numdots))) {
++q;
}
memcpy(szBuffer, p, q - p);
szBuffer[q-p] = 0;
szResult = szBuffer;
break;
}
}
fclose(fp);
}
return szResult;
}","static const char *
GetVersionFromFile(
const char *VAR_0,
const char *VAR_1,
int VAR_2)
{
size_t VAR_3 = 100;
static char VAR_4[100];
char *VAR_5 = NULL;
FILE *VAR_6 = fopen(VAR_0, ""rt"");
if (VAR_6 != NULL) {
while (fgets(VAR_4, VAR_3, VAR_6) != NULL) {
LPSTR VAR_7, VAR_8;
VAR_7 = strstr(VAR_4, VAR_1);
if (VAR_7 != NULL) {
VAR_7 += strlen(VAR_1);
while (*VAR_7 && !isdigit(*VAR_7)) {
++VAR_7;
}
VAR_8 = VAR_7;
while (*VAR_8 && (strchr(""0123456789.ab"", *VAR_8)) && ((!strchr("".ab"", *VAR_8)
&& (!strchr(""ab"", VAR_8[-1])) || --VAR_2))) {
++VAR_8;
}
memcpy(VAR_4, VAR_7, VAR_8 - VAR_7);
VAR_4[VAR_8-VAR_7] = 0;
VAR_5 = VAR_4;
break;
}
}
fclose(VAR_6);
}
return VAR_5;
}",tcltk/tcl/4705dbdde2f32ff90420765cd93e7ac71d81a222/nmakehlp.c/vul/before/1.json,"static const char *
GetVersionFromFile(
    const char *filename,
    const char *match,
    int numdots)
{
    size_t cbBuffer = 100;
    static char szBuffer[100];
    char *szResult = NULL;
    FILE *fp = fopen(filename, ""rt"");

    if (fp != NULL) {
	/*
	 * Read data until we see our match string.
	 */

	while (fgets(szBuffer, cbBuffer, fp) != NULL) {
	    LPSTR p, q;

	    p = strstr(szBuffer, match);
	    if (p != NULL) {
		/*
		 * Skip to first digit after the match.
		 */

		p += strlen(match);
		while (*p && !isdigit(*p)) {
		    ++p;
		}

		/*
		 * Find ending whitespace.
		 */

		q = p;
		while (*q && (strchr(""0123456789.ab"", *q)) && ((!strchr("".ab"", *q)
			    && (!strchr(""ab"", q[-1])) || --numdots))) {
		    ++q;
		}

		memmove(szBuffer, p, q - p);
		szBuffer[q-p] = 0;
		szResult = szBuffer;
		break;
	    }
	}
	fclose(fp);
    }
    return szResult;
}","static const char *
GetVersionFromFile(
    const char *VAR_0,
    const char *VAR_1,
    int VAR_2)
{
    size_t VAR_3 = 100;
    static char VAR_4[100];
    char *VAR_5 = NULL;
    FILE *VAR_6 = fopen(VAR_0, ""rt"");

    if (VAR_6 != NULL) {
	/* COMMENT_0 */
                                            
    

	while (fgets(VAR_4, VAR_3, VAR_6) != NULL) {
	    LPSTR VAR_7, VAR_8;

	    VAR_7 = strstr(VAR_4, VAR_1);
	    if (VAR_7 != NULL) {
		/* COMMENT_3 */
                                         
     

		VAR_7 += strlen(VAR_1);
		while (*VAR_7 && !isdigit(*VAR_7)) {
		    ++VAR_7;
		}

		/* COMMENT_6 */
                            
     

		VAR_8 = VAR_7;
		while (*VAR_8 && (strchr(""0123456789.ab"", *VAR_8)) && ((!strchr("".ab"", *VAR_8)
			    && (!strchr(""ab"", VAR_8[-1])) || --VAR_2))) {
		    ++VAR_8;
		}

		memmove(VAR_4, VAR_7, VAR_8 - VAR_7);
		VAR_4[VAR_8-VAR_7] = 0;
		VAR_5 = VAR_4;
		break;
	    }
	}
	fclose(VAR_6);
    }
    return VAR_5;
}",tcltk/tcl/4705dbdde2f32ff90420765cd93e7ac71d81a222/nmakehlp.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -38,7 +38,7 @@
 		    ++q;
 		}
 
-		memcpy(szBuffer, p, q - p);
+		memmove(szBuffer, p, q - p);
 		szBuffer[q-p] = 0;
 		szResult = szBuffer;
 		break;","{'deleted_lines': ['\t\tmemcpy(szBuffer, p, q - p);'], 'added_lines': ['\t\tmemmove(szBuffer, p, q - p);']}",True,"In Tcl 8.6.11, a format string vulnerability in nmakehlp.c might allow code execution via a crafted file. NOTE: multiple third parties dispute the significance of this finding",7.8,HIGH,2,test,2021-06-22T09:02:00Z,3
CVE-2021-35331,['CWE-134'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,tcltk/tcl,"Fix [bad6cc213d]: A format string vulnerability in Tcl nmakehelp.c allows code execution via a crated file.
Also change a memcpy() to a memmove(), because the range could be overlapping",4705dbdde2f32ff90420765cd93e7ac71d81a222,https://github.com/tcltk/tcl/commit/4705dbdde2f32ff90420765cd93e7ac71d81a222,win/nmakehlp.c,SubstituteFile,"static int
SubstituteFile(
const char *substitutions,
const char *filename)
{
size_t cbBuffer = 1024;
static char szBuffer[1024], szCopy[1024];
char *szResult = NULL;
list_item_t *substPtr = NULL;
FILE *fp, *sp;
fp = fopen(filename, ""rt"");
if (fp != NULL) {
sp = fopen(substitutions, ""rt"");
if (sp != NULL) {
while (fgets(szBuffer, cbBuffer, sp) != NULL) {
unsigned char *ks, *ke, *vs, *ve;
ks = (unsigned char*)szBuffer;
while (ks && *ks && isspace(*ks)) ++ks;
ke = ks;
while (ke && *ke && !isspace(*ke)) ++ke;
vs = ke;
while (vs && *vs && isspace(*vs)) ++vs;
ve = vs;
while (ve && *ve && !(*ve == '\r' || *ve == '\n')) ++ve;
*ke = 0, *ve = 0;
list_insert(&substPtr, (char*)ks, (char*)vs);
}
fclose(sp);
}
#ifndef NDEBUG
{
int n = 0;
list_item_t *p = NULL;
for (p = substPtr; p != NULL; p = p->nextPtr, ++n) {
fprintf(stderr, ""% 3d '%s' => '%s'\n"", n, p->key, p->value);
}
}
#endif
while (fgets(szBuffer, cbBuffer, fp) != NULL) {
list_item_t *p = NULL;
for (p = substPtr; p != NULL; p = p->nextPtr) {
char *m = strstr(szBuffer, p->key);
if (m) {
char *cp, *op, *sp;
cp = szCopy;
op = szBuffer;
while (op != m) *cp++ = *op++;
sp = p->value;
while (sp && *sp) *cp++ = *sp++;
op += strlen(p->key);
while (*op) *cp++ = *op++;
*cp = 0;
memcpy(szBuffer, szCopy, sizeof(szCopy));
}
}
printf(szBuffer);
}
list_free(&substPtr);
}
fclose(fp);
return 0;
}","static int
SubstituteFile(
const char *VAR_0,
const char *VAR_1)
{
size_t VAR_2 = 1024;
static char VAR_3[1024], VAR_4[1024];
char *VAR_5 = NULL;
list_item_t *VAR_6 = NULL;
FILE *VAR_7, *VAR_8;
VAR_7 = fopen(VAR_1, ""rt"");
if (VAR_7 != NULL) {
VAR_8 = fopen(VAR_0, ""rt"");
if (VAR_8 != NULL) {
while (fgets(VAR_3, VAR_2, VAR_8) != NULL) {
unsigned char *VAR_9, *VAR_10, *VAR_11, *VAR_12;
VAR_9 = (unsigned char*)VAR_3;
while (VAR_9 && *VAR_9 && isspace(*VAR_9)) ++VAR_9;
VAR_10 = VAR_9;
while (VAR_10 && *VAR_10 && !isspace(*VAR_10)) ++VAR_10;
VAR_11 = VAR_10;
while (VAR_11 && *VAR_11 && isspace(*VAR_11)) ++VAR_11;
VAR_12 = VAR_11;
while (VAR_12 && *VAR_12 && !(*VAR_12 == '\r' || *VAR_12 == '\n')) ++VAR_12;
*VAR_10 = 0, *VAR_12 = 0;
list_insert(&VAR_6, (char*)VAR_9, (char*)VAR_11);
}
fclose(VAR_8);
}
#ifndef VAR_13
{
int VAR_14 = 0;
list_item_t *VAR_15 = NULL;
for (VAR_15 = VAR_6; VAR_15 != NULL; VAR_15 = VAR_15->nextPtr, ++VAR_14) {
fprintf(VAR_16, ""% 3d '%s' => '%s'\n"", VAR_14, VAR_15->key, VAR_15->value);
}
}
#endif
while (fgets(VAR_3, VAR_2, VAR_7) != NULL) {
list_item_t *VAR_15 = NULL;
for (VAR_15 = VAR_6; VAR_15 != NULL; VAR_15 = VAR_15->nextPtr) {
char *VAR_17 = strstr(VAR_3, VAR_15->key);
if (VAR_17) {
char *VAR_18, *VAR_19, *VAR_8;
VAR_18 = VAR_4;
VAR_19 = VAR_3;
while (VAR_19 != VAR_17) *VAR_18++ = *VAR_19++;
VAR_8 = VAR_15->value;
while (VAR_8 && *VAR_8) *VAR_18++ = *VAR_8++;
VAR_19 += strlen(VAR_15->key);
while (*VAR_19) *VAR_18++ = *VAR_19++;
*VAR_18 = 0;
memcpy(VAR_3, VAR_4, sizeof(VAR_4));
}
}
printf(VAR_3);
}
list_free(&VAR_6);
}
fclose(VAR_7);
return 0;
}",tcltk/tcl/4705dbdde2f32ff90420765cd93e7ac71d81a222/nmakehlp.c/vul/before/0.json,"static int
SubstituteFile(
    const char *substitutions,
    const char *filename)
{
    size_t cbBuffer = 1024;
    static char szBuffer[1024], szCopy[1024];
    char *szResult = NULL;
    list_item_t *substPtr = NULL;
    FILE *fp, *sp;

    fp = fopen(filename, ""rt"");
    if (fp != NULL) {

	/*
	 * Build a list of substutitions from the first filename
	 */

	sp = fopen(substitutions, ""rt"");
	if (sp != NULL) {
	    while (fgets(szBuffer, cbBuffer, sp) != NULL) {
		unsigned char *ks, *ke, *vs, *ve;
		ks = (unsigned char*)szBuffer;
		while (ks && *ks && isspace(*ks)) ++ks;
		ke = ks;
		while (ke && *ke && !isspace(*ke)) ++ke;
		vs = ke;
		while (vs && *vs && isspace(*vs)) ++vs;
		ve = vs;
		while (ve && *ve && !(*ve == '\r' || *ve == '\n')) ++ve;
		*ke = 0, *ve = 0;
		list_insert(&substPtr, (char*)ks, (char*)vs);
	    }
	    fclose(sp);
	}

	/* debug: dump the list */
#ifndef NDEBUG
	{
	    int n = 0;
	    list_item_t *p = NULL;
	    for (p = substPtr; p != NULL; p = p->nextPtr, ++n) {
		fprintf(stderr, ""% 3d '%s' => '%s'\n"", n, p->key, p->value);
	    }
	}
#endif

	/*
	 * Run the substitutions over each line of the input
	 */

	while (fgets(szBuffer, cbBuffer, fp) != NULL) {
	    list_item_t *p = NULL;
	    for (p = substPtr; p != NULL; p = p->nextPtr) {
		char *m = strstr(szBuffer, p->key);
		if (m) {
		    char *cp, *op, *sp;
		    cp = szCopy;
		    op = szBuffer;
		    while (op != m) *cp++ = *op++;
		    sp = p->value;
		    while (sp && *sp) *cp++ = *sp++;
		    op += strlen(p->key);
		    while (*op) *cp++ = *op++;
		    *cp = 0;
		    memcpy(szBuffer, szCopy, sizeof(szCopy));
		}
	    }
	    printf(""%s"", szBuffer);
	}

	list_free(&substPtr);
    }
    fclose(fp);
    return 0;
}","static int
SubstituteFile(
    const char *VAR_0,
    const char *VAR_1)
{
    size_t VAR_2 = 1024;
    static char VAR_3[1024], VAR_4[1024];
    char *VAR_5 = NULL;
    list_item_t *VAR_6 = NULL;
    FILE *VAR_7, *VAR_8;

    VAR_7 = fopen(VAR_1, ""rt"");
    if (VAR_7 != NULL) {

	/* COMMENT_0 */
                                                         
    

	VAR_8 = fopen(VAR_0, ""rt"");
	if (VAR_8 != NULL) {
	    while (fgets(VAR_3, VAR_2, VAR_8) != NULL) {
		unsigned char *VAR_9, *VAR_10, *VAR_11, *VAR_12;
		VAR_9 = (unsigned char*)VAR_3;
		while (VAR_9 && *VAR_9 && isspace(*VAR_9)) ++VAR_9;
		VAR_10 = VAR_9;
		while (VAR_10 && *VAR_10 && !isspace(*VAR_10)) ++VAR_10;
		VAR_11 = VAR_10;
		while (VAR_11 && *VAR_11 && isspace(*VAR_11)) ++VAR_11;
		VAR_12 = VAR_11;
		while (VAR_12 && *VAR_12 && !(*VAR_12 == '\r' || *VAR_12 == '\n')) ++VAR_12;
		*VAR_10 = 0, *VAR_12 = 0;
		list_insert(&VAR_6, (char*)VAR_9, (char*)VAR_11);
	    }
	    fclose(VAR_8);
	}

	/* COMMENT_3 */
#ifndef VAR_13
	{
	    int VAR_14 = 0;
	    list_item_t *VAR_15 = NULL;
	    for (VAR_15 = VAR_6; VAR_15 != NULL; VAR_15 = VAR_15->nextPtr, ++VAR_14) {
		fprintf(VAR_16, ""% 3d '%s' => '%s'\n"", VAR_14, VAR_15->key, VAR_15->value);
	    }
	}
#endif

	/* COMMENT_4 */
                                                     
    

	while (fgets(VAR_3, VAR_2, VAR_7) != NULL) {
	    list_item_t *VAR_15 = NULL;
	    for (VAR_15 = VAR_6; VAR_15 != NULL; VAR_15 = VAR_15->nextPtr) {
		char *VAR_17 = strstr(VAR_3, VAR_15->key);
		if (VAR_17) {
		    char *VAR_18, *VAR_19, *VAR_8;
		    VAR_18 = VAR_4;
		    VAR_19 = VAR_3;
		    while (VAR_19 != VAR_17) *VAR_18++ = *VAR_19++;
		    VAR_8 = VAR_15->value;
		    while (VAR_8 && *VAR_8) *VAR_18++ = *VAR_8++;
		    VAR_19 += strlen(VAR_15->key);
		    while (*VAR_19) *VAR_18++ = *VAR_19++;
		    *VAR_18 = 0;
		    memcpy(VAR_3, VAR_4, sizeof(VAR_4));
		}
	    }
	    printf(""%s"", VAR_3);
	}

	list_free(&VAR_6);
    }
    fclose(VAR_7);
    return 0;
}",tcltk/tcl/4705dbdde2f32ff90420765cd93e7ac71d81a222/nmakehlp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -66,7 +66,7 @@
 		    memcpy(szBuffer, szCopy, sizeof(szCopy));
 		}
 	    }
-	    printf(szBuffer);
+	    printf(""%s"", szBuffer);
 	}
 
 	list_free(&substPtr);","{'deleted_lines': ['\t    printf(szBuffer);'], 'added_lines': ['\t    printf(""%s"", szBuffer);']}",True,"In Tcl 8.6.11, a format string vulnerability in nmakehlp.c might allow code execution via a crafted file. NOTE: multiple third parties dispute the significance of this finding",7.8,HIGH,2,test,2021-06-22T09:02:00Z,3
CVE-2021-3658,['CWE-863'],AV:A/AC:L/Au:N/C:P/I:N/A:N,0,bluez,"adapter: Fix storing discoverable setting

discoverable setting shall only be store when changed via Discoverable
property and not when discovery client set it as that be considered
temporary just for the lifetime of the discovery.",b497b5942a8beb8f89ca1c359c54ad67ec843055,https://github.com/bluez/bluez/commit/b497b5942a8beb8f89ca1c359c54ad67ec843055,src/adapter.c,update_discovery_filter,"static int update_discovery_filter(struct btd_adapter *adapter)
{
struct mgmt_cp_start_service_discovery *sd_cp;
GSList *l;
DBG("""");
if (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) {
btd_error(adapter->dev_id,
""discovery_filter_to_mgmt_cp returned error"");
return -ENOMEM;
}
for (l = adapter->discovery_list; l; l = g_slist_next(l)) {
struct discovery_client *client = l->data;
if (!client->discovery_filter)
continue;
if (client->discovery_filter->discoverable)
break;
}
set_discovery_discoverable(adapter, l ? true : false);
if (filters_equal(adapter->current_discovery_filter, sd_cp) &&
adapter->discovering != 0) {
DBG(""filters were equal, deciding to not restart the scan."");
g_free(sd_cp);
return 0;
}
g_free(adapter->current_discovery_filter);
adapter->current_discovery_filter = sd_cp;
trigger_start_discovery(adapter, 0);
return -EINPROGRESS;
}","static int update_discovery_filter(struct btd_adapter *VAR_0)
{
struct mgmt_cp_start_service_discovery *VAR_1;
GSList *VAR_2;
DBG("""");
if (discovery_filter_to_mgmt_cp(VAR_0, &VAR_1)) {
btd_error(VAR_0->dev_id,
""discovery_filter_to_mgmt_cp returned error"");
return -VAR_3;
}
for (VAR_2 = VAR_0->discovery_list; VAR_2; VAR_2 = g_slist_next(VAR_2)) {
struct discovery_client *VAR_4 = VAR_2->data;
if (!VAR_4->discovery_filter)
continue;
if (VAR_4->discovery_filter->discoverable)
break;
}
set_discovery_discoverable(VAR_0, VAR_2 ? true : false);
if (filters_equal(VAR_0->current_discovery_filter, VAR_1) &&
VAR_0->discovering != 0) {
DBG(""filters were equal, deciding to not restart the scan."");
g_free(VAR_1);
return 0;
}
g_free(VAR_0->current_discovery_filter);
VAR_0->current_discovery_filter = VAR_1;
trigger_start_discovery(VAR_0, 0);
return -VAR_5;
}",bluez/b497b5942a8beb8f89ca1c359c54ad67ec843055/adapter.c/vul/before/3.json,"static int update_discovery_filter(struct btd_adapter *adapter)
{
	struct mgmt_cp_start_service_discovery *sd_cp;

	DBG("""");

	if (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) {
		btd_error(adapter->dev_id,
				""discovery_filter_to_mgmt_cp returned error"");
		return -ENOMEM;
	}

	/* Only attempt to overwrite current discoverable setting when not
	 * discoverable.
	 */
	if (!(adapter->current_settings & MGMT_OP_SET_DISCOVERABLE)) {
		GSList *l;

		for (l = adapter->discovery_list; l; l = g_slist_next(l)) {
			struct discovery_client *client = l->data;

			if (!client->discovery_filter)
				continue;

			if (client->discovery_filter->discoverable) {
				set_discovery_discoverable(adapter, true);
				break;
			}
		}
	}

	/*
	 * If filters are equal, then don't update scan, except for when
	 * starting discovery.
	 */
	if (filters_equal(adapter->current_discovery_filter, sd_cp) &&
	    adapter->discovering != 0) {
		DBG(""filters were equal, deciding to not restart the scan."");
		g_free(sd_cp);
		return 0;
	}

	g_free(adapter->current_discovery_filter);
	adapter->current_discovery_filter = sd_cp;

	trigger_start_discovery(adapter, 0);

	return -EINPROGRESS;
}","static int update_discovery_filter(struct btd_adapter *VAR_0)
{
	struct mgmt_cp_start_service_discovery *VAR_1;

	DBG("""");

	if (discovery_filter_to_mgmt_cp(VAR_0, &VAR_1)) {
		btd_error(VAR_0->dev_id,
				""discovery_filter_to_mgmt_cp returned error"");
		return -VAR_2;
	}

	/* COMMENT_0 */
                 
    
	if (!(VAR_0->current_settings & VAR_3)) {
		GSList *VAR_4;

		for (VAR_4 = VAR_0->discovery_list; VAR_4; VAR_4 = g_slist_next(VAR_4)) {
			struct discovery_client *VAR_5 = VAR_4->data;

			if (!VAR_5->discovery_filter)
				continue;

			if (VAR_5->discovery_filter->discoverable) {
				set_discovery_discoverable(VAR_0, true);
				break;
			}
		}
	}

	/* COMMENT_3 */
                                                                 
                       
    
	if (filters_equal(VAR_0->current_discovery_filter, VAR_1) &&
	    VAR_0->discovering != 0) {
		DBG(""filters were equal, deciding to not restart the scan."");
		g_free(VAR_1);
		return 0;
	}

	g_free(VAR_0->current_discovery_filter);
	VAR_0->current_discovery_filter = VAR_1;

	trigger_start_discovery(VAR_0, 0);

	return -VAR_6;
}",bluez/b497b5942a8beb8f89ca1c359c54ad67ec843055/adapter.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -1,8 +1,6 @@
 static int update_discovery_filter(struct btd_adapter *adapter)
 {
 	struct mgmt_cp_start_service_discovery *sd_cp;
-	GSList *l;
-
 
 	DBG("""");
 
@@ -12,17 +10,24 @@
 		return -ENOMEM;
 	}
 
-	for (l = adapter->discovery_list; l; l = g_slist_next(l)) {
-		struct discovery_client *client = l->data;
+	/* Only attempt to overwrite current discoverable setting when not
+	 * discoverable.
+	 */
+	if (!(adapter->current_settings & MGMT_OP_SET_DISCOVERABLE)) {
+		GSList *l;
 
-		if (!client->discovery_filter)
-			continue;
+		for (l = adapter->discovery_list; l; l = g_slist_next(l)) {
+			struct discovery_client *client = l->data;
 
-		if (client->discovery_filter->discoverable)
-			break;
+			if (!client->discovery_filter)
+				continue;
+
+			if (client->discovery_filter->discoverable) {
+				set_discovery_discoverable(adapter, true);
+				break;
+			}
+		}
 	}
-
-	set_discovery_discoverable(adapter, l ? true : false);
 
 	/*
 	 * If filters are equal, then don't update scan, except for when","{'deleted_lines': ['\tGSList *l;', '', '\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {', '\t\tstruct discovery_client *client = l->data;', '\t\tif (!client->discovery_filter)', '\t\t\tcontinue;', '\t\tif (client->discovery_filter->discoverable)', '\t\t\tbreak;', '', '\tset_discovery_discoverable(adapter, l ? true : false);'], 'added_lines': ['\t/* Only attempt to overwrite current discoverable setting when not', '\t * discoverable.', '\t */', '\tif (!(adapter->current_settings & MGMT_OP_SET_DISCOVERABLE)) {', '\t\tGSList *l;', '\t\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {', '\t\t\tstruct discovery_client *client = l->data;', '\t\t\tif (!client->discovery_filter)', '\t\t\t\tcontinue;', '', '\t\t\tif (client->discovery_filter->discoverable) {', '\t\t\t\tset_discovery_discoverable(adapter, true);', '\t\t\t\tbreak;', '\t\t\t}', '\t\t}']}",True,"bluetoothd from bluez incorrectly saves adapters' Discoverable status when a device is powered down, and restores it when powered up. If a device is powered down while discoverable, it will be discoverable when powered on again. This could lead to inadvertent exposure of the bluetooth stack to physically nearby attackers.",6.5,MEDIUM,1,test,2021-06-24T23:32:04Z,3
CVE-2021-3658,['CWE-863'],AV:A/AC:L/Au:N/C:P/I:N/A:N,0,bluez,"adapter: Fix storing discoverable setting

discoverable setting shall only be store when changed via Discoverable
property and not when discovery client set it as that be considered
temporary just for the lifetime of the discovery.",b497b5942a8beb8f89ca1c359c54ad67ec843055,https://github.com/bluez/bluez/commit/b497b5942a8beb8f89ca1c359c54ad67ec843055,src/adapter.c,adapter_stop,"static void adapter_stop(struct btd_adapter *adapter)
{
reply_pending_requests(adapter);
cancel_passive_scanning(adapter);
remove_discovery_list(adapter);
discovery_cleanup(adapter, 0);
adapter->filtered_discovery = false;
adapter->no_scan_restart_delay = false;
g_free(adapter->current_discovery_filter);
adapter->current_discovery_filter = NULL;
adapter->discovering = false;
while (adapter->connections) {
struct btd_device *device = adapter->connections->data;
uint8_t addr_type = btd_device_get_bdaddr_type(device);
adapter_remove_connection(adapter, device, BDADDR_BREDR);
if (addr_type != BDADDR_BREDR)
adapter_remove_connection(adapter, device, addr_type);
}
g_dbus_emit_property_changed(dbus_conn, adapter->path,
ADAPTER_INTERFACE, ""Discovering"");
if (adapter->dev_class) {
adapter->dev_class = 0;
g_dbus_emit_property_changed(dbus_conn, adapter->path,
ADAPTER_INTERFACE, ""Class"");
}
g_dbus_emit_property_changed(dbus_conn, adapter->path,
ADAPTER_INTERFACE, ""Powered"");
DBG(""adapter %s has been disabled"", adapter->path);
}","static void adapter_stop(struct btd_adapter *VAR_0)
{
reply_pending_requests(VAR_0);
cancel_passive_scanning(VAR_0);
remove_discovery_list(VAR_0);
discovery_cleanup(VAR_0, 0);
VAR_0->filtered_discovery = false;
VAR_0->no_scan_restart_delay = false;
g_free(VAR_0->current_discovery_filter);
VAR_0->current_discovery_filter = NULL;
VAR_0->discovering = false;
while (VAR_0->connections) {
struct btd_device *VAR_1 = VAR_0->connections->data;
uint8_t VAR_2 = btd_device_get_bdaddr_type(VAR_1);
adapter_remove_connection(VAR_0, VAR_1, VAR_3);
if (VAR_2 != VAR_3)
adapter_remove_connection(VAR_0, VAR_1, VAR_2);
}
g_dbus_emit_property_changed(VAR_4, VAR_0->path,
VAR_5, ""Discovering"");
if (VAR_0->dev_class) {
VAR_0->dev_class = 0;
g_dbus_emit_property_changed(VAR_4, VAR_0->path,
VAR_5, ""Class"");
}
g_dbus_emit_property_changed(VAR_4, VAR_0->path,
VAR_5, ""Powered"");
DBG(""adapter %s has been disabled"", VAR_0->path);
}",bluez/b497b5942a8beb8f89ca1c359c54ad67ec843055/adapter.c/vul/before/2.json,"static void adapter_stop(struct btd_adapter *adapter)
{
	/* check pending requests */
	reply_pending_requests(adapter);

	cancel_passive_scanning(adapter);

	remove_discovery_list(adapter);

	discovery_cleanup(adapter, 0);

	adapter->filtered_discovery = false;
	adapter->no_scan_restart_delay = false;
	g_free(adapter->current_discovery_filter);
	adapter->current_discovery_filter = NULL;

	set_discovery_discoverable(adapter, false);
	adapter->discovering = false;

	while (adapter->connections) {
		struct btd_device *device = adapter->connections->data;
		uint8_t addr_type = btd_device_get_bdaddr_type(device);

		adapter_remove_connection(adapter, device, BDADDR_BREDR);
		if (addr_type != BDADDR_BREDR)
			adapter_remove_connection(adapter, device, addr_type);
	}

	g_dbus_emit_property_changed(dbus_conn, adapter->path,
					ADAPTER_INTERFACE, ""Discovering"");

	if (adapter->dev_class) {
		/* the kernel should reset the class of device when powering
		 * down, but it does not. So force it here ... */
		adapter->dev_class = 0;
		g_dbus_emit_property_changed(dbus_conn, adapter->path,
						ADAPTER_INTERFACE, ""Class"");
	}

	g_dbus_emit_property_changed(dbus_conn, adapter->path,
						ADAPTER_INTERFACE, ""Powered"");

	DBG(""adapter %s has been disabled"", adapter->path);
}","static void adapter_stop(struct btd_adapter *VAR_0)
{
	/* COMMENT_0 */
	reply_pending_requests(VAR_0);

	cancel_passive_scanning(VAR_0);

	remove_discovery_list(VAR_0);

	discovery_cleanup(VAR_0, 0);

	VAR_0->filtered_discovery = false;
	VAR_0->no_scan_restart_delay = false;
	g_free(VAR_0->current_discovery_filter);
	VAR_0->current_discovery_filter = NULL;

	set_discovery_discoverable(VAR_0, false);
	VAR_0->discovering = false;

	while (VAR_0->connections) {
		struct btd_device *VAR_1 = VAR_0->connections->data;
		uint8_t VAR_2 = btd_device_get_bdaddr_type(VAR_1);

		adapter_remove_connection(VAR_0, VAR_1, VAR_3);
		if (VAR_2 != VAR_3)
			adapter_remove_connection(VAR_0, VAR_1, VAR_2);
	}

	g_dbus_emit_property_changed(VAR_4, VAR_0->path,
					VAR_5, ""Discovering"");

	if (VAR_0->dev_class) {
		/* COMMENT_1 */
                                                   
		VAR_0->dev_class = 0;
		g_dbus_emit_property_changed(VAR_4, VAR_0->path,
						VAR_5, ""Class"");
	}

	g_dbus_emit_property_changed(VAR_4, VAR_0->path,
						VAR_5, ""Powered"");

	DBG(""adapter %s has been disabled"", VAR_0->path);
}",bluez/b497b5942a8beb8f89ca1c359c54ad67ec843055/adapter.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -14,6 +14,7 @@
 	g_free(adapter->current_discovery_filter);
 	adapter->current_discovery_filter = NULL;
 
+	set_discovery_discoverable(adapter, false);
 	adapter->discovering = false;
 
 	while (adapter->connections) {","{'deleted_lines': [], 'added_lines': ['\tset_discovery_discoverable(adapter, false);']}",True,"bluetoothd from bluez incorrectly saves adapters' Discoverable status when a device is powered down, and restores it when powered up. If a device is powered down while discoverable, it will be discoverable when powered on again. This could lead to inadvertent exposure of the bluetooth stack to physically nearby attackers.",6.5,MEDIUM,1,test,2021-06-24T23:32:04Z,3
CVE-2021-3658,['CWE-863'],AV:A/AC:L/Au:N/C:P/I:N/A:N,0,bluez,"adapter: Fix storing discoverable setting

discoverable setting shall only be store when changed via Discoverable
property and not when discovery client set it as that be considered
temporary just for the lifetime of the discovery.",b497b5942a8beb8f89ca1c359c54ad67ec843055,https://github.com/bluez/bluez/commit/b497b5942a8beb8f89ca1c359c54ad67ec843055,src/adapter.c,discovery_stop,"static int discovery_stop(struct discovery_client *client)
{
struct btd_adapter *adapter = client->adapter;
struct mgmt_cp_stop_discovery cp;
if (g_slist_next(adapter->discovery_list)) {
discovery_remove(client);
update_discovery_filter(adapter);
return 0;
}
if (adapter->discovery_discoverable)
set_discovery_discoverable(adapter, false);
if (adapter->discovery_enable == 0x00) {
discovery_remove(client);
adapter->discovering = false;
g_dbus_emit_property_changed(dbus_conn, adapter->path,
ADAPTER_INTERFACE, ""Discovering"");
trigger_passive_scanning(adapter);
return 0;
}
cp.type = adapter->discovery_type;
adapter->client = client;
mgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,
adapter->dev_id, sizeof(cp), &cp,
stop_discovery_complete, adapter, NULL);
return -EINPROGRESS;
}","static int discovery_stop(struct discovery_client *VAR_0)
{
struct btd_adapter *VAR_1 = VAR_0->adapter;
struct mgmt_cp_stop_discovery VAR_2;
if (g_slist_next(VAR_1->discovery_list)) {
discovery_remove(VAR_0);
update_discovery_filter(VAR_1);
return 0;
}
if (VAR_1->discovery_discoverable)
set_discovery_discoverable(VAR_1, false);
if (VAR_1->discovery_enable == 0x00) {
discovery_remove(VAR_0);
VAR_1->discovering = false;
g_dbus_emit_property_changed(VAR_3, VAR_1->path,
VAR_4, ""Discovering"");
trigger_passive_scanning(VAR_1);
return 0;
}
VAR_2.type = VAR_1->discovery_type;
VAR_1->client = VAR_0;
mgmt_send(VAR_1->mgmt, VAR_5,
VAR_1->dev_id, sizeof(VAR_2), &VAR_2,
VAR_6, VAR_1, NULL);
return -VAR_7;
}",bluez/b497b5942a8beb8f89ca1c359c54ad67ec843055/adapter.c/vul/before/1.json,"static int discovery_stop(struct discovery_client *client)
{
	struct btd_adapter *adapter = client->adapter;
	struct mgmt_cp_stop_discovery cp;

	/* Check if there are more client discovering */
	if (g_slist_next(adapter->discovery_list)) {
		discovery_remove(client);
		update_discovery_filter(adapter);
		return 0;
	}

	set_discovery_discoverable(adapter, false);

	/*
	 * In the idle phase of a discovery, there is no need to stop it
	 * and so it is enough to send out the signal and just return.
	 */
	if (adapter->discovery_enable == 0x00) {
		discovery_remove(client);
		adapter->discovering = false;
		g_dbus_emit_property_changed(dbus_conn, adapter->path,
					ADAPTER_INTERFACE, ""Discovering"");

		trigger_passive_scanning(adapter);

		return 0;
	}

	cp.type = adapter->discovery_type;
	adapter->client = client;

	mgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,
			adapter->dev_id, sizeof(cp), &cp,
			stop_discovery_complete, adapter, NULL);

	return -EINPROGRESS;
}","static int discovery_stop(struct discovery_client *VAR_0)
{
	struct btd_adapter *VAR_1 = VAR_0->adapter;
	struct mgmt_cp_stop_discovery VAR_2;

	/* COMMENT_0 */
	if (g_slist_next(VAR_1->discovery_list)) {
		discovery_remove(VAR_0);
		update_discovery_filter(VAR_1);
		return 0;
	}

	set_discovery_discoverable(VAR_1, false);

	/* COMMENT_1 */
                                                                 
                                                               
    
	if (VAR_1->discovery_enable == 0x00) {
		discovery_remove(VAR_0);
		VAR_1->discovering = false;
		g_dbus_emit_property_changed(VAR_3, VAR_1->path,
					VAR_4, ""Discovering"");

		trigger_passive_scanning(VAR_1);

		return 0;
	}

	VAR_2.type = VAR_1->discovery_type;
	VAR_1->client = VAR_0;

	mgmt_send(VAR_1->mgmt, VAR_5,
			VAR_1->dev_id, sizeof(VAR_2), &VAR_2,
			VAR_6, VAR_1, NULL);

	return -VAR_7;
}",bluez/b497b5942a8beb8f89ca1c359c54ad67ec843055/adapter.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -10,8 +10,7 @@
 		return 0;
 	}
 
-	if (adapter->discovery_discoverable)
-		set_discovery_discoverable(adapter, false);
+	set_discovery_discoverable(adapter, false);
 
 	/*
 	 * In the idle phase of a discovery, there is no need to stop it","{'deleted_lines': ['\tif (adapter->discovery_discoverable)', '\t\tset_discovery_discoverable(adapter, false);'], 'added_lines': ['\tset_discovery_discoverable(adapter, false);']}",True,"bluetoothd from bluez incorrectly saves adapters' Discoverable status when a device is powered down, and restores it when powered up. If a device is powered down while discoverable, it will be discoverable when powered on again. This could lead to inadvertent exposure of the bluetooth stack to physically nearby attackers.",6.5,MEDIUM,1,test,2021-06-24T23:32:04Z,3
CVE-2021-3658,['CWE-863'],AV:A/AC:L/Au:N/C:P/I:N/A:N,0,bluez,"adapter: Fix storing discoverable setting

discoverable setting shall only be store when changed via Discoverable
property and not when discovery client set it as that be considered
temporary just for the lifetime of the discovery.",b497b5942a8beb8f89ca1c359c54ad67ec843055,https://github.com/bluez/bluez/commit/b497b5942a8beb8f89ca1c359c54ad67ec843055,src/adapter.c,settings_changed,"static void settings_changed(struct btd_adapter *adapter, uint32_t settings)
{
uint32_t changed_mask;
changed_mask = adapter->current_settings ^ settings;
adapter->current_settings = settings;
adapter->pending_settings &= ~changed_mask;
DBG(""Changed settings: 0x%08x"", changed_mask);
DBG(""Pending settings: 0x%08x"", adapter->pending_settings);
if (changed_mask & MGMT_SETTING_POWERED) {
g_dbus_emit_property_changed(dbus_conn, adapter->path,
ADAPTER_INTERFACE, ""Powered"");
if (adapter->current_settings & MGMT_SETTING_POWERED) {
adapter_start(adapter);
} else {
adapter_stop(adapter);
if (powering_down) {
adapter_remaining--;
if (!adapter_remaining)
btd_exit();
}
}
}
if ((changed_mask & MGMT_SETTING_LE) &&
btd_adapter_get_powered(adapter) &&
(adapter->current_settings & MGMT_SETTING_LE))
trigger_passive_scanning(adapter);
if (changed_mask & MGMT_SETTING_DISCOVERABLE) {
g_dbus_emit_property_changed(dbus_conn, adapter->path,
ADAPTER_INTERFACE, ""Discoverable"");
store_adapter_info(adapter);
btd_adv_manager_refresh(adapter->adv_manager);
}
if (changed_mask & MGMT_SETTING_BONDABLE) {
g_dbus_emit_property_changed(dbus_conn, adapter->path,
ADAPTER_INTERFACE, ""Pairable"");
trigger_pairable_timeout(adapter);
}
}","static void settings_changed(struct btd_adapter *VAR_0, uint32_t VAR_1)
{
uint32_t VAR_2;
VAR_2 = VAR_0->current_settings ^ VAR_1;
VAR_0->current_settings = VAR_1;
VAR_0->pending_settings &= ~VAR_2;
DBG(""Changed settings: 0x%08x"", VAR_2);
DBG(""Pending settings: 0x%08x"", VAR_0->pending_settings);
if (VAR_2 & VAR_3) {
g_dbus_emit_property_changed(VAR_4, VAR_0->path,
VAR_5, ""Powered"");
if (VAR_0->current_settings & VAR_3) {
adapter_start(VAR_0);
} else {
adapter_stop(VAR_0);
if (VAR_6) {
VAR_7--;
if (!VAR_7)
btd_exit();
}
}
}
if ((VAR_2 & VAR_8) &&
btd_adapter_get_powered(VAR_0) &&
(VAR_0->current_settings & VAR_8))
trigger_passive_scanning(VAR_0);
if (VAR_2 & VAR_9) {
g_dbus_emit_property_changed(VAR_4, VAR_0->path,
VAR_5, ""Discoverable"");
store_adapter_info(VAR_0);
btd_adv_manager_refresh(VAR_0->adv_manager);
}
if (VAR_2 & VAR_10) {
g_dbus_emit_property_changed(VAR_4, VAR_0->path,
VAR_5, ""Pairable"");
trigger_pairable_timeout(VAR_0);
}
}",bluez/b497b5942a8beb8f89ca1c359c54ad67ec843055/adapter.c/vul/before/0.json,"static void settings_changed(struct btd_adapter *adapter, uint32_t settings)
{
	uint32_t changed_mask;

	changed_mask = adapter->current_settings ^ settings;

	adapter->current_settings = settings;
	adapter->pending_settings &= ~changed_mask;

	DBG(""Changed settings: 0x%08x"", changed_mask);
	DBG(""Pending settings: 0x%08x"", adapter->pending_settings);

	if (changed_mask & MGMT_SETTING_POWERED) {
	        g_dbus_emit_property_changed(dbus_conn, adapter->path,
					ADAPTER_INTERFACE, ""Powered"");

		if (adapter->current_settings & MGMT_SETTING_POWERED) {
			adapter_start(adapter);
		} else {
			adapter_stop(adapter);

			if (powering_down) {
				adapter_remaining--;

				if (!adapter_remaining)
					btd_exit();
			}
		}
	}

	if ((changed_mask & MGMT_SETTING_LE) &&
				btd_adapter_get_powered(adapter) &&
				(adapter->current_settings & MGMT_SETTING_LE))
		trigger_passive_scanning(adapter);

	if (changed_mask & MGMT_SETTING_DISCOVERABLE) {
		g_dbus_emit_property_changed(dbus_conn, adapter->path,
					ADAPTER_INTERFACE, ""Discoverable"");
		/* Only persist discoverable setting if it was not set
		 * temporarily by discovery.
		 */
		if (!adapter->discovery_discoverable)
			store_adapter_info(adapter);
		btd_adv_manager_refresh(adapter->adv_manager);
	}

	if (changed_mask & MGMT_SETTING_BONDABLE) {
		g_dbus_emit_property_changed(dbus_conn, adapter->path,
					ADAPTER_INTERFACE, ""Pairable"");

		trigger_pairable_timeout(adapter);
	}
}","static void settings_changed(struct btd_adapter *VAR_0, uint32_t VAR_1)
{
	uint32_t VAR_2;

	VAR_2 = VAR_0->current_settings ^ VAR_1;

	VAR_0->current_settings = VAR_1;
	VAR_0->pending_settings &= ~VAR_2;

	DBG(""Changed settings: 0x%08x"", VAR_2);
	DBG(""Pending settings: 0x%08x"", VAR_0->pending_settings);

	if (VAR_2 & VAR_3) {
	        g_dbus_emit_property_changed(VAR_4, VAR_0->path,
					VAR_5, ""Powered"");

		if (VAR_0->current_settings & VAR_3) {
			adapter_start(VAR_0);
		} else {
			adapter_stop(VAR_0);

			if (VAR_6) {
				VAR_7--;

				if (!VAR_7)
					btd_exit();
			}
		}
	}

	if ((VAR_2 & VAR_8) &&
				btd_adapter_get_powered(VAR_0) &&
				(VAR_0->current_settings & VAR_8))
		trigger_passive_scanning(VAR_0);

	if (VAR_2 & VAR_9) {
		g_dbus_emit_property_changed(VAR_4, VAR_0->path,
					VAR_5, ""Discoverable"");
		/* COMMENT_0 */
                              
     
		if (!VAR_0->discovery_discoverable)
			store_adapter_info(VAR_0);
		btd_adv_manager_refresh(VAR_0->adv_manager);
	}

	if (VAR_2 & VAR_10) {
		g_dbus_emit_property_changed(VAR_4, VAR_0->path,
					VAR_5, ""Pairable"");

		trigger_pairable_timeout(VAR_0);
	}
}",bluez/b497b5942a8beb8f89ca1c359c54ad67ec843055/adapter.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -36,7 +36,11 @@
 	if (changed_mask & MGMT_SETTING_DISCOVERABLE) {
 		g_dbus_emit_property_changed(dbus_conn, adapter->path,
 					ADAPTER_INTERFACE, ""Discoverable"");
-		store_adapter_info(adapter);
+		/* Only persist discoverable setting if it was not set
+		 * temporarily by discovery.
+		 */
+		if (!adapter->discovery_discoverable)
+			store_adapter_info(adapter);
 		btd_adv_manager_refresh(adapter->adv_manager);
 	}
 ","{'deleted_lines': ['\t\tstore_adapter_info(adapter);'], 'added_lines': ['\t\t/* Only persist discoverable setting if it was not set', '\t\t * temporarily by discovery.', '\t\t */', '\t\tif (!adapter->discovery_discoverable)', '\t\t\tstore_adapter_info(adapter);']}",True,"bluetoothd from bluez incorrectly saves adapters' Discoverable status when a device is powered down, and restores it when powered up. If a device is powered down while discoverable, it will be discoverable when powered on again. This could lead to inadvertent exposure of the bluetooth stack to physically nearby attackers.",6.5,MEDIUM,1,test,2021-06-24T23:32:04Z,3
CVE-2021-37680,['CWE-369'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,tensorflow,"Prevent division by 0 in `fully_connected.cc`

PiperOrigin-RevId: 385137282
Change-Id: If201e69b6e0048f0be001330b4b977e2b46db2cb",718721986aa137691ee23f03638867151f74935f,https://github.com/tensorflow/tensorflow/commit/718721986aa137691ee23f03638867151f74935f,tensorflow/lite/kernels/fully_connected.cc,PrepareImpl,"TfLiteStatus PrepareImpl(TfLiteContext* context, TfLiteNode* node) {
auto* params =
reinterpret_cast<TfLiteFullyConnectedParams*>(node->builtin_data);
OpData* data = reinterpret_cast<OpData*>(node->user_data);
TF_LITE_ENSURE(context, node->inputs->size == 2 || node->inputs->size == 3);
const int expected_outputs_count =
params->weights_format == kTfLiteFullyConnectedWeightsFormatDefault ? 1
: 2;
TF_LITE_ENSURE_EQ(context, node->outputs->size, expected_outputs_count);
const TfLiteTensor* input;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
const TfLiteTensor* filter;
TF_LITE_ENSURE_OK(context,
GetInputSafe(context, node, kWeightsTensor, &filter));
const TfLiteTensor* bias =
(node->inputs->size == 3)
? GetOptionalInputTensor(context, node, kBiasTensor)
: nullptr;
TfLiteTensor* output;
TF_LITE_ENSURE_OK(context,
GetOutputSafe(context, node, kOutputTensor, &output));
TF_LITE_ENSURE_STATUS(
CheckTypes(context, input, filter, bias, output, params));
int input_size = 1;
for (int i = 0; i < input->dims->size; i++) {
input_size *= input->dims->data[i];
}
TF_LITE_ENSURE_EQ(context, NumDimensions(filter), 2);
const int batch_size = input_size / filter->dims->data[1];
const int num_units = filter->dims->data[0];
if (bias) {
TF_LITE_ENSURE_EQ(context, NumElements(bias), SizeOfDimension(filter, 0));
}
if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8 ||
input->type == kTfLiteInt16) {
double real_multiplier = 0.0;
TF_LITE_ENSURE_STATUS(GetQuantizedConvolutionMultipler(
context, input, filter, bias, output, &real_multiplier));
int exponent;
QuantizeMultiplier(real_multiplier, &data->output_multiplier, &exponent);
data->output_shift = exponent;
TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(
context, params->activation, output, &data->output_activation_min,
&data->output_activation_max));
}
if (input->type == kTfLiteInt16 && output->type == kTfLiteInt16) {
TF_LITE_ENSURE_EQ(context, input->params.zero_point, 0);
TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);
}
const bool is_hybrid =
(input->type == kTfLiteFloat32 &&
(filter->type == kTfLiteUInt8 || filter->type == kTfLiteInt8));
const bool is_sparse = filter->sparsity != nullptr;
if (is_hybrid) {
TfLiteIntArrayFree(node->temporaries);
data->compute_row_sums = true;
if (is_sparse) {
node->temporaries = TfLiteIntArrayCreate(6);
} else {
node->temporaries = TfLiteIntArrayCreate(5);
}
node->temporaries->data[0] = data->scratch_tensor_index;
TfLiteTensor* input_quantized;
TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, 0,
&input_quantized));
input_quantized->type = filter->type;
input_quantized->allocation_type = kTfLiteArenaRw;
TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);
TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,
input_quantized_size));
node->temporaries->data[1] = data->scratch_tensor_index + 1;
TfLiteTensor* scaling_factors;
TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, 1,
&scaling_factors));
scaling_factors->type = kTfLiteFloat32;
scaling_factors->allocation_type = kTfLiteArenaRw;
int scaling_dims[1] = {batch_size};
if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {
TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);
scaling_factors_size->data[0] = batch_size;
TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,
scaling_factors_size));
}
node->temporaries->data[2] = data->scratch_tensor_index + 2;
TfLiteTensor* accum_scratch;
TF_LITE_ENSURE_OK(
context, GetTemporarySafe(context, node, 2, &accum_scratch));
accum_scratch->type = kTfLiteInt32;
accum_scratch->allocation_type = kTfLiteArenaRw;
int accum_scratch_dims[2] = {num_units, batch_size};
if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2,
accum_scratch_dims)) {
TfLiteIntArray* accum_size = TfLiteIntArrayCreate(2);
accum_size->data[0] = num_units;
accum_size->data[1] = batch_size;
TF_LITE_ENSURE_OK(
context, context->ResizeTensor(context, accum_scratch, accum_size));
}
node->temporaries->data[3] = data->scratch_tensor_index + 3;
TfLiteTensor* input_offsets;
TF_LITE_ENSURE_OK(
context, GetTemporarySafe(context, node, 3, &input_offsets));
input_offsets->type = kTfLiteInt32;
input_offsets->allocation_type = kTfLiteArenaRw;
if (!TfLiteIntArrayEqualsArray(input_offsets->dims, 1, scaling_dims)) {
TfLiteIntArray* input_offsets_size = TfLiteIntArrayCreate(1);
input_offsets_size->data[0] = batch_size;
TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_offsets,
input_offsets_size));
}
node->temporaries->data[4] = data->scratch_tensor_index + 4;
TfLiteTensor* row_sums;
TF_LITE_ENSURE_OK(context,
GetTemporarySafe(context, node, 4, &row_sums));
row_sums->type = kTfLiteInt32;
row_sums->allocation_type = kTfLiteArenaRwPersistent;
int row_sums_dims[1] = {num_units};
if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) {
TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1);
row_sums_size->data[0] = row_sums_dims[0];
TF_LITE_ENSURE_OK(
context, context->ResizeTensor(context, row_sums, row_sums_size));
}
if (is_sparse) {
data->ledger_initialized = false;
node->temporaries->data[5] = data->scratch_tensor_index + 5;
TfLiteTensor* filter_ledger =
&context->tensors[node->temporaries->data[5]];
auto status =
CreateLedgerTensor(filter->sparsity, context, filter_ledger);
if (status != kTfLiteOk) return status;
}
}
TfLiteIntArray* output_size_array = nullptr;
if (params->keep_num_dims) {
TF_LITE_ENSURE_EQ(context, input->dims->data[input->dims->size - 1],
SizeOfDimension(filter, 1));
output_size_array = TfLiteIntArrayCopy(input->dims);
output_size_array->data[output_size_array->size - 1] = num_units;
} else {
output_size_array = TfLiteIntArrayCreate(2);
output_size_array->data[0] = batch_size;
output_size_array->data[1] = num_units;
}
TF_LITE_ENSURE_OK(context,
context->ResizeTensor(context, output, output_size_array));
return kTfLiteOk;
}","TfLiteStatus PrepareImpl(TfLiteContext* VAR_0, TfLiteNode* VAR_1) {
auto* VAR_2 =
VAR_3<TfLiteFullyConnectedParams*>(VAR_1->builtin_data);
OpData* VAR_4 = VAR_3<OpData*>(VAR_1->user_data);
TF_LITE_ENSURE(VAR_0, VAR_1->inputs->size == 2 || VAR_1->inputs->size == 3);
const int VAR_5 =
VAR_2->weights_format == VAR_6 ? 1
: 2;
TF_LITE_ENSURE_EQ(VAR_0, VAR_1->outputs->size, VAR_5);
const TfLiteTensor* VAR_7;
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_8, &VAR_7));
const TfLiteTensor* VAR_9;
TF_LITE_ENSURE_OK(VAR_0,
GetInputSafe(VAR_0, VAR_1, VAR_10, &VAR_9));
const TfLiteTensor* VAR_11 =
(VAR_1->inputs->size == 3)
? GetOptionalInputTensor(VAR_0, VAR_1, VAR_12)
: nullptr;
TfLiteTensor* VAR_13;
TF_LITE_ENSURE_OK(VAR_0,
GetOutputSafe(VAR_0, VAR_1, VAR_14, &VAR_13));
TF_LITE_ENSURE_STATUS(
CheckTypes(VAR_0, VAR_7, VAR_9, VAR_11, VAR_13, VAR_2));
int VAR_15 = 1;
for (int VAR_16 = 0; VAR_16 < VAR_7->dims->size; VAR_16++) {
VAR_15 *= VAR_7->dims->data[VAR_16];
}
TF_LITE_ENSURE_EQ(VAR_0, NumDimensions(VAR_9), 2);
const int VAR_17 = VAR_15 / VAR_9->dims->data[1];
const int VAR_18 = VAR_9->dims->data[0];
if (VAR_11) {
TF_LITE_ENSURE_EQ(VAR_0, NumElements(VAR_11), SizeOfDimension(VAR_9, 0));
}
if (VAR_7->type == VAR_19 || VAR_7->type == VAR_20 ||
VAR_7->type == VAR_21) {
double VAR_22 = 0.0;
TF_LITE_ENSURE_STATUS(GetQuantizedConvolutionMultipler(
VAR_0, VAR_7, VAR_9, VAR_11, VAR_13, &VAR_22));
int VAR_23;
QuantizeMultiplier(VAR_22, &VAR_4->output_multiplier, &VAR_23);
VAR_4->output_shift = VAR_23;
TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(
VAR_0, VAR_2->activation, VAR_13, &VAR_4->output_activation_min,
&VAR_4->output_activation_max));
}
if (VAR_7->type == VAR_21 && VAR_13->type == VAR_21) {
TF_LITE_ENSURE_EQ(VAR_0, VAR_7->params.zero_point, 0);
TF_LITE_ENSURE_EQ(VAR_0, VAR_13->params.zero_point, 0);
}
const bool VAR_24 =
(VAR_7->type == VAR_25 &&
(VAR_9->type == VAR_19 || VAR_9->type == VAR_20));
const bool VAR_26 = VAR_9->sparsity != nullptr;
if (VAR_24) {
TfLiteIntArrayFree(VAR_1->temporaries);
VAR_4->compute_row_sums = true;
if (VAR_26) {
VAR_1->temporaries = TfLiteIntArrayCreate(6);
} else {
VAR_1->temporaries = TfLiteIntArrayCreate(5);
}
VAR_1->temporaries->data[0] = VAR_4->scratch_tensor_index;
TfLiteTensor* VAR_27;
TF_LITE_ENSURE_OK(VAR_0, GetTemporarySafe(VAR_0, VAR_1, 0,
&VAR_27));
VAR_27->type = VAR_9->type;
VAR_27->allocation_type = VAR_28;
TfLiteIntArray* VAR_29 = TfLiteIntArrayCopy(VAR_7->dims);
TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_27,
VAR_29));
VAR_1->temporaries->data[1] = VAR_4->scratch_tensor_index + 1;
TfLiteTensor* VAR_30;
TF_LITE_ENSURE_OK(VAR_0, GetTemporarySafe(VAR_0, VAR_1, 1,
&VAR_30));
VAR_30->type = VAR_25;
VAR_30->allocation_type = VAR_28;
int VAR_31[1] = {VAR_17};
if (!TfLiteIntArrayEqualsArray(VAR_30->dims, 1, VAR_31)) {
TfLiteIntArray* VAR_32 = TfLiteIntArrayCreate(1);
VAR_32->data[0] = VAR_17;
TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_30,
VAR_32));
}
VAR_1->temporaries->data[2] = VAR_4->scratch_tensor_index + 2;
TfLiteTensor* VAR_33;
TF_LITE_ENSURE_OK(
VAR_0, GetTemporarySafe(VAR_0, VAR_1, 2, &VAR_33));
VAR_33->type = VAR_34;
VAR_33->allocation_type = VAR_28;
int VAR_35[2] = {VAR_18, VAR_17};
if (!TfLiteIntArrayEqualsArray(VAR_33->dims, 2,
VAR_35)) {
TfLiteIntArray* VAR_36 = TfLiteIntArrayCreate(2);
VAR_36->data[0] = VAR_18;
VAR_36->data[1] = VAR_17;
TF_LITE_ENSURE_OK(
VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_33, VAR_36));
}
VAR_1->temporaries->data[3] = VAR_4->scratch_tensor_index + 3;
TfLiteTensor* VAR_37;
TF_LITE_ENSURE_OK(
VAR_0, GetTemporarySafe(VAR_0, VAR_1, 3, &VAR_37));
VAR_37->type = VAR_34;
VAR_37->allocation_type = VAR_28;
if (!TfLiteIntArrayEqualsArray(VAR_37->dims, 1, VAR_31)) {
TfLiteIntArray* VAR_38 = TfLiteIntArrayCreate(1);
VAR_38->data[0] = VAR_17;
TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_37,
VAR_38));
}
VAR_1->temporaries->data[4] = VAR_4->scratch_tensor_index + 4;
TfLiteTensor* VAR_39;
TF_LITE_ENSURE_OK(VAR_0,
GetTemporarySafe(VAR_0, VAR_1, 4, &VAR_39));
VAR_39->type = VAR_34;
VAR_39->allocation_type = VAR_40;
int VAR_41[1] = {VAR_18};
if (!TfLiteIntArrayEqualsArray(VAR_39->dims, 1, VAR_41)) {
TfLiteIntArray* VAR_42 = TfLiteIntArrayCreate(1);
VAR_42->data[0] = VAR_41[0];
TF_LITE_ENSURE_OK(
VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_39, VAR_42));
}
if (VAR_26) {
VAR_4->ledger_initialized = false;
VAR_1->temporaries->data[5] = VAR_4->scratch_tensor_index + 5;
TfLiteTensor* VAR_43 =
&VAR_0->tensors[VAR_1->temporaries->data[5]];
auto VAR_44 =
CreateLedgerTensor(VAR_9->sparsity, VAR_0, VAR_43);
if (VAR_44 != VAR_45) return VAR_44;
}
}
TfLiteIntArray* VAR_46 = nullptr;
if (VAR_2->keep_num_dims) {
TF_LITE_ENSURE_EQ(VAR_0, VAR_7->dims->data[VAR_7->dims->size - 1],
SizeOfDimension(VAR_9, 1));
VAR_46 = TfLiteIntArrayCopy(VAR_7->dims);
VAR_46->data[VAR_46->size - 1] = VAR_18;
} else {
VAR_46 = TfLiteIntArrayCreate(2);
VAR_46->data[0] = VAR_17;
VAR_46->data[1] = VAR_18;
}
TF_LITE_ENSURE_OK(VAR_0,
VAR_0->ResizeTensor(VAR_0, VAR_13, VAR_46));
return VAR_45;
}",tensorflow/718721986aa137691ee23f03638867151f74935f/fully_connected.cc/vul/before/0.json,"TfLiteStatus PrepareImpl(TfLiteContext* context, TfLiteNode* node) {
  auto* params =
      reinterpret_cast<TfLiteFullyConnectedParams*>(node->builtin_data);
  OpData* data = reinterpret_cast<OpData*>(node->user_data);
  // Check we have all the inputs and outputs we need.
  TF_LITE_ENSURE(context, node->inputs->size == 2 || node->inputs->size == 3);
  // Shuffled formats need a workspace to store the shuffled input activations.
  const int expected_outputs_count =
      params->weights_format == kTfLiteFullyConnectedWeightsFormatDefault ? 1
                                                                          : 2;
  TF_LITE_ENSURE_EQ(context, node->outputs->size, expected_outputs_count);

  const TfLiteTensor* input;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
  const TfLiteTensor* filter;
  TF_LITE_ENSURE_OK(context,
                    GetInputSafe(context, node, kWeightsTensor, &filter));
  const TfLiteTensor* bias =
      (node->inputs->size == 3)
          ? GetOptionalInputTensor(context, node, kBiasTensor)
          : nullptr;
  TfLiteTensor* output;
  TF_LITE_ENSURE_OK(context,
                    GetOutputSafe(context, node, kOutputTensor, &output));

  // Check proper datatype match among all Input Tensors
  TF_LITE_ENSURE_STATUS(
      CheckTypes(context, input, filter, bias, output, params));

  // Check all the parameters of tensor match within themselves and match the
  // input configuration.
  int input_size = 1;
  for (int i = 0; i < input->dims->size; i++) {
    input_size *= input->dims->data[i];
  }

  TF_LITE_ENSURE_EQ(context, NumDimensions(filter), 2);
  TF_LITE_ENSURE(context, filter->dims->data[1] != 0);
  const int batch_size = input_size / filter->dims->data[1];
  const int num_units = filter->dims->data[0];

  if (bias) {
    TF_LITE_ENSURE_EQ(context, NumElements(bias), SizeOfDimension(filter, 0));
  }

  // Note that quantized inference requires that all tensors have their
  // parameters set. This is usually done during quantized training.
  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8 ||
      input->type == kTfLiteInt16) {
    double real_multiplier = 0.0;
    TF_LITE_ENSURE_STATUS(GetQuantizedConvolutionMultipler(
        context, input, filter, bias, output, &real_multiplier));
    int exponent;
    QuantizeMultiplier(real_multiplier, &data->output_multiplier, &exponent);
    data->output_shift = exponent;
    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(
        context, params->activation, output, &data->output_activation_min,
        &data->output_activation_max));
  }

  if (input->type == kTfLiteInt16 && output->type == kTfLiteInt16) {
    TF_LITE_ENSURE_EQ(context, input->params.zero_point, 0);
    TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);
  }

  // If we have to perform on-the-fly quantization (with quantized weights and
  // float inputs) first we need to quantize the inputs. Allocate a temporary
  // buffer to store the intermediate quantized values.
  // Additionally, we allocate a temporary buffer to store the accumulated
  // quantized values prior to multiplication by the scaling factor.
  const bool is_hybrid =
      (input->type == kTfLiteFloat32 &&
       (filter->type == kTfLiteUInt8 || filter->type == kTfLiteInt8));
  const bool is_sparse = filter->sparsity != nullptr;
  if (is_hybrid) {
    TfLiteIntArrayFree(node->temporaries);
    data->compute_row_sums = true;
    if (is_sparse) {
      node->temporaries = TfLiteIntArrayCreate(6);
    } else {
      node->temporaries = TfLiteIntArrayCreate(5);
    }
    node->temporaries->data[0] = data->scratch_tensor_index;

    TfLiteTensor* input_quantized;
    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/0,
                                                &input_quantized));
    input_quantized->type = filter->type;
    input_quantized->allocation_type = kTfLiteArenaRw;

    TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);
    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,
                                                     input_quantized_size));

    node->temporaries->data[1] = data->scratch_tensor_index + 1;
    TfLiteTensor* scaling_factors;
    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/1,
                                                &scaling_factors));
    scaling_factors->type = kTfLiteFloat32;
    scaling_factors->allocation_type = kTfLiteArenaRw;

    int scaling_dims[1] = {batch_size};
    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {
      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);
      scaling_factors_size->data[0] = batch_size;
      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,
                                                       scaling_factors_size));
    }

    node->temporaries->data[2] = data->scratch_tensor_index + 2;
    TfLiteTensor* accum_scratch;
    TF_LITE_ENSURE_OK(
        context, GetTemporarySafe(context, node, /*index=*/2, &accum_scratch));
    accum_scratch->type = kTfLiteInt32;
    accum_scratch->allocation_type = kTfLiteArenaRw;
    int accum_scratch_dims[2] = {num_units, batch_size};
    if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2,
                                   accum_scratch_dims)) {
      TfLiteIntArray* accum_size = TfLiteIntArrayCreate(2);
      accum_size->data[0] = num_units;
      accum_size->data[1] = batch_size;
      TF_LITE_ENSURE_OK(
          context, context->ResizeTensor(context, accum_scratch, accum_size));
    }

    node->temporaries->data[3] = data->scratch_tensor_index + 3;
    TfLiteTensor* input_offsets;
    TF_LITE_ENSURE_OK(
        context, GetTemporarySafe(context, node, /*index=*/3, &input_offsets));
    input_offsets->type = kTfLiteInt32;
    input_offsets->allocation_type = kTfLiteArenaRw;
    if (!TfLiteIntArrayEqualsArray(input_offsets->dims, 1, scaling_dims)) {
      TfLiteIntArray* input_offsets_size = TfLiteIntArrayCreate(1);
      input_offsets_size->data[0] = batch_size;
      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_offsets,
                                                       input_offsets_size));
    }
    node->temporaries->data[4] = data->scratch_tensor_index + 4;
    TfLiteTensor* row_sums;
    TF_LITE_ENSURE_OK(context,
                      GetTemporarySafe(context, node, /*index=*/4, &row_sums));
    row_sums->type = kTfLiteInt32;
    row_sums->allocation_type = kTfLiteArenaRwPersistent;
    int row_sums_dims[1] = {num_units};
    if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) {
      TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1);
      row_sums_size->data[0] = row_sums_dims[0];
      TF_LITE_ENSURE_OK(
          context, context->ResizeTensor(context, row_sums, row_sums_size));
    }

    if (is_sparse) {
      data->ledger_initialized = false;
      node->temporaries->data[5] = data->scratch_tensor_index + 5;
      TfLiteTensor* filter_ledger =
          &context->tensors[node->temporaries->data[5]];
      auto status =
          CreateLedgerTensor(filter->sparsity, context, filter_ledger);
      if (status != kTfLiteOk) return status;
    }
  }

  // Resize output.
  TfLiteIntArray* output_size_array = nullptr;
  if (params->keep_num_dims) {
    // When number of dimensions are kept the filter operates along the last
    // dimensions. In other words, for an input tensor with shape
    // [batch_size, ..., n_inputs] and a filter of shape [n_inputs, n_units]
    // this Op produces an output of shape [batch_size, ..., n_units].
    TF_LITE_ENSURE_EQ(context, input->dims->data[input->dims->size - 1],
                      SizeOfDimension(filter, 1));
    output_size_array = TfLiteIntArrayCopy(input->dims);
    output_size_array->data[output_size_array->size - 1] = num_units;
  } else {
    // Otherwise, the output is (potentially flattened to) a 2-D matrix.
    output_size_array = TfLiteIntArrayCreate(2);
    output_size_array->data[0] = batch_size;
    output_size_array->data[1] = num_units;
  }
  TF_LITE_ENSURE_OK(context,
                    context->ResizeTensor(context, output, output_size_array));

  return kTfLiteOk;
}","TfLiteStatus PrepareImpl(TfLiteContext* VAR_0, TfLiteNode* VAR_1) {
  auto* VAR_2 =
      VAR_3<TfLiteFullyConnectedParams*>(VAR_1->builtin_data);
  OpData* VAR_4 = VAR_3<OpData*>(VAR_1->user_data);
  /* COMMENT_0 */
  TF_LITE_ENSURE(VAR_0, VAR_1->inputs->size == 2 || VAR_1->inputs->size == 3);
  /* COMMENT_1 */
  const int VAR_5 =
      VAR_2->weights_format == VAR_6 ? 1
                                                                          : 2;
  TF_LITE_ENSURE_EQ(VAR_0, VAR_1->outputs->size, VAR_5);

  const TfLiteTensor* VAR_7;
  TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_8, &VAR_7));
  const TfLiteTensor* VAR_9;
  TF_LITE_ENSURE_OK(VAR_0,
                    GetInputSafe(VAR_0, VAR_1, VAR_10, &VAR_9));
  const TfLiteTensor* VAR_11 =
      (VAR_1->inputs->size == 3)
          ? GetOptionalInputTensor(VAR_0, VAR_1, VAR_12)
          : nullptr;
  TfLiteTensor* VAR_13;
  TF_LITE_ENSURE_OK(VAR_0,
                    GetOutputSafe(VAR_0, VAR_1, VAR_14, &VAR_13));

  /* COMMENT_2 */
  TF_LITE_ENSURE_STATUS(
      CheckTypes(VAR_0, VAR_7, VAR_9, VAR_11, VAR_13, VAR_2));

  /* COMMENT_3 */
  /* COMMENT_4 */
  int VAR_15 = 1;
  for (int VAR_16 = 0; VAR_16 < VAR_7->dims->size; VAR_16++) {
    VAR_15 *= VAR_7->dims->data[VAR_16];
  }

  TF_LITE_ENSURE_EQ(VAR_0, NumDimensions(VAR_9), 2);
  TF_LITE_ENSURE(VAR_0, VAR_9->dims->data[1] != 0);
  const int VAR_17 = VAR_15 / VAR_9->dims->data[1];
  const int VAR_18 = VAR_9->dims->data[0];

  if (VAR_11) {
    TF_LITE_ENSURE_EQ(VAR_0, NumElements(VAR_11), SizeOfDimension(VAR_9, 0));
  }

  /* COMMENT_5 */
  /* COMMENT_6 */
  if (VAR_7->type == VAR_19 || VAR_7->type == VAR_20 ||
      VAR_7->type == VAR_21) {
    double VAR_22 = 0.0;
    TF_LITE_ENSURE_STATUS(GetQuantizedConvolutionMultipler(
        VAR_0, VAR_7, VAR_9, VAR_11, VAR_13, &VAR_22));
    int VAR_23;
    QuantizeMultiplier(VAR_22, &VAR_4->output_multiplier, &VAR_23);
    VAR_4->output_shift = VAR_23;
    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(
        VAR_0, VAR_2->activation, VAR_13, &VAR_4->output_activation_min,
        &VAR_4->output_activation_max));
  }

  if (VAR_7->type == VAR_21 && VAR_13->type == VAR_21) {
    TF_LITE_ENSURE_EQ(VAR_0, VAR_7->params.zero_point, 0);
    TF_LITE_ENSURE_EQ(VAR_0, VAR_13->params.zero_point, 0);
  }

  /* COMMENT_7 */
  /* COMMENT_8 */
  /* COMMENT_9 */
  /* COMMENT_10 */
  /* COMMENT_11 */
  const bool VAR_24 =
      (VAR_7->type == VAR_25 &&
       (VAR_9->type == VAR_19 || VAR_9->type == VAR_20));
  const bool VAR_26 = VAR_9->sparsity != nullptr;
  if (VAR_24) {
    TfLiteIntArrayFree(VAR_1->temporaries);
    VAR_4->compute_row_sums = true;
    if (VAR_26) {
      VAR_1->temporaries = TfLiteIntArrayCreate(6);
    } else {
      VAR_1->temporaries = TfLiteIntArrayCreate(5);
    }
    VAR_1->temporaries->data[0] = VAR_4->scratch_tensor_index;

    TfLiteTensor* VAR_27;
    TF_LITE_ENSURE_OK(VAR_0, GetTemporarySafe(VAR_0, VAR_1, /* COMMENT_12 */0,
                                                &VAR_27));
    VAR_27->type = VAR_9->type;
    VAR_27->allocation_type = VAR_28;

    TfLiteIntArray* VAR_29 = TfLiteIntArrayCopy(VAR_7->dims);
    TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_27,
                                                     VAR_29));

    VAR_1->temporaries->data[1] = VAR_4->scratch_tensor_index + 1;
    TfLiteTensor* VAR_30;
    TF_LITE_ENSURE_OK(VAR_0, GetTemporarySafe(VAR_0, VAR_1, /* COMMENT_12 */1,
                                                &VAR_30));
    VAR_30->type = VAR_25;
    VAR_30->allocation_type = VAR_28;

    int VAR_31[1] = {VAR_17};
    if (!TfLiteIntArrayEqualsArray(VAR_30->dims, 1, VAR_31)) {
      TfLiteIntArray* VAR_32 = TfLiteIntArrayCreate(1);
      VAR_32->data[0] = VAR_17;
      TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_30,
                                                       VAR_32));
    }

    VAR_1->temporaries->data[2] = VAR_4->scratch_tensor_index + 2;
    TfLiteTensor* VAR_33;
    TF_LITE_ENSURE_OK(
        VAR_0, GetTemporarySafe(VAR_0, VAR_1, /* COMMENT_12 */2, &VAR_33));
    VAR_33->type = VAR_34;
    VAR_33->allocation_type = VAR_28;
    int VAR_35[2] = {VAR_18, VAR_17};
    if (!TfLiteIntArrayEqualsArray(VAR_33->dims, 2,
                                   VAR_35)) {
      TfLiteIntArray* VAR_36 = TfLiteIntArrayCreate(2);
      VAR_36->data[0] = VAR_18;
      VAR_36->data[1] = VAR_17;
      TF_LITE_ENSURE_OK(
          VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_33, VAR_36));
    }

    VAR_1->temporaries->data[3] = VAR_4->scratch_tensor_index + 3;
    TfLiteTensor* VAR_37;
    TF_LITE_ENSURE_OK(
        VAR_0, GetTemporarySafe(VAR_0, VAR_1, /* COMMENT_12 */3, &VAR_37));
    VAR_37->type = VAR_34;
    VAR_37->allocation_type = VAR_28;
    if (!TfLiteIntArrayEqualsArray(VAR_37->dims, 1, VAR_31)) {
      TfLiteIntArray* VAR_38 = TfLiteIntArrayCreate(1);
      VAR_38->data[0] = VAR_17;
      TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_37,
                                                       VAR_38));
    }
    VAR_1->temporaries->data[4] = VAR_4->scratch_tensor_index + 4;
    TfLiteTensor* VAR_39;
    TF_LITE_ENSURE_OK(VAR_0,
                      GetTemporarySafe(VAR_0, VAR_1, /* COMMENT_12 */4, &VAR_39));
    VAR_39->type = VAR_34;
    VAR_39->allocation_type = VAR_40;
    int VAR_41[1] = {VAR_18};
    if (!TfLiteIntArrayEqualsArray(VAR_39->dims, 1, VAR_41)) {
      TfLiteIntArray* VAR_42 = TfLiteIntArrayCreate(1);
      VAR_42->data[0] = VAR_41[0];
      TF_LITE_ENSURE_OK(
          VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_39, VAR_42));
    }

    if (VAR_26) {
      VAR_4->ledger_initialized = false;
      VAR_1->temporaries->data[5] = VAR_4->scratch_tensor_index + 5;
      TfLiteTensor* VAR_43 =
          &VAR_0->tensors[VAR_1->temporaries->data[5]];
      auto VAR_44 =
          CreateLedgerTensor(VAR_9->sparsity, VAR_0, VAR_43);
      if (VAR_44 != VAR_45) return VAR_44;
    }
  }

  /* COMMENT_13 */
  TfLiteIntArray* VAR_46 = nullptr;
  if (VAR_2->keep_num_dims) {
    /* COMMENT_14 */
    /* COMMENT_15 */
    /* COMMENT_16 */
    /* COMMENT_17 */
    TF_LITE_ENSURE_EQ(VAR_0, VAR_7->dims->data[VAR_7->dims->size - 1],
                      SizeOfDimension(VAR_9, 1));
    VAR_46 = TfLiteIntArrayCopy(VAR_7->dims);
    VAR_46->data[VAR_46->size - 1] = VAR_18;
  } else {
    /* COMMENT_18 */
    VAR_46 = TfLiteIntArrayCreate(2);
    VAR_46->data[0] = VAR_17;
    VAR_46->data[1] = VAR_18;
  }
  TF_LITE_ENSURE_OK(VAR_0,
                    VAR_0->ResizeTensor(VAR_0, VAR_13, VAR_46));

  return VAR_45;
}",tensorflow/718721986aa137691ee23f03638867151f74935f/fully_connected.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,6 +35,7 @@
   }
 
   TF_LITE_ENSURE_EQ(context, NumDimensions(filter), 2);
+  TF_LITE_ENSURE(context, filter->dims->data[1] != 0);
   const int batch_size = input_size / filter->dims->data[1];
   const int num_units = filter->dims->data[0];
 ","{'deleted_lines': [], 'added_lines': ['  TF_LITE_ENSURE(context, filter->dims->data[1] != 0);']}",True,"TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of fully connected layers in TFLite is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/fully_connected.cc#L226). We have patched the issue in GitHub commit 718721986aa137691ee23f03638867151f74935f. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",5.5,MEDIUM,1,test,2021-07-16T13:49:45Z,3
CVE-2021-38383,['CWE-416'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,owntone/owntone-server,"[misc] Fix use-after-free in net_bind()

Thanks to Ba Jinsheng for reporting this bug",246d8ae0cef27377e5dfe9ee3ad87e864d6b6266,https://github.com/owntone/owntone-server/commit/246d8ae0cef27377e5dfe9ee3ad87e864d6b6266,src/misc.c,net_bind,"int
net_bind(short unsigned *port, int type, const char *log_service_name)
{
struct addrinfo hints = { 0 };
struct addrinfo *servinfo;
struct addrinfo *ptr;
const char *cfgaddr;
char addr[INET6_ADDRSTRLEN];
char strport[8];
int yes = 1;
int no = 0;
int fd;
int ret;
cfgaddr = cfg_getstr(cfg_getsec(cfg, ""general""), ""bind_address"");
hints.ai_socktype = (type & (SOCK_STREAM | SOCK_DGRAM));   hints.ai_family = (cfg_getbool(cfg_getsec(cfg, ""general""), ""ipv6"")) ? AF_INET6 : AF_INET;
hints.ai_flags = cfgaddr ? 0 : AI_PASSIVE;
snprintf(strport, sizeof(strport), ""%hu"", *port);
ret = getaddrinfo(cfgaddr, strport, &hints, &servinfo);
if (ret < 0)
{
DPRINTF(E_LOG, L_MISC, ""Failure creating '%s' service, could not resolve '%s' (port %s): %s\n"", log_service_name, cfgaddr ? cfgaddr : ""(ANY)"", strport, gai_strerror(ret));
return -1;
}
for (ptr = servinfo, fd = -1; ptr != NULL; ptr = ptr->ai_next)
{
if (fd >= 0)
close(fd);
fd = socket(ptr->ai_family, type | SOCK_CLOEXEC, ptr->ai_protocol);
if (fd < 0)
continue;
ret = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes));
if (ret < 0)
continue;
ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
if (ret < 0)
continue;
if (ptr->ai_family == AF_INET6)
{
ret = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &no, sizeof(no));
if (ret < 0)
continue;
}
ret = bind(fd, ptr->ai_addr, ptr->ai_addrlen);
if (ret < 0)
continue;
break;
}
freeaddrinfo(servinfo);
if (!ptr)
{
DPRINTF(E_LOG, L_MISC, ""Could not create service '%s' with address %s, port %hu: %s\n"", log_service_name, cfgaddr ? cfgaddr : ""(ANY)"", *port, strerror(errno));
goto error;
}
ret = getsockname(fd, ptr->ai_addr, &ptr->ai_addrlen);
if (ret < 0)
{
DPRINTF(E_LOG, L_MISC, ""Could not find address of service '%s': %s\n"", log_service_name, strerror(errno));
goto error;
}
net_port_get(port, (union net_sockaddr *)ptr->ai_addr);
net_address_get(addr, sizeof(addr), (union net_sockaddr *)ptr->ai_addr);
DPRINTF(E_DBG, L_MISC, ""Service '%s' bound to %s, port %hu, socket %d\n"", log_service_name, addr, *port, fd);
return fd;
error:
close(fd);
return -1;
}","int
net_bind(short unsigned *VAR_0, int VAR_1, const char *VAR_2)
{
struct addrinfo VAR_3 = { 0 };
struct addrinfo *VAR_4;
struct addrinfo *VAR_5;
const char *VAR_6;
char VAR_7[VAR_8];
char VAR_9[8];
int VAR_10 = 1;
int VAR_11 = 0;
int VAR_12;
int VAR_13;
VAR_6 = cfg_getstr(cfg_getsec(VAR_14, ""general""), ""bind_address"");
VAR_3.ai_socktype = (VAR_1 & (VAR_15 | VAR_16)); 
VAR_3.ai_family = (cfg_getbool(cfg_getsec(VAR_14, ""general""), ""ipv6"")) ? VAR_17 : VAR_18;
VAR_3.ai_flags = VAR_6 ? 0 : VAR_19;
snprintf(VAR_9, sizeof(VAR_9), ""%hu"", *VAR_0);
VAR_13 = getaddrinfo(VAR_6, VAR_9, &VAR_3, &VAR_4);
if (VAR_13 < 0)
{
DPRINTF(VAR_20, VAR_21, ""Failure creating '%s' service, could not resolve '%s' (port %s): %s\n"", VAR_2, VAR_6 ? VAR_6 : ""(ANY)"", VAR_9, gai_strerror(VAR_13));
return -1;
}
for (VAR_5 = VAR_4, VAR_12 = -1; VAR_5 != NULL; VAR_5 = VAR_5->ai_next)
{
if (VAR_12 >= 0)
close(VAR_12);
VAR_12 = socket(VAR_5->ai_family, VAR_1 | VAR_22, VAR_5->ai_protocol);
if (VAR_12 < 0)
continue;
VAR_13 = setsockopt(VAR_12, VAR_23, VAR_24, &VAR_10, sizeof(VAR_10));
if (VAR_13 < 0)
continue;
VAR_13 = setsockopt(VAR_12, VAR_23, VAR_25, &VAR_10, sizeof(VAR_10));
if (VAR_13 < 0)
continue;
if (VAR_5->ai_family == VAR_17)
{
VAR_13 = setsockopt(VAR_12, VAR_26, VAR_27, &VAR_11, sizeof(VAR_11));
if (VAR_13 < 0)
continue;
}
VAR_13 = bind(VAR_12, VAR_5->ai_addr, VAR_5->ai_addrlen);
if (VAR_13 < 0)
continue;
break;
}
freeaddrinfo(VAR_4);
if (!VAR_5)
{
DPRINTF(VAR_20, VAR_21, ""Could not create service '%s' with address %s, port %hu: %s\n"", VAR_2, VAR_6 ? VAR_6 : ""(ANY)"", *VAR_0, strerror(VAR_28));
goto error;
}
VAR_13 = getsockname(VAR_12, VAR_5->ai_addr, &VAR_5->ai_addrlen);
if (VAR_13 < 0)
{
DPRINTF(VAR_20, VAR_21, ""Could not find address of service '%s': %s\n"", VAR_2, strerror(VAR_28));
goto error;
}
net_port_get(VAR_0, (union net_sockaddr *)VAR_5->ai_addr);
net_address_get(VAR_7, sizeof(VAR_7), (union net_sockaddr *)VAR_5->ai_addr);
DPRINTF(VAR_29, VAR_21, ""Service '%s' bound to %s, port %hu, socket %d\n"", VAR_2, VAR_7, *VAR_0, VAR_12);
return VAR_12;
error:
close(VAR_12);
return -1;
}",owntone/owntone-server/246d8ae0cef27377e5dfe9ee3ad87e864d6b6266/misc.c/vul/before/0.json,"int
net_bind(short unsigned *port, int type, const char *log_service_name)
{
  struct addrinfo hints = { 0 };
  struct addrinfo *servinfo;
  struct addrinfo *ptr;
  union net_sockaddr naddr = { 0 };
  socklen_t naddr_len = sizeof(naddr);
  const char *cfgaddr;
  char addr[INET6_ADDRSTRLEN];
  char strport[8];
  int yes = 1;
  int no = 0;
  int fd;
  int ret;

  cfgaddr = cfg_getstr(cfg_getsec(cfg, ""general""), ""bind_address"");

  hints.ai_socktype = (type & (SOCK_STREAM | SOCK_DGRAM)); // filter since type can be SOCK_STREAM | SOCK_NONBLOCK
  hints.ai_family = (cfg_getbool(cfg_getsec(cfg, ""general""), ""ipv6"")) ? AF_INET6 : AF_INET;
  hints.ai_flags = cfgaddr ? 0 : AI_PASSIVE;

  snprintf(strport, sizeof(strport), ""%hu"", *port);
  ret = getaddrinfo(cfgaddr, strport, &hints, &servinfo);
  if (ret < 0)
    {
      DPRINTF(E_LOG, L_MISC, ""Failure creating '%s' service, could not resolve '%s' (port %s): %s\n"", log_service_name, cfgaddr ? cfgaddr : ""(ANY)"", strport, gai_strerror(ret));
      return -1;
    }

  for (ptr = servinfo, fd = -1; ptr != NULL; ptr = ptr->ai_next)
    {
      if (fd >= 0)
	close(fd);

      fd = socket(ptr->ai_family, type | SOCK_CLOEXEC, ptr->ai_protocol);
      if (fd < 0)
	continue;

      // TODO libevent sets this, we do the same?
      ret = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes));
      if (ret < 0)
	continue;

      ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
      if (ret < 0)
	continue;

      if (ptr->ai_family == AF_INET6)
	{
	  // We want to be sure the service is dual stack
	  ret = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &no, sizeof(no));
	  if (ret < 0)
	    continue;
	}

      ret = bind(fd, ptr->ai_addr, ptr->ai_addrlen);
      if (ret < 0)
	continue;

      break;
    }

  freeaddrinfo(servinfo);

  if (!ptr)
    {
      DPRINTF(E_LOG, L_MISC, ""Could not create service '%s' with address %s, port %hu: %s\n"", log_service_name, cfgaddr ? cfgaddr : ""(ANY)"", *port, strerror(errno));
      goto error;
    }

  // Get our address (as string) and the port that was assigned (necessary when
  // caller didn't specify a port)
  ret = getsockname(fd, &naddr.sa, &naddr_len);
  if (ret < 0)
    {
      DPRINTF(E_LOG, L_MISC, ""Error finding address of service '%s': %s\n"", log_service_name, strerror(errno));
      goto error;
    }
  else if (naddr_len > sizeof(naddr))
    {
      DPRINTF(E_LOG, L_MISC, ""Unexpected address length of service '%s'\n"", log_service_name);
      goto error;
    }

  net_port_get(port, &naddr);
  net_address_get(addr, sizeof(addr), &naddr);

  DPRINTF(E_DBG, L_MISC, ""Service '%s' bound to %s, port %hu, socket %d\n"", log_service_name, addr, *port, fd);

  return fd;

 error:
  close(fd);
  return -1;
}","int
net_bind(short unsigned *VAR_0, int VAR_1, const char *VAR_2)
{
  struct addrinfo VAR_3 = { 0 };
  struct addrinfo *VAR_4;
  struct addrinfo *VAR_5;
  union net_sockaddr VAR_6 = { 0 };
  socklen_t VAR_7 = sizeof(VAR_6);
  const char *VAR_8;
  char VAR_9[VAR_10];
  char VAR_11[8];
  int VAR_12 = 1;
  int VAR_13 = 0;
  int VAR_14;
  int VAR_15;

  VAR_8 = cfg_getstr(cfg_getsec(VAR_16, ""general""), ""bind_address"");

  VAR_3.ai_socktype = (VAR_1 & (VAR_17 | VAR_18)); /* COMMENT_0 */
  VAR_3.ai_family = (cfg_getbool(cfg_getsec(VAR_16, ""general""), ""ipv6"")) ? VAR_19 : VAR_20;
  VAR_3.ai_flags = VAR_8 ? 0 : VAR_21;

  snprintf(VAR_11, sizeof(VAR_11), ""%hu"", *VAR_0);
  VAR_15 = getaddrinfo(VAR_8, VAR_11, &VAR_3, &VAR_4);
  if (VAR_15 < 0)
    {
      DPRINTF(VAR_22, VAR_23, ""Failure creating '%s' service, could not resolve '%s' (port %s): %s\n"", VAR_2, VAR_8 ? VAR_8 : ""(ANY)"", VAR_11, gai_strerror(VAR_15));
      return -1;
    }

  for (VAR_5 = VAR_4, VAR_14 = -1; VAR_5 != NULL; VAR_5 = VAR_5->ai_next)
    {
      if (VAR_14 >= 0)
	close(VAR_14);

      VAR_14 = socket(VAR_5->ai_family, VAR_1 | VAR_24, VAR_5->ai_protocol);
      if (VAR_14 < 0)
	continue;

      /* COMMENT_1 */
      VAR_15 = setsockopt(VAR_14, VAR_25, VAR_26, &VAR_12, sizeof(VAR_12));
      if (VAR_15 < 0)
	continue;

      VAR_15 = setsockopt(VAR_14, VAR_25, VAR_27, &VAR_12, sizeof(VAR_12));
      if (VAR_15 < 0)
	continue;

      if (VAR_5->ai_family == VAR_19)
	{
	  /* COMMENT_2 */
	  VAR_15 = setsockopt(VAR_14, VAR_28, VAR_29, &VAR_13, sizeof(VAR_13));
	  if (VAR_15 < 0)
	    continue;
	}

      VAR_15 = bind(VAR_14, VAR_5->ai_addr, VAR_5->ai_addrlen);
      if (VAR_15 < 0)
	continue;

      break;
    }

  freeaddrinfo(VAR_4);

  if (!VAR_5)
    {
      DPRINTF(VAR_22, VAR_23, ""Could not create service '%s' with address %s, port %hu: %s\n"", VAR_2, VAR_8 ? VAR_8 : ""(ANY)"", *VAR_0, strerror(VAR_30));
      goto error;
    }

  /* COMMENT_3 */
  /* COMMENT_4 */
  VAR_15 = getsockname(VAR_14, &VAR_6.sa, &VAR_7);
  if (VAR_15 < 0)
    {
      DPRINTF(VAR_22, VAR_23, ""Error finding address of service '%s': %s\n"", VAR_2, strerror(VAR_30));
      goto error;
    }
  else if (VAR_7 > sizeof(VAR_6))
    {
      DPRINTF(VAR_22, VAR_23, ""Unexpected address length of service '%s'\n"", VAR_2);
      goto error;
    }

  net_port_get(VAR_0, &VAR_6);
  net_address_get(VAR_9, sizeof(VAR_9), &VAR_6);

  DPRINTF(VAR_31, VAR_23, ""Service '%s' bound to %s, port %hu, socket %d\n"", VAR_2, VAR_9, *VAR_0, VAR_14);

  return VAR_14;

 error:
  close(VAR_14);
  return -1;
}",owntone/owntone-server/246d8ae0cef27377e5dfe9ee3ad87e864d6b6266/misc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,8 @@
   struct addrinfo hints = { 0 };
   struct addrinfo *servinfo;
   struct addrinfo *ptr;
+  union net_sockaddr naddr = { 0 };
+  socklen_t naddr_len = sizeof(naddr);
   const char *cfgaddr;
   char addr[INET6_ADDRSTRLEN];
   char strport[8];
@@ -67,16 +69,22 @@
       goto error;
     }
 
-  // Get the port that was assigned
-  ret = getsockname(fd, ptr->ai_addr, &ptr->ai_addrlen);
+  // Get our address (as string) and the port that was assigned (necessary when
+  // caller didn't specify a port)
+  ret = getsockname(fd, &naddr.sa, &naddr_len);
   if (ret < 0)
     {
-      DPRINTF(E_LOG, L_MISC, ""Could not find address of service '%s': %s\n"", log_service_name, strerror(errno));
+      DPRINTF(E_LOG, L_MISC, ""Error finding address of service '%s': %s\n"", log_service_name, strerror(errno));
+      goto error;
+    }
+  else if (naddr_len > sizeof(naddr))
+    {
+      DPRINTF(E_LOG, L_MISC, ""Unexpected address length of service '%s'\n"", log_service_name);
       goto error;
     }
 
-  net_port_get(port, (union net_sockaddr *)ptr->ai_addr);
-  net_address_get(addr, sizeof(addr), (union net_sockaddr *)ptr->ai_addr);
+  net_port_get(port, &naddr);
+  net_address_get(addr, sizeof(addr), &naddr);
 
   DPRINTF(E_DBG, L_MISC, ""Service '%s' bound to %s, port %hu, socket %d\n"", log_service_name, addr, *port, fd);
 ","{'deleted_lines': ['  // Get the port that was assigned', '  ret = getsockname(fd, ptr->ai_addr, &ptr->ai_addrlen);', '      DPRINTF(E_LOG, L_MISC, ""Could not find address of service \'%s\': %s\\n"", log_service_name, strerror(errno));', '  net_port_get(port, (union net_sockaddr *)ptr->ai_addr);', '  net_address_get(addr, sizeof(addr), (union net_sockaddr *)ptr->ai_addr);'], 'added_lines': ['  union net_sockaddr naddr = { 0 };', '  socklen_t naddr_len = sizeof(naddr);', '  // Get our address (as string) and the port that was assigned (necessary when', ""  // caller didn't specify a port)"", '  ret = getsockname(fd, &naddr.sa, &naddr_len);', '      DPRINTF(E_LOG, L_MISC, ""Error finding address of service \'%s\': %s\\n"", log_service_name, strerror(errno));', '      goto error;', '    }', '  else if (naddr_len > sizeof(naddr))', '    {', '      DPRINTF(E_LOG, L_MISC, ""Unexpected address length of service \'%s\'\\n"", log_service_name);', '  net_port_get(port, &naddr);', '  net_address_get(addr, sizeof(addr), &naddr);']}",True,OwnTone (aka owntone-server) through 28.1 has a use-after-free in net_bind() in misc.c.,9.8,CRITICAL,3,test,2021-07-30T22:55:48Z,3
CVE-2021-37674,['CWE-1284'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,tensorflow,"Add missing validation to `maxpooling_op.cc`

PiperOrigin-RevId: 387932441
Change-Id: I43a0b24e6a12cc965611144ba035accd384594b9",136b51f10903e044308cf77117c0ed9871350475,https://github.com/tensorflow/tensorflow/commit/136b51f10903e044308cf77117c0ed9871350475,tensorflow/core/kernels/pooling_ops_common.cc,PoolParameters::PoolParameters,"PoolParameters::PoolParameters(OpKernelContext* context,
const std::vector<int32>& ksize,
const std::vector<int32>& stride,
Padding padding,
std::vector<int64> explicit_paddings,
TensorFormat data_format,
const TensorShape& tensor_in_shape) {
OP_REQUIRES(context,
GetTensorSpatialDims(tensor_in_shape.dims(), data_format) == 2,
errors::InvalidArgument(
""tensor_in_shape must have 2 spatial dimensions. "",
tensor_in_shape.dims(), "" "", data_format));
this->data_format = data_format;
depth = GetTensorDim(tensor_in_shape, data_format, 'C') *
(data_format == FORMAT_NCHW_VECT_C ? 4 : 1);
tensor_in_cols = GetTensorDim(tensor_in_shape, data_format, 'W');
tensor_in_rows = GetTensorDim(tensor_in_shape, data_format, 'H');
tensor_in_batch = GetTensorDim(tensor_in_shape, data_format, 'N');
window_rows = GetTensorDim(ksize, data_format, 'H');
window_cols = GetTensorDim(ksize, data_format, 'W');
depth_window = GetTensorDim(ksize, data_format, 'C');
row_stride = GetTensorDim(stride, data_format, 'H');
col_stride = GetTensorDim(stride, data_format, 'W');
depth_stride = GetTensorDim(stride, data_format, 'C');
OP_REQUIRES(context,
(depth_window == 1 || (window_rows == 1 && window_cols == 1)),
errors::Unimplemented(
""MaxPooling supports exactly one of pooling across depth ""
""or pooling across width/height.""));
if (padding == Padding::EXPLICIT) {
OP_REQUIRES_OK(context, CheckValidPadding(padding, explicit_paddings,
4, data_format));
GetExplicitPaddingForDim(explicit_paddings, data_format, 'H', &pad_top,
&pad_bottom);
GetExplicitPaddingForDim(explicit_paddings, data_format, 'W', &pad_left,
&pad_right);
OP_REQUIRES_OK(context, CheckPaddingSize(window_rows, window_cols, pad_top,
pad_bottom, pad_left, pad_right));
}
if (depth_window == 1) {
OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(
tensor_in_rows, window_rows, row_stride,
padding, &out_height, &pad_top, &pad_bottom));
OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(
tensor_in_cols, window_cols, col_stride,
padding, &out_width, &pad_left, &pad_right));
pad_depth = 0;
out_depth = depth;
} else {
OP_REQUIRES(
context, depth % depth_window == 0,
errors::Unimplemented(""Depthwise max pooling requires the depth ""
""window to evenly divide the input depth""));
OP_REQUIRES(
context, depth_stride == depth_window,
errors::Unimplemented(""Depthwise max pooling requires the depth ""
""window to equal the depth stride""));
OP_REQUIRES(context,
(DeviceType(static_cast<Device*>(context->device())
->attributes()
.device_type()) == DeviceType(DEVICE_CPU)),
errors::Unimplemented(""Depthwise max pooling is currently ""
""only implemented for CPU devices.""));
pad_depth = 0;
out_depth = depth / depth_window;
}
}","PoolParameters::PoolParameters(OpKernelContext* VAR_0,
const std::vector<int32>& VAR_1,
const std::vector<int32>& VAR_2,
Padding VAR_3,
std::vector<int64> VAR_4,
TensorFormat VAR_5,
const TensorShape& VAR_6) {
OP_REQUIRES(VAR_0,
GetTensorSpatialDims(VAR_6.dims(), VAR_5) == 2,
errors::InvalidArgument(
""tensor_in_shape must have 2 spatial dimensions. "",
VAR_6.dims(), "" "", VAR_5));
this->data_format = VAR_5;
VAR_7 = GetTensorDim(VAR_6, VAR_5, 'C') *
(VAR_5 == VAR_8 ? 4 : 1);
VAR_9 = GetTensorDim(VAR_6, VAR_5, 'W');
VAR_10 = GetTensorDim(VAR_6, VAR_5, 'H');
VAR_11 = GetTensorDim(VAR_6, VAR_5, 'N');
VAR_12 = GetTensorDim(VAR_1, VAR_5, 'H');
VAR_13 = GetTensorDim(VAR_1, VAR_5, 'W');
VAR_14 = GetTensorDim(VAR_1, VAR_5, 'C');
VAR_15 = GetTensorDim(VAR_2, VAR_5, 'H');
VAR_16 = GetTensorDim(VAR_2, VAR_5, 'W');
VAR_17 = GetTensorDim(VAR_2, VAR_5, 'C');
OP_REQUIRES(VAR_0,
(VAR_14 == 1 || (VAR_12 == 1 && VAR_13 == 1)),
errors::Unimplemented(
""MaxPooling supports exactly one of pooling across depth ""
""or pooling across width/height.""));
if (VAR_3 == Padding::EXPLICIT) {
OP_REQUIRES_OK(VAR_0, CheckValidPadding(VAR_3, VAR_4,
4, VAR_5));
GetExplicitPaddingForDim(VAR_4, VAR_5, 'H', &VAR_18,
&VAR_19);
GetExplicitPaddingForDim(VAR_4, VAR_5, 'W', &VAR_20,
&VAR_21);
OP_REQUIRES_OK(VAR_0, CheckPaddingSize(VAR_12, VAR_13, VAR_18,
VAR_19, VAR_20, VAR_21));
}
if (VAR_14 == 1) {
OP_REQUIRES_OK(VAR_0, GetWindowedOutputSizeVerbose(
VAR_10, VAR_12, VAR_15,
VAR_3, &VAR_22, &VAR_18, &VAR_19));
OP_REQUIRES_OK(VAR_0, GetWindowedOutputSizeVerbose(
VAR_9, VAR_13, VAR_16,
VAR_3, &VAR_23, &VAR_20, &VAR_21));
VAR_24 = 0;
VAR_25 = VAR_7;
} else {
OP_REQUIRES(
VAR_0, VAR_7 % VAR_14 == 0,
errors::Unimplemented(""Depthwise max pooling requires the depth ""
""window to evenly divide the input depth""));
OP_REQUIRES(
VAR_0, VAR_17 == VAR_14,
errors::Unimplemented(""Depthwise max pooling requires the depth ""
""window to equal the depth stride""));
OP_REQUIRES(VAR_0,
(DeviceType(VAR_26<Device*>(VAR_0->device())
->attributes()
.device_type()) == DeviceType(VAR_27)),
errors::Unimplemented(""Depthwise max pooling is currently ""
""only implemented for CPU devices.""));
VAR_24 = 0;
VAR_25 = VAR_7 / VAR_14;
}
}",tensorflow/136b51f10903e044308cf77117c0ed9871350475/pooling_ops_common.cc/vul/before/0.json,"PoolParameters::PoolParameters(OpKernelContext* context,
                               const std::vector<int32>& ksize,
                               const std::vector<int32>& stride,
                               Padding padding,
                               std::vector<int64> explicit_paddings,
                               TensorFormat data_format,
                               const TensorShape& tensor_in_shape) {
  // For maxpooling, tensor_in should have 2 spatial dimensions.
  // Note: the total number of dimensions could be 4 for NHWC, NCHW,
  // or 5 for NCHW_VECT_C.
  OP_REQUIRES(context,
              GetTensorSpatialDims(tensor_in_shape.dims(), data_format) == 2,
              errors::InvalidArgument(
                  ""tensor_in_shape must have 2 spatial dimensions. "",
                  tensor_in_shape.dims(), "" "", data_format));

  this->data_format = data_format;
  depth = GetTensorDim(tensor_in_shape, data_format, 'C') *
          (data_format == FORMAT_NCHW_VECT_C ? 4 : 1);
  tensor_in_cols = GetTensorDim(tensor_in_shape, data_format, 'W');
  tensor_in_rows = GetTensorDim(tensor_in_shape, data_format, 'H');
  tensor_in_batch = GetTensorDim(tensor_in_shape, data_format, 'N');
  window_rows = GetTensorDim(ksize, data_format, 'H');
  window_cols = GetTensorDim(ksize, data_format, 'W');
  depth_window = GetTensorDim(ksize, data_format, 'C');
  row_stride = GetTensorDim(stride, data_format, 'H');
  col_stride = GetTensorDim(stride, data_format, 'W');
  depth_stride = GetTensorDim(stride, data_format, 'C');

  // We only support 2D pooling across width/height and depthwise
  // pooling, not a combination.
  OP_REQUIRES(context,
              (depth_window == 1 || (window_rows == 1 && window_cols == 1)),
              errors::Unimplemented(
                  ""MaxPooling supports exactly one of pooling across depth ""
                  ""or pooling across width/height.""));
  if (padding == Padding::EXPLICIT) {
    OP_REQUIRES_OK(context, CheckValidPadding(padding, explicit_paddings,
                                              /*num_dims=*/4, data_format));
    GetExplicitPaddingForDim(explicit_paddings, data_format, 'H', &pad_top,
                             &pad_bottom);
    GetExplicitPaddingForDim(explicit_paddings, data_format, 'W', &pad_left,
                             &pad_right);
    OP_REQUIRES_OK(context, CheckPaddingSize(window_rows, window_cols, pad_top,
                                             pad_bottom, pad_left, pad_right));
  }

  if (depth_window == 1) {
    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(
                                tensor_in_rows, window_rows, row_stride,
                                padding, &out_height, &pad_top, &pad_bottom));
    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(
                                tensor_in_cols, window_cols, col_stride,
                                padding, &out_width, &pad_left, &pad_right));
    pad_depth = 0;
    out_depth = depth;
  } else {
    OP_REQUIRES(context, depth_window > 0,
                errors::InvalidArgument(""depth_window must not be 0""));
    // Our current version of depthwise max pooling does not support
    // any padding, and expects the depth_window to equal the
    // depth_stride (no overlapping).
    OP_REQUIRES(
        context, depth % depth_window == 0,
        errors::Unimplemented(""Depthwise max pooling requires the depth ""
                              ""window to evenly divide the input depth""));
    OP_REQUIRES(
        context, depth_stride == depth_window,
        errors::Unimplemented(""Depthwise max pooling requires the depth ""
                              ""window to equal the depth stride""));

    // The current version of depthwise max is only implemented on CPU.
    OP_REQUIRES(context,
                (DeviceType(static_cast<Device*>(context->device())
                                ->attributes()
                                .device_type()) == DeviceType(DEVICE_CPU)),
                errors::Unimplemented(""Depthwise max pooling is currently ""
                                      ""only implemented for CPU devices.""));

    pad_depth = 0;
    out_depth = depth / depth_window;
  }
}","PoolParameters::PoolParameters(OpKernelContext* VAR_0,
                               const std::vector<int32>& VAR_1,
                               const std::vector<int32>& VAR_2,
                               Padding VAR_3,
                               std::vector<int64> VAR_4,
                               TensorFormat VAR_5,
                               const TensorShape& VAR_6) {
  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  OP_REQUIRES(VAR_0,
              GetTensorSpatialDims(VAR_6.dims(), VAR_5) == 2,
              errors::InvalidArgument(
                  ""tensor_in_shape must have 2 spatial dimensions. "",
                  VAR_6.dims(), "" "", VAR_5));

  this->data_format = VAR_5;
  VAR_7 = GetTensorDim(VAR_6, VAR_5, 'C') *
          (VAR_5 == VAR_8 ? 4 : 1);
  VAR_9 = GetTensorDim(VAR_6, VAR_5, 'W');
  VAR_10 = GetTensorDim(VAR_6, VAR_5, 'H');
  VAR_11 = GetTensorDim(VAR_6, VAR_5, 'N');
  VAR_12 = GetTensorDim(VAR_1, VAR_5, 'H');
  VAR_13 = GetTensorDim(VAR_1, VAR_5, 'W');
  VAR_14 = GetTensorDim(VAR_1, VAR_5, 'C');
  VAR_15 = GetTensorDim(VAR_2, VAR_5, 'H');
  VAR_16 = GetTensorDim(VAR_2, VAR_5, 'W');
  VAR_17 = GetTensorDim(VAR_2, VAR_5, 'C');

  /* COMMENT_3 */
  /* COMMENT_4 */
  OP_REQUIRES(VAR_0,
              (VAR_14 == 1 || (VAR_12 == 1 && VAR_13 == 1)),
              errors::Unimplemented(
                  ""MaxPooling supports exactly one of pooling across depth ""
                  ""or pooling across width/height.""));
  if (VAR_3 == Padding::EXPLICIT) {
    OP_REQUIRES_OK(VAR_0, CheckValidPadding(VAR_3, VAR_4,
                                              /* COMMENT_5 */4, VAR_5));
    GetExplicitPaddingForDim(VAR_4, VAR_5, 'H', &VAR_18,
                             &VAR_19);
    GetExplicitPaddingForDim(VAR_4, VAR_5, 'W', &VAR_20,
                             &VAR_21);
    OP_REQUIRES_OK(VAR_0, CheckPaddingSize(VAR_12, VAR_13, VAR_18,
                                             VAR_19, VAR_20, VAR_21));
  }

  if (VAR_14 == 1) {
    OP_REQUIRES_OK(VAR_0, GetWindowedOutputSizeVerbose(
                                VAR_10, VAR_12, VAR_15,
                                VAR_3, &VAR_22, &VAR_18, &VAR_19));
    OP_REQUIRES_OK(VAR_0, GetWindowedOutputSizeVerbose(
                                VAR_9, VAR_13, VAR_16,
                                VAR_3, &VAR_23, &VAR_20, &VAR_21));
    VAR_24 = 0;
    VAR_25 = VAR_7;
  } else {
    OP_REQUIRES(VAR_0, VAR_14 > 0,
                errors::InvalidArgument(""depth_window must not be 0""));
    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_8 */
    OP_REQUIRES(
        VAR_0, VAR_7 % VAR_14 == 0,
        errors::Unimplemented(""Depthwise max pooling requires the depth ""
                              ""window to evenly divide the input depth""));
    OP_REQUIRES(
        VAR_0, VAR_17 == VAR_14,
        errors::Unimplemented(""Depthwise max pooling requires the depth ""
                              ""window to equal the depth stride""));

    /* COMMENT_9 */
    OP_REQUIRES(VAR_0,
                (DeviceType(VAR_26<Device*>(VAR_0->device())
                                ->attributes()
                                .device_type()) == DeviceType(VAR_27)),
                errors::Unimplemented(""Depthwise max pooling is currently ""
                                      ""only implemented for CPU devices.""));

    VAR_24 = 0;
    VAR_25 = VAR_7 / VAR_14;
  }
}",tensorflow/136b51f10903e044308cf77117c0ed9871350475/pooling_ops_common.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -55,6 +55,8 @@
     pad_depth = 0;
     out_depth = depth;
   } else {
+    OP_REQUIRES(context, depth_window > 0,
+                errors::InvalidArgument(""depth_window must not be 0""));
     // Our current version of depthwise max pooling does not support
     // any padding, and expects the depth_window to equal the
     // depth_stride (no overlapping).","{'deleted_lines': [], 'added_lines': ['    OP_REQUIRES(context, depth_window > 0,', '                errors::InvalidArgument(""depth_window must not be 0""));']}",True,"TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a denial of service via a segmentation fault in `tf.raw_ops.MaxPoolGrad` caused by missing validation. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/maxpooling_op.cc) misses some validation for the `orig_input` and `orig_output` tensors. The fixes for CVE-2021-29579 were incomplete. We have patched the issue in GitHub commit 136b51f10903e044308cf77117c0ed9871350475. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",5.5,MEDIUM,1,test,2021-07-31T03:50:00Z,3
CVE-2021-37674,['CWE-1284'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,tensorflow,"Add missing validation to `maxpooling_op.cc`

PiperOrigin-RevId: 387932441
Change-Id: I43a0b24e6a12cc965611144ba035accd384594b9",136b51f10903e044308cf77117c0ed9871350475,https://github.com/tensorflow/tensorflow/commit/136b51f10903e044308cf77117c0ed9871350475,tensorflow/core/kernels/maxpooling_op.cc,SpatialMaxPoolWithArgMaxHelper,"static void SpatialMaxPoolWithArgMaxHelper(
OpKernelContext* context, Tensor* output, Tensor* output_arg_max,
Tensor* input_backprop, const Tensor& tensor_in, const Tensor& out_backprop,
const PoolParameters& params, const bool include_batch_in_index) {
if (input_backprop != nullptr) {
OP_REQUIRES(
context, include_batch_in_index,
errors::Internal(
""SpatialMaxPoolWithArgMaxHelper requires include_batch_in_index ""
""to be True when input_backprop != nullptr""));
OP_REQUIRES(
context, (std::is_same<Targmax, int64>::value),
errors::Internal(""SpatialMaxPoolWithArgMaxHelper requires Targmax ""
""to be int64 when input_backprop != nullptr""));
}
typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>
ConstEigenMatrixMap;
typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>
EigenMatrixMap;
typedef Eigen::Map<Eigen::Matrix<Targmax, Eigen::Dynamic, Eigen::Dynamic>>
EigenIndexMatrixMap;
ConstEigenMatrixMap in_mat(
tensor_in.flat<T>().data(), params.depth,
params.tensor_in_cols * params.tensor_in_rows * params.tensor_in_batch);
EigenMatrixMap out_mat(
output->flat<T>().data(), params.depth,
params.out_width * params.out_height * params.tensor_in_batch);
EigenIndexMatrixMap out_arg_max_mat(
output_arg_max->flat<Targmax>().data(), params.depth,
params.out_width * params.out_height * params.tensor_in_batch);
const DeviceBase::CpuWorkerThreads& worker_threads =
*(context->device()->tensorflow_cpu_worker_threads());
auto shard = [&params, &in_mat, &out_mat, &out_arg_max_mat, &input_backprop,
&output_arg_max, &out_backprop,
include_batch_in_index](int64_t start, int64_t limit) {
const int32_t depth = params.depth;
const int32_t in_rows = params.tensor_in_rows;
const int32_t in_cols = params.tensor_in_cols;
const int32_t pad_top = params.pad_top;
const int32_t pad_left = params.pad_left;
const int32_t window_rows = params.window_rows;
const int32_t window_cols = params.window_cols;
const int32_t row_stride = params.row_stride;
const int32_t col_stride = params.col_stride;
const int32_t out_height = params.out_height;
const int32_t out_width = params.out_width;
{
const int32_t output_image_size = out_height * out_width * depth;
EigenMatrixMap out_shard(out_mat.data() + start * output_image_size, 1,
(limit - start) * output_image_size);
out_shard.setConstant(Eigen::NumTraits<T>::lowest());
EigenIndexMatrixMap out_arg_max_shard(
out_arg_max_mat.data() + start * output_image_size, 1,
(limit - start) * output_image_size);
out_arg_max_shard.setConstant(kInvalidMaxPoolingIndex);
}
for (int64_t b = start; b < limit; ++b) {
for (int h = 0; h < in_rows; ++h) {
for (int w = 0; w < in_cols; ++w) {
const int hpad = h + pad_top;
const int wpad = w + pad_left;
const int h_start =
(hpad < window_rows) ? 0 : (hpad - window_rows) / row_stride + 1;
const int h_end = std::min(hpad / row_stride + 1, out_height);
const int w_start =
(wpad < window_cols) ? 0 : (wpad - window_cols) / col_stride + 1;
const int w_end = std::min(wpad / col_stride + 1, out_width);
const int64_t in_index = (b * in_rows + h) * in_cols + w;
for (int ph = h_start; ph < h_end; ++ph) {
const int64_t out_index_base = (b * out_height + ph) * out_width;
for (int pw = w_start; pw < w_end; ++pw) {
const int64_t out_index = out_index_base + pw;
for (int d = 0; d < depth; ++d) {
const T& input_ref = in_mat.coeffRef(d, in_index);
T& output_ref = out_mat.coeffRef(d, out_index);
Targmax& out_arg_max_ref =
out_arg_max_mat.coeffRef(d, out_index);
if (output_ref < input_ref ||
out_arg_max_ref == kInvalidMaxPoolingIndex) {
output_ref = input_ref;
if (include_batch_in_index) {
out_arg_max_ref = in_index * depth + d;
} else {
out_arg_max_ref = (h * in_cols + w) * depth + d;
}
}
}
}
}
}
}
}
if (input_backprop != nullptr) {
auto input_backprop_flat = input_backprop->flat<T>();
auto out_arg_max_flat = output_arg_max->flat<int64>();
auto out_backprop_flat = out_backprop.flat<T>();
const int64_t in_size = in_rows * in_cols * depth;
const int64_t in_start = start * in_size;
const int64_t in_end = limit * in_size;
EigenMatrixMap in_shard(input_backprop_flat.data() + in_start, 1,
in_end - in_start);
in_shard.setConstant(T(0));
const int out_size = out_height * out_width * depth;
const int out_start = start * out_size;
const int out_end = limit * out_size;
for (int index = out_start; index < out_end; ++index) {
int input_backprop_index = out_arg_max_flat(index);
FastBoundsCheck(input_backprop_index - in_start, in_end - in_start);
if (index < out_backprop.NumElements()) {
input_backprop_flat(input_backprop_index) += out_backprop_flat(index);
}
}
}
};
const int64_t shard_cost = params.tensor_in_rows * params.tensor_in_cols *
params.depth * params.window_rows *
params.window_cols;
Shard(worker_threads.num_threads, worker_threads.workers,
params.tensor_in_batch, shard_cost, shard);
}","static void SpatialMaxPoolWithArgMaxHelper(
OpKernelContext* VAR_0, Tensor* VAR_1, Tensor* VAR_2,
Tensor* VAR_3, const Tensor& VAR_4, const Tensor& VAR_5,
const PoolParameters& VAR_6, const bool VAR_7) {
if (VAR_3 != nullptr) {
OP_REQUIRES(
VAR_0, VAR_7,
errors::Internal(
""SpatialMaxPoolWithArgMaxHelper requires include_batch_in_index ""
""to be True when input_backprop != nullptr""));
OP_REQUIRES(
VAR_0, (std::is_same<Targmax, int64>::value),
errors::Internal(""SpatialMaxPoolWithArgMaxHelper requires Targmax ""
""to be int64 when input_backprop != nullptr""));
}
typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>
ConstEigenMatrixMap;
typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>
EigenMatrixMap;
typedef Eigen::Map<Eigen::Matrix<Targmax, Eigen::Dynamic, Eigen::Dynamic>>
EigenIndexMatrixMap;
ConstEigenMatrixMap VAR_8(
VAR_4.flat<T>().data(), VAR_6.depth,
VAR_6.tensor_in_cols * VAR_6.tensor_in_rows * VAR_6.tensor_in_batch);
EigenMatrixMap VAR_9(
VAR_1->flat<T>().data(), VAR_6.depth,
VAR_6.out_width * VAR_6.out_height * VAR_6.tensor_in_batch);
EigenIndexMatrixMap VAR_10(
VAR_2->flat<Targmax>().data(), VAR_6.depth,
VAR_6.out_width * VAR_6.out_height * VAR_6.tensor_in_batch);
const DeviceBase::CpuWorkerThreads& VAR_11 =
*(VAR_0->device()->tensorflow_cpu_worker_threads());
auto VAR_12 = [&VAR_6, &VAR_8, &VAR_9, &VAR_10, &VAR_3,
&VAR_2, &VAR_5,
VAR_7](int64_t VAR_13, int64_t VAR_14) {
const int32_t VAR_15 = VAR_6.depth;
const int32_t VAR_16 = VAR_6.tensor_in_rows;
const int32_t VAR_17 = VAR_6.tensor_in_cols;
const int32_t VAR_18 = VAR_6.pad_top;
const int32_t VAR_19 = VAR_6.pad_left;
const int32_t VAR_20 = VAR_6.window_rows;
const int32_t VAR_21 = VAR_6.window_cols;
const int32_t VAR_22 = VAR_6.row_stride;
const int32_t VAR_23 = VAR_6.col_stride;
const int32_t VAR_24 = VAR_6.out_height;
const int32_t VAR_25 = VAR_6.out_width;
{
const int32_t VAR_26 = VAR_24 * VAR_25 * VAR_15;
EigenMatrixMap VAR_27(VAR_9.data() + VAR_13 * VAR_26, 1,
(VAR_14 - VAR_13) * VAR_26);
VAR_27.setConstant(Eigen::NumTraits<T>::lowest());
EigenIndexMatrixMap VAR_28(
VAR_10.data() + VAR_13 * VAR_26, 1,
(VAR_14 - VAR_13) * VAR_26);
VAR_28.setConstant(VAR_29);
}
for (int64_t VAR_30 = VAR_13; VAR_30 < VAR_14; ++VAR_30) {
for (int VAR_31 = 0; VAR_31 < VAR_16; ++VAR_31) {
for (int VAR_32 = 0; VAR_32 < VAR_17; ++VAR_32) {
const int VAR_33 = VAR_31 + VAR_18;
const int VAR_34 = VAR_32 + VAR_19;
const int VAR_35 =
(VAR_33 < VAR_20) ? 0 : (VAR_33 - VAR_20) / VAR_22 + 1;
const int VAR_36 = std::min(VAR_33 / VAR_22 + 1, VAR_24);
const int VAR_37 =
(VAR_34 < VAR_21) ? 0 : (VAR_34 - VAR_21) / VAR_23 + 1;
const int VAR_38 = std::min(VAR_34 / VAR_23 + 1, VAR_25);
const int64_t VAR_39 = (VAR_30 * VAR_16 + VAR_31) * VAR_17 + VAR_32;
for (int VAR_40 = VAR_35; VAR_40 < VAR_36; ++VAR_40) {
const int64_t VAR_41 = (VAR_30 * VAR_24 + VAR_40) * VAR_25;
for (int VAR_42 = VAR_37; VAR_42 < VAR_38; ++VAR_42) {
const int64_t VAR_43 = VAR_41 + VAR_42;
for (int VAR_44 = 0; VAR_44 < VAR_15; ++VAR_44) {
const T& VAR_45 = VAR_8.coeffRef(VAR_44, VAR_39);
T& VAR_46 = VAR_9.coeffRef(VAR_44, VAR_43);
Targmax& VAR_47 =
VAR_10.coeffRef(VAR_44, VAR_43);
if (VAR_46 < VAR_45 ||
VAR_47 == VAR_29) {
VAR_46 = VAR_45;
if (VAR_7) {
VAR_47 = VAR_39 * VAR_15 + VAR_44;
} else {
VAR_47 = (VAR_31 * VAR_17 + VAR_32) * VAR_15 + VAR_44;
}
}
}
}
}
}
}
}
if (VAR_3 != nullptr) {
auto VAR_48 = VAR_3->flat<T>();
auto VAR_49 = VAR_2->flat<int64>();
auto VAR_50 = VAR_5.flat<T>();
const int64_t VAR_51 = VAR_16 * VAR_17 * VAR_15;
const int64_t VAR_52 = VAR_13 * VAR_51;
const int64_t VAR_53 = VAR_14 * VAR_51;
EigenMatrixMap VAR_54(VAR_48.data() + VAR_52, 1,
VAR_53 - VAR_52);
VAR_54.setConstant(T(0));
const int VAR_55 = VAR_24 * VAR_25 * VAR_15;
const int VAR_56 = VAR_13 * VAR_55;
const int VAR_57 = VAR_14 * VAR_55;
for (int VAR_58 = VAR_56; VAR_58 < VAR_57; ++VAR_58) {
int VAR_59 = VAR_49(VAR_58);
FastBoundsCheck(VAR_59 - VAR_52, VAR_53 - VAR_52);
if (VAR_58 < VAR_5.NumElements()) {
VAR_48(VAR_59) += VAR_50(VAR_58);
}
}
}
};
const int64_t VAR_60 = VAR_6.tensor_in_rows * VAR_6.tensor_in_cols *
VAR_6.depth * VAR_6.window_rows *
VAR_6.window_cols;
Shard(VAR_11.num_threads, VAR_11.workers,
VAR_6.tensor_in_batch, VAR_60, VAR_12);
}",tensorflow/136b51f10903e044308cf77117c0ed9871350475/maxpooling_op.cc/vul/before/0.json,"static void SpatialMaxPoolWithArgMaxHelper(
    OpKernelContext* context, Tensor* output, Tensor* output_arg_max,
    Tensor* input_backprop, const Tensor& tensor_in, const Tensor& out_backprop,
    const PoolParameters& params, const bool include_batch_in_index) {
  if (input_backprop != nullptr) {
    OP_REQUIRES(
        context, include_batch_in_index,
        errors::Internal(
            ""SpatialMaxPoolWithArgMaxHelper requires include_batch_in_index ""
            ""to be True when input_backprop != nullptr""));
    OP_REQUIRES(
        context, (std::is_same<Targmax, int64>::value),
        errors::Internal(""SpatialMaxPoolWithArgMaxHelper requires Targmax ""
                         ""to be int64 when input_backprop != nullptr""));
  }
  if (tensor_in.NumElements() == 0 || output->NumElements() == 0) return;

  typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>
      ConstEigenMatrixMap;
  typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>
      EigenMatrixMap;
  typedef Eigen::Map<Eigen::Matrix<Targmax, Eigen::Dynamic, Eigen::Dynamic>>
      EigenIndexMatrixMap;

  ConstEigenMatrixMap in_mat(
      tensor_in.flat<T>().data(), params.depth,
      params.tensor_in_cols * params.tensor_in_rows * params.tensor_in_batch);
  EigenMatrixMap out_mat(
      output->flat<T>().data(), params.depth,
      params.out_width * params.out_height * params.tensor_in_batch);
  EigenIndexMatrixMap out_arg_max_mat(
      output_arg_max->flat<Targmax>().data(), params.depth,
      params.out_width * params.out_height * params.tensor_in_batch);

  const DeviceBase::CpuWorkerThreads& worker_threads =
      *(context->device()->tensorflow_cpu_worker_threads());

  // The following code basically does the following:
  // 1. Flattens the input and output tensors into two dimensional arrays.
  //    tensor_in_as_matrix:
  //      depth by (tensor_in_cols * tensor_in_rows * tensor_in_batch)
  //    output_as_matrix:
  //      depth by (out_width * out_height * tensor_in_batch)
  //
  // 2. Walks through the set of columns in the flattened tensor_in_as_matrix,
  //    and updates the corresponding column(s) in output_as_matrix with the
  //    max value.
  auto shard = [&params, &in_mat, &out_mat, &out_arg_max_mat, &input_backprop,
                &output_arg_max, &out_backprop,
                include_batch_in_index](int64_t start, int64_t limit) {
    const int32_t depth = params.depth;
    const int32_t in_rows = params.tensor_in_rows;
    const int32_t in_cols = params.tensor_in_cols;
    const int32_t pad_top = params.pad_top;
    const int32_t pad_left = params.pad_left;
    const int32_t window_rows = params.window_rows;
    const int32_t window_cols = params.window_cols;
    const int32_t row_stride = params.row_stride;
    const int32_t col_stride = params.col_stride;
    const int32_t out_height = params.out_height;
    const int32_t out_width = params.out_width;

    {
      // Initializes the output tensor with MIN<T>.
      const int32_t output_image_size = out_height * out_width * depth;
      EigenMatrixMap out_shard(out_mat.data() + start * output_image_size, 1,
                               (limit - start) * output_image_size);
      out_shard.setConstant(Eigen::NumTraits<T>::lowest());
      EigenIndexMatrixMap out_arg_max_shard(
          out_arg_max_mat.data() + start * output_image_size, 1,
          (limit - start) * output_image_size);
      out_arg_max_shard.setConstant(kInvalidMaxPoolingIndex);
    }

    for (int64_t b = start; b < limit; ++b) {
      for (int h = 0; h < in_rows; ++h) {
        for (int w = 0; w < in_cols; ++w) {
          // (h_start, h_end) * (w_start, w_end) is the range that the input
          // vector projects to.
          const int hpad = h + pad_top;
          const int wpad = w + pad_left;
          const int h_start =
              (hpad < window_rows) ? 0 : (hpad - window_rows) / row_stride + 1;
          const int h_end = std::min(hpad / row_stride + 1, out_height);
          const int w_start =
              (wpad < window_cols) ? 0 : (wpad - window_cols) / col_stride + 1;
          const int w_end = std::min(wpad / col_stride + 1, out_width);
          // compute elementwise max
          const int64_t in_index = (b * in_rows + h) * in_cols + w;
          for (int ph = h_start; ph < h_end; ++ph) {
            const int64_t out_index_base = (b * out_height + ph) * out_width;
            for (int pw = w_start; pw < w_end; ++pw) {
              const int64_t out_index = out_index_base + pw;
              /// NOTES(zhengxq): not using the eigen matrix operation for
              /// now.
              for (int d = 0; d < depth; ++d) {
                const T& input_ref = in_mat.coeffRef(d, in_index);
                T& output_ref = out_mat.coeffRef(d, out_index);
                Targmax& out_arg_max_ref =
                    out_arg_max_mat.coeffRef(d, out_index);
                if (output_ref < input_ref ||
                    out_arg_max_ref == kInvalidMaxPoolingIndex) {
                  output_ref = input_ref;
                  if (include_batch_in_index) {
                    out_arg_max_ref = in_index * depth + d;
                  } else {
                    out_arg_max_ref = (h * in_cols + w) * depth + d;
                  }
                }
              }
            }
          }
        }
      }
    }

    if (input_backprop != nullptr) {
      auto input_backprop_flat = input_backprop->flat<T>();
      auto out_arg_max_flat = output_arg_max->flat<int64>();
      auto out_backprop_flat = out_backprop.flat<T>();

      // Initialize output to 0.
      const int64_t in_size = in_rows * in_cols * depth;
      const int64_t in_start = start * in_size;
      const int64_t in_end = limit * in_size;
      EigenMatrixMap in_shard(input_backprop_flat.data() + in_start, 1,
                              in_end - in_start);
      in_shard.setConstant(T(0));

      // Backpropagate.
      const int out_size = out_height * out_width * depth;
      const int out_start = start * out_size;
      const int out_end = limit * out_size;
      for (int index = out_start; index < out_end; ++index) {
        int input_backprop_index = out_arg_max_flat(index);
        // Although this check is in the inner loop, it is worth its value
        // so we don't end up with memory corruptions. Our benchmark shows that
        // the performance impact is quite small
        // CHECK(input_backprop_index >= in_start && input_backprop_index <
        // in_end)
        FastBoundsCheck(input_backprop_index - in_start, in_end - in_start);
        if (index < out_backprop.NumElements()) {
          input_backprop_flat(input_backprop_index) += out_backprop_flat(index);
        }
      }
    }
  };

  const int64_t shard_cost = params.tensor_in_rows * params.tensor_in_cols *
                             params.depth * params.window_rows *
                             params.window_cols;
  Shard(worker_threads.num_threads, worker_threads.workers,
        params.tensor_in_batch, shard_cost, shard);
}","static void SpatialMaxPoolWithArgMaxHelper(
    OpKernelContext* VAR_0, Tensor* VAR_1, Tensor* VAR_2,
    Tensor* VAR_3, const Tensor& VAR_4, const Tensor& VAR_5,
    const PoolParameters& VAR_6, const bool VAR_7) {
  if (VAR_3 != nullptr) {
    OP_REQUIRES(
        VAR_0, VAR_7,
        errors::Internal(
            ""SpatialMaxPoolWithArgMaxHelper requires include_batch_in_index ""
            ""to be True when input_backprop != nullptr""));
    OP_REQUIRES(
        VAR_0, (std::is_same<Targmax, int64>::value),
        errors::Internal(""SpatialMaxPoolWithArgMaxHelper requires Targmax ""
                         ""to be int64 when input_backprop != nullptr""));
  }
  if (VAR_4.NumElements() == 0 || VAR_1->NumElements() == 0) return;

  typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>
      ConstEigenMatrixMap;
  typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>
      EigenMatrixMap;
  typedef Eigen::Map<Eigen::Matrix<Targmax, Eigen::Dynamic, Eigen::Dynamic>>
      EigenIndexMatrixMap;

  ConstEigenMatrixMap VAR_8(
      VAR_4.flat<T>().data(), VAR_6.depth,
      VAR_6.tensor_in_cols * VAR_6.tensor_in_rows * VAR_6.tensor_in_batch);
  EigenMatrixMap VAR_9(
      VAR_1->flat<T>().data(), VAR_6.depth,
      VAR_6.out_width * VAR_6.out_height * VAR_6.tensor_in_batch);
  EigenIndexMatrixMap VAR_10(
      VAR_2->flat<Targmax>().data(), VAR_6.depth,
      VAR_6.out_width * VAR_6.out_height * VAR_6.tensor_in_batch);

  const DeviceBase::CpuWorkerThreads& VAR_11 =
      *(VAR_0->device()->tensorflow_cpu_worker_threads());

  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  /* COMMENT_3 */
  /* COMMENT_4 */
  /* COMMENT_5 */
  /* COMMENT_6 */
  /* COMMENT_7 */
  /* COMMENT_8 */
  /* COMMENT_9 */
  auto VAR_12 = [&VAR_6, &VAR_8, &VAR_9, &VAR_10, &VAR_3,
                &VAR_2, &VAR_5,
                VAR_7](int64_t VAR_13, int64_t VAR_14) {
    const int32_t VAR_15 = VAR_6.depth;
    const int32_t VAR_16 = VAR_6.tensor_in_rows;
    const int32_t VAR_17 = VAR_6.tensor_in_cols;
    const int32_t VAR_18 = VAR_6.pad_top;
    const int32_t VAR_19 = VAR_6.pad_left;
    const int32_t VAR_20 = VAR_6.window_rows;
    const int32_t VAR_21 = VAR_6.window_cols;
    const int32_t VAR_22 = VAR_6.row_stride;
    const int32_t VAR_23 = VAR_6.col_stride;
    const int32_t VAR_24 = VAR_6.out_height;
    const int32_t VAR_25 = VAR_6.out_width;

    {
      /* COMMENT_10 */
      const int32_t VAR_26 = VAR_24 * VAR_25 * VAR_15;
      EigenMatrixMap VAR_27(VAR_9.data() + VAR_13 * VAR_26, 1,
                               (VAR_14 - VAR_13) * VAR_26);
      VAR_27.setConstant(Eigen::NumTraits<T>::lowest());
      EigenIndexMatrixMap VAR_28(
          VAR_10.data() + VAR_13 * VAR_26, 1,
          (VAR_14 - VAR_13) * VAR_26);
      VAR_28.setConstant(VAR_29);
    }

    for (int64_t VAR_30 = VAR_13; VAR_30 < VAR_14; ++VAR_30) {
      for (int VAR_31 = 0; VAR_31 < VAR_16; ++VAR_31) {
        for (int VAR_32 = 0; VAR_32 < VAR_17; ++VAR_32) {
          /* COMMENT_11 */
          /* COMMENT_12 */
          const int VAR_33 = VAR_31 + VAR_18;
          const int VAR_34 = VAR_32 + VAR_19;
          const int VAR_35 =
              (VAR_33 < VAR_20) ? 0 : (VAR_33 - VAR_20) / VAR_22 + 1;
          const int VAR_36 = std::min(VAR_33 / VAR_22 + 1, VAR_24);
          const int VAR_37 =
              (VAR_34 < VAR_21) ? 0 : (VAR_34 - VAR_21) / VAR_23 + 1;
          const int VAR_38 = std::min(VAR_34 / VAR_23 + 1, VAR_25);
          /* COMMENT_13 */
          const int64_t VAR_39 = (VAR_30 * VAR_16 + VAR_31) * VAR_17 + VAR_32;
          for (int VAR_40 = VAR_35; VAR_40 < VAR_36; ++VAR_40) {
            const int64_t VAR_41 = (VAR_30 * VAR_24 + VAR_40) * VAR_25;
            for (int VAR_42 = VAR_37; VAR_42 < VAR_38; ++VAR_42) {
              const int64_t VAR_43 = VAR_41 + VAR_42;
              /* COMMENT_14 */
              /* COMMENT_15 */
              for (int VAR_44 = 0; VAR_44 < VAR_15; ++VAR_44) {
                const T& VAR_45 = VAR_8.coeffRef(VAR_44, VAR_39);
                T& VAR_46 = VAR_9.coeffRef(VAR_44, VAR_43);
                Targmax& VAR_47 =
                    VAR_10.coeffRef(VAR_44, VAR_43);
                if (VAR_46 < VAR_45 ||
                    VAR_47 == VAR_29) {
                  VAR_46 = VAR_45;
                  if (VAR_7) {
                    VAR_47 = VAR_39 * VAR_15 + VAR_44;
                  } else {
                    VAR_47 = (VAR_31 * VAR_17 + VAR_32) * VAR_15 + VAR_44;
                  }
                }
              }
            }
          }
        }
      }
    }

    if (VAR_3 != nullptr) {
      auto VAR_48 = VAR_3->flat<T>();
      auto VAR_49 = VAR_2->flat<int64>();
      auto VAR_50 = VAR_5.flat<T>();

      /* COMMENT_16 */
      const int64_t VAR_51 = VAR_16 * VAR_17 * VAR_15;
      const int64_t VAR_52 = VAR_13 * VAR_51;
      const int64_t VAR_53 = VAR_14 * VAR_51;
      EigenMatrixMap VAR_54(VAR_48.data() + VAR_52, 1,
                              VAR_53 - VAR_52);
      VAR_54.setConstant(T(0));

      /* COMMENT_17 */
      const int VAR_55 = VAR_24 * VAR_25 * VAR_15;
      const int VAR_56 = VAR_13 * VAR_55;
      const int VAR_57 = VAR_14 * VAR_55;
      for (int VAR_58 = VAR_56; VAR_58 < VAR_57; ++VAR_58) {
        int VAR_59 = VAR_49(VAR_58);
        /* COMMENT_18 */
        /* COMMENT_19 */
        /* COMMENT_20 */
        /* COMMENT_21 */
        /* COMMENT_22 */
        FastBoundsCheck(VAR_59 - VAR_52, VAR_53 - VAR_52);
        if (VAR_58 < VAR_5.NumElements()) {
          VAR_48(VAR_59) += VAR_50(VAR_58);
        }
      }
    }
  };

  const int64_t VAR_60 = VAR_6.tensor_in_rows * VAR_6.tensor_in_cols *
                             VAR_6.depth * VAR_6.window_rows *
                             VAR_6.window_cols;
  Shard(VAR_11.num_threads, VAR_11.workers,
        VAR_6.tensor_in_batch, VAR_60, VAR_12);
}",tensorflow/136b51f10903e044308cf77117c0ed9871350475/maxpooling_op.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,6 +13,7 @@
         errors::Internal(""SpatialMaxPoolWithArgMaxHelper requires Targmax ""
                          ""to be int64 when input_backprop != nullptr""));
   }
+  if (tensor_in.NumElements() == 0 || output->NumElements() == 0) return;
 
   typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>
       ConstEigenMatrixMap;","{'deleted_lines': [], 'added_lines': ['  if (tensor_in.NumElements() == 0 || output->NumElements() == 0) return;']}",True,"TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a denial of service via a segmentation fault in `tf.raw_ops.MaxPoolGrad` caused by missing validation. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/maxpooling_op.cc) misses some validation for the `orig_input` and `orig_output` tensors. The fixes for CVE-2021-29579 were incomplete. We have patched the issue in GitHub commit 136b51f10903e044308cf77117c0ed9871350475. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",5.5,MEDIUM,1,test,2021-07-31T03:50:00Z,3
CVE-2021-37639,"['CWE-476', 'CWE-125']",AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Fix NPE in restoring code.

PiperOrigin-RevId: 388303253
Change-Id: Ia8c68568cb854bca538909a182b31a618d68ce55",9e82dce6e6bd1f36a57e08fa85af213e2b2f2622,https://github.com/tensorflow/tensorflow/commit/9e82dce6e6bd1f36a57e08fa85af213e2b2f2622,tensorflow/core/kernels/save_restore_tensor.cc,RestoreTensor,"void RestoreTensor(OpKernelContext* context,
checkpoint::TensorSliceReader::OpenTableFunction open_func,
int preferred_shard, bool restore_slice, int restore_index) {
const Tensor& file_pattern_t = context->input(0);
{
const int64_t size = file_pattern_t.NumElements();
OP_REQUIRES(
context, size == 1,
errors::InvalidArgument(
""Input 0 (file_pattern) must be a string scalar; got a tensor of "",
size, ""elements""));
}
const string& file_pattern = file_pattern_t.flat<tstring>()(0);
const Tensor& tensor_name_t = context->input(1);
const string& tensor_name = tensor_name_t.flat<tstring>()(restore_index);
std::unique_ptr<checkpoint::TensorSliceReader> allocated_reader;
const checkpoint::TensorSliceReader* reader = nullptr;
if (context->slice_reader_cache()) {
reader = context->slice_reader_cache()->GetReader(file_pattern, open_func,
preferred_shard);
}
if (!reader) {
allocated_reader.reset(new checkpoint::TensorSliceReader(
file_pattern, open_func, preferred_shard));
reader = allocated_reader.get();
}
OP_REQUIRES_OK(context, CHECK_NOTNULL(reader)->status());
DataType type;
TensorShape saved_shape;
OP_REQUIRES(
context, reader->HasTensor(tensor_name, &saved_shape, &type),
errors::NotFound(""Tensor name \"""", tensor_name,
""\"" not found in checkpoint files "", file_pattern));
OP_REQUIRES(
context, type == context->expected_output_dtype(restore_index),
errors::InvalidArgument(""Expected to restore a tensor of type "",
DataTypeString(context->expected_output_dtype(0)),
"", got a tensor of type "", DataTypeString(type),
"" instead: tensor_name = "", tensor_name));
TensorShape output_shape(saved_shape);
TensorSlice slice_to_load(saved_shape.dims());
if (restore_slice) {
const tstring& shape_spec =
context->input(2).flat<tstring>()(restore_index);
if (!shape_spec.empty()) {
TensorShape parsed_shape;
OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(
shape_spec, &parsed_shape, &slice_to_load,
&output_shape));
OP_REQUIRES(
context, parsed_shape.IsSameSize(saved_shape),
errors::InvalidArgument(
""Shape in shape_and_slice spec does not match the shape in the ""
""save file: "",
parsed_shape.DebugString(),
"", save file shape: "", saved_shape.DebugString()));
}
}
Tensor* t = nullptr;
OP_REQUIRES_OK(context,
context->allocate_output(restore_index, output_shape, &t));
if (output_shape.num_elements() == 0) return;
#define READER_COPY(T)                                                \
case DataTypeToEnum<T>::value:                                      \
OP_REQUIRES(context,                                              \
reader->CopySliceData(tensor_name, slice_to_load,     \
t->flat<T>().data()),           \
errors::InvalidArgument(""Error copying slice data"")); \
break;
switch (type) {
TF_CALL_SAVE_RESTORE_TYPES(READER_COPY)
default:
context->SetStatus(errors::Unimplemented(
""Restoring data type "", DataTypeString(type), "" not yet supported""));
}
#undef READER_COPY
}","void RestoreTensor(OpKernelContext* VAR_0,
checkpoint::TensorSliceReader::OpenTableFunction VAR_1,
int VAR_2, bool VAR_3, int VAR_4) {
const Tensor& VAR_5 = VAR_0->input(0);
{
const int64_t VAR_6 = VAR_5.NumElements();
OP_REQUIRES(
VAR_0, VAR_6 == 1,
errors::InvalidArgument(
""Input 0 (file_pattern) must be a string scalar; got a tensor of "",
VAR_6, ""elements""));
}
const string& VAR_7 = VAR_5.flat<tstring>()(0);
const Tensor& VAR_8 = VAR_0->input(1);
const string& VAR_9 = VAR_8.flat<tstring>()(VAR_4);
std::unique_ptr<checkpoint::TensorSliceReader> VAR_10;
const checkpoint::TensorSliceReader* VAR_11 = nullptr;
if (VAR_0->slice_reader_cache()) {
VAR_11 = VAR_0->slice_reader_cache()->GetReader(VAR_7, VAR_1,
VAR_2);
}
if (!VAR_11) {
VAR_10.reset(new checkpoint::TensorSliceReader(
VAR_7, VAR_1, VAR_2));
VAR_11 = VAR_10.get();
}
OP_REQUIRES_OK(VAR_0, CHECK_NOTNULL(VAR_11)->status());
DataType VAR_12;
TensorShape VAR_13;
OP_REQUIRES(
VAR_0, VAR_11->HasTensor(VAR_9, &VAR_13, &VAR_12),
errors::NotFound(""Tensor name \"""", VAR_9,
""\"" not found in checkpoint files "", VAR_7));
OP_REQUIRES(
VAR_0, VAR_12 == VAR_0->expected_output_dtype(VAR_4),
errors::InvalidArgument(""Expected to restore a tensor of type "",
DataTypeString(VAR_0->expected_output_dtype(0)),
"", got a tensor of type "", DataTypeString(VAR_12),
"" instead: tensor_name = "", VAR_9));
TensorShape output_shape(saved_shape);
TensorSlice VAR_14(saved_shape.dims());
if (VAR_3) {
const tstring& VAR_15 =
VAR_0->input(2).flat<tstring>()(VAR_4);
if (!VAR_15.empty()) {
TensorShape VAR_16;
OP_REQUIRES_OK(VAR_0, checkpoint::ParseShapeAndSlice(
VAR_15, &VAR_16, &VAR_14,
&VAR_17));
OP_REQUIRES(
VAR_0, VAR_16.IsSameSize(saved_shape),
errors::InvalidArgument(
""Shape in shape_and_slice spec does not match the shape in the ""
""save file: "",
VAR_16.DebugString(),
"", save file shape: "", saved_shape.DebugString()));
}
}
Tensor* VAR_18 = nullptr;
OP_REQUIRES_OK(VAR_0,
VAR_0->allocate_output(VAR_4, VAR_17, &VAR_18));
if (VAR_17.num_elements() == 0) return;
#define READER_COPY(VAR_19)                                                \
case DataTypeToEnum<T>::value:                                      \
OP_REQUIRES(context,                                              \
reader->CopySliceData(tensor_name, slice_to_load,     \
t->flat<T>().data()),           \
errors::InvalidArgument(""Error copying slice data"")); \
break;
switch (VAR_12) {
TF_CALL_SAVE_RESTORE_TYPES(VAR_20)
default:
VAR_0->SetStatus(errors::Unimplemented(
""Restoring data type "", DataTypeString(VAR_12), "" not yet supported""));
}
#undef READER_COPY
}",tensorflow/9e82dce6e6bd1f36a57e08fa85af213e2b2f2622/save_restore_tensor.cc/vul/before/0.json,"void RestoreTensor(OpKernelContext* context,
                   checkpoint::TensorSliceReader::OpenTableFunction open_func,
                   int preferred_shard, bool restore_slice, int restore_index) {
  const Tensor& file_pattern_t = context->input(0);
  {
    const int64_t size = file_pattern_t.NumElements();
    OP_REQUIRES(
        context, size == 1,
        errors::InvalidArgument(
            ""Input 0 (file_pattern) must be a string scalar; got a tensor of "",
            size, "" elements""));
  }
  const string& file_pattern = file_pattern_t.flat<tstring>()(0);

  const Tensor& tensor_name_t = context->input(1);
  {
    const int64_t size = tensor_name_t.NumElements();
    OP_REQUIRES(context, size > restore_index,
                errors::InvalidArgument(
                    ""Input 1 (file_pattern) must be a have at least "",
                    restore_index + 1, "" elements""));
  }
  const string& tensor_name = tensor_name_t.flat<tstring>()(restore_index);

  // If we cannot find a cached reader we will allocate our own.
  std::unique_ptr<checkpoint::TensorSliceReader> allocated_reader;

  const checkpoint::TensorSliceReader* reader = nullptr;

  if (context->slice_reader_cache()) {
    reader = context->slice_reader_cache()->GetReader(file_pattern, open_func,
                                                      preferred_shard);
  }
  if (!reader) {
    allocated_reader.reset(new checkpoint::TensorSliceReader(
        file_pattern, open_func, preferred_shard));
    reader = allocated_reader.get();
  }
  OP_REQUIRES_OK(context, CHECK_NOTNULL(reader)->status());

  // Get the shape and type from the save file.
  DataType type;
  TensorShape saved_shape;
  OP_REQUIRES(
      context, reader->HasTensor(tensor_name, &saved_shape, &type),
      errors::NotFound(""Tensor name \"""", tensor_name,
                       ""\"" not found in checkpoint files "", file_pattern));
  OP_REQUIRES(
      context, type == context->expected_output_dtype(restore_index),
      errors::InvalidArgument(""Expected to restore a tensor of type "",
                              DataTypeString(context->expected_output_dtype(0)),
                              "", got a tensor of type "", DataTypeString(type),
                              "" instead: tensor_name = "", tensor_name));

  // Shape of the output and slice to load.
  TensorShape output_shape(saved_shape);
  TensorSlice slice_to_load(saved_shape.dims());
  if (restore_slice) {
    const tstring& shape_spec =
        context->input(2).flat<tstring>()(restore_index);
    if (!shape_spec.empty()) {
      TensorShape parsed_shape;
      OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(
                                  shape_spec, &parsed_shape, &slice_to_load,
                                  &output_shape));
      OP_REQUIRES(
          context, parsed_shape.IsSameSize(saved_shape),
          errors::InvalidArgument(
              ""Shape in shape_and_slice spec does not match the shape in the ""
              ""save file: "",
              parsed_shape.DebugString(),
              "", save file shape: "", saved_shape.DebugString()));
    }
  }

  Tensor* t = nullptr;
  OP_REQUIRES_OK(context,
                 context->allocate_output(restore_index, output_shape, &t));

  if (output_shape.num_elements() == 0) return;

#define READER_COPY(T)                                                \
  case DataTypeToEnum<T>::value:                                      \
    OP_REQUIRES(context,                                              \
                reader->CopySliceData(tensor_name, slice_to_load,     \
                                      t->flat<T>().data()),           \
                errors::InvalidArgument(""Error copying slice data"")); \
    break;

  switch (type) {
    TF_CALL_SAVE_RESTORE_TYPES(READER_COPY)
    default:
      context->SetStatus(errors::Unimplemented(
          ""Restoring data type "", DataTypeString(type), "" not yet supported""));
  }
#undef READER_COPY
}","void RestoreTensor(OpKernelContext* VAR_0,
                   checkpoint::TensorSliceReader::OpenTableFunction VAR_1,
                   int VAR_2, bool VAR_3, int VAR_4) {
  const Tensor& VAR_5 = VAR_0->input(0);
  {
    const int64_t VAR_6 = VAR_5.NumElements();
    OP_REQUIRES(
        VAR_0, VAR_6 == 1,
        errors::InvalidArgument(
            ""Input 0 (file_pattern) must be a string scalar; got a tensor of "",
            VAR_6, "" elements""));
  }
  const string& VAR_7 = VAR_5.flat<tstring>()(0);

  const Tensor& VAR_8 = VAR_0->input(1);
  {
    const int64_t VAR_6 = VAR_8.NumElements();
    OP_REQUIRES(VAR_0, VAR_6 > VAR_4,
                errors::InvalidArgument(
                    ""Input 1 (file_pattern) must be a have at least "",
                    VAR_4 + 1, "" elements""));
  }
  const string& VAR_9 = VAR_8.flat<tstring>()(VAR_4);

  /* COMMENT_0 */
  std::unique_ptr<checkpoint::TensorSliceReader> VAR_10;

  const checkpoint::TensorSliceReader* VAR_11 = nullptr;

  if (VAR_0->slice_reader_cache()) {
    VAR_11 = VAR_0->slice_reader_cache()->GetReader(VAR_7, VAR_1,
                                                      VAR_2);
  }
  if (!VAR_11) {
    VAR_10.reset(new checkpoint::TensorSliceReader(
        VAR_7, VAR_1, VAR_2));
    VAR_11 = VAR_10.get();
  }
  OP_REQUIRES_OK(VAR_0, CHECK_NOTNULL(VAR_11)->status());

  /* COMMENT_1 */
  DataType VAR_12;
  TensorShape VAR_13;
  OP_REQUIRES(
      VAR_0, VAR_11->HasTensor(VAR_9, &VAR_13, &VAR_12),
      errors::NotFound(""Tensor name \"""", VAR_9,
                       ""\"" not found in checkpoint files "", VAR_7));
  OP_REQUIRES(
      VAR_0, VAR_12 == VAR_0->expected_output_dtype(VAR_4),
      errors::InvalidArgument(""Expected to restore a tensor of type "",
                              DataTypeString(VAR_0->expected_output_dtype(0)),
                              "", got a tensor of type "", DataTypeString(VAR_12),
                              "" instead: tensor_name = "", VAR_9));

  /* COMMENT_2 */
  TensorShape output_shape(saved_shape);
  TensorSlice VAR_14(saved_shape.dims());
  if (VAR_3) {
    const tstring& VAR_15 =
        VAR_0->input(2).flat<tstring>()(VAR_4);
    if (!VAR_15.empty()) {
      TensorShape VAR_16;
      OP_REQUIRES_OK(VAR_0, checkpoint::ParseShapeAndSlice(
                                  VAR_15, &VAR_16, &VAR_14,
                                  &VAR_17));
      OP_REQUIRES(
          VAR_0, VAR_16.IsSameSize(saved_shape),
          errors::InvalidArgument(
              ""Shape in shape_and_slice spec does not match the shape in the ""
              ""save file: "",
              VAR_16.DebugString(),
              "", save file shape: "", saved_shape.DebugString()));
    }
  }

  Tensor* VAR_18 = nullptr;
  OP_REQUIRES_OK(VAR_0,
                 VAR_0->allocate_output(VAR_4, VAR_17, &VAR_18));

  if (VAR_17.num_elements() == 0) return;

#define READER_COPY(VAR_19)                                                \
  case DataTypeToEnum<T>::value:                                      \
    OP_REQUIRES(context,                                              \
                reader->CopySliceData(tensor_name, slice_to_load,     \
                                      t->flat<T>().data()),           \
                errors::InvalidArgument(""Error copying slice data"")); \
    break;

  switch (VAR_12) {
    TF_CALL_SAVE_RESTORE_TYPES(VAR_20)
    default:
      VAR_0->SetStatus(errors::Unimplemented(
          ""Restoring data type "", DataTypeString(VAR_12), "" not yet supported""));
  }
#undef READER_COPY
}",tensorflow/9e82dce6e6bd1f36a57e08fa85af213e2b2f2622/save_restore_tensor.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,11 +8,18 @@
         context, size == 1,
         errors::InvalidArgument(
             ""Input 0 (file_pattern) must be a string scalar; got a tensor of "",
-            size, ""elements""));
+            size, "" elements""));
   }
   const string& file_pattern = file_pattern_t.flat<tstring>()(0);
 
   const Tensor& tensor_name_t = context->input(1);
+  {
+    const int64_t size = tensor_name_t.NumElements();
+    OP_REQUIRES(context, size > restore_index,
+                errors::InvalidArgument(
+                    ""Input 1 (file_pattern) must be a have at least "",
+                    restore_index + 1, "" elements""));
+  }
   const string& tensor_name = tensor_name_t.flat<tstring>()(restore_index);
 
   // If we cannot find a cached reader we will allocate our own.","{'deleted_lines': ['            size, ""elements""));'], 'added_lines': ['            size, "" elements""));', '  {', '    const int64_t size = tensor_name_t.NumElements();', '    OP_REQUIRES(context, size > restore_index,', '                errors::InvalidArgument(', '                    ""Input 1 (file_pattern) must be a have at least "",', '                    restore_index + 1, "" elements""));', '  }']}",True,"TensorFlow is an end-to-end open source platform for machine learning. When restoring tensors via raw APIs, if the tensor name is not provided, TensorFlow can be tricked into dereferencing a null pointer. Alternatively, attackers can read memory outside the bounds of heap allocated data by providing some tensor names but not enough for a successful restoration. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/save_restore_tensor.cc#L158-L159) retrieves the tensor list corresponding to the `tensor_name` user controlled input and immediately retrieves the tensor at the restoration index (controlled via `preferred_shard` argument). This occurs without validating that the provided list has enough values. If the list is empty this results in dereferencing a null pointer (undefined behavior). If, however, the list has some elements, if the restoration index is outside the bounds this results in heap OOB read. We have patched the issue in GitHub commit 9e82dce6e6bd1f36a57e08fa85af213e2b2f2622. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",8.4,HIGH,2,test,2021-08-02T21:21:41Z,3
CVE-2021-23177,['CWE-59'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,libarchive,"Fix handling of symbolic link ACLs

On Linux ACLs on symbolic links are not supported.
We must avoid calling acl_set_file() on symbolic links as their
targets are modified instead.

While here, do not try to set default ACLs on non-directories.

Fixes #1565",fba4f123cc456d2b2538f811bb831483bf336bad,https://github.com/libarchive/libarchive/commit/fba4f123cc456d2b2538f811bb831483bf336bad,libarchive/archive_disk_acl_linux.c,set_richacl,"static int
set_richacl(struct archive *a, int fd, const char *name,
struct archive_acl *abstract_acl, __LA_MODE_T mode,
int ae_requested_type, const char *tname)
{
int ae_type, ae_permset, ae_tag, ae_id;
uid_t ae_uid;
gid_t ae_gid;
const char*ae_name;
int entries;
int i;
int ret;
int e = 0;
struct richacl  *richacl = NULL;
struct richace  *richace;
ret = ARCHIVE_OK;
entries = archive_acl_reset(abstract_acl, ae_requested_type);
if (entries == 0)
return (ARCHIVE_OK);
if (ae_requested_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {
errno = ENOENT;
archive_set_error(a, errno, ""Unsupported ACL type"");
return (ARCHIVE_FAILED);
}
richacl = richacl_alloc(entries);
if (richacl == NULL) {
archive_set_error(a, errno,
""Failed to initialize RichACL working storage"");
return (ARCHIVE_FAILED);
}
e = 0;
while (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,
&ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {
richace = &(richacl->a_entries[e]);
richace->e_flags = 0;
richace->e_mask = 0;
switch (ae_tag) {
case ARCHIVE_ENTRY_ACL_USER:
ae_uid = archive_write_disk_uid(a, ae_name, ae_id);
richace->e_id = ae_uid;
break;
case ARCHIVE_ENTRY_ACL_GROUP:
ae_gid = archive_write_disk_gid(a, ae_name, ae_id);
richace->e_id = ae_gid;
richace->e_flags |= RICHACE_IDENTIFIER_GROUP;
break;
case ARCHIVE_ENTRY_ACL_USER_OBJ:
richace->e_flags |= RICHACE_SPECIAL_WHO;
richace->e_id = RICHACE_OWNER_SPECIAL_ID;
break;
case ARCHIVE_ENTRY_ACL_GROUP_OBJ:
richace->e_flags |= RICHACE_SPECIAL_WHO;
richace->e_id = RICHACE_GROUP_SPECIAL_ID;
break;
case ARCHIVE_ENTRY_ACL_EVERYONE:
richace->e_flags |= RICHACE_SPECIAL_WHO;
richace->e_id = RICHACE_EVERYONE_SPECIAL_ID;
break;
default:
archive_set_error(a, ARCHIVE_ERRNO_MISC,
""Unsupported ACL tag"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
switch (ae_type) {
case ARCHIVE_ENTRY_ACL_TYPE_ALLOW:
richace->e_type =
RICHACE_ACCESS_ALLOWED_ACE_TYPE;
break;
case ARCHIVE_ENTRY_ACL_TYPE_DENY:
richace->e_type =
RICHACE_ACCESS_DENIED_ACE_TYPE;
break;
case ARCHIVE_ENTRY_ACL_TYPE_AUDIT:
case ARCHIVE_ENTRY_ACL_TYPE_ALARM:
break;
default:
archive_set_error(a, ARCHIVE_ERRNO_MISC,
""Unsupported ACL entry type"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
for (i = 0; i < acl_nfs4_perm_map_size; ++i) {
if (ae_permset & acl_nfs4_perm_map[i].a_perm)
richace->e_mask |= acl_nfs4_perm_map[i].p_perm;
}
for (i = 0; i < acl_nfs4_flag_map_size; ++i) {
if (ae_permset &
acl_nfs4_flag_map[i].a_perm)
richace->e_flags |= acl_nfs4_flag_map[i].p_perm;
}
e++;
}
_richacl_mode_to_masks(richacl, mode);
if (fd >= 0) {
if (richacl_set_fd(fd, richacl) == 0)
ret = ARCHIVE_OK;
else {
if (errno == EOPNOTSUPP) {
ret = ARCHIVE_OK;
} else {
archive_set_error(a, errno,
""Failed to set richacl on fd: %s"", tname);
ret = ARCHIVE_WARN;
}
}
} else if (richacl_set_file(name, richacl) != 0) {
if (errno == EOPNOTSUPP) {
ret = ARCHIVE_OK;
} else {
archive_set_error(a, errno, ""Failed to set richacl: %s"",
tname);
ret = ARCHIVE_WARN;
}
}
exit_free:
richacl_free(richacl);
return (ret);
}","static int
set_richacl(struct archive *VAR_0, int VAR_1, const char *VAR_2,
struct archive_acl *VAR_3, __LA_MODE_T VAR_4,
int VAR_5, const char *VAR_6)
{
int VAR_7, VAR_8, VAR_9, VAR_10;
uid_t VAR_11;
gid_t VAR_12;
const char*VAR_13;
int VAR_14;
int VAR_15;
int VAR_16;
int VAR_17 = 0;
struct richacl  *richacl = NULL;
struct richace  *richace;
VAR_16 = VAR_18;
VAR_14 = archive_acl_reset(VAR_3, VAR_5);
if (VAR_14 == 0)
return (VAR_18);
if (VAR_5 != VAR_19) {
VAR_20 = VAR_21;
archive_set_error(VAR_0, VAR_20, ""Unsupported ACL type"");
return (VAR_22);
}
richacl = richacl_alloc(VAR_14);
if (richacl == NULL) {
archive_set_error(VAR_0, VAR_20,
""Failed to initialize RichACL working storage"");
return (VAR_22);
}
VAR_17 = 0;
while (archive_acl_next(VAR_0, VAR_3, VAR_5, &VAR_7,
&VAR_8, &VAR_9, &VAR_10, &VAR_13) == VAR_18) {
richace = &(richacl->a_entries[VAR_17]);
richace->e_flags = 0;
richace->e_mask = 0;
switch (VAR_9) {
case VAR_23:
VAR_11 = archive_write_disk_uid(VAR_0, VAR_13, VAR_10);
richace->e_id = VAR_11;
break;
case VAR_24:
VAR_12 = archive_write_disk_gid(VAR_0, VAR_13, VAR_10);
richace->e_id = VAR_12;
richace->e_flags |= VAR_25;
break;
case VAR_26:
richace->e_flags |= VAR_27;
richace->e_id = VAR_28;
break;
case VAR_29:
richace->e_flags |= VAR_27;
richace->e_id = VAR_30;
break;
case VAR_31:
richace->e_flags |= VAR_27;
richace->e_id = VAR_32;
break;
default:
archive_set_error(VAR_0, VAR_33,
""Unsupported ACL tag"");
VAR_16 = VAR_22;
goto exit_free;
}
switch (VAR_7) {
case VAR_34:
richace->e_type =
VAR_35;
break;
case VAR_36:
richace->e_type =
VAR_37;
break;
case VAR_38:
case VAR_39:
break;
default:
archive_set_error(VAR_0, VAR_33,
""Unsupported ACL entry type"");
VAR_16 = VAR_22;
goto exit_free;
}
for (VAR_15 = 0; VAR_15 < VAR_40; ++VAR_15) {
if (VAR_8 & VAR_41[VAR_15].a_perm)
richace->e_mask |= VAR_41[VAR_15].p_perm;
}
for (VAR_15 = 0; VAR_15 < VAR_42; ++VAR_15) {
if (VAR_8 &
VAR_43[VAR_15].a_perm)
richace->e_flags |= VAR_43[VAR_15].p_perm;
}
VAR_17++;
}
_richacl_mode_to_masks(richacl, VAR_4);
if (VAR_1 >= 0) {
if (richacl_set_fd(VAR_1, richacl) == 0)
VAR_16 = VAR_18;
else {
if (VAR_20 == VAR_44) {
VAR_16 = VAR_18;
} else {
archive_set_error(VAR_0, VAR_20,
""Failed to set richacl on fd: %s"", VAR_6);
VAR_16 = VAR_45;
}
}
} else if (richacl_set_file(VAR_2, richacl) != 0) {
if (VAR_20 == VAR_44) {
VAR_16 = VAR_18;
} else {
archive_set_error(VAR_0, VAR_20, ""Failed to set richacl: %s"",
VAR_6);
VAR_16 = VAR_45;
}
}
exit_free:
richacl_free(richacl);
return (VAR_16);
}",libarchive/fba4f123cc456d2b2538f811bb831483bf336bad/archive_disk_acl_linux.c/vul/before/2.json,"static int
set_richacl(struct archive *a, int fd, const char *name,
    struct archive_acl *abstract_acl, __LA_MODE_T mode,
    int ae_requested_type, const char *tname)
{
	int		 ae_type, ae_permset, ae_tag, ae_id;
	uid_t		 ae_uid;
	gid_t		 ae_gid;
	const char	*ae_name;
	int		 entries;
	int		 i;
	int		 ret;
	int		 e = 0;
	struct richacl  *richacl = NULL;
	struct richace  *richace;

	ret = ARCHIVE_OK;
	entries = archive_acl_reset(abstract_acl, ae_requested_type);
	if (entries == 0)
		return (ARCHIVE_OK);

	if (ae_requested_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {
		errno = ENOENT;
		archive_set_error(a, errno, ""Unsupported ACL type"");
		return (ARCHIVE_FAILED);
	}

	if (S_ISLNK(mode)) {
		/* Linux does not support RichACLs on symbolic links */
		return (ARCHIVE_OK);
	}

	richacl = richacl_alloc(entries);
	if (richacl == NULL) {
		archive_set_error(a, errno,
			""Failed to initialize RichACL working storage"");
		return (ARCHIVE_FAILED);
	}

	e = 0;

	while (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,
		   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {
		richace = &(richacl->a_entries[e]);

		richace->e_flags = 0;
		richace->e_mask = 0;

		switch (ae_tag) {
		case ARCHIVE_ENTRY_ACL_USER:
			ae_uid = archive_write_disk_uid(a, ae_name, ae_id);
			richace->e_id = ae_uid;
			break;
		case ARCHIVE_ENTRY_ACL_GROUP:
			ae_gid = archive_write_disk_gid(a, ae_name, ae_id);
			richace->e_id = ae_gid;
			richace->e_flags |= RICHACE_IDENTIFIER_GROUP;
			break;
		case ARCHIVE_ENTRY_ACL_USER_OBJ:
			richace->e_flags |= RICHACE_SPECIAL_WHO;
			richace->e_id = RICHACE_OWNER_SPECIAL_ID;
			break;
		case ARCHIVE_ENTRY_ACL_GROUP_OBJ:
			richace->e_flags |= RICHACE_SPECIAL_WHO;
			richace->e_id = RICHACE_GROUP_SPECIAL_ID;
			break;
		case ARCHIVE_ENTRY_ACL_EVERYONE:
			richace->e_flags |= RICHACE_SPECIAL_WHO;
			richace->e_id = RICHACE_EVERYONE_SPECIAL_ID;
			break;
		default:
			archive_set_error(a, ARCHIVE_ERRNO_MISC,
			    ""Unsupported ACL tag"");
			ret = ARCHIVE_FAILED;
			goto exit_free;
		}

		switch (ae_type) {
			case ARCHIVE_ENTRY_ACL_TYPE_ALLOW:
				richace->e_type =
				    RICHACE_ACCESS_ALLOWED_ACE_TYPE;
				break;
			case ARCHIVE_ENTRY_ACL_TYPE_DENY:
				richace->e_type =
				    RICHACE_ACCESS_DENIED_ACE_TYPE;
				break;
			case ARCHIVE_ENTRY_ACL_TYPE_AUDIT:
			case ARCHIVE_ENTRY_ACL_TYPE_ALARM:
				break;
		default:
			archive_set_error(a, ARCHIVE_ERRNO_MISC,
			    ""Unsupported ACL entry type"");
			ret = ARCHIVE_FAILED;
			goto exit_free;
		}

		for (i = 0; i < acl_nfs4_perm_map_size; ++i) {
			if (ae_permset & acl_nfs4_perm_map[i].a_perm)
				richace->e_mask |= acl_nfs4_perm_map[i].p_perm;
		}

		for (i = 0; i < acl_nfs4_flag_map_size; ++i) {
			if (ae_permset &
			    acl_nfs4_flag_map[i].a_perm)
				richace->e_flags |= acl_nfs4_flag_map[i].p_perm;
		}
	e++;
	}

	/* Fill RichACL masks */
	_richacl_mode_to_masks(richacl, mode);

	if (fd >= 0) {
		if (richacl_set_fd(fd, richacl) == 0)
			ret = ARCHIVE_OK;
		else {
			if (errno == EOPNOTSUPP) {
				/* Filesystem doesn't support ACLs */
				ret = ARCHIVE_OK;
			} else {
				archive_set_error(a, errno,
				    ""Failed to set richacl on fd: %s"", tname);
				ret = ARCHIVE_WARN;
			}
		}
	} else if (richacl_set_file(name, richacl) != 0) {
		if (errno == EOPNOTSUPP) {
			/* Filesystem doesn't support ACLs */
			ret = ARCHIVE_OK;
		} else {
			archive_set_error(a, errno, ""Failed to set richacl: %s"",
			    tname);
			ret = ARCHIVE_WARN;
		}
	}
exit_free:
	richacl_free(richacl);
	return (ret);
}","static int
set_richacl(struct archive *VAR_0, int VAR_1, const char *VAR_2,
    struct archive_acl *VAR_3, __LA_MODE_T VAR_4,
    int VAR_5, const char *VAR_6)
{
	int		 VAR_7, VAR_8, VAR_9, VAR_10;
	uid_t		 VAR_11;
	gid_t		 VAR_12;
	const char	*VAR_13;
	int		 VAR_14;
	int		 VAR_15;
	int		 VAR_16;
	int		 VAR_17 = 0;
	struct richacl  *richacl = NULL;
	struct richace  *richace;

	VAR_16 = VAR_18;
	VAR_14 = archive_acl_reset(VAR_3, VAR_5);
	if (VAR_14 == 0)
		return (VAR_18);

	if (VAR_5 != VAR_19) {
		VAR_20 = VAR_21;
		archive_set_error(VAR_0, VAR_20, ""Unsupported ACL type"");
		return (VAR_22);
	}

	if (S_ISLNK(VAR_4)) {
		/* COMMENT_0 */
		return (VAR_18);
	}

	richacl = richacl_alloc(VAR_14);
	if (richacl == NULL) {
		archive_set_error(VAR_0, VAR_20,
			""Failed to initialize RichACL working storage"");
		return (VAR_22);
	}

	VAR_17 = 0;

	while (archive_acl_next(VAR_0, VAR_3, VAR_5, &VAR_7,
		   &VAR_8, &VAR_9, &VAR_10, &VAR_13) == VAR_18) {
		richace = &(richacl->a_entries[VAR_17]);

		richace->e_flags = 0;
		richace->e_mask = 0;

		switch (VAR_9) {
		case VAR_23:
			VAR_11 = archive_write_disk_uid(VAR_0, VAR_13, VAR_10);
			richace->e_id = VAR_11;
			break;
		case VAR_24:
			VAR_12 = archive_write_disk_gid(VAR_0, VAR_13, VAR_10);
			richace->e_id = VAR_12;
			richace->e_flags |= VAR_25;
			break;
		case VAR_26:
			richace->e_flags |= VAR_27;
			richace->e_id = VAR_28;
			break;
		case VAR_29:
			richace->e_flags |= VAR_27;
			richace->e_id = VAR_30;
			break;
		case VAR_31:
			richace->e_flags |= VAR_27;
			richace->e_id = VAR_32;
			break;
		default:
			archive_set_error(VAR_0, VAR_33,
			    ""Unsupported ACL tag"");
			VAR_16 = VAR_22;
			goto exit_free;
		}

		switch (VAR_7) {
			case VAR_34:
				richace->e_type =
				    VAR_35;
				break;
			case VAR_36:
				richace->e_type =
				    VAR_37;
				break;
			case VAR_38:
			case VAR_39:
				break;
		default:
			archive_set_error(VAR_0, VAR_33,
			    ""Unsupported ACL entry type"");
			VAR_16 = VAR_22;
			goto exit_free;
		}

		for (VAR_15 = 0; VAR_15 < VAR_40; ++VAR_15) {
			if (VAR_8 & VAR_41[VAR_15].a_perm)
				richace->e_mask |= VAR_41[VAR_15].p_perm;
		}

		for (VAR_15 = 0; VAR_15 < VAR_42; ++VAR_15) {
			if (VAR_8 &
			    VAR_43[VAR_15].a_perm)
				richace->e_flags |= VAR_43[VAR_15].p_perm;
		}
	VAR_17++;
	}

	/* COMMENT_1 */
	_richacl_mode_to_masks(richacl, VAR_4);

	if (VAR_1 >= 0) {
		if (richacl_set_fd(VAR_1, richacl) == 0)
			VAR_16 = VAR_18;
		else {
			if (VAR_20 == VAR_44) {
				/* COMMENT_2 */
				VAR_16 = VAR_18;
			} else {
				archive_set_error(VAR_0, VAR_20,
				    ""Failed to set richacl on fd: %s"", VAR_6);
				VAR_16 = VAR_45;
			}
		}
	} else if (richacl_set_file(VAR_2, richacl) != 0) {
		if (VAR_20 == VAR_44) {
			/* COMMENT_2 */
			VAR_16 = VAR_18;
		} else {
			archive_set_error(VAR_0, VAR_20, ""Failed to set richacl: %s"",
			    VAR_6);
			VAR_16 = VAR_45;
		}
	}
exit_free:
	richacl_free(richacl);
	return (VAR_16);
}",libarchive/fba4f123cc456d2b2538f811bb831483bf336bad/archive_disk_acl_linux.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -23,6 +23,11 @@
 		errno = ENOENT;
 		archive_set_error(a, errno, ""Unsupported ACL type"");
 		return (ARCHIVE_FAILED);
+	}
+
+	if (S_ISLNK(mode)) {
+		/* Linux does not support RichACLs on symbolic links */
+		return (ARCHIVE_OK);
 	}
 
 	richacl = richacl_alloc(entries);","{'deleted_lines': [], 'added_lines': ['\t}', '', '\tif (S_ISLNK(mode)) {', '\t\t/* Linux does not support RichACLs on symbolic links */', '\t\treturn (ARCHIVE_OK);']}",True,"An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges.",7.8,HIGH,2,test,2021-08-21T18:51:07Z,3
CVE-2021-23177,['CWE-59'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,libarchive,"Fix handling of symbolic link ACLs

On Linux ACLs on symbolic links are not supported.
We must avoid calling acl_set_file() on symbolic links as their
targets are modified instead.

While here, do not try to set default ACLs on non-directories.

Fixes #1565",fba4f123cc456d2b2538f811bb831483bf336bad,https://github.com/libarchive/libarchive/commit/fba4f123cc456d2b2538f811bb831483bf336bad,libarchive/archive_disk_acl_linux.c,archive_write_disk_set_acls,"int
archive_write_disk_set_acls(struct archive *a, int fd, const char *name,
struct archive_acl *abstract_acl, __LA_MODE_T mode)
{
intret = ARCHIVE_OK;
#if !ARCHIVE_ACL_LIBRICHACL
(void)mode;
#endif
#if ARCHIVE_ACL_LIBRICHACL
if ((archive_acl_types(abstract_acl)
& ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {
ret = set_richacl(a, fd, name, abstract_acl, mode,
ARCHIVE_ENTRY_ACL_TYPE_NFS4, ""nfs4"");
}
#if ARCHIVE_ACL_LIBACL
else
#endif
#endif
#if ARCHIVE_ACL_LIBACL
if ((archive_acl_types(abstract_acl)
& ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {
if ((archive_acl_types(abstract_acl)
& ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {
ret = set_acl(a, fd, name, abstract_acl,
ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ""access"");
if (ret != ARCHIVE_OK)
return (ret);
}
if ((archive_acl_types(abstract_acl)
& ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)
ret = set_acl(a, fd, name, abstract_acl,
ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, ""default"");
}
#endif
return (ret);
}","int
archive_write_disk_set_acls(struct archive *VAR_0, int VAR_1, const char *VAR_2,
struct archive_acl *VAR_3, __LA_MODE_T VAR_4)
{
intVAR_5 = VAR_6;
#if !VAR_7
(void)VAR_4;
#endif
#if VAR_7
if ((archive_acl_types(VAR_3)
& VAR_8) != 0) {
VAR_5 = set_richacl(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
VAR_8, ""nfs4"");
}
#if VAR_9
else
#endif
#endif
#if VAR_9
if ((archive_acl_types(VAR_3)
& VAR_10) != 0) {
if ((archive_acl_types(VAR_3)
& VAR_11) != 0) {
VAR_5 = set_acl(VAR_0, VAR_1, VAR_2, VAR_3,
VAR_11, ""access"");
if (VAR_5 != VAR_6)
return (VAR_5);
}
if ((archive_acl_types(VAR_3)
& VAR_12) != 0)
VAR_5 = set_acl(VAR_0, VAR_1, VAR_2, VAR_3,
VAR_12, ""default"");
}
#endif
return (VAR_5);
}",libarchive/fba4f123cc456d2b2538f811bb831483bf336bad/archive_disk_acl_linux.c/vul/before/1.json,"int
archive_write_disk_set_acls(struct archive *a, int fd, const char *name,
    struct archive_acl *abstract_acl, __LA_MODE_T mode)
{
	int		ret = ARCHIVE_OK;

#if !ARCHIVE_ACL_LIBRICHACL
	(void)mode;	/* UNUSED */
#endif

#if ARCHIVE_ACL_LIBRICHACL
	if ((archive_acl_types(abstract_acl)
	    & ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {
		ret = set_richacl(a, fd, name, abstract_acl, mode,
		    ARCHIVE_ENTRY_ACL_TYPE_NFS4, ""nfs4"");
	}
#if ARCHIVE_ACL_LIBACL
	else
#endif
#endif	/* ARCHIVE_ACL_LIBRICHACL */
#if ARCHIVE_ACL_LIBACL
	if ((archive_acl_types(abstract_acl)
	    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {
		if ((archive_acl_types(abstract_acl)
		    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {
			ret = set_acl(a, fd, name, abstract_acl, mode,
			    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ""access"");
			if (ret != ARCHIVE_OK)
				return (ret);
		}
		if ((archive_acl_types(abstract_acl)
		    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)
			ret = set_acl(a, fd, name, abstract_acl, mode,
			    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, ""default"");
	}
#endif	/* ARCHIVE_ACL_LIBACL */
	return (ret);
}","int
archive_write_disk_set_acls(struct archive *VAR_0, int VAR_1, const char *VAR_2,
    struct archive_acl *VAR_3, __LA_MODE_T VAR_4)
{
	int		VAR_5 = VAR_6;

#if !VAR_7
	(void)VAR_4;	/* COMMENT_0 */
#endif

#if VAR_7
	if ((archive_acl_types(VAR_3)
	    & VAR_8) != 0) {
		VAR_5 = set_richacl(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
		    VAR_8, ""nfs4"");
	}
#if VAR_9
	else
#endif
#endif	/* COMMENT_1 */
#if VAR_9
	if ((archive_acl_types(VAR_3)
	    & VAR_10) != 0) {
		if ((archive_acl_types(VAR_3)
		    & VAR_11) != 0) {
			VAR_5 = set_acl(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
			    VAR_11, ""access"");
			if (VAR_5 != VAR_6)
				return (VAR_5);
		}
		if ((archive_acl_types(VAR_3)
		    & VAR_12) != 0)
			VAR_5 = set_acl(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
			    VAR_12, ""default"");
	}
#endif	/* COMMENT_2 */
	return (VAR_5);
}",libarchive/fba4f123cc456d2b2538f811bb831483bf336bad/archive_disk_acl_linux.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -23,14 +23,14 @@
 	    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {
 		if ((archive_acl_types(abstract_acl)
 		    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {
-			ret = set_acl(a, fd, name, abstract_acl,
+			ret = set_acl(a, fd, name, abstract_acl, mode,
 			    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ""access"");
 			if (ret != ARCHIVE_OK)
 				return (ret);
 		}
 		if ((archive_acl_types(abstract_acl)
 		    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)
-			ret = set_acl(a, fd, name, abstract_acl,
+			ret = set_acl(a, fd, name, abstract_acl, mode,
 			    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, ""default"");
 	}
 #endif	/* ARCHIVE_ACL_LIBACL */","{'deleted_lines': ['\t\t\tret = set_acl(a, fd, name, abstract_acl,', '\t\t\tret = set_acl(a, fd, name, abstract_acl,'], 'added_lines': ['\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,', '\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,']}",True,"An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges.",7.8,HIGH,2,test,2021-08-21T18:51:07Z,3
CVE-2021-23177,['CWE-59'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,libarchive,"Fix handling of symbolic link ACLs

On Linux ACLs on symbolic links are not supported.
We must avoid calling acl_set_file() on symbolic links as their
targets are modified instead.

While here, do not try to set default ACLs on non-directories.

Fixes #1565",fba4f123cc456d2b2538f811bb831483bf336bad,https://github.com/libarchive/libarchive/commit/fba4f123cc456d2b2538f811bb831483bf336bad,libarchive/archive_disk_acl_freebsd.c,archive_write_disk_set_acls,"int
archive_write_disk_set_acls(struct archive *a, int fd, const char *name,
struct archive_acl *abstract_acl, __LA_MODE_T mode)
{
intret = ARCHIVE_OK;
(void)mode;
if ((archive_acl_types(abstract_acl)
& ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {
if ((archive_acl_types(abstract_acl)
& ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {
ret = set_acl(a, fd, name, abstract_acl,
ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ""access"");
if (ret != ARCHIVE_OK)
return (ret);
}
if ((archive_acl_types(abstract_acl)
& ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)
ret = set_acl(a, fd, name, abstract_acl,
ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, ""default"");
return (ret);
}
#if ARCHIVE_ACL_FREEBSD_NFS4
else if ((archive_acl_types(abstract_acl) &
ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {
ret = set_acl(a, fd, name, abstract_acl,
ARCHIVE_ENTRY_ACL_TYPE_NFS4, ""nfs4"");
}
#endif
return (ret);
}","int
archive_write_disk_set_acls(struct archive *VAR_0, int VAR_1, const char *VAR_2,
struct archive_acl *VAR_3, __LA_MODE_T VAR_4)
{
intVAR_5 = VAR_6;
(void)VAR_4;
if ((archive_acl_types(VAR_3)
& VAR_7) != 0) {
if ((archive_acl_types(VAR_3)
& VAR_8) != 0) {
VAR_5 = set_acl(VAR_0, VAR_1, VAR_2, VAR_3,
VAR_8, ""access"");
if (VAR_5 != VAR_6)
return (VAR_5);
}
if ((archive_acl_types(VAR_3)
& VAR_9) != 0)
VAR_5 = set_acl(VAR_0, VAR_1, VAR_2, VAR_3,
VAR_9, ""default"");
return (VAR_5);
}
#if VAR_10
else if ((VAR_11(abstract_acl) &
VAR_12) != 0) {
VAR_5 = set_acl(VAR_0, VAR_1, VAR_2, abstract_acl,
VAR_12, ""nfs4"");
}
#endif
return (VAR_5);
}",libarchive/fba4f123cc456d2b2538f811bb831483bf336bad/archive_disk_acl_freebsd.c/vul/before/0.json,"int
archive_write_disk_set_acls(struct archive *a, int fd, const char *name,
    struct archive_acl *abstract_acl, __LA_MODE_T mode)
{
	int		ret = ARCHIVE_OK;

	(void)mode;	/* UNUSED */

	if ((archive_acl_types(abstract_acl)
	    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {
		if ((archive_acl_types(abstract_acl)
		    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {
			ret = set_acl(a, fd, name, abstract_acl, mode,
			    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ""access"");
			if (ret != ARCHIVE_OK)
				return (ret);
		}
		if ((archive_acl_types(abstract_acl)
		    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)
			ret = set_acl(a, fd, name, abstract_acl, mode,
			    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, ""default"");

		/* Simultaneous POSIX.1e and NFSv4 is not supported */
		return (ret);
	}
#if ARCHIVE_ACL_FREEBSD_NFS4
	else if ((archive_acl_types(abstract_acl) &
	    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {
		ret = set_acl(a, fd, name, abstract_acl, mode,
		    ARCHIVE_ENTRY_ACL_TYPE_NFS4, ""nfs4"");
	}
#endif
	return (ret);
}","int
archive_write_disk_set_acls(struct archive *VAR_0, int VAR_1, const char *VAR_2,
    struct archive_acl *VAR_3, __LA_MODE_T VAR_4)
{
	int		VAR_5 = VAR_6;

	(void)VAR_4;	/* COMMENT_0 */

	if ((archive_acl_types(VAR_3)
	    & VAR_7) != 0) {
		if ((archive_acl_types(VAR_3)
		    & VAR_8) != 0) {
			VAR_5 = set_acl(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
			    VAR_8, ""access"");
			if (VAR_5 != VAR_6)
				return (VAR_5);
		}
		if ((archive_acl_types(VAR_3)
		    & VAR_9) != 0)
			VAR_5 = set_acl(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
			    VAR_9, ""default"");

		/* COMMENT_1 */
		return (VAR_5);
	}
#if VAR_10
	else if ((VAR_11(abstract_acl) &
	    VAR_12) != 0) {
		VAR_5 = set_acl(VAR_0, VAR_1, VAR_2, abstract_acl, VAR_4,
		    VAR_12, ""nfs4"");
	}
#endif
	return (VAR_5);
}",libarchive/fba4f123cc456d2b2538f811bb831483bf336bad/archive_disk_acl_freebsd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,14 +10,14 @@
 	    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {
 		if ((archive_acl_types(abstract_acl)
 		    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {
-			ret = set_acl(a, fd, name, abstract_acl,
+			ret = set_acl(a, fd, name, abstract_acl, mode,
 			    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ""access"");
 			if (ret != ARCHIVE_OK)
 				return (ret);
 		}
 		if ((archive_acl_types(abstract_acl)
 		    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)
-			ret = set_acl(a, fd, name, abstract_acl,
+			ret = set_acl(a, fd, name, abstract_acl, mode,
 			    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, ""default"");
 
 		/* Simultaneous POSIX.1e and NFSv4 is not supported */
@@ -26,7 +26,7 @@
 #if ARCHIVE_ACL_FREEBSD_NFS4
 	else if ((archive_acl_types(abstract_acl) &
 	    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {
-		ret = set_acl(a, fd, name, abstract_acl,
+		ret = set_acl(a, fd, name, abstract_acl, mode,
 		    ARCHIVE_ENTRY_ACL_TYPE_NFS4, ""nfs4"");
 	}
 #endif","{'deleted_lines': ['\t\t\tret = set_acl(a, fd, name, abstract_acl,', '\t\t\tret = set_acl(a, fd, name, abstract_acl,', '\t\tret = set_acl(a, fd, name, abstract_acl,'], 'added_lines': ['\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,', '\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,', '\t\tret = set_acl(a, fd, name, abstract_acl, mode,']}",True,"An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges.",7.8,HIGH,2,test,2021-08-21T18:51:07Z,3
CVE-2021-23177,['CWE-59'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,libarchive,"Fix handling of symbolic link ACLs

On Linux ACLs on symbolic links are not supported.
We must avoid calling acl_set_file() on symbolic links as their
targets are modified instead.

While here, do not try to set default ACLs on non-directories.

Fixes #1565",fba4f123cc456d2b2538f811bb831483bf336bad,https://github.com/libarchive/libarchive/commit/fba4f123cc456d2b2538f811bb831483bf336bad,libarchive/archive_disk_acl_linux.c,set_acl,"static int
set_acl(struct archive *a, int fd, const char *name,
struct archive_acl *abstract_acl,
int ae_requested_type, const char *tname)
{
int acl_type = 0;
int ae_type, ae_permset, ae_tag, ae_id;
uid_t ae_uid;
gid_t ae_gid;
const char*ae_name;
int entries;
int i;
int ret;
acl_t acl = NULL;
acl_entry_t acl_entry;
acl_permset_t acl_permset;
ret = ARCHIVE_OK;
entries = archive_acl_reset(abstract_acl, ae_requested_type);
if (entries == 0)
return (ARCHIVE_OK);
switch (ae_requested_type) {
case ARCHIVE_ENTRY_ACL_TYPE_ACCESS:
acl_type = ACL_TYPE_ACCESS;
break;
case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:
acl_type = ACL_TYPE_DEFAULT;
break;
default:
errno = ENOENT;
archive_set_error(a, errno, ""Unsupported ACL type"");
return (ARCHIVE_FAILED);
}
acl = acl_init(entries);
if (acl == (acl_t)NULL) {
archive_set_error(a, errno,
""Failed to initialize ACL working storage"");
return (ARCHIVE_FAILED);
}
while (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,
&ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {
if (acl_create_entry(&acl, &acl_entry) != 0) {
archive_set_error(a, errno,
""Failed to create a new ACL entry"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
switch (ae_tag) {
case ARCHIVE_ENTRY_ACL_USER:
ae_uid = archive_write_disk_uid(a, ae_name, ae_id);
acl_set_tag_type(acl_entry, ACL_USER);
acl_set_qualifier(acl_entry, &ae_uid);
break;
case ARCHIVE_ENTRY_ACL_GROUP:
ae_gid = archive_write_disk_gid(a, ae_name, ae_id);
acl_set_tag_type(acl_entry, ACL_GROUP);
acl_set_qualifier(acl_entry, &ae_gid);
break;
case ARCHIVE_ENTRY_ACL_USER_OBJ:
acl_set_tag_type(acl_entry, ACL_USER_OBJ);
break;
case ARCHIVE_ENTRY_ACL_GROUP_OBJ:
acl_set_tag_type(acl_entry, ACL_GROUP_OBJ);
break;
case ARCHIVE_ENTRY_ACL_MASK:
acl_set_tag_type(acl_entry, ACL_MASK);
break;
case ARCHIVE_ENTRY_ACL_OTHER:
acl_set_tag_type(acl_entry, ACL_OTHER);
break;
default:
archive_set_error(a, ARCHIVE_ERRNO_MISC,
""Unsupported ACL tag"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
if (acl_get_permset(acl_entry, &acl_permset) != 0) {
archive_set_error(a, errno,
""Failed to get ACL permission set"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
if (acl_clear_perms(acl_permset) != 0) {
archive_set_error(a, errno,
""Failed to clear ACL permissions"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
for (i = 0; i < acl_posix_perm_map_size; ++i) {
if (ae_permset & acl_posix_perm_map[i].a_perm) {
if (acl_add_perm(acl_permset,
acl_posix_perm_map[i].p_perm) != 0) {
archive_set_error(a, errno,
""Failed to add ACL permission"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
}
}
}
if (fd >= 0 && ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_ACCESS) {
if (acl_set_fd(fd, acl) == 0)
ret = ARCHIVE_OK;
else {
if (errno == EOPNOTSUPP) {
ret = ARCHIVE_OK;
} else {
archive_set_error(a, errno,
""Failed to set acl on fd: %s"", tname);
ret = ARCHIVE_WARN;
}
}
} else if (acl_set_file(name, acl_type, acl) != 0) {
if (errno == EOPNOTSUPP) {
ret = ARCHIVE_OK;
} else {
archive_set_error(a, errno, ""Failed to set acl: %s"",
tname);
ret = ARCHIVE_WARN;
}
}
exit_free:
acl_free(acl);
return (ret);
}","static int
set_acl(struct archive *VAR_0, int VAR_1, const char *VAR_2,
struct archive_acl *VAR_3,
int VAR_4, const char *VAR_5)
{
int VAR_6 = 0;
int VAR_7, VAR_8, VAR_9, VAR_10;
uid_t VAR_11;
gid_t VAR_12;
const char*VAR_13;
int VAR_14;
int VAR_15;
int VAR_16;
acl_t VAR_17 = NULL;
acl_entry_t VAR_18;
acl_permset_t VAR_19;
VAR_16 = VAR_20;
VAR_14 = archive_acl_reset(VAR_3, VAR_4);
if (VAR_14 == 0)
return (VAR_20);
switch (VAR_4) {
case VAR_21:
VAR_6 = VAR_22;
break;
case VAR_23:
VAR_6 = VAR_24;
break;
default:
VAR_25 = VAR_26;
archive_set_error(VAR_0, VAR_25, ""Unsupported ACL type"");
return (VAR_27);
}
VAR_17 = acl_init(VAR_14);
if (VAR_17 == (acl_t)NULL) {
archive_set_error(VAR_0, VAR_25,
""Failed to initialize ACL working storage"");
return (VAR_27);
}
while (archive_acl_next(VAR_0, VAR_3, VAR_4, &VAR_7,
&VAR_8, &VAR_9, &VAR_10, &VAR_13) == VAR_20) {
if (acl_create_entry(&VAR_17, &VAR_18) != 0) {
archive_set_error(VAR_0, VAR_25,
""Failed to create a new ACL entry"");
VAR_16 = VAR_27;
goto exit_free;
}
switch (VAR_9) {
case VAR_28:
VAR_11 = archive_write_disk_uid(VAR_0, VAR_13, VAR_10);
acl_set_tag_type(VAR_18, VAR_29);
acl_set_qualifier(VAR_18, &VAR_11);
break;
case VAR_30:
VAR_12 = archive_write_disk_gid(VAR_0, VAR_13, VAR_10);
acl_set_tag_type(VAR_18, VAR_31);
acl_set_qualifier(VAR_18, &VAR_12);
break;
case VAR_32:
acl_set_tag_type(VAR_18, VAR_33);
break;
case VAR_34:
acl_set_tag_type(VAR_18, VAR_35);
break;
case VAR_36:
acl_set_tag_type(VAR_18, VAR_37);
break;
case VAR_38:
acl_set_tag_type(VAR_18, VAR_39);
break;
default:
archive_set_error(VAR_0, VAR_40,
""Unsupported ACL tag"");
VAR_16 = VAR_27;
goto exit_free;
}
if (acl_get_permset(VAR_18, &VAR_19) != 0) {
archive_set_error(VAR_0, VAR_25,
""Failed to get ACL permission set"");
VAR_16 = VAR_27;
goto exit_free;
}
if (acl_clear_perms(VAR_19) != 0) {
archive_set_error(VAR_0, VAR_25,
""Failed to clear ACL permissions"");
VAR_16 = VAR_27;
goto exit_free;
}
for (VAR_15 = 0; VAR_15 < VAR_41; ++VAR_15) {
if (VAR_8 & VAR_42[VAR_15].a_perm) {
if (acl_add_perm(VAR_19,
VAR_42[VAR_15].p_perm) != 0) {
archive_set_error(VAR_0, VAR_25,
""Failed to add ACL permission"");
VAR_16 = VAR_27;
goto exit_free;
}
}
}
}
if (VAR_1 >= 0 && VAR_4 == VAR_21) {
if (acl_set_fd(VAR_1, VAR_17) == 0)
VAR_16 = VAR_20;
else {
if (VAR_25 == VAR_43) {
VAR_16 = VAR_20;
} else {
archive_set_error(VAR_0, VAR_25,
""Failed to set acl on fd: %s"", VAR_5);
VAR_16 = VAR_44;
}
}
} else if (acl_set_file(VAR_2, VAR_6, VAR_17) != 0) {
if (VAR_25 == VAR_43) {
VAR_16 = VAR_20;
} else {
archive_set_error(VAR_0, VAR_25, ""Failed to set acl: %s"",
VAR_5);
VAR_16 = VAR_44;
}
}
exit_free:
acl_free(VAR_17);
return (VAR_16);
}",libarchive/fba4f123cc456d2b2538f811bb831483bf336bad/archive_disk_acl_linux.c/vul/before/0.json,"static int
set_acl(struct archive *a, int fd, const char *name,
    struct archive_acl *abstract_acl, __LA_MODE_T mode,
    int ae_requested_type, const char *tname)
{
	int		 acl_type = 0;
	int		 ae_type, ae_permset, ae_tag, ae_id;
	uid_t		 ae_uid;
	gid_t		 ae_gid;
	const char	*ae_name;
	int		 entries;
	int		 i;
	int		 ret;
	acl_t		 acl = NULL;
	acl_entry_t	 acl_entry;
	acl_permset_t	 acl_permset;

	ret = ARCHIVE_OK;
	entries = archive_acl_reset(abstract_acl, ae_requested_type);
	if (entries == 0)
		return (ARCHIVE_OK);

	switch (ae_requested_type) {
	case ARCHIVE_ENTRY_ACL_TYPE_ACCESS:
		acl_type = ACL_TYPE_ACCESS;
		break;
	case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:
		acl_type = ACL_TYPE_DEFAULT;
		break;
	default:
		errno = ENOENT;
		archive_set_error(a, errno, ""Unsupported ACL type"");
		return (ARCHIVE_FAILED);
	}

	if (S_ISLNK(mode)) {
		/* Linux does not support ACLs on symbolic links */
		return (ARCHIVE_OK);
	}

	if (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) {
		errno = EINVAL;
		archive_set_error(a, errno,
		    ""Cannot set default ACL on non-directory"");
		return (ARCHIVE_WARN);
	}

	acl = acl_init(entries);
	if (acl == (acl_t)NULL) {
		archive_set_error(a, errno,
		    ""Failed to initialize ACL working storage"");
		return (ARCHIVE_FAILED);
	}

	while (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,
		   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {

		if (acl_create_entry(&acl, &acl_entry) != 0) {
			archive_set_error(a, errno,
			    ""Failed to create a new ACL entry"");
			ret = ARCHIVE_FAILED;
			goto exit_free;
		}

		switch (ae_tag) {
		case ARCHIVE_ENTRY_ACL_USER:
			ae_uid = archive_write_disk_uid(a, ae_name, ae_id);
			acl_set_tag_type(acl_entry, ACL_USER);
			acl_set_qualifier(acl_entry, &ae_uid);
			break;
		case ARCHIVE_ENTRY_ACL_GROUP:
			ae_gid = archive_write_disk_gid(a, ae_name, ae_id);
			acl_set_tag_type(acl_entry, ACL_GROUP);
			acl_set_qualifier(acl_entry, &ae_gid);
			break;
		case ARCHIVE_ENTRY_ACL_USER_OBJ:
			acl_set_tag_type(acl_entry, ACL_USER_OBJ);
			break;
		case ARCHIVE_ENTRY_ACL_GROUP_OBJ:
			acl_set_tag_type(acl_entry, ACL_GROUP_OBJ);
			break;
		case ARCHIVE_ENTRY_ACL_MASK:
			acl_set_tag_type(acl_entry, ACL_MASK);
			break;
		case ARCHIVE_ENTRY_ACL_OTHER:
			acl_set_tag_type(acl_entry, ACL_OTHER);
			break;
		default:
			archive_set_error(a, ARCHIVE_ERRNO_MISC,
			    ""Unsupported ACL tag"");
			ret = ARCHIVE_FAILED;
			goto exit_free;
		}

		if (acl_get_permset(acl_entry, &acl_permset) != 0) {
			archive_set_error(a, errno,
			    ""Failed to get ACL permission set"");
			ret = ARCHIVE_FAILED;
			goto exit_free;
		}
		if (acl_clear_perms(acl_permset) != 0) {
			archive_set_error(a, errno,
			    ""Failed to clear ACL permissions"");
			ret = ARCHIVE_FAILED;
			goto exit_free;
		}

		for (i = 0; i < acl_posix_perm_map_size; ++i) {
			if (ae_permset & acl_posix_perm_map[i].a_perm) {
				if (acl_add_perm(acl_permset,
				    acl_posix_perm_map[i].p_perm) != 0) {
					archive_set_error(a, errno,
					    ""Failed to add ACL permission"");
					ret = ARCHIVE_FAILED;
					goto exit_free;
				}
			}
		}

	}

	if (fd >= 0 && ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_ACCESS) {
		if (acl_set_fd(fd, acl) == 0)
			ret = ARCHIVE_OK;
		else {
			if (errno == EOPNOTSUPP) {
				/* Filesystem doesn't support ACLs */
				ret = ARCHIVE_OK;
			} else {
				archive_set_error(a, errno,
				    ""Failed to set acl on fd: %s"", tname);
				ret = ARCHIVE_WARN;
			}
		}
	} else if (acl_set_file(name, acl_type, acl) != 0) {
		if (errno == EOPNOTSUPP) {
			/* Filesystem doesn't support ACLs */
			ret = ARCHIVE_OK;
		} else {
			archive_set_error(a, errno, ""Failed to set acl: %s"",
			    tname);
			ret = ARCHIVE_WARN;
		}
	}
exit_free:
	acl_free(acl);
	return (ret);
}","static int
set_acl(struct archive *VAR_0, int VAR_1, const char *VAR_2,
    struct archive_acl *VAR_3, __LA_MODE_T VAR_4,
    int VAR_5, const char *VAR_6)
{
	int		 VAR_7 = 0;
	int		 VAR_8, VAR_9, VAR_10, VAR_11;
	uid_t		 VAR_12;
	gid_t		 VAR_13;
	const char	*VAR_14;
	int		 VAR_15;
	int		 VAR_16;
	int		 VAR_17;
	acl_t		 VAR_18 = NULL;
	acl_entry_t	 VAR_19;
	acl_permset_t	 VAR_20;

	VAR_17 = VAR_21;
	VAR_15 = archive_acl_reset(VAR_3, VAR_5);
	if (VAR_15 == 0)
		return (VAR_21);

	switch (VAR_5) {
	case VAR_22:
		VAR_7 = VAR_23;
		break;
	case VAR_24:
		VAR_7 = VAR_25;
		break;
	default:
		VAR_26 = VAR_27;
		archive_set_error(VAR_0, VAR_26, ""Unsupported ACL type"");
		return (VAR_28);
	}

	if (S_ISLNK(VAR_4)) {
		/* COMMENT_0 */
		return (VAR_21);
	}

	if (VAR_7 == VAR_25 && !S_ISDIR(VAR_4)) {
		VAR_26 = VAR_29;
		archive_set_error(VAR_0, VAR_26,
		    ""Cannot set default ACL on non-directory"");
		return (VAR_30);
	}

	VAR_18 = acl_init(VAR_15);
	if (VAR_18 == (acl_t)NULL) {
		archive_set_error(VAR_0, VAR_26,
		    ""Failed to initialize ACL working storage"");
		return (VAR_28);
	}

	while (archive_acl_next(VAR_0, VAR_3, VAR_5, &VAR_8,
		   &VAR_9, &VAR_10, &VAR_11, &VAR_14) == VAR_21) {

		if (acl_create_entry(&VAR_18, &VAR_19) != 0) {
			archive_set_error(VAR_0, VAR_26,
			    ""Failed to create a new ACL entry"");
			VAR_17 = VAR_28;
			goto exit_free;
		}

		switch (VAR_10) {
		case VAR_31:
			VAR_12 = archive_write_disk_uid(VAR_0, VAR_14, VAR_11);
			acl_set_tag_type(VAR_19, VAR_32);
			acl_set_qualifier(VAR_19, &VAR_12);
			break;
		case VAR_33:
			VAR_13 = archive_write_disk_gid(VAR_0, VAR_14, VAR_11);
			acl_set_tag_type(VAR_19, VAR_34);
			acl_set_qualifier(VAR_19, &VAR_13);
			break;
		case VAR_35:
			acl_set_tag_type(VAR_19, VAR_36);
			break;
		case VAR_37:
			acl_set_tag_type(VAR_19, VAR_38);
			break;
		case VAR_39:
			acl_set_tag_type(VAR_19, VAR_40);
			break;
		case VAR_41:
			acl_set_tag_type(VAR_19, VAR_42);
			break;
		default:
			archive_set_error(VAR_0, VAR_43,
			    ""Unsupported ACL tag"");
			VAR_17 = VAR_28;
			goto exit_free;
		}

		if (acl_get_permset(VAR_19, &VAR_20) != 0) {
			archive_set_error(VAR_0, VAR_26,
			    ""Failed to get ACL permission set"");
			VAR_17 = VAR_28;
			goto exit_free;
		}
		if (acl_clear_perms(VAR_20) != 0) {
			archive_set_error(VAR_0, VAR_26,
			    ""Failed to clear ACL permissions"");
			VAR_17 = VAR_28;
			goto exit_free;
		}

		for (VAR_16 = 0; VAR_16 < VAR_44; ++VAR_16) {
			if (VAR_9 & VAR_45[VAR_16].a_perm) {
				if (acl_add_perm(VAR_20,
				    VAR_45[VAR_16].p_perm) != 0) {
					archive_set_error(VAR_0, VAR_26,
					    ""Failed to add ACL permission"");
					VAR_17 = VAR_28;
					goto exit_free;
				}
			}
		}

	}

	if (VAR_1 >= 0 && VAR_5 == VAR_22) {
		if (acl_set_fd(VAR_1, VAR_18) == 0)
			VAR_17 = VAR_21;
		else {
			if (VAR_26 == VAR_46) {
				/* COMMENT_1 */
				VAR_17 = VAR_21;
			} else {
				archive_set_error(VAR_0, VAR_26,
				    ""Failed to set acl on fd: %s"", VAR_6);
				VAR_17 = VAR_30;
			}
		}
	} else if (acl_set_file(VAR_2, VAR_7, VAR_18) != 0) {
		if (VAR_26 == VAR_46) {
			/* COMMENT_1 */
			VAR_17 = VAR_21;
		} else {
			archive_set_error(VAR_0, VAR_26, ""Failed to set acl: %s"",
			    VAR_6);
			VAR_17 = VAR_30;
		}
	}
exit_free:
	acl_free(VAR_18);
	return (VAR_17);
}",libarchive/fba4f123cc456d2b2538f811bb831483bf336bad/archive_disk_acl_linux.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 set_acl(struct archive *a, int fd, const char *name,
-    struct archive_acl *abstract_acl,
+    struct archive_acl *abstract_acl, __LA_MODE_T mode,
     int ae_requested_type, const char *tname)
 {
 	int		 acl_type = 0;
@@ -31,6 +31,18 @@
 		errno = ENOENT;
 		archive_set_error(a, errno, ""Unsupported ACL type"");
 		return (ARCHIVE_FAILED);
+	}
+
+	if (S_ISLNK(mode)) {
+		/* Linux does not support ACLs on symbolic links */
+		return (ARCHIVE_OK);
+	}
+
+	if (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) {
+		errno = EINVAL;
+		archive_set_error(a, errno,
+		    ""Cannot set default ACL on non-directory"");
+		return (ARCHIVE_WARN);
 	}
 
 	acl = acl_init(entries);","{'deleted_lines': ['    struct archive_acl *abstract_acl,'], 'added_lines': ['    struct archive_acl *abstract_acl, __LA_MODE_T mode,', '\t}', '', '\tif (S_ISLNK(mode)) {', '\t\t/* Linux does not support ACLs on symbolic links */', '\t\treturn (ARCHIVE_OK);', '\t}', '', '\tif (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) {', '\t\terrno = EINVAL;', '\t\tarchive_set_error(a, errno,', '\t\t    ""Cannot set default ACL on non-directory"");', '\t\treturn (ARCHIVE_WARN);']}",True,"An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges.",7.8,HIGH,2,test,2021-08-21T18:51:07Z,3
CVE-2021-23177,['CWE-59'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,libarchive,"Fix handling of symbolic link ACLs

On Linux ACLs on symbolic links are not supported.
We must avoid calling acl_set_file() on symbolic links as their
targets are modified instead.

While here, do not try to set default ACLs on non-directories.

Fixes #1565",fba4f123cc456d2b2538f811bb831483bf336bad,https://github.com/libarchive/libarchive/commit/fba4f123cc456d2b2538f811bb831483bf336bad,libarchive/archive_disk_acl_freebsd.c,set_acl,"static int
set_acl(struct archive *a, int fd, const char *name,
struct archive_acl *abstract_acl,
int ae_requested_type, const char *tname)
{
int acl_type = 0;
acl_t acl;
acl_entry_t acl_entry;
acl_permset_t acl_permset;
#if ARCHIVE_ACL_FREEBSD_NFS4
acl_flagset_t acl_flagset;
int r;
#endif
int ret;
int ae_type, ae_permset, ae_tag, ae_id;
int perm_map_size;
const acl_perm_map_t*perm_map;
uid_t ae_uid;
gid_t ae_gid;
const char*ae_name;
int entries;
int i;
ret = ARCHIVE_OK;
entries = archive_acl_reset(abstract_acl, ae_requested_type);
if (entries == 0)
return (ARCHIVE_OK);
switch (ae_requested_type) {
case ARCHIVE_ENTRY_ACL_TYPE_ACCESS:
acl_type = ACL_TYPE_ACCESS;
break;
case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:
acl_type = ACL_TYPE_DEFAULT;
break;
#if ARCHIVE_ACL_FREEBSD_NFS4
case ARCHIVE_ENTRY_ACL_TYPE_NFS4:
acl_type = ACL_TYPE_NFS4;
break;
#endif
default:
errno = ENOENT;
archive_set_error(a, errno, ""Unsupported ACL type"");
return (ARCHIVE_FAILED);
}
acl = acl_init(entries);
if (acl == (acl_t)NULL) {
archive_set_error(a, errno,
""Failed to initialize ACL working storage"");
return (ARCHIVE_FAILED);
}
while (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,
&ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {
if (acl_create_entry(&acl, &acl_entry) != 0) {
archive_set_error(a, errno,
""Failed to create a new ACL entry"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
switch (ae_tag) {
case ARCHIVE_ENTRY_ACL_USER:
ae_uid = archive_write_disk_uid(a, ae_name, ae_id);
acl_set_tag_type(acl_entry, ACL_USER);
acl_set_qualifier(acl_entry, &ae_uid);
break;
case ARCHIVE_ENTRY_ACL_GROUP:
ae_gid = archive_write_disk_gid(a, ae_name, ae_id);
acl_set_tag_type(acl_entry, ACL_GROUP);
acl_set_qualifier(acl_entry, &ae_gid);
break;
case ARCHIVE_ENTRY_ACL_USER_OBJ:
acl_set_tag_type(acl_entry, ACL_USER_OBJ);
break;
case ARCHIVE_ENTRY_ACL_GROUP_OBJ:
acl_set_tag_type(acl_entry, ACL_GROUP_OBJ);
break;
case ARCHIVE_ENTRY_ACL_MASK:
acl_set_tag_type(acl_entry, ACL_MASK);
break;
case ARCHIVE_ENTRY_ACL_OTHER:
acl_set_tag_type(acl_entry, ACL_OTHER);
break;
#if ARCHIVE_ACL_FREEBSD_NFS4
case ARCHIVE_ENTRY_ACL_EVERYONE:
acl_set_tag_type(acl_entry, ACL_EVERYONE);
break;
#endif
default:
archive_set_error(a, ARCHIVE_ERRNO_MISC,
""Unsupported ACL tag"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
#if ARCHIVE_ACL_FREEBSD_NFS4
r = 0;
switch (ae_type) {
case ARCHIVE_ENTRY_ACL_TYPE_ALLOW:
r = acl_set_entry_type_np(acl_entry,
ACL_ENTRY_TYPE_ALLOW);
break;
case ARCHIVE_ENTRY_ACL_TYPE_DENY:
r = acl_set_entry_type_np(acl_entry,
ACL_ENTRY_TYPE_DENY);
break;
case ARCHIVE_ENTRY_ACL_TYPE_AUDIT:
r = acl_set_entry_type_np(acl_entry,
ACL_ENTRY_TYPE_AUDIT);
break;
case ARCHIVE_ENTRY_ACL_TYPE_ALARM:
r = acl_set_entry_type_np(acl_entry,
ACL_ENTRY_TYPE_ALARM);
break;
case ARCHIVE_ENTRY_ACL_TYPE_ACCESS:
case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:
break;
default:
archive_set_error(a, ARCHIVE_ERRNO_MISC,
""Unsupported ACL entry type"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
if (r != 0) {
archive_set_error(a, errno,
""Failed to set ACL entry type"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
#endif
if (acl_get_permset(acl_entry, &acl_permset) != 0) {
archive_set_error(a, errno,
""Failed to get ACL permission set"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
if (acl_clear_perms(acl_permset) != 0) {
archive_set_error(a, errno,
""Failed to clear ACL permissions"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
#if ARCHIVE_ACL_FREEBSD_NFS4
if (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {
perm_map_size = acl_nfs4_perm_map_size;
perm_map = acl_nfs4_perm_map;
} else {
#endif
perm_map_size = acl_posix_perm_map_size;
perm_map = acl_posix_perm_map;
#if ARCHIVE_ACL_FREEBSD_NFS4
}
#endif
for (i = 0; i < perm_map_size; ++i) {
if (ae_permset & perm_map[i].a_perm) {
if (acl_add_perm(acl_permset,
perm_map[i].p_perm) != 0) {
archive_set_error(a, errno,
""Failed to add ACL permission"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
}
}
#if ARCHIVE_ACL_FREEBSD_NFS4
if (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {
if (acl_get_flagset_np(acl_entry, &acl_flagset) != 0) {
archive_set_error(a, errno,
""Failed to get flagset from an NFSv4 ""
""ACL entry"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
if (acl_clear_flags_np(acl_flagset) != 0) {
archive_set_error(a, errno,
""Failed to clear flags from an NFSv4 ""
""ACL flagset"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
for (i = 0; i < acl_nfs4_flag_map_size; ++i) {
if (ae_permset & acl_nfs4_flag_map[i].a_perm) {
if (acl_add_flag_np(acl_flagset,
acl_nfs4_flag_map[i].p_perm) != 0) {
archive_set_error(a, errno,
""Failed to add flag to ""
""NFSv4 ACL flagset"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
}
}
}
#endif
}
if (fd >= 0) {
if (acl_set_fd_np(fd, acl, acl_type) == 0)
ret = ARCHIVE_OK;
else {
if (errno == EOPNOTSUPP) {
ret = ARCHIVE_OK;
} else {
archive_set_error(a, errno,
""Failed to set acl on fd: %s"", tname);
ret = ARCHIVE_WARN;
}
}
}
#if HAVE_ACL_SET_LINK_NP
else if (acl_set_link_np(name, acl_type, acl) != 0)
#else
else if (acl_set_file(name, acl_type, acl) != 0)
#endif
{
if (errno == EOPNOTSUPP) {
ret = ARCHIVE_OK;
} else {
archive_set_error(a, errno, ""Failed to set acl: %s"",
tname);
ret = ARCHIVE_WARN;
}
}
exit_free:
acl_free(acl);
return (ret);
}","static int
set_acl(struct archive *VAR_0, int VAR_1, const char *VAR_2,
struct archive_acl *VAR_3,
int VAR_4, const char *VAR_5)
{
int VAR_6 = 0;
acl_t VAR_7;
acl_entry_t VAR_8;
acl_permset_t VAR_9;
#if VAR_10
acl_flagset_t VAR_11;
int VAR_12;
#endif
int VAR_13;
int VAR_14, VAR_15, VAR_16, VAR_17;
int VAR_18;
const acl_perm_map_t*VAR_19;
uid_t VAR_20;
gid_t VAR_21;
const char*VAR_22;
int VAR_23;
int VAR_24;
VAR_13 = VAR_25;
VAR_23 = archive_acl_reset(VAR_3, VAR_4);
if (VAR_23 == 0)
return (VAR_25);
switch (VAR_4) {
case VAR_26:
VAR_6 = VAR_27;
break;
case VAR_28:
VAR_6 = VAR_29;
break;
#if VAR_10
case VAR_30:
VAR_6 = VAR_31;
break;
#endif
default:
VAR_32 = VAR_33;
archive_set_error(VAR_0, VAR_32, ""Unsupported ACL type"");
return (VAR_34);
}
VAR_7 = acl_init(VAR_23);
if (VAR_7 == (acl_t)NULL) {
archive_set_error(VAR_0, VAR_32,
""Failed to initialize ACL working storage"");
return (VAR_34);
}
while (archive_acl_next(VAR_0, VAR_3, VAR_4, &VAR_14,
&VAR_15, &VAR_16, &VAR_17, &VAR_22) == VAR_25) {
if (acl_create_entry(&VAR_7, &VAR_8) != 0) {
archive_set_error(VAR_0, VAR_32,
""Failed to create a new ACL entry"");
VAR_13 = VAR_34;
goto exit_free;
}
switch (VAR_16) {
case VAR_35:
VAR_20 = archive_write_disk_uid(VAR_0, VAR_22, VAR_17);
acl_set_tag_type(VAR_8, VAR_36);
acl_set_qualifier(VAR_8, &VAR_20);
break;
case VAR_37:
VAR_21 = archive_write_disk_gid(VAR_0, VAR_22, VAR_17);
acl_set_tag_type(VAR_8, VAR_38);
acl_set_qualifier(VAR_8, &VAR_21);
break;
case VAR_39:
acl_set_tag_type(VAR_8, VAR_40);
break;
case VAR_41:
acl_set_tag_type(VAR_8, VAR_42);
break;
case VAR_43:
acl_set_tag_type(VAR_8, VAR_44);
break;
case VAR_45:
acl_set_tag_type(VAR_8, VAR_46);
break;
#if VAR_10
case VAR_47:
acl_set_tag_type(VAR_8, VAR_48);
break;
#endif
default:
archive_set_error(VAR_0, VAR_49,
""Unsupported ACL tag"");
VAR_13 = VAR_34;
goto exit_free;
}
#if VAR_10
VAR_12 = 0;
switch (VAR_14) {
case VAR_50:
VAR_12 = acl_set_entry_type_np(VAR_8,
VAR_51);
break;
case VAR_52:
VAR_12 = acl_set_entry_type_np(VAR_8,
VAR_53);
break;
case VAR_54:
VAR_12 = acl_set_entry_type_np(VAR_8,
VAR_55);
break;
case VAR_56:
VAR_12 = acl_set_entry_type_np(VAR_8,
VAR_57);
break;
case VAR_26:
case VAR_28:
break;
default:
archive_set_error(VAR_0, VAR_49,
""Unsupported ACL entry type"");
VAR_13 = VAR_34;
goto exit_free;
}
if (VAR_12 != 0) {
archive_set_error(VAR_0, VAR_32,
""Failed to set ACL entry type"");
VAR_13 = VAR_34;
goto exit_free;
}
#endif
if (acl_get_permset(VAR_8, &VAR_9) != 0) {
archive_set_error(VAR_0, VAR_32,
""Failed to get ACL permission set"");
VAR_13 = VAR_34;
goto exit_free;
}
if (acl_clear_perms(VAR_9) != 0) {
archive_set_error(VAR_0, VAR_32,
""Failed to clear ACL permissions"");
VAR_13 = VAR_34;
goto exit_free;
}
#if VAR_10
if (VAR_4 == VAR_30) {
VAR_18 = VAR_58;
VAR_19 = VAR_59;
} else {
#endif
perm_map_size = acl_posix_perm_map_size;
VAR_19 = VAR_60;
#if VAR_10
}
#endif
for (VAR_24 = 0; VAR_24 < VAR_18; ++VAR_24) {
if (VAR_15 & VAR_19[VAR_24].a_perm) {
if (acl_add_perm(VAR_9,
VAR_19[VAR_24].p_perm) != 0) {
archive_set_error(VAR_0, VAR_32,
""Failed to add ACL permission"");
VAR_13 = VAR_34;
goto exit_free;
}
}
}
#if VAR_10
if (VAR_4 == VAR_30) {
if (acl_get_flagset_np(VAR_8, &VAR_11) != 0) {
archive_set_error(VAR_0, VAR_32,
""Failed to get flagset from an NFSv4 ""
""ACL entry"");
VAR_13 = VAR_34;
goto exit_free;
}
if (acl_clear_flags_np(VAR_11) != 0) {
archive_set_error(VAR_0, VAR_32,
""Failed to clear flags from an NFSv4 ""
""ACL flagset"");
VAR_13 = VAR_34;
goto exit_free;
}
for (VAR_24 = 0; VAR_24 < VAR_61; ++VAR_24) {
if (VAR_15 & VAR_62[VAR_24].a_perm) {
if (acl_add_flag_np(VAR_11,
VAR_62[VAR_24].p_perm) != 0) {
archive_set_error(VAR_0, VAR_32,
""Failed to add flag to ""
""NFSv4 ACL flagset"");
VAR_13 = VAR_34;
goto exit_free;
}
}
}
}
#endif
}
if (VAR_1 >= 0) {
if (acl_set_fd_np(VAR_1, VAR_7, VAR_6) == 0)
VAR_13 = VAR_25;
else {
if (VAR_32 == VAR_63) {
VAR_13 = VAR_25;
} else {
archive_set_error(VAR_0, VAR_32,
""Failed to set acl on fd: %s"", VAR_5);
VAR_13 = VAR_64;
}
}
}
#if VAR_65
else if (acl_set_link_np(name, acl_type, acl) != 0)
#else
else if (acl_set_file(name, acl_type, acl) != 0)
#endif
{
if (VAR_32 == VAR_63) {
VAR_13 = VAR_25;
} else {
archive_set_error(VAR_0, VAR_32, ""Failed to set acl: %s"",
VAR_5);
VAR_13 = VAR_64;
}
}
exit_free:
acl_free(acl);
return (VAR_13);
}",libarchive/fba4f123cc456d2b2538f811bb831483bf336bad/archive_disk_acl_freebsd.c/vul/before/1.json,"static int
set_acl(struct archive *a, int fd, const char *name,
    struct archive_acl *abstract_acl, __LA_MODE_T mode,
    int ae_requested_type, const char *tname)
{
	int		 acl_type = 0;
	acl_t		 acl;
	acl_entry_t	 acl_entry;
	acl_permset_t	 acl_permset;
#if ARCHIVE_ACL_FREEBSD_NFS4
	acl_flagset_t	 acl_flagset;
	int		 r;
#endif
	int		 ret;
	int		 ae_type, ae_permset, ae_tag, ae_id;
	int		 perm_map_size;
	const acl_perm_map_t	*perm_map;
	uid_t		 ae_uid;
	gid_t		 ae_gid;
	const char	*ae_name;
	int		 entries;
	int		 i;

	ret = ARCHIVE_OK;
	entries = archive_acl_reset(abstract_acl, ae_requested_type);
	if (entries == 0)
		return (ARCHIVE_OK);


	switch (ae_requested_type) {
	case ARCHIVE_ENTRY_ACL_TYPE_ACCESS:
		acl_type = ACL_TYPE_ACCESS;
		break;
	case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:
		acl_type = ACL_TYPE_DEFAULT;
		break;
#if ARCHIVE_ACL_FREEBSD_NFS4
	case ARCHIVE_ENTRY_ACL_TYPE_NFS4:
		acl_type = ACL_TYPE_NFS4;
		break;
#endif
	default:
		errno = ENOENT;
		archive_set_error(a, errno, ""Unsupported ACL type"");
		return (ARCHIVE_FAILED);
	}

	if (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) {
		errno = EINVAL;
		archive_set_error(a, errno,
		    ""Cannot set default ACL on non-directory"");
		return (ARCHIVE_WARN);
	}

	acl = acl_init(entries);
	if (acl == (acl_t)NULL) {
		archive_set_error(a, errno,
		    ""Failed to initialize ACL working storage"");
		return (ARCHIVE_FAILED);
	}

	while (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,
		   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {
		if (acl_create_entry(&acl, &acl_entry) != 0) {
			archive_set_error(a, errno,
			    ""Failed to create a new ACL entry"");
			ret = ARCHIVE_FAILED;
			goto exit_free;
		}
		switch (ae_tag) {
		case ARCHIVE_ENTRY_ACL_USER:
			ae_uid = archive_write_disk_uid(a, ae_name, ae_id);
			acl_set_tag_type(acl_entry, ACL_USER);
			acl_set_qualifier(acl_entry, &ae_uid);
			break;
		case ARCHIVE_ENTRY_ACL_GROUP:
			ae_gid = archive_write_disk_gid(a, ae_name, ae_id);
			acl_set_tag_type(acl_entry, ACL_GROUP);
			acl_set_qualifier(acl_entry, &ae_gid);
			break;
		case ARCHIVE_ENTRY_ACL_USER_OBJ:
			acl_set_tag_type(acl_entry, ACL_USER_OBJ);
			break;
		case ARCHIVE_ENTRY_ACL_GROUP_OBJ:
			acl_set_tag_type(acl_entry, ACL_GROUP_OBJ);
			break;
		case ARCHIVE_ENTRY_ACL_MASK:
			acl_set_tag_type(acl_entry, ACL_MASK);
			break;
		case ARCHIVE_ENTRY_ACL_OTHER:
			acl_set_tag_type(acl_entry, ACL_OTHER);
			break;
#if ARCHIVE_ACL_FREEBSD_NFS4
		case ARCHIVE_ENTRY_ACL_EVERYONE:
			acl_set_tag_type(acl_entry, ACL_EVERYONE);
			break;
#endif
		default:
			archive_set_error(a, ARCHIVE_ERRNO_MISC,
			    ""Unsupported ACL tag"");
			ret = ARCHIVE_FAILED;
			goto exit_free;
		}

#if ARCHIVE_ACL_FREEBSD_NFS4
		r = 0;
		switch (ae_type) {
		case ARCHIVE_ENTRY_ACL_TYPE_ALLOW:
			r = acl_set_entry_type_np(acl_entry,
			    ACL_ENTRY_TYPE_ALLOW);
			break;
		case ARCHIVE_ENTRY_ACL_TYPE_DENY:
			r = acl_set_entry_type_np(acl_entry,
			    ACL_ENTRY_TYPE_DENY);
			break;
		case ARCHIVE_ENTRY_ACL_TYPE_AUDIT:
			r = acl_set_entry_type_np(acl_entry,
			    ACL_ENTRY_TYPE_AUDIT);
			break;
		case ARCHIVE_ENTRY_ACL_TYPE_ALARM:
			r = acl_set_entry_type_np(acl_entry,
			    ACL_ENTRY_TYPE_ALARM);
			break;
		case ARCHIVE_ENTRY_ACL_TYPE_ACCESS:
		case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:
			// These don't translate directly into the system ACL.
			break;
		default:
			archive_set_error(a, ARCHIVE_ERRNO_MISC,
			    ""Unsupported ACL entry type"");
			ret = ARCHIVE_FAILED;
			goto exit_free;
		}

		if (r != 0) {
			archive_set_error(a, errno,
			    ""Failed to set ACL entry type"");
			ret = ARCHIVE_FAILED;
			goto exit_free;
		}
#endif

		if (acl_get_permset(acl_entry, &acl_permset) != 0) {
			archive_set_error(a, errno,
			    ""Failed to get ACL permission set"");
			ret = ARCHIVE_FAILED;
			goto exit_free;
		}
		if (acl_clear_perms(acl_permset) != 0) {
			archive_set_error(a, errno,
			    ""Failed to clear ACL permissions"");
			ret = ARCHIVE_FAILED;
			goto exit_free;
		}
#if ARCHIVE_ACL_FREEBSD_NFS4
		if (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {
			perm_map_size = acl_nfs4_perm_map_size;
			perm_map = acl_nfs4_perm_map;
		} else {
#endif
			perm_map_size = acl_posix_perm_map_size;
			perm_map = acl_posix_perm_map;
#if ARCHIVE_ACL_FREEBSD_NFS4
		}
#endif

		for (i = 0; i < perm_map_size; ++i) {
			if (ae_permset & perm_map[i].a_perm) {
				if (acl_add_perm(acl_permset,
				    perm_map[i].p_perm) != 0) {
					archive_set_error(a, errno,
					    ""Failed to add ACL permission"");
					ret = ARCHIVE_FAILED;
					goto exit_free;
				}
			}
		}

#if ARCHIVE_ACL_FREEBSD_NFS4
		if (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {
			/*
			 * acl_get_flagset_np() fails with non-NFSv4 ACLs
			 */
			if (acl_get_flagset_np(acl_entry, &acl_flagset) != 0) {
				archive_set_error(a, errno,
				    ""Failed to get flagset from an NFSv4 ""
				    ""ACL entry"");
				ret = ARCHIVE_FAILED;
				goto exit_free;
			}
			if (acl_clear_flags_np(acl_flagset) != 0) {
				archive_set_error(a, errno,
				    ""Failed to clear flags from an NFSv4 ""
				    ""ACL flagset"");
				ret = ARCHIVE_FAILED;
				goto exit_free;
			}
			for (i = 0; i < acl_nfs4_flag_map_size; ++i) {
				if (ae_permset & acl_nfs4_flag_map[i].a_perm) {
					if (acl_add_flag_np(acl_flagset,
					    acl_nfs4_flag_map[i].p_perm) != 0) {
						archive_set_error(a, errno,
						    ""Failed to add flag to ""
						    ""NFSv4 ACL flagset"");
						ret = ARCHIVE_FAILED;
						goto exit_free;
					}
				}
			}
		}
#endif
	}

	/* Try restoring the ACL through 'fd' if we can. */
	if (fd >= 0) {
		if (acl_set_fd_np(fd, acl, acl_type) == 0)
			ret = ARCHIVE_OK;
		else {
			if (errno == EOPNOTSUPP) {
				/* Filesystem doesn't support ACLs */
				ret = ARCHIVE_OK;
			} else {
				archive_set_error(a, errno,
				    ""Failed to set acl on fd: %s"", tname);
				ret = ARCHIVE_WARN;
			}
		}
	}
#if HAVE_ACL_SET_LINK_NP
	else if (acl_set_link_np(name, acl_type, acl) != 0)
#else
	/* FreeBSD older than 8.0 */
	else if (S_ISLNK(mode)) {
	    /* acl_set_file() follows symbolic links, skip */
	    ret = ARCHIVE_OK;
	} else if (acl_set_file(name, acl_type, acl) != 0)
#endif
	{
		if (errno == EOPNOTSUPP) {
			/* Filesystem doesn't support ACLs */
			ret = ARCHIVE_OK;
		} else {
			archive_set_error(a, errno, ""Failed to set acl: %s"",
			    tname);
			ret = ARCHIVE_WARN;
		}
	}
exit_free:
	acl_free(acl);
	return (ret);
}","static int
set_acl(struct archive *VAR_0, int VAR_1, const char *VAR_2,
    struct archive_acl *VAR_3, __LA_MODE_T VAR_4,
    int VAR_5, const char *VAR_6)
{
	int		 VAR_7 = 0;
	acl_t		 VAR_8;
	acl_entry_t	 VAR_9;
	acl_permset_t	 VAR_10;
#if VAR_11
	acl_flagset_t	 VAR_12;
	int		 VAR_13;
#endif
	int		 VAR_14;
	int		 VAR_15, VAR_16, VAR_17, VAR_18;
	int		 VAR_19;
	const acl_perm_map_t	*VAR_20;
	uid_t		 VAR_21;
	gid_t		 VAR_22;
	const char	*VAR_23;
	int		 VAR_24;
	int		 VAR_25;

	VAR_14 = VAR_26;
	VAR_24 = archive_acl_reset(VAR_3, VAR_5);
	if (VAR_24 == 0)
		return (VAR_26);


	switch (VAR_5) {
	case VAR_27:
		VAR_7 = VAR_28;
		break;
	case VAR_29:
		VAR_7 = VAR_30;
		break;
#if VAR_11
	case VAR_31:
		VAR_7 = VAR_32;
		break;
#endif
	default:
		VAR_33 = VAR_34;
		archive_set_error(VAR_0, VAR_33, ""Unsupported ACL type"");
		return (VAR_35);
	}

	if (VAR_7 == VAR_30 && !S_ISDIR(VAR_4)) {
		VAR_33 = VAR_36;
		archive_set_error(VAR_0, VAR_33,
		    ""Cannot set default ACL on non-directory"");
		return (VAR_37);
	}

	VAR_8 = acl_init(VAR_24);
	if (VAR_8 == (acl_t)NULL) {
		archive_set_error(VAR_0, VAR_33,
		    ""Failed to initialize ACL working storage"");
		return (VAR_35);
	}

	while (archive_acl_next(VAR_0, VAR_3, VAR_5, &VAR_15,
		   &VAR_16, &VAR_17, &VAR_18, &VAR_23) == VAR_26) {
		if (acl_create_entry(&VAR_8, &VAR_9) != 0) {
			archive_set_error(VAR_0, VAR_33,
			    ""Failed to create a new ACL entry"");
			VAR_14 = VAR_35;
			goto exit_free;
		}
		switch (VAR_17) {
		case VAR_38:
			VAR_21 = archive_write_disk_uid(VAR_0, VAR_23, VAR_18);
			acl_set_tag_type(VAR_9, VAR_39);
			acl_set_qualifier(VAR_9, &VAR_21);
			break;
		case VAR_40:
			VAR_22 = archive_write_disk_gid(VAR_0, VAR_23, VAR_18);
			acl_set_tag_type(VAR_9, VAR_41);
			acl_set_qualifier(VAR_9, &VAR_22);
			break;
		case VAR_42:
			acl_set_tag_type(VAR_9, VAR_43);
			break;
		case VAR_44:
			acl_set_tag_type(VAR_9, VAR_45);
			break;
		case VAR_46:
			acl_set_tag_type(VAR_9, VAR_47);
			break;
		case VAR_48:
			acl_set_tag_type(VAR_9, VAR_49);
			break;
#if VAR_11
		case VAR_50:
			acl_set_tag_type(VAR_9, VAR_51);
			break;
#endif
		default:
			archive_set_error(VAR_0, VAR_52,
			    ""Unsupported ACL tag"");
			VAR_14 = VAR_35;
			goto exit_free;
		}

#if VAR_11
		VAR_13 = 0;
		switch (VAR_15) {
		case VAR_53:
			VAR_13 = acl_set_entry_type_np(VAR_9,
			    VAR_54);
			break;
		case VAR_55:
			VAR_13 = acl_set_entry_type_np(VAR_9,
			    VAR_56);
			break;
		case VAR_57:
			VAR_13 = acl_set_entry_type_np(VAR_9,
			    VAR_58);
			break;
		case VAR_59:
			VAR_13 = acl_set_entry_type_np(VAR_9,
			    VAR_60);
			break;
		case VAR_27:
		case VAR_29:
			/* COMMENT_0 */
			break;
		default:
			archive_set_error(VAR_0, VAR_52,
			    ""Unsupported ACL entry type"");
			VAR_14 = VAR_35;
			goto exit_free;
		}

		if (VAR_13 != 0) {
			archive_set_error(VAR_0, VAR_33,
			    ""Failed to set ACL entry type"");
			VAR_14 = VAR_35;
			goto exit_free;
		}
#endif

		if (acl_get_permset(VAR_9, &VAR_10) != 0) {
			archive_set_error(VAR_0, VAR_33,
			    ""Failed to get ACL permission set"");
			VAR_14 = VAR_35;
			goto exit_free;
		}
		if (acl_clear_perms(VAR_10) != 0) {
			archive_set_error(VAR_0, VAR_33,
			    ""Failed to clear ACL permissions"");
			VAR_14 = VAR_35;
			goto exit_free;
		}
#if VAR_11
		if (VAR_5 == VAR_31) {
			VAR_19 = VAR_61;
			VAR_20 = VAR_62;
		} else {
#endif
			perm_map_size = acl_posix_perm_map_size;
			VAR_20 = VAR_63;
#if VAR_11
		}
#endif

		for (VAR_25 = 0; VAR_25 < VAR_19; ++VAR_25) {
			if (VAR_16 & VAR_20[VAR_25].a_perm) {
				if (acl_add_perm(VAR_10,
				    VAR_20[VAR_25].p_perm) != 0) {
					archive_set_error(VAR_0, VAR_33,
					    ""Failed to add ACL permission"");
					VAR_14 = VAR_35;
					goto exit_free;
				}
			}
		}

#if VAR_11
		if (VAR_5 == VAR_31) {
			/* COMMENT_1 */
                                                    
      
			if (acl_get_flagset_np(VAR_9, &VAR_12) != 0) {
				archive_set_error(VAR_0, VAR_33,
				    ""Failed to get flagset from an NFSv4 ""
				    ""ACL entry"");
				VAR_14 = VAR_35;
				goto exit_free;
			}
			if (acl_clear_flags_np(VAR_12) != 0) {
				archive_set_error(VAR_0, VAR_33,
				    ""Failed to clear flags from an NFSv4 ""
				    ""ACL flagset"");
				VAR_14 = VAR_35;
				goto exit_free;
			}
			for (VAR_25 = 0; VAR_25 < VAR_64; ++VAR_25) {
				if (VAR_16 & VAR_65[VAR_25].a_perm) {
					if (acl_add_flag_np(VAR_12,
					    VAR_65[VAR_25].p_perm) != 0) {
						archive_set_error(VAR_0, VAR_33,
						    ""Failed to add flag to ""
						    ""NFSv4 ACL flagset"");
						VAR_14 = VAR_35;
						goto exit_free;
					}
				}
			}
		}
#endif
	}

	/* COMMENT_4 */
	if (VAR_1 >= 0) {
		if (acl_set_fd_np(VAR_1, VAR_8, VAR_7) == 0)
			VAR_14 = VAR_26;
		else {
			if (VAR_33 == VAR_66) {
				/* COMMENT_5 */
				VAR_14 = VAR_26;
			} else {
				archive_set_error(VAR_0, VAR_33,
				    ""Failed to set acl on fd: %s"", VAR_6);
				VAR_14 = VAR_37;
			}
		}
	}
#if VAR_67
	else if (acl_set_link_np(name, acl_type, acl) != 0)
#else
	/* COMMENT_6 */
	else if (S_ISLNK(mode)) {
	    /* COMMENT_7 */
	    VAR_14 = VAR_26;
	} else if (acl_set_file(name, acl_type, acl) != 0)
#endif
	{
		if (VAR_33 == VAR_66) {
			/* COMMENT_5 */
			VAR_14 = VAR_26;
		} else {
			archive_set_error(VAR_0, VAR_33, ""Failed to set acl: %s"",
			    VAR_6);
			VAR_14 = VAR_37;
		}
	}
exit_free:
	acl_free(acl);
	return (VAR_14);
}",libarchive/fba4f123cc456d2b2538f811bb831483bf336bad/archive_disk_acl_freebsd.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 set_acl(struct archive *a, int fd, const char *name,
-    struct archive_acl *abstract_acl,
+    struct archive_acl *abstract_acl, __LA_MODE_T mode,
     int ae_requested_type, const char *tname)
 {
 	int		 acl_type = 0;
@@ -43,6 +43,13 @@
 		errno = ENOENT;
 		archive_set_error(a, errno, ""Unsupported ACL type"");
 		return (ARCHIVE_FAILED);
+	}
+
+	if (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) {
+		errno = EINVAL;
+		archive_set_error(a, errno,
+		    ""Cannot set default ACL on non-directory"");
+		return (ARCHIVE_WARN);
 	}
 
 	acl = acl_init(entries);
@@ -223,7 +230,10 @@
 	else if (acl_set_link_np(name, acl_type, acl) != 0)
 #else
 	/* FreeBSD older than 8.0 */
-	else if (acl_set_file(name, acl_type, acl) != 0)
+	else if (S_ISLNK(mode)) {
+	    /* acl_set_file() follows symbolic links, skip */
+	    ret = ARCHIVE_OK;
+	} else if (acl_set_file(name, acl_type, acl) != 0)
 #endif
 	{
 		if (errno == EOPNOTSUPP) {","{'deleted_lines': ['    struct archive_acl *abstract_acl,', '\telse if (acl_set_file(name, acl_type, acl) != 0)'], 'added_lines': ['    struct archive_acl *abstract_acl, __LA_MODE_T mode,', '\t}', '', '\tif (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) {', '\t\terrno = EINVAL;', '\t\tarchive_set_error(a, errno,', '\t\t    ""Cannot set default ACL on non-directory"");', '\t\treturn (ARCHIVE_WARN);', '\telse if (S_ISLNK(mode)) {', '\t    /* acl_set_file() follows symbolic links, skip */', '\t    ret = ARCHIVE_OK;', '\t} else if (acl_set_file(name, acl_type, acl) != 0)']}",True,"An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges.",7.8,HIGH,2,test,2021-08-21T18:51:07Z,3
CVE-2021-23177,['CWE-59'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,libarchive,"Fix handling of symbolic link ACLs

On Linux ACLs on symbolic links are not supported.
We must avoid calling acl_set_file() on symbolic links as their
targets are modified instead.

While here, do not try to set default ACLs on non-directories.

Fixes #1565",fba4f123cc456d2b2538f811bb831483bf336bad,https://github.com/libarchive/libarchive/commit/fba4f123cc456d2b2538f811bb831483bf336bad,libarchive/archive_disk_acl_sunos.c,set_acl,"static int
set_acl(struct archive *a, int fd, const char *name,
struct archive_acl *abstract_acl,
int ae_requested_type, const char *tname)
{
aclent_t *aclent;
#if ARCHIVE_ACL_SUNOS_NFS4
ace_t *ace;
#endif
int cmd, e, r;
void *aclp;
int ret;
int ae_type, ae_permset, ae_tag, ae_id;
int perm_map_size;
const acl_perm_map_t*perm_map;
uid_t ae_uid;
gid_t ae_gid;
const char*ae_name;
int entries;
int i;
ret = ARCHIVE_OK;
entries = archive_acl_reset(abstract_acl, ae_requested_type);
if (entries == 0)
return (ARCHIVE_OK);
switch (ae_requested_type) {
case ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:
cmd = SETACL;
aclp = malloc(entries * sizeof(aclent_t));
break;
#if ARCHIVE_ACL_SUNOS_NFS4
case ARCHIVE_ENTRY_ACL_TYPE_NFS4:
cmd = ACE_SETACL;
aclp = malloc(entries * sizeof(ace_t));
break;
#endif
default:
errno = ENOENT;
archive_set_error(a, errno, ""Unsupported ACL type"");
return (ARCHIVE_FAILED);
}
if (aclp == NULL) {
archive_set_error(a, errno,
""Can't allocate memory for acl buffer"");
return (ARCHIVE_FAILED);
}
e = 0;
while (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,
&ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {
aclent = NULL;
#if ARCHIVE_ACL_SUNOS_NFS4
ace = NULL;
#endif
if (cmd == SETACL) {
aclent = &((aclent_t *)aclp)[e];
aclent->a_id = -1;
aclent->a_type = 0;
aclent->a_perm = 0;
}
#if ARCHIVE_ACL_SUNOS_NFS4
else {
ace = &((ace_t *)aclp)[e];
ace->a_who = -1;
ace->a_access_mask = 0;
ace->a_flags = 0;
}
#endif
switch (ae_tag) {
case ARCHIVE_ENTRY_ACL_USER:
ae_uid = archive_write_disk_uid(a, ae_name, ae_id);
if (aclent != NULL) {
aclent->a_id = ae_uid;
aclent->a_type |= USER;
}
#if ARCHIVE_ACL_SUNOS_NFS4
else {
ace->a_who = ae_uid;
}
#endif
break;
case ARCHIVE_ENTRY_ACL_GROUP:
ae_gid = archive_write_disk_gid(a, ae_name, ae_id);
if (aclent != NULL) {
aclent->a_id = ae_gid;
aclent->a_type |= GROUP;
}
#if ARCHIVE_ACL_SUNOS_NFS4
else {
ace->a_who = ae_gid;
ace->a_flags |= ACE_IDENTIFIER_GROUP;
}
#endif
break;
case ARCHIVE_ENTRY_ACL_USER_OBJ:
if (aclent != NULL)
aclent->a_type |= USER_OBJ;
#if ARCHIVE_ACL_SUNOS_NFS4
else {
ace->a_flags |= ACE_OWNER;
}
#endif
break;
case ARCHIVE_ENTRY_ACL_GROUP_OBJ:
if (aclent != NULL)
aclent->a_type |= GROUP_OBJ;
#if ARCHIVE_ACL_SUNOS_NFS4
else {
ace->a_flags |= ACE_GROUP;
ace->a_flags |= ACE_IDENTIFIER_GROUP;
}
#endif
break;
case ARCHIVE_ENTRY_ACL_MASK:
if (aclent != NULL)
aclent->a_type |= CLASS_OBJ;
break;
case ARCHIVE_ENTRY_ACL_OTHER:
if (aclent != NULL)
aclent->a_type |= OTHER_OBJ;
break;
#if ARCHIVE_ACL_SUNOS_NFS4
case ARCHIVE_ENTRY_ACL_EVERYONE:
if (ace != NULL)
ace->a_flags |= ACE_EVERYONE;
break;
#endif
default:
archive_set_error(a, ARCHIVE_ERRNO_MISC,
""Unsupported ACL tag"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
r = 0;
switch (ae_type) {
#if ARCHIVE_ACL_SUNOS_NFS4
case ARCHIVE_ENTRY_ACL_TYPE_ALLOW:
if (ace != NULL)
ace->a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;
else
r = -1;
break;
case ARCHIVE_ENTRY_ACL_TYPE_DENY:
if (ace != NULL)
ace->a_type = ACE_ACCESS_DENIED_ACE_TYPE;
else
r = -1;
break;
case ARCHIVE_ENTRY_ACL_TYPE_AUDIT:
if (ace != NULL)
ace->a_type = ACE_SYSTEM_AUDIT_ACE_TYPE;
else
r = -1;
break;
case ARCHIVE_ENTRY_ACL_TYPE_ALARM:
if (ace != NULL)
ace->a_type = ACE_SYSTEM_ALARM_ACE_TYPE;
else
r = -1;
break;
#endif
case ARCHIVE_ENTRY_ACL_TYPE_ACCESS:
if (aclent == NULL)
r = -1;
break;
case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:
if (aclent != NULL)
aclent->a_type |= ACL_DEFAULT;
else
r = -1;
break;
default:
archive_set_error(a, ARCHIVE_ERRNO_MISC,
""Unsupported ACL entry type"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
if (r != 0) {
errno = EINVAL;
archive_set_error(a, errno,
""Failed to set ACL entry type"");
ret = ARCHIVE_FAILED;
goto exit_free;
}
#if ARCHIVE_ACL_SUNOS_NFS4
if (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {
perm_map_size = acl_nfs4_perm_map_size;
perm_map = acl_nfs4_perm_map;
} else {
#endif
perm_map_size = acl_posix_perm_map_size;
perm_map = acl_posix_perm_map;
#if ARCHIVE_ACL_SUNOS_NFS4
}
#endif
for (i = 0; i < perm_map_size; ++i) {
if (ae_permset & perm_map[i].a_perm) {
#if ARCHIVE_ACL_SUNOS_NFS4
if (ae_requested_type ==
ARCHIVE_ENTRY_ACL_TYPE_NFS4)
ace->a_access_mask |=
perm_map[i].p_perm;
else
#endif
aclent->a_perm |= perm_map[i].p_perm;
}
}
#if ARCHIVE_ACL_SUNOS_NFS4
if (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {
for (i = 0; i < acl_nfs4_flag_map_size; ++i) {
if (ae_permset & acl_nfs4_flag_map[i].a_perm) {
ace->a_flags |=
acl_nfs4_flag_map[i].p_perm;
}
}
}
#endif
e++;
}
if (fd >= 0) {
if (facl(fd, cmd, entries, aclp) == 0)
ret = ARCHIVE_OK;
else {
if (errno == EOPNOTSUPP) {
ret = ARCHIVE_OK;
} else {
archive_set_error(a, errno,
""Failed to set acl on fd: %s"", tname);
ret = ARCHIVE_WARN;
}
}
} else if (acl(name, cmd, entries, aclp) != 0) {
if (errno == EOPNOTSUPP) {
ret = ARCHIVE_OK;
} else {
archive_set_error(a, errno, ""Failed to set acl: %s"",
tname);
ret = ARCHIVE_WARN;
}
}
exit_free:
free(aclp);
return (ret);
}","static int
set_acl(struct archive *VAR_0, int VAR_1, const char *VAR_2,
struct archive_acl *VAR_3,
int VAR_4, const char *VAR_5)
{
aclent_t *VAR_6;
#if VAR_7
ace_t *VAR_8;
#endif
int VAR_9, VAR_10, VAR_11;
void *VAR_12;
int VAR_13;
int VAR_14, VAR_15, VAR_16, VAR_17;
int VAR_18;
const acl_perm_map_t*VAR_19;
uid_t VAR_20;
gid_t VAR_21;
const char*VAR_22;
int VAR_23;
int VAR_24;
VAR_13 = VAR_25;
VAR_23 = archive_acl_reset(VAR_3, VAR_4);
if (VAR_23 == 0)
return (VAR_25);
switch (VAR_4) {
case VAR_26:
VAR_9 = VAR_27;
VAR_12 = malloc(VAR_23 * sizeof(aclent_t));
break;
#if VAR_7
case VAR_28:
VAR_9 = VAR_29;
VAR_12 = malloc(VAR_23 * sizeof(ace_t));
break;
#endif
default:
VAR_30 = VAR_31;
archive_set_error(VAR_0, VAR_30, ""Unsupported ACL type"");
return (VAR_32);
}
if (VAR_12 == NULL) {
archive_set_error(VAR_0, VAR_30,
""Can't allocate memory for acl buffer"");
return (VAR_32);
}
VAR_10 = 0;
while (archive_acl_next(VAR_0, VAR_3, VAR_4, &VAR_14,
&VAR_15, &VAR_16, &VAR_17, &VAR_22) == VAR_25) {
VAR_6 = NULL;
#if VAR_7
VAR_8 = NULL;
#endif
if (VAR_9 == VAR_27) {
VAR_6 = &((aclent_t *)VAR_12)[VAR_10];
VAR_6->a_id = -1;
VAR_6->a_type = 0;
VAR_6->a_perm = 0;
}
#if VAR_7
else {
VAR_8 = &((ace_t *)VAR_12)[VAR_10];
VAR_8->a_who = -1;
VAR_8->a_access_mask = 0;
VAR_8->a_flags = 0;
}
#endif
switch (VAR_16) {
case VAR_33:
VAR_20 = archive_write_disk_uid(VAR_0, VAR_22, VAR_17);
if (VAR_6 != NULL) {
VAR_6->a_id = VAR_20;
VAR_6->a_type |= VAR_34;
}
#if VAR_7
else {
VAR_8->a_who = VAR_20;
}
#endif
break;
case VAR_35:
VAR_21 = archive_write_disk_gid(VAR_0, VAR_22, VAR_17);
if (VAR_6 != NULL) {
VAR_6->a_id = VAR_21;
VAR_6->a_type |= VAR_36;
}
#if VAR_7
else {
VAR_8->a_who = VAR_21;
VAR_8->a_flags |= VAR_37;
}
#endif
break;
case VAR_38:
if (VAR_6 != NULL)
VAR_6->a_type |= VAR_39;
#if VAR_7
else {
VAR_8->a_flags |= VAR_40;
}
#endif
break;
case VAR_41:
if (VAR_6 != NULL)
VAR_6->a_type |= VAR_42;
#if VAR_7
else {
VAR_8->a_flags |= VAR_43;
VAR_8->a_flags |= VAR_37;
}
#endif
break;
case VAR_44:
if (VAR_6 != NULL)
VAR_6->a_type |= VAR_45;
break;
case VAR_46:
if (VAR_6 != NULL)
VAR_6->a_type |= VAR_47;
break;
#if VAR_7
case VAR_48:
if (VAR_8 != NULL)
VAR_8->a_flags |= VAR_49;
break;
#endif
default:
archive_set_error(VAR_0, VAR_50,
""Unsupported ACL tag"");
VAR_13 = VAR_32;
goto exit_free;
}
VAR_11 = 0;
switch (VAR_14) {
#if VAR_7
case VAR_51:
if (VAR_8 != NULL)
VAR_8->a_type = VAR_52;
else
VAR_11 = -1;
break;
case VAR_53:
if (VAR_8 != NULL)
VAR_8->a_type = VAR_54;
else
VAR_11 = -1;
break;
case VAR_55:
if (VAR_8 != NULL)
VAR_8->a_type = VAR_56;
else
VAR_11 = -1;
break;
case VAR_57:
if (VAR_8 != NULL)
VAR_8->a_type = VAR_58;
else
VAR_11 = -1;
break;
#endif
case VAR_59:
if (VAR_6 == NULL)
VAR_11 = -1;
break;
case VAR_60:
if (VAR_6 != NULL)
VAR_6->a_type |= VAR_61;
else
VAR_11 = -1;
break;
default:
archive_set_error(VAR_0, VAR_50,
""Unsupported ACL entry type"");
VAR_13 = VAR_32;
goto exit_free;
}
if (VAR_11 != 0) {
VAR_30 = VAR_62;
archive_set_error(VAR_0, VAR_30,
""Failed to set ACL entry type"");
VAR_13 = VAR_32;
goto exit_free;
}
#if VAR_7
if (VAR_4 == VAR_28) {
VAR_18 = VAR_63;
VAR_19 = VAR_64;
} else {
#endif
perm_map_size = acl_posix_perm_map_size;
VAR_19 = VAR_65;
#if VAR_7
}
#endif
for (VAR_24 = 0; VAR_24 < VAR_18; ++VAR_24) {
if (VAR_15 & VAR_19[VAR_24].a_perm) {
#if VAR_7
if (VAR_4 ==
VAR_28)
VAR_8->a_access_mask |=
VAR_19[VAR_24].p_perm;
else
#endif
VAR_6->a_perm |= VAR_19[VAR_24].p_perm;
}
}
#if VAR_7
if (VAR_4 == VAR_28) {
for (VAR_24 = 0; VAR_24 < VAR_66; ++VAR_24) {
if (VAR_15 & VAR_67[VAR_24].a_perm) {
VAR_8->a_flags |=
VAR_67[VAR_24].p_perm;
}
}
}
#endif
VAR_10++;
}
if (VAR_1 >= 0) {
if (facl(VAR_1, VAR_9, VAR_23, VAR_12) == 0)
VAR_13 = VAR_25;
else {
if (VAR_30 == VAR_68) {
VAR_13 = VAR_25;
} else {
archive_set_error(VAR_0, VAR_30,
""Failed to set acl on fd: %s"", VAR_5);
VAR_13 = VAR_69;
}
}
} else if (acl(VAR_2, VAR_9, VAR_23, VAR_12) != 0) {
if (VAR_30 == VAR_68) {
VAR_13 = VAR_25;
} else {
archive_set_error(VAR_0, VAR_30, ""Failed to set acl: %s"",
VAR_5);
VAR_13 = VAR_69;
}
}
exit_free:
free(VAR_12);
return (VAR_13);
}",libarchive/fba4f123cc456d2b2538f811bb831483bf336bad/archive_disk_acl_sunos.c/vul/before/0.json,"static int
set_acl(struct archive *a, int fd, const char *name,
    struct archive_acl *abstract_acl, __LA_MODE_T mode,
    int ae_requested_type, const char *tname)
{
	aclent_t	 *aclent;
#if ARCHIVE_ACL_SUNOS_NFS4
	ace_t		 *ace;
#endif
	int		 cmd, e, r;
	void		 *aclp;
	int		 ret;
	int		 ae_type, ae_permset, ae_tag, ae_id;
	int		 perm_map_size;
	const acl_perm_map_t	*perm_map;
	uid_t		 ae_uid;
	gid_t		 ae_gid;
	const char	*ae_name;
	int		 entries;
	int		 i;

	ret = ARCHIVE_OK;
	entries = archive_acl_reset(abstract_acl, ae_requested_type);
	if (entries == 0)
		return (ARCHIVE_OK);

	switch (ae_requested_type) {
	case ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:
		cmd = SETACL;
		aclp = malloc(entries * sizeof(aclent_t));
		break;
#if ARCHIVE_ACL_SUNOS_NFS4
	case ARCHIVE_ENTRY_ACL_TYPE_NFS4:
		cmd = ACE_SETACL;
		aclp = malloc(entries * sizeof(ace_t));

		break;
#endif
	default:
		errno = ENOENT;
		archive_set_error(a, errno, ""Unsupported ACL type"");
		return (ARCHIVE_FAILED);
	}

	if (aclp == NULL) {
		archive_set_error(a, errno,
		    ""Can't allocate memory for acl buffer"");
		return (ARCHIVE_FAILED);
	}

        if (S_ISLNK(mode)) {
                /* Skip ACLs on symbolic links */
		ret = ARCHIVE_OK;
		goto exit_free;
        }

	e = 0;

	while (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,
		   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {
		aclent = NULL;
#if ARCHIVE_ACL_SUNOS_NFS4
		ace = NULL;
#endif
		if (cmd == SETACL) {
			aclent = &((aclent_t *)aclp)[e];
			aclent->a_id = -1;
			aclent->a_type = 0;
			aclent->a_perm = 0;
		}
#if ARCHIVE_ACL_SUNOS_NFS4
		else {	/* cmd == ACE_SETACL */
			ace = &((ace_t *)aclp)[e];
			ace->a_who = -1;
			ace->a_access_mask = 0;
			ace->a_flags = 0;
		}
#endif	/* ARCHIVE_ACL_SUNOS_NFS4 */

		switch (ae_tag) {
		case ARCHIVE_ENTRY_ACL_USER:
			ae_uid = archive_write_disk_uid(a, ae_name, ae_id);
			if (aclent != NULL) {
				aclent->a_id = ae_uid;
				aclent->a_type |= USER;
			}
#if ARCHIVE_ACL_SUNOS_NFS4
			else {
				ace->a_who = ae_uid;
			}
#endif
			break;
		case ARCHIVE_ENTRY_ACL_GROUP:
			ae_gid = archive_write_disk_gid(a, ae_name, ae_id);
			if (aclent != NULL) {
				aclent->a_id = ae_gid;
				aclent->a_type |= GROUP;
			}
#if ARCHIVE_ACL_SUNOS_NFS4
			else {
				ace->a_who = ae_gid;
				ace->a_flags |= ACE_IDENTIFIER_GROUP;
			}
#endif
			break;
		case ARCHIVE_ENTRY_ACL_USER_OBJ:
			if (aclent != NULL)
				aclent->a_type |= USER_OBJ;
#if ARCHIVE_ACL_SUNOS_NFS4
			else {
				ace->a_flags |= ACE_OWNER;
			}
#endif
			break;
		case ARCHIVE_ENTRY_ACL_GROUP_OBJ:
			if (aclent != NULL)
				aclent->a_type |= GROUP_OBJ;
#if ARCHIVE_ACL_SUNOS_NFS4
			else {
				ace->a_flags |= ACE_GROUP;
				ace->a_flags |= ACE_IDENTIFIER_GROUP;
			}
#endif
			break;
		case ARCHIVE_ENTRY_ACL_MASK:
			if (aclent != NULL)
				aclent->a_type |= CLASS_OBJ;
			break;
		case ARCHIVE_ENTRY_ACL_OTHER:
			if (aclent != NULL)
				aclent->a_type |= OTHER_OBJ;
			break;
#if ARCHIVE_ACL_SUNOS_NFS4
		case ARCHIVE_ENTRY_ACL_EVERYONE:
			if (ace != NULL)
				ace->a_flags |= ACE_EVERYONE;
			break;
#endif
		default:
			archive_set_error(a, ARCHIVE_ERRNO_MISC,
			    ""Unsupported ACL tag"");
			ret = ARCHIVE_FAILED;
			goto exit_free;
		}

		r = 0;
		switch (ae_type) {
#if ARCHIVE_ACL_SUNOS_NFS4
		case ARCHIVE_ENTRY_ACL_TYPE_ALLOW:
			if (ace != NULL)
				ace->a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;
			else
				r = -1;
			break;
		case ARCHIVE_ENTRY_ACL_TYPE_DENY:
			if (ace != NULL)
				ace->a_type = ACE_ACCESS_DENIED_ACE_TYPE;
			else
				r = -1;
			break;
		case ARCHIVE_ENTRY_ACL_TYPE_AUDIT:
			if (ace != NULL)
				ace->a_type = ACE_SYSTEM_AUDIT_ACE_TYPE;
			else
				r = -1;
			break;
		case ARCHIVE_ENTRY_ACL_TYPE_ALARM:
			if (ace != NULL)
				ace->a_type = ACE_SYSTEM_ALARM_ACE_TYPE;
			else
				r = -1;
			break;
#endif
		case ARCHIVE_ENTRY_ACL_TYPE_ACCESS:
			if (aclent == NULL)
				r = -1;
			break;
		case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:
			if (aclent != NULL)
				aclent->a_type |= ACL_DEFAULT;
			else
				r = -1;
			break;
		default:
			archive_set_error(a, ARCHIVE_ERRNO_MISC,
			    ""Unsupported ACL entry type"");
			ret = ARCHIVE_FAILED;
			goto exit_free;
		}

		if (r != 0) {
			errno = EINVAL;
			archive_set_error(a, errno,
			    ""Failed to set ACL entry type"");
			ret = ARCHIVE_FAILED;
			goto exit_free;
		}

#if ARCHIVE_ACL_SUNOS_NFS4
		if (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {
			perm_map_size = acl_nfs4_perm_map_size;
			perm_map = acl_nfs4_perm_map;
		} else {
#endif
			perm_map_size = acl_posix_perm_map_size;
			perm_map = acl_posix_perm_map;
#if ARCHIVE_ACL_SUNOS_NFS4
		}
#endif
		for (i = 0; i < perm_map_size; ++i) {
			if (ae_permset & perm_map[i].a_perm) {
#if ARCHIVE_ACL_SUNOS_NFS4
				if (ae_requested_type ==
				    ARCHIVE_ENTRY_ACL_TYPE_NFS4)
					ace->a_access_mask |=
					    perm_map[i].p_perm;
				else
#endif
					aclent->a_perm |= perm_map[i].p_perm;
			}
		}

#if ARCHIVE_ACL_SUNOS_NFS4
		if (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {
			for (i = 0; i < acl_nfs4_flag_map_size; ++i) {
				if (ae_permset & acl_nfs4_flag_map[i].a_perm) {
					ace->a_flags |=
					    acl_nfs4_flag_map[i].p_perm;
				}
			}
		}
#endif
	e++;
	}

	/* Try restoring the ACL through 'fd' if we can. */
	if (fd >= 0) {
		if (facl(fd, cmd, entries, aclp) == 0)
			ret = ARCHIVE_OK;
		else {
			if (errno == EOPNOTSUPP) {
				/* Filesystem doesn't support ACLs */
				ret = ARCHIVE_OK;
			} else {
				archive_set_error(a, errno,
				    ""Failed to set acl on fd: %s"", tname);
				ret = ARCHIVE_WARN;
			}
		}
	} else if (acl(name, cmd, entries, aclp) != 0) {
		if (errno == EOPNOTSUPP) {
			/* Filesystem doesn't support ACLs */
			ret = ARCHIVE_OK;
		} else {
			archive_set_error(a, errno, ""Failed to set acl: %s"",
			    tname);
			ret = ARCHIVE_WARN;
		}
	}
exit_free:
	free(aclp);
	return (ret);
}","static int
set_acl(struct archive *VAR_0, int VAR_1, const char *VAR_2,
    struct archive_acl *VAR_3, __LA_MODE_T VAR_4,
    int VAR_5, const char *VAR_6)
{
	aclent_t	 *VAR_7;
#if VAR_8
	ace_t		 *VAR_9;
#endif
	int		 VAR_10, VAR_11, VAR_12;
	void		 *VAR_13;
	int		 VAR_14;
	int		 VAR_15, VAR_16, VAR_17, VAR_18;
	int		 VAR_19;
	const acl_perm_map_t	*VAR_20;
	uid_t		 VAR_21;
	gid_t		 VAR_22;
	const char	*VAR_23;
	int		 VAR_24;
	int		 VAR_25;

	VAR_14 = VAR_26;
	VAR_24 = archive_acl_reset(VAR_3, VAR_5);
	if (VAR_24 == 0)
		return (VAR_26);

	switch (VAR_5) {
	case VAR_27:
		VAR_10 = VAR_28;
		VAR_13 = malloc(VAR_24 * sizeof(aclent_t));
		break;
#if VAR_8
	case VAR_29:
		VAR_10 = VAR_30;
		VAR_13 = malloc(VAR_24 * sizeof(ace_t));

		break;
#endif
	default:
		VAR_31 = VAR_32;
		archive_set_error(VAR_0, VAR_31, ""Unsupported ACL type"");
		return (VAR_33);
	}

	if (VAR_13 == NULL) {
		archive_set_error(VAR_0, VAR_31,
		    ""Can't allocate memory for acl buffer"");
		return (VAR_33);
	}

        if (S_ISLNK(VAR_4)) {
                /* COMMENT_0 */
		VAR_14 = VAR_26;
		goto exit_free;
        }

	VAR_11 = 0;

	while (archive_acl_next(VAR_0, VAR_3, VAR_5, &VAR_15,
		   &VAR_16, &VAR_17, &VAR_18, &VAR_23) == VAR_26) {
		VAR_7 = NULL;
#if VAR_8
		VAR_9 = NULL;
#endif
		if (VAR_10 == VAR_28) {
			VAR_7 = &((aclent_t *)VAR_13)[VAR_11];
			VAR_7->a_id = -1;
			VAR_7->a_type = 0;
			VAR_7->a_perm = 0;
		}
#if VAR_8
		else {	/* COMMENT_1 */
			VAR_9 = &((ace_t *)VAR_13)[VAR_11];
			VAR_9->a_who = -1;
			VAR_9->a_access_mask = 0;
			VAR_9->a_flags = 0;
		}
#endif	/* COMMENT_2 */

		switch (VAR_17) {
		case VAR_34:
			VAR_21 = archive_write_disk_uid(VAR_0, VAR_23, VAR_18);
			if (VAR_7 != NULL) {
				VAR_7->a_id = VAR_21;
				VAR_7->a_type |= VAR_35;
			}
#if VAR_8
			else {
				VAR_9->a_who = VAR_21;
			}
#endif
			break;
		case VAR_36:
			VAR_22 = archive_write_disk_gid(VAR_0, VAR_23, VAR_18);
			if (VAR_7 != NULL) {
				VAR_7->a_id = VAR_22;
				VAR_7->a_type |= VAR_37;
			}
#if VAR_8
			else {
				VAR_9->a_who = VAR_22;
				VAR_9->a_flags |= VAR_38;
			}
#endif
			break;
		case VAR_39:
			if (VAR_7 != NULL)
				VAR_7->a_type |= VAR_40;
#if VAR_8
			else {
				VAR_9->a_flags |= VAR_41;
			}
#endif
			break;
		case VAR_42:
			if (VAR_7 != NULL)
				VAR_7->a_type |= VAR_43;
#if VAR_8
			else {
				VAR_9->a_flags |= VAR_44;
				VAR_9->a_flags |= VAR_38;
			}
#endif
			break;
		case VAR_45:
			if (VAR_7 != NULL)
				VAR_7->a_type |= VAR_46;
			break;
		case VAR_47:
			if (VAR_7 != NULL)
				VAR_7->a_type |= VAR_48;
			break;
#if VAR_8
		case VAR_49:
			if (VAR_9 != NULL)
				VAR_9->a_flags |= VAR_50;
			break;
#endif
		default:
			archive_set_error(VAR_0, VAR_51,
			    ""Unsupported ACL tag"");
			VAR_14 = VAR_33;
			goto exit_free;
		}

		VAR_12 = 0;
		switch (VAR_15) {
#if VAR_8
		case VAR_52:
			if (VAR_9 != NULL)
				VAR_9->a_type = VAR_53;
			else
				VAR_12 = -1;
			break;
		case VAR_54:
			if (VAR_9 != NULL)
				VAR_9->a_type = VAR_55;
			else
				VAR_12 = -1;
			break;
		case VAR_56:
			if (VAR_9 != NULL)
				VAR_9->a_type = VAR_57;
			else
				VAR_12 = -1;
			break;
		case VAR_58:
			if (VAR_9 != NULL)
				VAR_9->a_type = VAR_59;
			else
				VAR_12 = -1;
			break;
#endif
		case VAR_60:
			if (VAR_7 == NULL)
				VAR_12 = -1;
			break;
		case VAR_61:
			if (VAR_7 != NULL)
				VAR_7->a_type |= VAR_62;
			else
				VAR_12 = -1;
			break;
		default:
			archive_set_error(VAR_0, VAR_51,
			    ""Unsupported ACL entry type"");
			VAR_14 = VAR_33;
			goto exit_free;
		}

		if (VAR_12 != 0) {
			VAR_31 = VAR_63;
			archive_set_error(VAR_0, VAR_31,
			    ""Failed to set ACL entry type"");
			VAR_14 = VAR_33;
			goto exit_free;
		}

#if VAR_8
		if (VAR_5 == VAR_29) {
			VAR_19 = VAR_64;
			VAR_20 = VAR_65;
		} else {
#endif
			perm_map_size = acl_posix_perm_map_size;
			VAR_20 = VAR_66;
#if VAR_8
		}
#endif
		for (VAR_25 = 0; VAR_25 < VAR_19; ++VAR_25) {
			if (VAR_16 & VAR_20[VAR_25].a_perm) {
#if VAR_8
				if (VAR_5 ==
				    VAR_29)
					VAR_9->a_access_mask |=
					    VAR_20[VAR_25].p_perm;
				else
#endif
					VAR_7->a_perm |= VAR_20[VAR_25].p_perm;
			}
		}

#if VAR_8
		if (VAR_5 == VAR_29) {
			for (VAR_25 = 0; VAR_25 < VAR_67; ++VAR_25) {
				if (VAR_16 & VAR_68[VAR_25].a_perm) {
					VAR_9->a_flags |=
					    VAR_68[VAR_25].p_perm;
				}
			}
		}
#endif
	VAR_11++;
	}

	/* COMMENT_3 */
	if (VAR_1 >= 0) {
		if (facl(VAR_1, VAR_10, VAR_24, VAR_13) == 0)
			VAR_14 = VAR_26;
		else {
			if (VAR_31 == VAR_69) {
				/* COMMENT_4 */
				VAR_14 = VAR_26;
			} else {
				archive_set_error(VAR_0, VAR_31,
				    ""Failed to set acl on fd: %s"", VAR_6);
				VAR_14 = VAR_70;
			}
		}
	} else if (acl(VAR_2, VAR_10, VAR_24, VAR_13) != 0) {
		if (VAR_31 == VAR_69) {
			/* COMMENT_4 */
			VAR_14 = VAR_26;
		} else {
			archive_set_error(VAR_0, VAR_31, ""Failed to set acl: %s"",
			    VAR_6);
			VAR_14 = VAR_70;
		}
	}
exit_free:
	free(VAR_13);
	return (VAR_14);
}",libarchive/fba4f123cc456d2b2538f811bb831483bf336bad/archive_disk_acl_sunos.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 set_acl(struct archive *a, int fd, const char *name,
-    struct archive_acl *abstract_acl,
+    struct archive_acl *abstract_acl, __LA_MODE_T mode,
     int ae_requested_type, const char *tname)
 {
 	aclent_t	 *aclent;
@@ -24,7 +24,6 @@
 	if (entries == 0)
 		return (ARCHIVE_OK);
 
-
 	switch (ae_requested_type) {
 	case ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:
 		cmd = SETACL;
@@ -48,6 +47,12 @@
 		    ""Can't allocate memory for acl buffer"");
 		return (ARCHIVE_FAILED);
 	}
+
+        if (S_ISLNK(mode)) {
+                /* Skip ACLs on symbolic links */
+		ret = ARCHIVE_OK;
+		goto exit_free;
+        }
 
 	e = 0;
 ","{'deleted_lines': ['    struct archive_acl *abstract_acl,', ''], 'added_lines': ['    struct archive_acl *abstract_acl, __LA_MODE_T mode,', '', '        if (S_ISLNK(mode)) {', '                /* Skip ACLs on symbolic links */', '\t\tret = ARCHIVE_OK;', '\t\tgoto exit_free;', '        }']}",True,"An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges.",7.8,HIGH,2,test,2021-08-21T18:51:07Z,3
CVE-2021-23177,['CWE-59'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1,libarchive,"Fix handling of symbolic link ACLs

On Linux ACLs on symbolic links are not supported.
We must avoid calling acl_set_file() on symbolic links as their
targets are modified instead.

While here, do not try to set default ACLs on non-directories.

Fixes #1565",fba4f123cc456d2b2538f811bb831483bf336bad,https://github.com/libarchive/libarchive/commit/fba4f123cc456d2b2538f811bb831483bf336bad,libarchive/archive_disk_acl_sunos.c,archive_write_disk_set_acls,"int
archive_write_disk_set_acls(struct archive *a, int fd, const char *name,
struct archive_acl *abstract_acl, __LA_MODE_T mode)
{
intret = ARCHIVE_OK;
(void)mode;
if ((archive_acl_types(abstract_acl)
& ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {
ret = set_acl(a, fd, name, abstract_acl,
ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, ""posix1e"");
return (ret);
}
#if ARCHIVE_ACL_SUNOS_NFS4
else if ((archive_acl_types(abstract_acl) &
ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {
ret = set_acl(a, fd, name, abstract_acl,
ARCHIVE_ENTRY_ACL_TYPE_NFS4, ""nfs4"");
}
#endif
return (ret);
}","int
archive_write_disk_set_acls(struct archive *VAR_0, int VAR_1, const char *VAR_2,
struct archive_acl *VAR_3, __LA_MODE_T VAR_4)
{
intVAR_5 = VAR_6;
(void)VAR_4;
if ((archive_acl_types(VAR_3)
& VAR_7) != 0) {
VAR_5 = set_acl(VAR_0, VAR_1, VAR_2, VAR_3,
VAR_7, ""posix1e"");
return (VAR_5);
}
#if VAR_8
else if ((VAR_9(abstract_acl) &
VAR_10) != 0) {
VAR_5 = set_acl(VAR_0, VAR_1, VAR_2, abstract_acl,
VAR_10, ""nfs4"");
}
#endif
return (VAR_5);
}",libarchive/fba4f123cc456d2b2538f811bb831483bf336bad/archive_disk_acl_sunos.c/vul/before/1.json,"int
archive_write_disk_set_acls(struct archive *a, int fd, const char *name,
    struct archive_acl *abstract_acl, __LA_MODE_T mode)
{
	int		ret = ARCHIVE_OK;

	(void)mode;	/* UNUSED */

	if ((archive_acl_types(abstract_acl)
	    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {
		/* Solaris writes POSIX.1e access and default ACLs together */
		ret = set_acl(a, fd, name, abstract_acl, mode,
		    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, ""posix1e"");

		/* Simultaneous POSIX.1e and NFSv4 is not supported */
		return (ret);
	}
#if ARCHIVE_ACL_SUNOS_NFS4
	else if ((archive_acl_types(abstract_acl) &
	    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {
		ret = set_acl(a, fd, name, abstract_acl, mode,
		    ARCHIVE_ENTRY_ACL_TYPE_NFS4, ""nfs4"");
	}
#endif
	return (ret);
}","int
archive_write_disk_set_acls(struct archive *VAR_0, int VAR_1, const char *VAR_2,
    struct archive_acl *VAR_3, __LA_MODE_T VAR_4)
{
	int		VAR_5 = VAR_6;

	(void)VAR_4;	/* COMMENT_0 */

	if ((archive_acl_types(VAR_3)
	    & VAR_7) != 0) {
		/* COMMENT_1 */
		VAR_5 = set_acl(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
		    VAR_7, ""posix1e"");

		/* COMMENT_2 */
		return (VAR_5);
	}
#if VAR_8
	else if ((VAR_9(abstract_acl) &
	    VAR_10) != 0) {
		VAR_5 = set_acl(VAR_0, VAR_1, VAR_2, abstract_acl, VAR_4,
		    VAR_10, ""nfs4"");
	}
#endif
	return (VAR_5);
}",libarchive/fba4f123cc456d2b2538f811bb831483bf336bad/archive_disk_acl_sunos.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -9,7 +9,7 @@
 	if ((archive_acl_types(abstract_acl)
 	    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {
 		/* Solaris writes POSIX.1e access and default ACLs together */
-		ret = set_acl(a, fd, name, abstract_acl,
+		ret = set_acl(a, fd, name, abstract_acl, mode,
 		    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, ""posix1e"");
 
 		/* Simultaneous POSIX.1e and NFSv4 is not supported */
@@ -18,7 +18,7 @@
 #if ARCHIVE_ACL_SUNOS_NFS4
 	else if ((archive_acl_types(abstract_acl) &
 	    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {
-		ret = set_acl(a, fd, name, abstract_acl,
+		ret = set_acl(a, fd, name, abstract_acl, mode,
 		    ARCHIVE_ENTRY_ACL_TYPE_NFS4, ""nfs4"");
 	}
 #endif","{'deleted_lines': ['\t\tret = set_acl(a, fd, name, abstract_acl,', '\t\tret = set_acl(a, fd, name, abstract_acl,'], 'added_lines': ['\t\tret = set_acl(a, fd, name, abstract_acl, mode,', '\t\tret = set_acl(a, fd, name, abstract_acl, mode,']}",True,"An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges.",7.8,HIGH,2,test,2021-08-21T18:51:07Z,3
CVE-2021-40608,['CWE-908'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1883,b09c75dc2d4bf68ac447daa71e72365aa30231a9,https://github.com/gpac/gpac/commit/b09c75dc2d4bf68ac447daa71e72365aa30231a9,src/isomedia/tx3g.c,gf_isom_text_get_encoded_tx3g,"GF_Err gf_isom_text_get_encoded_tx3g(GF_ISOFile *file, u32 track, u32 sidx, u32 sidx_offset, u8 **tx3g, u32 *tx3g_size)
{
GF_BitStream *bs;
GF_TrackBox *trak;
GF_Tx3gSampleEntryBox *a;
trak = gf_isom_get_track_from_file(file, track);
if (!trak) return GF_BAD_PARAM;
a = (GF_Tx3gSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sidx-1);
if (!a) return GF_BAD_PARAM;
if ((a->type != GF_ISOM_BOX_TYPE_TX3G) && (a->type != GF_ISOM_BOX_TYPE_TEXT)) return GF_BAD_PARAM;
bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
gf_isom_write_tx3g(a, bs, sidx, sidx_offset);
*tx3g = NULL;
*tx3g_size = 0;
gf_bs_get_content(bs, tx3g, tx3g_size);
gf_bs_del(bs);
return GF_OK;
}","GF_Err gf_isom_text_get_encoded_tx3g(GF_ISOFile *VAR_0, u32 VAR_1, u32 VAR_2, u32 VAR_3, u8 **VAR_4, u32 *VAR_5)
{
GF_BitStream *VAR_6;
GF_TrackBox *VAR_7;
GF_Tx3gSampleEntryBox *VAR_8;
VAR_7 = gf_isom_get_track_from_file(VAR_0, VAR_1);
if (!VAR_7) return VAR_9;
VAR_8 = (GF_Tx3gSampleEntryBox *) gf_list_get(VAR_7->Media->information->sampleTable->SampleDescription->child_boxes, VAR_2-1);
if (!VAR_8) return VAR_9;
if ((VAR_8->type != VAR_10) && (VAR_8->type != VAR_11)) return VAR_9;
VAR_6 = gf_bs_new(NULL, 0, VAR_12);
gf_isom_write_tx3g(VAR_8, VAR_6, VAR_2, VAR_3);
*VAR_4 = NULL;
*VAR_5 = 0;
gf_bs_get_content(VAR_6, VAR_4, VAR_5);
gf_bs_del(VAR_6);
return VAR_13;
}",gpac/b09c75dc2d4bf68ac447daa71e72365aa30231a9/tx3g.c/vul/before/0.json,"GF_Err gf_isom_text_get_encoded_tx3g(GF_ISOFile *file, u32 track, u32 sidx, u32 sidx_offset, u8 **tx3g, u32 *tx3g_size)
{
	GF_BitStream *bs;
	GF_TrackBox *trak;
	GF_Tx3gSampleEntryBox *a;

	*tx3g = NULL;
	*tx3g_size = 0;
	trak = gf_isom_get_track_from_file(file, track);
	if (!trak) return GF_BAD_PARAM;

	a = (GF_Tx3gSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sidx-1);
	if (!a) return GF_BAD_PARAM;
	if ((a->type != GF_ISOM_BOX_TYPE_TX3G) && (a->type != GF_ISOM_BOX_TYPE_TEXT)) return GF_BAD_PARAM;

	bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
	gf_isom_write_tx3g(a, bs, sidx, sidx_offset);
	gf_bs_get_content(bs, tx3g, tx3g_size);
	gf_bs_del(bs);
	return GF_OK;
}","GF_Err gf_isom_text_get_encoded_tx3g(GF_ISOFile *VAR_0, u32 VAR_1, u32 VAR_2, u32 VAR_3, u8 **VAR_4, u32 *VAR_5)
{
	GF_BitStream *VAR_6;
	GF_TrackBox *VAR_7;
	GF_Tx3gSampleEntryBox *VAR_8;

	*VAR_4 = NULL;
	*VAR_5 = 0;
	VAR_7 = gf_isom_get_track_from_file(VAR_0, VAR_1);
	if (!VAR_7) return VAR_9;

	VAR_8 = (GF_Tx3gSampleEntryBox *) gf_list_get(VAR_7->Media->information->sampleTable->SampleDescription->child_boxes, VAR_2-1);
	if (!VAR_8) return VAR_9;
	if ((VAR_8->type != VAR_10) && (VAR_8->type != VAR_11)) return VAR_9;

	VAR_6 = gf_bs_new(NULL, 0, VAR_12);
	gf_isom_write_tx3g(VAR_8, VAR_6, VAR_2, VAR_3);
	gf_bs_get_content(VAR_6, VAR_4, VAR_5);
	gf_bs_del(VAR_6);
	return VAR_13;
}",gpac/b09c75dc2d4bf68ac447daa71e72365aa30231a9/tx3g.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,8 @@
 	GF_TrackBox *trak;
 	GF_Tx3gSampleEntryBox *a;
 
+	*tx3g = NULL;
+	*tx3g_size = 0;
 	trak = gf_isom_get_track_from_file(file, track);
 	if (!trak) return GF_BAD_PARAM;
 
@@ -13,8 +15,6 @@
 
 	bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
 	gf_isom_write_tx3g(a, bs, sidx, sidx_offset);
-	*tx3g = NULL;
-	*tx3g_size = 0;
 	gf_bs_get_content(bs, tx3g, tx3g_size);
 	gf_bs_del(bs);
 	return GF_OK;","{'deleted_lines': ['\t*tx3g = NULL;', '\t*tx3g_size = 0;'], 'added_lines': ['\t*tx3g = NULL;', '\t*tx3g_size = 0;']}",True,The gf_hinter_track_finalize function in GPAC 1.0.1 allows attackers to cause a denial of service via a crafted file in the MP4Box command.,5.5,MEDIUM,1,test,2021-08-30T12:43:17Z,3
CVE-2021-40608,['CWE-908'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1883,b09c75dc2d4bf68ac447daa71e72365aa30231a9,https://github.com/gpac/gpac/commit/b09c75dc2d4bf68ac447daa71e72365aa30231a9,src/media_tools/isom_hinter.c,gf_hinter_track_finalize,"GF_EXPORT
GF_Err gf_hinter_track_finalize(GF_RTPHinter *tkHint, Bool AddSystemInfo)
{
u32 Width, Height;
GF_ESD *esd;
char sdpLine[20000];
char mediaName[30], payloadName[30];
u32 mtype;
Width = Height = 0;
gf_isom_sdp_clean_track(tkHint->file, tkHint->TrackNum);
mtype = gf_isom_get_media_type(tkHint->file, tkHint->TrackNum);
if (gf_isom_is_video_handler_type(mtype))
gf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);
gf_rtp_builder_get_payload_name(tkHint->rtp_p, payloadName, mediaName);
sprintf(sdpLine, ""m=%s 0 RTP/%s %d"", mediaName, tkHint->rtp_p->slMap.IV_length ? ""SAVP"" : ""AVP"", tkHint->rtp_p->PayloadType);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
if (tkHint->bandwidth) {
sprintf(sdpLine, ""b=AS:%d"", tkHint->bandwidth);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
if (tkHint->nb_chan) {
sprintf(sdpLine, ""a=rtpmap:%d %s/%d/%d"", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution, tkHint->nb_chan);
} else {
sprintf(sdpLine, ""a=rtpmap:%d %s/%d"", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution);
}
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
if (AddSystemInfo) {
sprintf(sdpLine, ""a=mpeg4-esid:%d"", gf_isom_get_track_id(tkHint->file, tkHint->TrackNum));
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
sprintf(sdpLine, ""a=control:trackID=%d"", gf_isom_get_track_id(tkHint->file, tkHint->HintTrack));
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
if (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H263) {
sprintf(sdpLine, ""a=cliprect:0,0,%d,%d"", Height, Width);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR_WB)) {
sprintf(sdpLine, ""a=fmtp:%d octet-align=1"", tkHint->rtp_p->PayloadType);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
else if (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_3GPP_TEXT) {
u32 w, h, i, m_w, m_h;
s32 tx, ty;
s16 l;
gf_isom_get_track_layout_info(tkHint->file, tkHint->TrackNum, &w, &h, &tx, &ty, &l);
m_w = w;
m_h = h;
for (i=0; i<gf_isom_get_track_count(tkHint->file); i++) {
switch (gf_isom_get_media_type(tkHint->file, i+1)) {
case GF_ISOM_MEDIA_SCENE:
case GF_ISOM_MEDIA_VISUAL:
case GF_ISOM_MEDIA_AUXV:
case GF_ISOM_MEDIA_PICT:
gf_isom_get_track_layout_info(tkHint->file, i+1, &w, &h, &tx, &ty, &l);
if (w>m_w) m_w = w;
if (h>m_h) m_h = h;
break;
default:
break;
}
}
gf_media_format_ttxt_sdp(tkHint->rtp_p, payloadName, sdpLine, w, h, tx, ty, l, m_w, m_h, NULL);
strcat(sdpLine, ""; tx3g="");
for (i=0; i<gf_isom_get_sample_description_count(tkHint->file, tkHint->TrackNum); i++) {
u8 *tx3g;
char buffer[2000];
u32 tx3g_len, len;
gf_isom_text_get_encoded_tx3g(tkHint->file, tkHint->TrackNum, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);
len = gf_base64_encode(tx3g, tx3g_len, buffer, 2000);
gf_free(tx3g);
buffer[len] = 0;
if (i) strcat(sdpLine, "", "");
strcat(sdpLine, buffer);
}
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_EVRC_SMV) && (tkHint->rtp_p->auh_size>1)) {
sprintf(sdpLine, ""a=fmtp:%d maxptime=%d"", tkHint->rtp_p->PayloadType, tkHint->rtp_p->auh_size*20);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_AVC) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_SVC))  {
GF_AVCConfig *avcc = gf_isom_avc_config_get(tkHint->file, tkHint->TrackNum, 1);
GF_AVCConfig *svcc = gf_isom_svc_config_get(tkHint->file, tkHint->TrackNum, 1);
if (avcc) {
sprintf(sdpLine, ""a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1"", tkHint->rtp_p->PayloadType, avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);
} else {
if (!svcc)
return GF_ISOM_INVALID_FILE;
sprintf(sdpLine, ""a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1"", tkHint->rtp_p->PayloadType, svcc->AVCProfileIndication, svcc->profile_compatibility, svcc->AVCLevelIndication);
}
write_avc_config(sdpLine, avcc, svcc);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
gf_odf_avc_cfg_del(avcc);
gf_odf_avc_cfg_del(svcc);
}
else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_MPEG4) {
esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);
if (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {
gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);
} else {
gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, NULL, 0);
}
if (esd) gf_odf_desc_del((GF_Descriptor *)esd);
if (tkHint->rtp_p->slMap.IV_length) {
const char *kms;
gf_isom_get_ismacryp_info(tkHint->file, tkHint->TrackNum, 1, NULL, NULL, NULL, NULL, &kms, NULL, NULL, NULL);
if (!strnicmp(kms, ""(key)"", 5) || !strnicmp(kms, ""(ipmp)"", 6) || !strnicmp(kms, ""(uri)"", 5)) {
strcat(sdpLine, ""; ISMACrypKey="");
} else {
strcat(sdpLine, ""; ISMACrypKey=(uri)"");
}
strcat(sdpLine, kms);
}
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_LATM) {
GF_BitStream *bs;
u8 *config_bytes;
u32 config_size;
bs = gf_bs_new(NULL, 32, GF_BITSTREAM_WRITE);
gf_bs_write_int(bs, 0, 1); 
gf_bs_write_int(bs, 1, 1); 
gf_bs_write_int(bs, 0, 6); 
gf_bs_write_int(bs, 0, 4); 
gf_bs_write_int(bs, 0, 3); 
esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);
if (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {
gf_bs_write_data(bs, esd->decoderConfig->decoderSpecificInfo->data, MIN(esd->decoderConfig->decoderSpecificInfo->dataLength, 2) );
}
if (esd) gf_odf_desc_del((GF_Descriptor *)esd);
gf_bs_write_int(bs, 0, 3); 
gf_bs_write_int(bs, 0xff, 8); 
gf_bs_write_int(bs, 0, 1); 
gf_bs_write_int(bs, 0, 1); 
gf_bs_get_content(bs, &config_bytes, &config_size);
gf_bs_del(bs);
gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, config_bytes, config_size);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
gf_free(config_bytes);
}
#if GPAC_ENABLE_3GPP_DIMS_RTP
else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_3GPP_DIMS) {
GF_DIMSDescription dims;
gf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);
gf_isom_get_dims_description(tkHint->file, tkHint->TrackNum, 1, &dims);
sprintf(sdpLine, ""a=fmtp:%d Version-profile=%d"", tkHint->rtp_p->PayloadType, dims.profile);
if (! dims.fullRequestHost) {
char fmt[200];
strcat(sdpLine, "";useFullRequestHost=0"");
sprintf(fmt, "";pathComponents=%d"", dims.pathComponents);
strcat(sdpLine, fmt);
}
if (!dims.streamType) strcat(sdpLine, "";stream-type=secondary"");
if (dims.containsRedundant == 1) strcat(sdpLine, "";contains-redundant=main"");
else if (dims.containsRedundant == 2) strcat(sdpLine, "";contains-redundant=redundant"");
if (dims.textEncoding && strlen(dims.textEncoding)) {
strcat(sdpLine, "";text-encoding="");
strcat(sdpLine, dims.textEncoding);
}
if (dims.contentEncoding && strlen(dims.contentEncoding)) {
strcat(sdpLine, "";content-coding="");
strcat(sdpLine, dims.contentEncoding);
}
if (dims.contentEncoding && dims.content_script_types && strlen(dims.content_script_types) ) {
strcat(sdpLine, "";content-script-types="");
strcat(sdpLine, dims.contentEncoding);
}
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
#endif
if (Width && Height) {
sprintf(sdpLine, ""a=framesize:%d %d-%d"", tkHint->rtp_p->PayloadType, Width, Height);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);
if (esd && esd->decoderConfig && (esd->decoderConfig->rvc_config || esd->decoderConfig->predefined_rvc_config)) {
if (esd->decoderConfig->predefined_rvc_config) {
sprintf(sdpLine, ""a=rvc-config-predef:%d"", esd->decoderConfig->predefined_rvc_config);
} else {
if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_SVC)) {
sprintf(sdpLine, ""a=rvc-config:%s"", ""http:} else {
sprintf(sdpLine, ""a=rvc-config:%s"", ""http:}
}
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
if (esd) gf_odf_desc_del((GF_Descriptor *)esd);
gf_isom_set_track_enabled(tkHint->file, tkHint->HintTrack, GF_TRUE);
return GF_OK;
}","GF_EXPORT
VAR_0 gf_hinter_track_finalize(GF_RTPHinter *VAR_1, Bool VAR_2)
{
u32 VAR_3, VAR_4;
GF_ESD *VAR_5;
char VAR_6[20000];
char VAR_7[30], VAR_8[30];
u32 VAR_9;
VAR_3 = VAR_4 = 0;
gf_isom_sdp_clean_track(VAR_1->file, VAR_1->TrackNum);
VAR_9 = gf_isom_get_media_type(VAR_1->file, VAR_1->TrackNum);
if (gf_isom_is_video_handler_type(VAR_9))
gf_isom_get_visual_info(VAR_1->file, VAR_1->TrackNum, 1, &VAR_3, &VAR_4);
gf_rtp_builder_get_payload_name(VAR_1->rtp_p, VAR_8, VAR_7);
sprintf(VAR_6, ""m=%s 0 RTP/%s %d"", VAR_7, VAR_1->rtp_p->slMap.IV_length ? ""SAVP"" : ""AVP"", VAR_1->rtp_p->PayloadType);
gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
if (VAR_1->bandwidth) {
sprintf(VAR_6, ""b=AS:%d"", VAR_1->bandwidth);
gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
}
if (VAR_1->nb_chan) {
sprintf(VAR_6, ""a=rtpmap:%d %s/%d/%d"", VAR_1->rtp_p->PayloadType, VAR_8, VAR_1->rtp_p->sl_config.timestampResolution, VAR_1->nb_chan);
} else {
sprintf(VAR_6, ""a=rtpmap:%d %s/%d"", VAR_1->rtp_p->PayloadType, VAR_8, VAR_1->rtp_p->sl_config.timestampResolution);
}
gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
if (VAR_2) {
sprintf(VAR_6, ""a=mpeg4-esid:%d"", gf_isom_get_track_id(VAR_1->file, VAR_1->TrackNum));
gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
}
sprintf(VAR_6, ""a=control:trackID=%d"", gf_isom_get_track_id(VAR_1->file, VAR_1->HintTrack));
gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
if (VAR_1->rtp_p->rtp_payt == VAR_10) {
sprintf(VAR_6, ""a=cliprect:0,0,%d,%d"", VAR_4, VAR_3);
gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
}
else if ((VAR_1->rtp_p->rtp_payt == VAR_11) || (VAR_1->rtp_p->rtp_payt == VAR_12)) {
sprintf(VAR_6, ""a=fmtp:%d octet-align=1"", VAR_1->rtp_p->PayloadType);
gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
}
else if (VAR_1->rtp_p->rtp_payt == VAR_13) {
u32 VAR_14, VAR_15, VAR_16, VAR_17, VAR_18;
s32 VAR_19, VAR_20;
s16 VAR_21;
gf_isom_get_track_layout_info(VAR_1->file, VAR_1->TrackNum, &VAR_14, &VAR_15, &VAR_19, &VAR_20, &VAR_21);
VAR_17 = VAR_14;
VAR_18 = VAR_15;
for (VAR_16=0; VAR_16<gf_isom_get_track_count(VAR_1->file); VAR_16++) {
switch (gf_isom_get_media_type(VAR_1->file, VAR_16+1)) {
case VAR_22:
case VAR_23:
case VAR_24:
case VAR_25:
gf_isom_get_track_layout_info(VAR_1->file, VAR_16+1, &VAR_14, &VAR_15, &VAR_19, &VAR_20, &VAR_21);
if (VAR_14>VAR_17) VAR_17 = VAR_14;
if (VAR_15>VAR_18) VAR_18 = VAR_15;
break;
default:
break;
}
}
gf_media_format_ttxt_sdp(VAR_1->rtp_p, VAR_8, VAR_6, VAR_14, VAR_15, VAR_19, VAR_20, VAR_21, VAR_17, VAR_18, NULL);
strcat(VAR_6, ""; tx3g="");
for (VAR_16=0; VAR_16<gf_isom_get_sample_description_count(VAR_1->file, VAR_1->TrackNum); VAR_16++) {
u8 *VAR_26;
char VAR_27[2000];
u32 VAR_28, VAR_29;
gf_isom_text_get_encoded_tx3g(VAR_1->file, VAR_1->TrackNum, VAR_16+1, VAR_30, &VAR_26, &VAR_28);
VAR_29 = gf_base64_encode(VAR_26, VAR_28, VAR_27, 2000);
gf_free(VAR_26);
VAR_27[VAR_29] = 0;
if (VAR_16) strcat(VAR_6, "", "");
strcat(VAR_6, VAR_27);
}
gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
}
else if ((VAR_1->rtp_p->rtp_payt == VAR_31) && (VAR_1->rtp_p->auh_size>1)) {
sprintf(VAR_6, ""a=fmtp:%d maxptime=%d"", VAR_1->rtp_p->PayloadType, VAR_1->rtp_p->auh_size*20);
gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
}
else if ((VAR_1->rtp_p->rtp_payt == VAR_32) || (VAR_1->rtp_p->rtp_payt == VAR_33))  {
GF_AVCConfig *VAR_34 = gf_isom_avc_config_get(VAR_1->file, VAR_1->TrackNum, 1);
GF_AVCConfig *VAR_35 = gf_isom_svc_config_get(VAR_1->file, VAR_1->TrackNum, 1);
if (VAR_34) {
sprintf(VAR_6, ""a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1"", VAR_1->rtp_p->PayloadType, VAR_34->AVCProfileIndication, VAR_34->profile_compatibility, VAR_34->AVCLevelIndication);
} else {
if (!VAR_35)
return VAR_36;
sprintf(VAR_6, ""a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1"", VAR_1->rtp_p->PayloadType, VAR_35->AVCProfileIndication, VAR_35->profile_compatibility, VAR_35->AVCLevelIndication);
}
write_avc_config(VAR_6, VAR_34, VAR_35);
gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
gf_odf_avc_cfg_del(VAR_34);
gf_odf_avc_cfg_del(VAR_35);
}
else if (VAR_1->rtp_p->rtp_payt==VAR_37) {
VAR_5 = gf_isom_get_esd(VAR_1->file, VAR_1->TrackNum, 1);
if (VAR_5 && VAR_5->decoderConfig && VAR_5->decoderConfig->decoderSpecificInfo && VAR_5->decoderConfig->decoderSpecificInfo->data) {
gf_rtp_builder_format_sdp(VAR_1->rtp_p, VAR_8, VAR_6, VAR_5->decoderConfig->decoderSpecificInfo->data, VAR_5->decoderConfig->decoderSpecificInfo->dataLength);
} else {
gf_rtp_builder_format_sdp(VAR_1->rtp_p, VAR_8, VAR_6, NULL, 0);
}
if (VAR_5) gf_odf_desc_del((GF_Descriptor *)VAR_5);
if (VAR_1->rtp_p->slMap.IV_length) {
const char *VAR_38;
gf_isom_get_ismacryp_info(VAR_1->file, VAR_1->TrackNum, 1, NULL, NULL, NULL, NULL, &VAR_38, NULL, NULL, NULL);
if (!strnicmp(VAR_38, ""(key)"", 5) || !strnicmp(VAR_38, ""(ipmp)"", 6) || !strnicmp(VAR_38, ""(uri)"", 5)) {
strcat(VAR_6, ""; ISMACrypKey="");
} else {
strcat(VAR_6, ""; ISMACrypKey=(uri)"");
}
strcat(VAR_6, VAR_38);
}
gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
}
else if (VAR_1->rtp_p->rtp_payt==VAR_39) {
GF_BitStream *VAR_40;
u8 *VAR_41;
u32 VAR_42;
VAR_40 = gf_bs_new(NULL, 32, VAR_43);
gf_bs_write_int(VAR_40, 0, 1); 
gf_bs_write_int(VAR_40, 1, 1); 
gf_bs_write_int(VAR_40, 0, 6); 
gf_bs_write_int(VAR_40, 0, 4); 
gf_bs_write_int(VAR_40, 0, 3); 
VAR_5 = gf_isom_get_esd(VAR_1->file, VAR_1->TrackNum, 1);
if (VAR_5 && VAR_5->decoderConfig && VAR_5->decoderConfig->decoderSpecificInfo) {
gf_bs_write_data(VAR_40, VAR_5->decoderConfig->decoderSpecificInfo->data, MIN(VAR_5->decoderConfig->decoderSpecificInfo->dataLength, 2) );
}
if (VAR_5) gf_odf_desc_del((GF_Descriptor *)VAR_5);
gf_bs_write_int(VAR_40, 0, 3); 
gf_bs_write_int(VAR_40, 0xff, 8); 
gf_bs_write_int(VAR_40, 0, 1); 
gf_bs_write_int(VAR_40, 0, 1); 
gf_bs_get_content(VAR_40, &VAR_41, &VAR_42);
gf_bs_del(VAR_40);
gf_rtp_builder_format_sdp(VAR_1->rtp_p, VAR_8, VAR_6, VAR_41, VAR_42);
gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
gf_free(VAR_41);
}
#if VAR_44
else if (tkHint->VAR_45->VAR_46==VAR_47) {
GF_DIMSDescription VAR_48;
gf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &VAR_3, &VAR_4);
gf_isom_get_dims_description(tkHint->file, tkHint->TrackNum, 1, &VAR_48);
sprintf(VAR_6, ""a=fmtp:%d Version-profile=%d"", tkHint->rtp_p->PayloadType, VAR_48.profile);
if (! VAR_48.fullRequestHost) {
char VAR_49[200];
strcat(VAR_6, "";useFullRequestHost=0"");
sprintf(VAR_49, "";pathComponents=%d"", VAR_48.pathComponents);
strcat(VAR_6, VAR_49);
}
if (!VAR_48.streamType) strcat(VAR_6, "";stream-type=secondary"");
if (VAR_48.containsRedundant == 1) strcat(VAR_6, "";contains-redundant=main"");
else if (VAR_48.containsRedundant == 2) strcat(VAR_6, "";contains-redundant=redundant"");
if (VAR_48.textEncoding && strlen(VAR_48.textEncoding)) {
strcat(VAR_6, "";text-encoding="");
strcat(VAR_6, VAR_48.textEncoding);
}
if (VAR_48.contentEncoding && strlen(VAR_48.contentEncoding)) {
strcat(VAR_6, "";content-coding="");
strcat(VAR_6, VAR_48.contentEncoding);
}
if (VAR_48.contentEncoding && VAR_48.content_script_types && strlen(VAR_48.content_script_types) ) {
strcat(VAR_6, "";content-script-types="");
strcat(VAR_6, VAR_48.contentEncoding);
}
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, VAR_6);
}
#endif
if (VAR_3 && VAR_4) {
sprintf(VAR_6, ""a=framesize:%d %d-%d"", tkHint->rtp_p->PayloadType, VAR_3, VAR_4);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, VAR_6);
}
VAR_5 = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);
if (VAR_5 && VAR_5->decoderConfig && (VAR_5->decoderConfig->rvc_config || VAR_5->decoderConfig->predefined_rvc_config)) {
if (VAR_5->decoderConfig->predefined_rvc_config) {
sprintf(VAR_6, ""a=rvc-config-predef:%d"", VAR_5->decoderConfig->predefined_rvc_config);
} else {
if ((VAR_5->decoderConfig->objectTypeIndication==VAR_50) || (VAR_5->decoderConfig->objectTypeIndication==VAR_51)) {
sprintf(VAR_6, ""a=rvc-config:%s"", ""http://download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_avc.xml"");
} else {
sprintf(VAR_6, ""a=rvc-config:%s"", ""http://download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_sp.xml"");
}
}
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, VAR_6);
}
if (VAR_5) gf_odf_desc_del((GF_Descriptor *)VAR_5);
gf_isom_set_track_enabled(tkHint->file, tkHint->HintTrack, VAR_52);
return VAR_53;
}",,"GF_EXPORT
GF_Err gf_hinter_track_finalize(GF_RTPHinter *tkHint, Bool AddSystemInfo)
{
	u32 Width, Height;
	GF_ESD *esd;
	char sdpLine[20000];
	char mediaName[30], payloadName[30];
    u32 mtype;

	Width = Height = 0;
	gf_isom_sdp_clean_track(tkHint->file, tkHint->TrackNum);
    mtype = gf_isom_get_media_type(tkHint->file, tkHint->TrackNum);
    if (gf_isom_is_video_handler_type(mtype))
		gf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);

	gf_rtp_builder_get_payload_name(tkHint->rtp_p, payloadName, mediaName);

	/*TODO- extract out of rtp_p for future live tools*/
	sprintf(sdpLine, ""m=%s 0 RTP/%s %d"", mediaName, tkHint->rtp_p->slMap.IV_length ? ""SAVP"" : ""AVP"", tkHint->rtp_p->PayloadType);
	gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
	if (tkHint->bandwidth) {
		sprintf(sdpLine, ""b=AS:%d"", tkHint->bandwidth);
		gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
	}
	if (tkHint->nb_chan) {
		sprintf(sdpLine, ""a=rtpmap:%d %s/%d/%d"", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution, tkHint->nb_chan);
	} else {
		sprintf(sdpLine, ""a=rtpmap:%d %s/%d"", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution);
	}
	gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
	/*control for MPEG-4*/
	if (AddSystemInfo) {
		sprintf(sdpLine, ""a=mpeg4-esid:%d"", gf_isom_get_track_id(tkHint->file, tkHint->TrackNum));
		gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
	}
	/*control for QTSS/DSS*/
	sprintf(sdpLine, ""a=control:trackID=%d"", gf_isom_get_track_id(tkHint->file, tkHint->HintTrack));
	gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);

	/*H263 extensions*/
	if (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H263) {
		sprintf(sdpLine, ""a=cliprect:0,0,%d,%d"", Height, Width);
		gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
	}
	/*AMR*/
	else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR_WB)) {
		sprintf(sdpLine, ""a=fmtp:%d octet-align=1"", tkHint->rtp_p->PayloadType);
		gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
	}
	/*Text*/
	else if (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_3GPP_TEXT) {
		u32 w, h, i, m_w, m_h;
		s32 tx, ty;
		s16 l;

		gf_isom_get_track_layout_info(tkHint->file, tkHint->TrackNum, &w, &h, &tx, &ty, &l);
		m_w = w;
		m_h = h;
		for (i=0; i<gf_isom_get_track_count(tkHint->file); i++) {
			switch (gf_isom_get_media_type(tkHint->file, i+1)) {
			case GF_ISOM_MEDIA_SCENE:
			case GF_ISOM_MEDIA_VISUAL:
			case GF_ISOM_MEDIA_AUXV:
			case GF_ISOM_MEDIA_PICT:
				gf_isom_get_track_layout_info(tkHint->file, i+1, &w, &h, &tx, &ty, &l);
				if (w>m_w) m_w = w;
				if (h>m_h) m_h = h;
				break;
			default:
				break;
			}
		}

		gf_media_format_ttxt_sdp(tkHint->rtp_p, payloadName, sdpLine, w, h, tx, ty, l, m_w, m_h, NULL);

		strcat(sdpLine, ""; tx3g="");
		for (i=0; i<gf_isom_get_sample_description_count(tkHint->file, tkHint->TrackNum); i++) {
			u8 *tx3g;
			GF_Err e;
			char buffer[2000];
			u32 tx3g_len, len;
			e = gf_isom_text_get_encoded_tx3g(tkHint->file, tkHint->TrackNum, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);
			if (e) {
				if (i) continue;
				return GF_ISOM_INVALID_FILE;
			}
			len = gf_base64_encode(tx3g, tx3g_len, buffer, 2000);
			gf_free(tx3g);
			buffer[len] = 0;
			if (i) strcat(sdpLine, "", "");
			strcat(sdpLine, buffer);
		}
		gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
	}
	/*EVRC/SMV in non header-free mode*/
	else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_EVRC_SMV) && (tkHint->rtp_p->auh_size>1)) {
		sprintf(sdpLine, ""a=fmtp:%d maxptime=%d"", tkHint->rtp_p->PayloadType, tkHint->rtp_p->auh_size*20);
		gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
	}
	/*H264/AVC*/
	else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_AVC) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_SVC))  {
		GF_AVCConfig *avcc = gf_isom_avc_config_get(tkHint->file, tkHint->TrackNum, 1);
		GF_AVCConfig *svcc = gf_isom_svc_config_get(tkHint->file, tkHint->TrackNum, 1);
		/*TODO - check syntax for SVC (might be some extra signaling)*/

		if (avcc) {
			sprintf(sdpLine, ""a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1"", tkHint->rtp_p->PayloadType, avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);
		} else {
			if (!svcc)
				return GF_ISOM_INVALID_FILE;
			sprintf(sdpLine, ""a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1"", tkHint->rtp_p->PayloadType, svcc->AVCProfileIndication, svcc->profile_compatibility, svcc->AVCLevelIndication);
		}

		write_avc_config(sdpLine, avcc, svcc);

		gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
		gf_odf_avc_cfg_del(avcc);
		gf_odf_avc_cfg_del(svcc);
	}
	/*MPEG-4 decoder config*/
	else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_MPEG4) {
		esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);

		if (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {
			gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);
		} else {
			gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, NULL, 0);
		}
		if (esd) gf_odf_desc_del((GF_Descriptor *)esd);

		if (tkHint->rtp_p->slMap.IV_length) {
			const char *kms;
			gf_isom_get_ismacryp_info(tkHint->file, tkHint->TrackNum, 1, NULL, NULL, NULL, NULL, &kms, NULL, NULL, NULL);
			if (!strnicmp(kms, ""(key)"", 5) || !strnicmp(kms, ""(ipmp)"", 6) || !strnicmp(kms, ""(uri)"", 5)) {
				strcat(sdpLine, ""; ISMACrypKey="");
			} else {
				strcat(sdpLine, ""; ISMACrypKey=(uri)"");
			}
			strcat(sdpLine, kms);
		}

		gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
	}
	/*MPEG-4 Audio LATM*/
	else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_LATM) {
		GF_BitStream *bs;
		u8 *config_bytes;
		u32 config_size;

		/* form config string */
		bs = gf_bs_new(NULL, 32, GF_BITSTREAM_WRITE);
		gf_bs_write_int(bs, 0, 1); /* AudioMuxVersion */
		gf_bs_write_int(bs, 1, 1); /* all streams same time */
		gf_bs_write_int(bs, 0, 6); /* numSubFrames */
		gf_bs_write_int(bs, 0, 4); /* numPrograms */
		gf_bs_write_int(bs, 0, 3); /* numLayer */

		/* audio-specific config */
		esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);
		if (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {
			/*PacketVideo patch: don't signal SBR and PS stuff, not allowed in LATM with audioMuxVersion=0*/
			gf_bs_write_data(bs, esd->decoderConfig->decoderSpecificInfo->data, MIN(esd->decoderConfig->decoderSpecificInfo->dataLength, 2) );
		}
		if (esd) gf_odf_desc_del((GF_Descriptor *)esd);

		/* other data */
		gf_bs_write_int(bs, 0, 3); /* frameLengthType */
		gf_bs_write_int(bs, 0xff, 8); /* latmBufferFullness */
		gf_bs_write_int(bs, 0, 1); /* otherDataPresent */
		gf_bs_write_int(bs, 0, 1); /* crcCheckPresent */
		gf_bs_get_content(bs, &config_bytes, &config_size);
		gf_bs_del(bs);

		gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, config_bytes, config_size);
		gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
		gf_free(config_bytes);
	}
#if GPAC_ENABLE_3GPP_DIMS_RTP
	/*3GPP DIMS*/
	else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_3GPP_DIMS) {
		GF_DIMSDescription dims;
		gf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);

		gf_isom_get_dims_description(tkHint->file, tkHint->TrackNum, 1, &dims);
		sprintf(sdpLine, ""a=fmtp:%d Version-profile=%d"", tkHint->rtp_p->PayloadType, dims.profile);
		if (! dims.fullRequestHost) {
			char fmt[200];
			strcat(sdpLine, "";useFullRequestHost=0"");
			sprintf(fmt, "";pathComponents=%d"", dims.pathComponents);
			strcat(sdpLine, fmt);
		}
		if (!dims.streamType) strcat(sdpLine, "";stream-type=secondary"");
		if (dims.containsRedundant == 1) strcat(sdpLine, "";contains-redundant=main"");
		else if (dims.containsRedundant == 2) strcat(sdpLine, "";contains-redundant=redundant"");

		if (dims.textEncoding && strlen(dims.textEncoding)) {
			strcat(sdpLine, "";text-encoding="");
			strcat(sdpLine, dims.textEncoding);
		}
		if (dims.contentEncoding && strlen(dims.contentEncoding)) {
			strcat(sdpLine, "";content-coding="");
			strcat(sdpLine, dims.contentEncoding);
		}
		if (dims.contentEncoding && dims.content_script_types && strlen(dims.content_script_types) ) {
			strcat(sdpLine, "";content-script-types="");
			strcat(sdpLine, dims.contentEncoding);
		}
		gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
	}
#endif
	/*extensions for some mobile phones*/
	if (Width && Height) {
		sprintf(sdpLine, ""a=framesize:%d %d-%d"", tkHint->rtp_p->PayloadType, Width, Height);
		gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
	}

	esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);
	if (esd && esd->decoderConfig && (esd->decoderConfig->rvc_config || esd->decoderConfig->predefined_rvc_config)) {
		if (esd->decoderConfig->predefined_rvc_config) {
			sprintf(sdpLine, ""a=rvc-config-predef:%d"", esd->decoderConfig->predefined_rvc_config);
		} else {
			/*temporary ...*/
			if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_SVC)) {
				sprintf(sdpLine, ""a=rvc-config:%s"", ""http://download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_avc.xml"");
			} else {
				sprintf(sdpLine, ""a=rvc-config:%s"", ""http://download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_sp.xml"");
			}
		}
		gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
	}
	if (esd) gf_odf_desc_del((GF_Descriptor *)esd);

	gf_isom_set_track_enabled(tkHint->file, tkHint->HintTrack, GF_TRUE);
	return GF_OK;
}","GF_EXPORT
VAR_0 gf_hinter_track_finalize(GF_RTPHinter *VAR_1, Bool VAR_2)
{
	u32 VAR_3, VAR_4;
	GF_ESD *VAR_5;
	char VAR_6[20000];
	char VAR_7[30], VAR_8[30];
    u32 VAR_9;

	VAR_3 = VAR_4 = 0;
	gf_isom_sdp_clean_track(VAR_1->file, VAR_1->TrackNum);
    VAR_9 = gf_isom_get_media_type(VAR_1->file, VAR_1->TrackNum);
    if (gf_isom_is_video_handler_type(VAR_9))
		gf_isom_get_visual_info(VAR_1->file, VAR_1->TrackNum, 1, &VAR_3, &VAR_4);

	gf_rtp_builder_get_payload_name(VAR_1->rtp_p, VAR_8, VAR_7);

	/* COMMENT_0 */
	sprintf(VAR_6, ""m=%s 0 RTP/%s %d"", VAR_7, VAR_1->rtp_p->slMap.IV_length ? ""SAVP"" : ""AVP"", VAR_1->rtp_p->PayloadType);
	gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
	if (VAR_1->bandwidth) {
		sprintf(VAR_6, ""b=AS:%d"", VAR_1->bandwidth);
		gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
	}
	if (VAR_1->nb_chan) {
		sprintf(VAR_6, ""a=rtpmap:%d %s/%d/%d"", VAR_1->rtp_p->PayloadType, VAR_8, VAR_1->rtp_p->sl_config.timestampResolution, VAR_1->nb_chan);
	} else {
		sprintf(VAR_6, ""a=rtpmap:%d %s/%d"", VAR_1->rtp_p->PayloadType, VAR_8, VAR_1->rtp_p->sl_config.timestampResolution);
	}
	gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
	/* COMMENT_1 */
	if (VAR_2) {
		sprintf(VAR_6, ""a=mpeg4-esid:%d"", gf_isom_get_track_id(VAR_1->file, VAR_1->TrackNum));
		gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
	}
	/* COMMENT_2 */
	sprintf(VAR_6, ""a=control:trackID=%d"", gf_isom_get_track_id(VAR_1->file, VAR_1->HintTrack));
	gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);

	/* COMMENT_3 */
	if (VAR_1->rtp_p->rtp_payt == VAR_10) {
		sprintf(VAR_6, ""a=cliprect:0,0,%d,%d"", VAR_4, VAR_3);
		gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
	}
	/* COMMENT_4 */
	else if ((VAR_1->rtp_p->rtp_payt == VAR_11) || (VAR_1->rtp_p->rtp_payt == VAR_12)) {
		sprintf(VAR_6, ""a=fmtp:%d octet-align=1"", VAR_1->rtp_p->PayloadType);
		gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
	}
	/* COMMENT_5 */
	else if (VAR_1->rtp_p->rtp_payt == VAR_13) {
		u32 VAR_14, VAR_15, VAR_16, VAR_17, VAR_18;
		s32 VAR_19, VAR_20;
		s16 VAR_21;

		gf_isom_get_track_layout_info(VAR_1->file, VAR_1->TrackNum, &VAR_14, &VAR_15, &VAR_19, &VAR_20, &VAR_21);
		VAR_17 = VAR_14;
		VAR_18 = VAR_15;
		for (VAR_16=0; VAR_16<gf_isom_get_track_count(VAR_1->file); VAR_16++) {
			switch (gf_isom_get_media_type(VAR_1->file, VAR_16+1)) {
			case VAR_22:
			case VAR_23:
			case VAR_24:
			case VAR_25:
				gf_isom_get_track_layout_info(VAR_1->file, VAR_16+1, &VAR_14, &VAR_15, &VAR_19, &VAR_20, &VAR_21);
				if (VAR_14>VAR_17) VAR_17 = VAR_14;
				if (VAR_15>VAR_18) VAR_18 = VAR_15;
				break;
			default:
				break;
			}
		}

		gf_media_format_ttxt_sdp(VAR_1->rtp_p, VAR_8, VAR_6, VAR_14, VAR_15, VAR_19, VAR_20, VAR_21, VAR_17, VAR_18, NULL);

		strcat(VAR_6, ""; tx3g="");
		for (VAR_16=0; VAR_16<gf_isom_get_sample_description_count(VAR_1->file, VAR_1->TrackNum); VAR_16++) {
			u8 *VAR_26;
			GF_Err VAR_27;
			char VAR_28[2000];
			u32 VAR_29, VAR_30;
			VAR_27 = gf_isom_text_get_encoded_tx3g(VAR_1->file, VAR_1->TrackNum, VAR_16+1, VAR_31, &VAR_26, &VAR_29);
			if (VAR_27) {
				if (VAR_16) continue;
				return VAR_32;
			}
			VAR_30 = gf_base64_encode(VAR_26, VAR_29, VAR_28, 2000);
			gf_free(VAR_26);
			VAR_28[VAR_30] = 0;
			if (VAR_16) strcat(VAR_6, "", "");
			strcat(VAR_6, VAR_28);
		}
		gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
	}
	/* COMMENT_6 */
	else if ((VAR_1->rtp_p->rtp_payt == VAR_33) && (VAR_1->rtp_p->auh_size>1)) {
		sprintf(VAR_6, ""a=fmtp:%d maxptime=%d"", VAR_1->rtp_p->PayloadType, VAR_1->rtp_p->auh_size*20);
		gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
	}
	/* COMMENT_7 */
	else if ((VAR_1->rtp_p->rtp_payt == VAR_34) || (VAR_1->rtp_p->rtp_payt == VAR_35))  {
		GF_AVCConfig *VAR_36 = gf_isom_avc_config_get(VAR_1->file, VAR_1->TrackNum, 1);
		GF_AVCConfig *VAR_37 = gf_isom_svc_config_get(VAR_1->file, VAR_1->TrackNum, 1);
		/* COMMENT_8 */

		if (VAR_36) {
			sprintf(VAR_6, ""a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1"", VAR_1->rtp_p->PayloadType, VAR_36->AVCProfileIndication, VAR_36->profile_compatibility, VAR_36->AVCLevelIndication);
		} else {
			if (!VAR_37)
				return VAR_32;
			sprintf(VAR_6, ""a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1"", VAR_1->rtp_p->PayloadType, VAR_37->AVCProfileIndication, VAR_37->profile_compatibility, VAR_37->AVCLevelIndication);
		}

		write_avc_config(VAR_6, VAR_36, VAR_37);

		gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
		gf_odf_avc_cfg_del(VAR_36);
		gf_odf_avc_cfg_del(VAR_37);
	}
	/* COMMENT_9 */
	else if (VAR_1->rtp_p->rtp_payt==VAR_38) {
		VAR_5 = gf_isom_get_esd(VAR_1->file, VAR_1->TrackNum, 1);

		if (VAR_5 && VAR_5->decoderConfig && VAR_5->decoderConfig->decoderSpecificInfo && VAR_5->decoderConfig->decoderSpecificInfo->data) {
			gf_rtp_builder_format_sdp(VAR_1->rtp_p, VAR_8, VAR_6, VAR_5->decoderConfig->decoderSpecificInfo->data, VAR_5->decoderConfig->decoderSpecificInfo->dataLength);
		} else {
			gf_rtp_builder_format_sdp(VAR_1->rtp_p, VAR_8, VAR_6, NULL, 0);
		}
		if (VAR_5) gf_odf_desc_del((GF_Descriptor *)VAR_5);

		if (VAR_1->rtp_p->slMap.IV_length) {
			const char *VAR_39;
			gf_isom_get_ismacryp_info(VAR_1->file, VAR_1->TrackNum, 1, NULL, NULL, NULL, NULL, &VAR_39, NULL, NULL, NULL);
			if (!strnicmp(VAR_39, ""(key)"", 5) || !strnicmp(VAR_39, ""(ipmp)"", 6) || !strnicmp(VAR_39, ""(uri)"", 5)) {
				strcat(VAR_6, ""; ISMACrypKey="");
			} else {
				strcat(VAR_6, ""; ISMACrypKey=(uri)"");
			}
			strcat(VAR_6, VAR_39);
		}

		gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
	}
	/* COMMENT_10 */
	else if (VAR_1->rtp_p->rtp_payt==VAR_40) {
		GF_BitStream *VAR_41;
		u8 *VAR_42;
		u32 VAR_43;

		/* COMMENT_11 */
		VAR_41 = gf_bs_new(NULL, 32, VAR_44);
		gf_bs_write_int(VAR_41, 0, 1); /* COMMENT_12 */
		gf_bs_write_int(VAR_41, 1, 1); /* COMMENT_13 */
		gf_bs_write_int(VAR_41, 0, 6); /* COMMENT_14 */
		gf_bs_write_int(VAR_41, 0, 4); /* COMMENT_15 */
		gf_bs_write_int(VAR_41, 0, 3); /* COMMENT_16 */

		/* COMMENT_17 */
		VAR_5 = gf_isom_get_esd(VAR_1->file, VAR_1->TrackNum, 1);
		if (VAR_5 && VAR_5->decoderConfig && VAR_5->decoderConfig->decoderSpecificInfo) {
			/* COMMENT_18 */
			gf_bs_write_data(VAR_41, VAR_5->decoderConfig->decoderSpecificInfo->data, MIN(VAR_5->decoderConfig->decoderSpecificInfo->dataLength, 2) );
		}
		if (VAR_5) gf_odf_desc_del((GF_Descriptor *)VAR_5);

		/* COMMENT_19 */
		gf_bs_write_int(VAR_41, 0, 3); /* COMMENT_20 */
		gf_bs_write_int(VAR_41, 0xff, 8); /* COMMENT_21 */
		gf_bs_write_int(VAR_41, 0, 1); /* COMMENT_22 */
		gf_bs_write_int(VAR_41, 0, 1); /* COMMENT_23 */
		gf_bs_get_content(VAR_41, &VAR_42, &VAR_43);
		gf_bs_del(VAR_41);

		gf_rtp_builder_format_sdp(VAR_1->rtp_p, VAR_8, VAR_6, VAR_42, VAR_43);
		gf_isom_sdp_add_track_line(VAR_1->file, VAR_1->HintTrack, VAR_6);
		gf_free(VAR_42);
	}
#if VAR_45
	/* COMMENT_24 */
	else if (tkHint->VAR_46->VAR_47==VAR_48) {
		GF_DIMSDescription VAR_49;
		gf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &VAR_3, &VAR_4);

		gf_isom_get_dims_description(tkHint->file, tkHint->TrackNum, 1, &VAR_49);
		sprintf(VAR_6, ""a=fmtp:%d Version-profile=%d"", tkHint->rtp_p->PayloadType, VAR_49.profile);
		if (! VAR_49.fullRequestHost) {
			char VAR_50[200];
			strcat(VAR_6, "";useFullRequestHost=0"");
			sprintf(VAR_50, "";pathComponents=%d"", VAR_49.pathComponents);
			strcat(VAR_6, VAR_50);
		}
		if (!VAR_49.streamType) strcat(VAR_6, "";stream-type=secondary"");
		if (VAR_49.containsRedundant == 1) strcat(VAR_6, "";contains-redundant=main"");
		else if (VAR_49.containsRedundant == 2) strcat(VAR_6, "";contains-redundant=redundant"");

		if (VAR_49.textEncoding && strlen(VAR_49.textEncoding)) {
			strcat(VAR_6, "";text-encoding="");
			strcat(VAR_6, VAR_49.textEncoding);
		}
		if (VAR_49.contentEncoding && strlen(VAR_49.contentEncoding)) {
			strcat(VAR_6, "";content-coding="");
			strcat(VAR_6, VAR_49.contentEncoding);
		}
		if (VAR_49.contentEncoding && VAR_49.content_script_types && strlen(VAR_49.content_script_types) ) {
			strcat(VAR_6, "";content-script-types="");
			strcat(VAR_6, VAR_49.contentEncoding);
		}
		gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, VAR_6);
	}
#endif
	/* COMMENT_25 */
	if (VAR_3 && VAR_4) {
		sprintf(VAR_6, ""a=framesize:%d %d-%d"", tkHint->rtp_p->PayloadType, VAR_3, VAR_4);
		gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, VAR_6);
	}

	VAR_5 = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);
	if (VAR_5 && VAR_5->decoderConfig && (VAR_5->decoderConfig->rvc_config || VAR_5->decoderConfig->predefined_rvc_config)) {
		if (VAR_5->decoderConfig->predefined_rvc_config) {
			sprintf(VAR_6, ""a=rvc-config-predef:%d"", VAR_5->decoderConfig->predefined_rvc_config);
		} else {
			/* COMMENT_26 */
			if ((VAR_5->decoderConfig->objectTypeIndication==VAR_51) || (VAR_5->decoderConfig->objectTypeIndication==VAR_52)) {
				sprintf(VAR_6, ""a=rvc-config:%s"", ""http://download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_avc.xml"");
			} else {
				sprintf(VAR_6, ""a=rvc-config:%s"", ""http://download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_sp.xml"");
			}
		}
		gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, VAR_6);
	}
	if (VAR_5) gf_odf_desc_del((GF_Descriptor *)VAR_5);

	gf_isom_set_track_enabled(tkHint->file, tkHint->HintTrack, VAR_53);
	return VAR_54;
}",,"--- func_before
+++ func_after
@@ -76,9 +76,14 @@
 		strcat(sdpLine, ""; tx3g="");
 		for (i=0; i<gf_isom_get_sample_description_count(tkHint->file, tkHint->TrackNum); i++) {
 			u8 *tx3g;
+			GF_Err e;
 			char buffer[2000];
 			u32 tx3g_len, len;
-			gf_isom_text_get_encoded_tx3g(tkHint->file, tkHint->TrackNum, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);
+			e = gf_isom_text_get_encoded_tx3g(tkHint->file, tkHint->TrackNum, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);
+			if (e) {
+				if (i) continue;
+				return GF_ISOM_INVALID_FILE;
+			}
 			len = gf_base64_encode(tx3g, tx3g_len, buffer, 2000);
 			gf_free(tx3g);
 			buffer[len] = 0;","{'deleted_lines': ['\t\t\tgf_isom_text_get_encoded_tx3g(tkHint->file, tkHint->TrackNum, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);'], 'added_lines': ['\t\t\tGF_Err e;', '\t\t\te = gf_isom_text_get_encoded_tx3g(tkHint->file, tkHint->TrackNum, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);', '\t\t\tif (e) {', '\t\t\t\tif (i) continue;', '\t\t\t\treturn GF_ISOM_INVALID_FILE;', '\t\t\t}']}",True,The gf_hinter_track_finalize function in GPAC 1.0.1 allows attackers to cause a denial of service via a crafted file in the MP4Box command.,5.5,MEDIUM,1,test,2021-08-30T12:43:17Z,3
CVE-2021-40568,['CWE-120'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,gpac,fixed #1900,f1ae01d745200a258cdf62622f71754c37cb6c30,https://github.com/gpac/gpac/commit/f1ae01d745200a258cdf62622f71754c37cb6c30,src/media_tools/av_parsers.c,gf_bs_read_ue_log_idx3,"u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)
{
u32 val=0, code;
s32 nb_lead = -1;
u32 bits = 0;
for (code=0; !code; nb_lead++) {
if (nb_lead>=32) {
if (!gf_bs_available(bs)) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] exp-golomb read failed, not enough bits in bitstream !\n""));
} else {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\n"", nb_lead));
}
return 0;
}
code = gf_bs_read_int(bs, 1);
bits++;
}
if (nb_lead) {
u32 leads=1;
val = gf_bs_read_int(bs, nb_lead);
leads <<= nb_lead;
leads -= 1;
val += leads;
bits += nb_lead;
}
if (fname) {
gf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);
}
return val;
}","u32 gf_bs_read_ue_log_idx3(GF_BitStream *VAR_0, const char *VAR_1, s32 VAR_2, s32 VAR_3, s32 VAR_4)
{
u32 VAR_5=0, VAR_6;
s32 VAR_7 = -1;
u32 VAR_8 = 0;
for (VAR_6=0; !VAR_6; VAR_7++) {
if (VAR_7>=32) {
if (!gf_bs_available(VAR_0)) {
GF_LOG(VAR_9, VAR_10, (""[Core] exp-golomb read failed, not enough bits in bitstream !\n""));
} else {
GF_LOG(VAR_9, VAR_10, (""[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\n"", VAR_7));
}
return 0;
}
VAR_6 = gf_bs_read_int(VAR_0, 1);
VAR_8++;
}
if (VAR_7) {
u32 VAR_11=1;
VAR_5 = gf_bs_read_int(VAR_0, VAR_7);
VAR_11 <<= VAR_7;
VAR_11 -= 1;
VAR_5 += VAR_11;
VAR_8 += VAR_7;
}
if (VAR_1) {
gf_bs_log_idx(VAR_0, VAR_8, VAR_1, VAR_5, VAR_2, VAR_3, VAR_4);
}
return VAR_5;
}",gpac/f1ae01d745200a258cdf62622f71754c37cb6c30/av_parsers.c/vul/before/0.json,"u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)
{
	u32 val=0, code;
	s32 nb_lead = -1;
	u32 bits = 0;
	for (code=0; !code; nb_lead++) {
		if (nb_lead>=32) {
			break;
		}
		code = gf_bs_read_int(bs, 1);
		bits++;
	}

	if (nb_lead>=32) {
		//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)
		//we only test once nb_lead>=32 to avoid testing at each bit read
		if (!gf_bs_available(bs)) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] exp-golomb read failed, not enough bits in bitstream !\n""));
		} else {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\n"", nb_lead));
		}
		return 0;
	}

	if (nb_lead) {
		u32 leads=1;
		val = gf_bs_read_int(bs, nb_lead);
		leads <<= nb_lead;
		leads -= 1;
		val += leads;
//		val += (1 << nb_lead) - 1;
		bits += nb_lead;
	}

	if (fname) {
		gf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);
	}
	return val;
}","u32 gf_bs_read_ue_log_idx3(GF_BitStream *VAR_0, const char *VAR_1, s32 VAR_2, s32 VAR_3, s32 VAR_4)
{
	u32 VAR_5=0, VAR_6;
	s32 VAR_7 = -1;
	u32 VAR_8 = 0;
	for (VAR_6=0; !VAR_6; VAR_7++) {
		if (VAR_7>=32) {
			break;
		}
		VAR_6 = gf_bs_read_int(VAR_0, 1);
		VAR_8++;
	}

	if (VAR_7>=32) {
		/* COMMENT_0 */
		/* COMMENT_1 */
		if (!gf_bs_available(VAR_0)) {
			GF_LOG(VAR_9, VAR_10, (""[Core] exp-golomb read failed, not enough bits in bitstream !\n""));
		} else {
			GF_LOG(VAR_9, VAR_10, (""[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\n"", VAR_7));
		}
		return 0;
	}

	if (VAR_7) {
		u32 VAR_11=1;
		VAR_5 = gf_bs_read_int(VAR_0, VAR_7);
		VAR_11 <<= VAR_7;
		VAR_11 -= 1;
		VAR_5 += VAR_11;
/* COMMENT_2 */
		VAR_8 += VAR_7;
	}

	if (VAR_1) {
		gf_bs_log_idx(VAR_0, VAR_8, VAR_1, VAR_5, VAR_2, VAR_3, VAR_4);
	}
	return VAR_5;
}",gpac/f1ae01d745200a258cdf62622f71754c37cb6c30/av_parsers.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,18 +5,21 @@
 	u32 bits = 0;
 	for (code=0; !code; nb_lead++) {
 		if (nb_lead>=32) {
-			//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)
-			//we only test once nb_lead>=32 to avoid testing at each bit read
-			if (!gf_bs_available(bs)) {
-				GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] exp-golomb read failed, not enough bits in bitstream !\n""));
-			} else {
-				GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\n"", nb_lead));
-			}
-			return 0;
+			break;
 		}
-
 		code = gf_bs_read_int(bs, 1);
 		bits++;
+	}
+
+	if (nb_lead>=32) {
+		//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)
+		//we only test once nb_lead>=32 to avoid testing at each bit read
+		if (!gf_bs_available(bs)) {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] exp-golomb read failed, not enough bits in bitstream !\n""));
+		} else {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\n"", nb_lead));
+		}
+		return 0;
 	}
 
 	if (nb_lead) {","{'deleted_lines': ['\t\t\t//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)', '\t\t\t//we only test once nb_lead>=32 to avoid testing at each bit read', '\t\t\tif (!gf_bs_available(bs)) {', '\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] exp-golomb read failed, not enough bits in bitstream !\\n""));', '\t\t\t} else {', '\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n"", nb_lead));', '\t\t\t}', '\t\t\treturn 0;', ''], 'added_lines': ['\t\t\tbreak;', '\t}', '', '\tif (nb_lead>=32) {', '\t\t//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)', '\t\t//we only test once nb_lead>=32 to avoid testing at each bit read', '\t\tif (!gf_bs_available(bs)) {', '\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] exp-golomb read failed, not enough bits in bitstream !\\n""));', '\t\t} else {', '\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n"", nb_lead));', '\t\t}', '\t\treturn 0;']}",True,"A buffer overflow vulnerability exists in Gpac through 1.0.1 via a malformed MP4 file in the svc_parse_slice function in av_parsers.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.",7.8,HIGH,2,test,2021-08-30T15:20:00Z,3
CVE-2021-40568,['CWE-120'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,gpac,fixed #1900,f1ae01d745200a258cdf62622f71754c37cb6c30,https://github.com/gpac/gpac/commit/f1ae01d745200a258cdf62622f71754c37cb6c30,src/media_tools/av_parsers.c,svc_parse_slice,"static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)
{
s32 pps_id;
gf_bs_read_ue_log(bs, ""first_mb_in_slice"");
si->slice_type = gf_bs_read_ue_log(bs, ""slice_type"");
if (si->slice_type > 9) return -1;
pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
if (pps_id > 255)
return -1;
si->pps = &avc->pps[pps_id];
si->pps->id = pps_id;
if (!si->pps->slice_group_count)
return -2;
si->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];
if (!si->sps->log2_max_frame_num)
return -2;
si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num"");
si->field_pic_flag = 0;
if (si->sps->frame_mbs_only_flag) {
}
else {
si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag"");
if (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag"");
}
if (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si->NalHeader.idr_pic_flag)
si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id"");
if (si->sps->poc_type == 0) {
si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb"");
if (si->pps->pic_order_present && !si->field_pic_flag) {
si->delta_poc_bottom = gf_bs_read_se_log(bs, ""delta_poc_bottom"");
}
}
else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {
si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0"");
if ((si->pps->pic_order_present == 1) && !si->field_pic_flag)
si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1"");
}
if (si->pps->redundant_pic_cnt_present) {
si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt"");
}
return 0;
}","static s32 svc_parse_slice(GF_BitStream *VAR_0, AVCState *VAR_1, AVCSliceInfo *VAR_2)
{
s32 VAR_3;
gf_bs_read_ue_log(VAR_0, ""first_mb_in_slice"");
VAR_2->slice_type = gf_bs_read_ue_log(VAR_0, ""slice_type"");
if (VAR_2->slice_type > 9) return -1;
VAR_3 = gf_bs_read_ue_log(VAR_0, ""pps_id"");
if (VAR_3 > 255)
return -1;
VAR_2->pps = &VAR_1->pps[VAR_3];
VAR_2->pps->id = VAR_3;
if (!VAR_2->pps->slice_group_count)
return -2;
VAR_2->sps = &VAR_1->sps[VAR_2->pps->sps_id + VAR_4];
if (!VAR_2->sps->log2_max_frame_num)
return -2;
VAR_2->frame_num = gf_bs_read_int_log(VAR_0, VAR_2->sps->log2_max_frame_num, ""frame_num"");
VAR_2->field_pic_flag = 0;
if (VAR_2->sps->frame_mbs_only_flag) {
}
else {
VAR_2->field_pic_flag = gf_bs_read_int_log(VAR_0, 1, ""field_pic_flag"");
if (VAR_2->field_pic_flag) VAR_2->bottom_field_flag = gf_bs_read_int_log(VAR_0, 1, ""bottom_field_flag"");
}
if (VAR_2->nal_unit_type == VAR_5 || VAR_2->NalHeader.idr_pic_flag)
VAR_2->idr_pic_id = gf_bs_read_ue_log(VAR_0, ""idr_pic_id"");
if (VAR_2->sps->poc_type == 0) {
VAR_2->poc_lsb = gf_bs_read_int_log(VAR_0, VAR_2->sps->log2_max_poc_lsb, ""poc_lsb"");
if (VAR_2->pps->pic_order_present && !VAR_2->field_pic_flag) {
VAR_2->delta_poc_bottom = gf_bs_read_se_log(VAR_0, ""delta_poc_bottom"");
}
}
else if ((VAR_2->sps->poc_type == 1) && !VAR_2->sps->delta_pic_order_always_zero_flag) {
VAR_2->delta_poc[0] = gf_bs_read_se_log(VAR_0, ""delta_poc0"");
if ((VAR_2->pps->pic_order_present == 1) && !VAR_2->field_pic_flag)
VAR_2->delta_poc[1] = gf_bs_read_se_log(VAR_0, ""delta_poc1"");
}
if (VAR_2->pps->redundant_pic_cnt_present) {
VAR_2->redundant_pic_cnt = gf_bs_read_ue_log(VAR_0, ""redundant_pic_cnt"");
}
return 0;
}",gpac/f1ae01d745200a258cdf62622f71754c37cb6c30/av_parsers.c/vul/before/1.json,"static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)
{
	s32 pps_id;

	/*s->current_picture.reference= h->nal_ref_idc != 0;*/
	gf_bs_read_ue_log(bs, ""first_mb_in_slice"");
	si->slice_type = gf_bs_read_ue_log(bs, ""slice_type"");
	if (si->slice_type > 9) return -1;

	pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
	if ((pps_id<0) || (pps_id > 255))
		return -1;
	si->pps = &avc->pps[pps_id];
	si->pps->id = pps_id;
	if (!si->pps->slice_group_count)
		return -2;
	si->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];
	if (!si->sps->log2_max_frame_num)
		return -2;

	si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num"");

	si->field_pic_flag = 0;
	if (si->sps->frame_mbs_only_flag) {
		/*s->picture_structure= PICT_FRAME;*/
	}
	else {
		si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag"");
		if (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag"");
	}
	if (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si->NalHeader.idr_pic_flag)
		si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id"");

	if (si->sps->poc_type == 0) {
		si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb"");
		if (si->pps->pic_order_present && !si->field_pic_flag) {
			si->delta_poc_bottom = gf_bs_read_se_log(bs, ""delta_poc_bottom"");
		}
	}
	else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {
		si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0"");
		if ((si->pps->pic_order_present == 1) && !si->field_pic_flag)
			si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1"");
	}
	if (si->pps->redundant_pic_cnt_present) {
		si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt"");
	}
	return 0;
}","static s32 svc_parse_slice(GF_BitStream *VAR_0, AVCState *VAR_1, AVCSliceInfo *VAR_2)
{
	s32 VAR_3;

	/* COMMENT_0 */
	gf_bs_read_ue_log(VAR_0, ""first_mb_in_slice"");
	VAR_2->slice_type = gf_bs_read_ue_log(VAR_0, ""slice_type"");
	if (VAR_2->slice_type > 9) return -1;

	VAR_3 = gf_bs_read_ue_log(VAR_0, ""pps_id"");
	if ((VAR_3<0) || (VAR_3 > 255))
		return -1;
	VAR_2->pps = &VAR_1->pps[VAR_3];
	VAR_2->pps->id = VAR_3;
	if (!VAR_2->pps->slice_group_count)
		return -2;
	VAR_2->sps = &VAR_1->sps[VAR_2->pps->sps_id + VAR_4];
	if (!VAR_2->sps->log2_max_frame_num)
		return -2;

	VAR_2->frame_num = gf_bs_read_int_log(VAR_0, VAR_2->sps->log2_max_frame_num, ""frame_num"");

	VAR_2->field_pic_flag = 0;
	if (VAR_2->sps->frame_mbs_only_flag) {
		/* COMMENT_1 */
	}
	else {
		VAR_2->field_pic_flag = gf_bs_read_int_log(VAR_0, 1, ""field_pic_flag"");
		if (VAR_2->field_pic_flag) VAR_2->bottom_field_flag = gf_bs_read_int_log(VAR_0, 1, ""bottom_field_flag"");
	}
	if (VAR_2->nal_unit_type == VAR_5 || VAR_2->NalHeader.idr_pic_flag)
		VAR_2->idr_pic_id = gf_bs_read_ue_log(VAR_0, ""idr_pic_id"");

	if (VAR_2->sps->poc_type == 0) {
		VAR_2->poc_lsb = gf_bs_read_int_log(VAR_0, VAR_2->sps->log2_max_poc_lsb, ""poc_lsb"");
		if (VAR_2->pps->pic_order_present && !VAR_2->field_pic_flag) {
			VAR_2->delta_poc_bottom = gf_bs_read_se_log(VAR_0, ""delta_poc_bottom"");
		}
	}
	else if ((VAR_2->sps->poc_type == 1) && !VAR_2->sps->delta_pic_order_always_zero_flag) {
		VAR_2->delta_poc[0] = gf_bs_read_se_log(VAR_0, ""delta_poc0"");
		if ((VAR_2->pps->pic_order_present == 1) && !VAR_2->field_pic_flag)
			VAR_2->delta_poc[1] = gf_bs_read_se_log(VAR_0, ""delta_poc1"");
	}
	if (VAR_2->pps->redundant_pic_cnt_present) {
		VAR_2->redundant_pic_cnt = gf_bs_read_ue_log(VAR_0, ""redundant_pic_cnt"");
	}
	return 0;
}",gpac/f1ae01d745200a258cdf62622f71754c37cb6c30/av_parsers.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -8,7 +8,7 @@
 	if (si->slice_type > 9) return -1;
 
 	pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
-	if (pps_id > 255)
+	if ((pps_id<0) || (pps_id > 255))
 		return -1;
 	si->pps = &avc->pps[pps_id];
 	si->pps->id = pps_id;","{'deleted_lines': ['\tif (pps_id > 255)'], 'added_lines': ['\tif ((pps_id<0) || (pps_id > 255))']}",True,"A buffer overflow vulnerability exists in Gpac through 1.0.1 via a malformed MP4 file in the svc_parse_slice function in av_parsers.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.",7.8,HIGH,2,test,2021-08-30T15:20:00Z,3
CVE-2021-40516,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,weechat,relay: fix crash when decoding a malformed websocket frame,8b1331f98de1714bae15a9ca2e2b393ba49d735b,https://github.com/weechat/weechat/commit/8b1331f98de1714bae15a9ca2e2b393ba49d735b,src/plugins/relay/relay-websocket.c,relay_websocket_decode_frame,"int
relay_websocket_decode_frame (const unsigned char *buffer,
unsigned long long buffer_length,
unsigned char *decoded,
unsigned long long *decoded_length)
{
unsigned long long i, index_buffer, length_frame_size, length_frame;
unsigned char opcode;
*decoded_length = 0;
index_buffer = 0;
while (index_buffer + 2 <= buffer_length)
{
opcode = buffer[index_buffer] & 15;
if (!(buffer[index_buffer + 1] & 128))
return 0;
length_frame_size = 1;
length_frame = buffer[index_buffer + 1] & 127;
index_buffer += 2;
if ((length_frame == 126) || (length_frame == 127))
{
length_frame_size = (length_frame == 126) ? 2 : 8;
if (buffer_length < 1 + length_frame_size)
return 0;
length_frame = 0;
for (i = 0; i < length_frame_size; i++)
{
length_frame += (unsigned long long)buffer[index_buffer + i] << ((length_frame_size - i - 1) * 8);
}
index_buffer += length_frame_size;
}
if (buffer_length < 1 + length_frame_size + 4 + length_frame)
return 0;
int masks[4];
for (i = 0; i < 4; i++)
{
masks[i] = (int)((unsigned char)buffer[index_buffer + i]);
}
index_buffer += 4;
switch (opcode)
{
case WEBSOCKET_FRAME_OPCODE_PING:
decoded[*decoded_length] = RELAY_CLIENT_MSG_PING;
break;
case WEBSOCKET_FRAME_OPCODE_CLOSE:
decoded[*decoded_length] = RELAY_CLIENT_MSG_CLOSE;
break;
default:
decoded[*decoded_length] = RELAY_CLIENT_MSG_STANDARD;
break;
}
*decoded_length += 1;
for (i = 0; i < length_frame; i++)
{
decoded[*decoded_length + i] = (int)((unsigned char)buffer[index_buffer + i]) ^ masks[i % 4];
}
decoded[*decoded_length + length_frame] = '\0';
*decoded_length += length_frame + 1;
index_buffer += length_frame;
}
return 1;
}","int
relay_websocket_decode_frame (const unsigned char *VAR_0,
unsigned long long VAR_1,
unsigned char *VAR_2,
unsigned long long *VAR_3)
{
unsigned long long VAR_4, VAR_5, VAR_6, VAR_7;
unsigned char VAR_8;
*VAR_3 = 0;
VAR_5 = 0;
while (VAR_5 + 2 <= VAR_1)
{
VAR_8 = VAR_0[VAR_5] & 15;
if (!(VAR_0[VAR_5 + 1] & 128))
return 0;
VAR_6 = 1;
VAR_7 = VAR_0[VAR_5 + 1] & 127;
VAR_5 += 2;
if ((VAR_7 == 126) || (VAR_7 == 127))
{
VAR_6 = (VAR_7 == 126) ? 2 : 8;
if (VAR_1 < 1 + VAR_6)
return 0;
VAR_7 = 0;
for (VAR_4 = 0; VAR_4 < VAR_6; VAR_4++)
{
VAR_7 += (unsigned long long)VAR_0[VAR_5 + VAR_4] << ((VAR_6 - VAR_4 - 1) * 8);
}
VAR_5 += VAR_6;
}
if (VAR_1 < 1 + VAR_6 + 4 + VAR_7)
return 0;
int VAR_9[4];
for (VAR_4 = 0; VAR_4 < 4; VAR_4++)
{
VAR_9[VAR_4] = (int)((unsigned char)VAR_0[VAR_5 + VAR_4]);
}
VAR_5 += 4;
switch (VAR_8)
{
case VAR_10:
VAR_2[*VAR_3] = VAR_11;
break;
case VAR_12:
VAR_2[*VAR_3] = VAR_13;
break;
default:
VAR_2[*VAR_3] = VAR_14;
break;
}
*VAR_3 += 1;
for (VAR_4 = 0; VAR_4 < VAR_7; VAR_4++)
{
VAR_2[*VAR_3 + VAR_4] = (int)((unsigned char)VAR_0[VAR_5 + VAR_4]) ^ VAR_9[VAR_4 % 4];
}
VAR_2[*VAR_3 + VAR_7] = '\0';
*VAR_3 += VAR_7 + 1;
VAR_5 += VAR_7;
}
return 1;
}",weechat/8b1331f98de1714bae15a9ca2e2b393ba49d735b/relay-websocket.c/vul/before/0.json,"int
relay_websocket_decode_frame (const unsigned char *buffer,
                              unsigned long long buffer_length,
                              unsigned char *decoded,
                              unsigned long long *decoded_length)
{
    unsigned long long i, index_buffer, length_frame_size, length_frame;
    unsigned char opcode;

    *decoded_length = 0;
    index_buffer = 0;

    /* loop to decode all frames in message */
    while (index_buffer + 1 < buffer_length)
    {
        opcode = buffer[index_buffer] & 15;

        /*
         * check if frame is masked: client MUST send a masked frame; if frame is
         * not masked, we MUST reject it and close the connection (see RFC 6455)
         */
        if (!(buffer[index_buffer + 1] & 128))
            return 0;

        /* decode frame */
        length_frame_size = 1;
        length_frame = buffer[index_buffer + 1] & 127;
        index_buffer += 2;
        if (index_buffer >= buffer_length)
            return 0;
        if ((length_frame == 126) || (length_frame == 127))
        {
            length_frame_size = (length_frame == 126) ? 2 : 8;
            if (index_buffer + length_frame_size > buffer_length)
                return 0;
            length_frame = 0;
            for (i = 0; i < length_frame_size; i++)
            {
                length_frame += (unsigned long long)buffer[index_buffer + i] << ((length_frame_size - i - 1) * 8);
            }
            index_buffer += length_frame_size;
        }

        /* read masks (4 bytes) */
        if (index_buffer + 4 > buffer_length)
            return 0;
        int masks[4];
        for (i = 0; i < 4; i++)
        {
            masks[i] = (int)((unsigned char)buffer[index_buffer + i]);
        }
        index_buffer += 4;

        /* copy opcode in decoded data */
        switch (opcode)
        {
            case WEBSOCKET_FRAME_OPCODE_PING:
                decoded[*decoded_length] = RELAY_CLIENT_MSG_PING;
                break;
            case WEBSOCKET_FRAME_OPCODE_CLOSE:
                decoded[*decoded_length] = RELAY_CLIENT_MSG_CLOSE;
                break;
            default:
                decoded[*decoded_length] = RELAY_CLIENT_MSG_STANDARD;
                break;
        }
        *decoded_length += 1;

        /* decode data using masks */
        if ((length_frame > buffer_length)
            || (index_buffer + length_frame > buffer_length))
        {
            return 0;
        }
        for (i = 0; i < length_frame; i++)
        {
            decoded[*decoded_length + i] = (int)((unsigned char)buffer[index_buffer + i]) ^ masks[i % 4];
        }
        decoded[*decoded_length + length_frame] = '\0';
        *decoded_length += length_frame + 1;
        index_buffer += length_frame;
    }

    return 1;
}","int
relay_websocket_decode_frame (const unsigned char *VAR_0,
                              unsigned long long VAR_1,
                              unsigned char *VAR_2,
                              unsigned long long *VAR_3)
{
    unsigned long long VAR_4, VAR_5, VAR_6, VAR_7;
    unsigned char VAR_8;

    *VAR_3 = 0;
    VAR_5 = 0;

    /* COMMENT_0 */
    while (VAR_5 + 1 < VAR_1)
    {
        VAR_8 = VAR_0[VAR_5] & 15;

        /* COMMENT_1 */
                                                                                 
                                                                                
           
        if (!(VAR_0[VAR_5 + 1] & 128))
            return 0;

        /* COMMENT_5 */
        VAR_6 = 1;
        VAR_7 = VAR_0[VAR_5 + 1] & 127;
        VAR_5 += 2;
        if (VAR_5 >= VAR_1)
            return 0;
        if ((VAR_7 == 126) || (VAR_7 == 127))
        {
            VAR_6 = (VAR_7 == 126) ? 2 : 8;
            if (VAR_5 + VAR_6 > VAR_1)
                return 0;
            VAR_7 = 0;
            for (VAR_4 = 0; VAR_4 < VAR_6; VAR_4++)
            {
                VAR_7 += (unsigned long long)VAR_0[VAR_5 + VAR_4] << ((VAR_6 - VAR_4 - 1) * 8);
            }
            VAR_5 += VAR_6;
        }

        /* COMMENT_6 */
        if (VAR_5 + 4 > VAR_1)
            return 0;
        int VAR_9[4];
        for (VAR_4 = 0; VAR_4 < 4; VAR_4++)
        {
            VAR_9[VAR_4] = (int)((unsigned char)VAR_0[VAR_5 + VAR_4]);
        }
        VAR_5 += 4;

        /* COMMENT_7 */
        switch (VAR_8)
        {
            case VAR_10:
                VAR_2[*VAR_3] = VAR_11;
                break;
            case VAR_12:
                VAR_2[*VAR_3] = VAR_13;
                break;
            default:
                VAR_2[*VAR_3] = VAR_14;
                break;
        }
        *VAR_3 += 1;

        /* COMMENT_8 */
        if ((VAR_7 > VAR_1)
            || (VAR_5 + VAR_7 > VAR_1))
        {
            return 0;
        }
        for (VAR_4 = 0; VAR_4 < VAR_7; VAR_4++)
        {
            VAR_2[*VAR_3 + VAR_4] = (int)((unsigned char)VAR_0[VAR_5 + VAR_4]) ^ VAR_9[VAR_4 % 4];
        }
        VAR_2[*VAR_3 + VAR_7] = '\0';
        *VAR_3 += VAR_7 + 1;
        VAR_5 += VAR_7;
    }

    return 1;
}",weechat/8b1331f98de1714bae15a9ca2e2b393ba49d735b/relay-websocket.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,7 +11,7 @@
     index_buffer = 0;
 
     /* loop to decode all frames in message */
-    while (index_buffer + 2 <= buffer_length)
+    while (index_buffer + 1 < buffer_length)
     {
         opcode = buffer[index_buffer] & 15;
 
@@ -26,10 +26,12 @@
         length_frame_size = 1;
         length_frame = buffer[index_buffer + 1] & 127;
         index_buffer += 2;
+        if (index_buffer >= buffer_length)
+            return 0;
         if ((length_frame == 126) || (length_frame == 127))
         {
             length_frame_size = (length_frame == 126) ? 2 : 8;
-            if (buffer_length < 1 + length_frame_size)
+            if (index_buffer + length_frame_size > buffer_length)
                 return 0;
             length_frame = 0;
             for (i = 0; i < length_frame_size; i++)
@@ -39,10 +41,9 @@
             index_buffer += length_frame_size;
         }
 
-        if (buffer_length < 1 + length_frame_size + 4 + length_frame)
+        /* read masks (4 bytes) */
+        if (index_buffer + 4 > buffer_length)
             return 0;
-
-        /* read masks (4 bytes) */
         int masks[4];
         for (i = 0; i < 4; i++)
         {
@@ -66,6 +67,11 @@
         *decoded_length += 1;
 
         /* decode data using masks */
+        if ((length_frame > buffer_length)
+            || (index_buffer + length_frame > buffer_length))
+        {
+            return 0;
+        }
         for (i = 0; i < length_frame; i++)
         {
             decoded[*decoded_length + i] = (int)((unsigned char)buffer[index_buffer + i]) ^ masks[i % 4];","{'deleted_lines': ['    while (index_buffer + 2 <= buffer_length)', '            if (buffer_length < 1 + length_frame_size)', '        if (buffer_length < 1 + length_frame_size + 4 + length_frame)', '', '        /* read masks (4 bytes) */'], 'added_lines': ['    while (index_buffer + 1 < buffer_length)', '        if (index_buffer >= buffer_length)', '            return 0;', '            if (index_buffer + length_frame_size > buffer_length)', '        /* read masks (4 bytes) */', '        if (index_buffer + 4 > buffer_length)', '        if ((length_frame > buffer_length)', '            || (index_buffer + length_frame > buffer_length))', '        {', '            return 0;', '        }']}",True,WeeChat before 3.2.1 allows remote attackers to cause a denial of service (crash) via a crafted WebSocket frame that trigger an out-of-bounds read in plugins/relay/relay-websocket.c in the Relay plugin.,7.5,HIGH,2,test,2021-09-04T09:39:22Z,3
CVE-2021-32762,"['CWE-190', 'CWE-680']",AV:N/AC:L/Au:S/C:C/I:C/A:C,0,redis,"Fix redis-cli / redis-sential overflow on some platforms (CVE-2021-32762) (#9587)

The redis-cli command line tool and redis-sentinel service may be vulnerable
to integer overflow when parsing specially crafted large multi-bulk network
replies. This is a result of a vulnerability in the underlying hiredis
library which does not perform an overflow check before calling the calloc()
heap allocation function.

This issue only impacts systems with heap allocators that do not perform their
own overflow checks. Most modern systems do and are therefore not likely to
be affected. Furthermore, by default redis-sentinel uses the jemalloc allocator
which is also not vulnerable.

Co-authored-by: Yossi Gottlieb <yossigo@gmail.com>",0215324a66af949be39b34be2d55143232c1cb71,https://github.com/redis/redis/commit/0215324a66af949be39b34be2d55143232c1cb71,deps/hiredis/hiredis.c,createArrayObject,"static void *createArrayObject(const redisReadTask *task, size_t elements) {
redisReply *r, *parent;
r = createReplyObject(task->type);
if (r == NULL)
return NULL;
if (elements > 0) {
r->element = hi_calloc(elements,sizeof(redisReply*));
if (r->element == NULL) {
freeReplyObject(r);
return NULL;
}
}
r->elements = elements;
if (task->parent) {
parent = task->parent->obj;
assert(parent->type == REDIS_REPLY_ARRAY ||
parent->type == REDIS_REPLY_MAP ||
parent->type == REDIS_REPLY_SET ||
parent->type == REDIS_REPLY_PUSH);
parent->element[task->idx] = r;
}
return r;
}","static void *createArrayObject(const redisReadTask *VAR_0, size_t VAR_1) {
redisReply *VAR_2, *VAR_3;
VAR_2 = createReplyObject(VAR_0->type);
if (VAR_2 == NULL)
return NULL;
if (VAR_1 > 0) {
VAR_2->element = hi_calloc(VAR_1,sizeof(redisReply*));
if (VAR_2->element == NULL) {
freeReplyObject(VAR_2);
return NULL;
}
}
VAR_2->elements = VAR_1;
if (VAR_0->parent) {
VAR_3 = VAR_0->parent->obj;
assert(VAR_3->type == VAR_4 ||
VAR_3->type == VAR_5 ||
VAR_3->type == VAR_6 ||
VAR_3->type == VAR_7);
VAR_3->element[VAR_0->idx] = VAR_2;
}
return VAR_2;
}",redis/0215324a66af949be39b34be2d55143232c1cb71/hiredis.c/vul/before/0.json,"static void *createArrayObject(const redisReadTask *task, size_t elements) {
    redisReply *r, *parent;

    r = createReplyObject(task->type);
    if (r == NULL)
        return NULL;

    if (elements > 0) {
        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  /* Don't overflow */
        r->element = hi_calloc(elements,sizeof(redisReply*));
        if (r->element == NULL) {
            freeReplyObject(r);
            return NULL;
        }
    }

    r->elements = elements;

    if (task->parent) {
        parent = task->parent->obj;
        assert(parent->type == REDIS_REPLY_ARRAY ||
               parent->type == REDIS_REPLY_MAP ||
               parent->type == REDIS_REPLY_SET ||
               parent->type == REDIS_REPLY_PUSH);
        parent->element[task->idx] = r;
    }
    return r;
}","static void *createArrayObject(const redisReadTask *VAR_0, size_t VAR_1) {
    redisReply *VAR_2, *VAR_3;

    VAR_2 = createReplyObject(VAR_0->type);
    if (VAR_2 == NULL)
        return NULL;

    if (VAR_1 > 0) {
        if (VAR_4 / sizeof(redisReply*) < VAR_1) return NULL;  /* COMMENT_0 */
        VAR_2->element = hi_calloc(VAR_1,sizeof(redisReply*));
        if (VAR_2->element == NULL) {
            freeReplyObject(VAR_2);
            return NULL;
        }
    }

    VAR_2->elements = VAR_1;

    if (VAR_0->parent) {
        VAR_3 = VAR_0->parent->obj;
        assert(VAR_3->type == VAR_5 ||
               VAR_3->type == VAR_6 ||
               VAR_3->type == VAR_7 ||
               VAR_3->type == VAR_8);
        VAR_3->element[VAR_0->idx] = VAR_2;
    }
    return VAR_2;
}",redis/0215324a66af949be39b34be2d55143232c1cb71/hiredis.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,7 @@
         return NULL;
 
     if (elements > 0) {
+        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  /* Don't overflow */
         r->element = hi_calloc(elements,sizeof(redisReply*));
         if (r->element == NULL) {
             freeReplyObject(r);","{'deleted_lines': [], 'added_lines': [""        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  /* Don't overflow */""]}",True,"Redis is an open source, in-memory database that persists on disk. The redis-cli command line tool and redis-sentinel service may be vulnerable to integer overflow when parsing specially crafted large multi-bulk network replies. This is a result of a vulnerability in the underlying hiredis library which does not perform an overflow check before calling the calloc() heap allocation function. This issue only impacts systems with heap allocators that do not perform their own overflow checks. Most modern systems do and are therefore not likely to be affected. Furthermore, by default redis-sentinel uses the jemalloc allocator which is also not vulnerable. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14.",7.5,HIGH,2,test,2021-10-04T09:10:17Z,3
CVE-2021-3872,['CWE-122'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vim,"patch 8.2.3487: illegal memory access if buffer name is very long

Problem:    Illegal memory access if buffer name is very long.
Solution:   Make sure not to go over the end of the buffer.",826bfe4bbd7594188e3d74d2539d9707b1c6a14b,https://github.com/vim/vim/commit/826bfe4bbd7594188e3d74d2539d9707b1c6a14b,src/drawscreen.c,win_redr_status,"static void
win_redr_status(win_T *wp, int ignore_pum UNUSED)
{
introw;
char_u*p;
intlen;
intfillchar;
intattr;
intthis_ru_col;
static int  busy = FALSE;
if (busy)
return;
busy = TRUE;
row = statusline_row(wp);
wp->w_redr_status = FALSE;
if (wp->w_status_height == 0)
{
redraw_cmdline = TRUE;
}
else if (!redrawing()
|| (!ignore_pum && pum_visible()))
{
wp->w_redr_status = TRUE;
}
#ifdef FEAT_STL_OPT
else if (*p_stl != NUL || *wp->w_p_stl != NUL)
{
redraw_custom_statusline(wp);
}
#endif
else
{
fillchar = fillchar_status(&attr, wp);
get_trans_bufname(wp->w_buffer);
p = NameBuff;
len = (int)STRLEN(p);
if (bt_help(wp->w_buffer)
#ifdef FEAT_QUICKFIX
|| wp->w_p_pvw
#endif
|| bufIsChanged(wp->w_buffer)
|| wp->w_buffer->b_p_ro)
*(p + len++) = ' ';
if (bt_help(wp->w_buffer))
{
STRCPY(p + len, _(""[Help]""));
len += (int)STRLEN(p + len);
}
#ifdef FEAT_QUICKFIX
if (wp->w_p_pvw)
{
STRCPY(p + len, _(""[Preview]""));
len += (int)STRLEN(p + len);
}
#endif
if (bufIsChanged(wp->w_buffer)
#ifdef FEAT_TERMINAL
&& !bt_terminal(wp->w_buffer)
#endif
)
{
STRCPY(p + len, ""[+]"");
len += 3;
}
if (wp->w_buffer->b_p_ro)
{
STRCPY(p + len, _(""[RO]""));
len += (int)STRLEN(p + len);
}
this_ru_col = ru_col - (Columns - wp->w_width);
if (this_ru_col < (wp->w_width + 1) / 2)
this_ru_col = (wp->w_width + 1) / 2;
if (this_ru_col <= 1)
{
p = (char_u *)""<"";    len = 1;
}
else if (has_mbyte)
{
intclen = 0, i;
clen = mb_string2cells(p, -1);
for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;
i += (*mb_ptr2len)(p + i))
clen -= (*mb_ptr2cells)(p + i);
len = clen;
if (i > 0)
{
p = p + i - 1;
*p = '<';
++len;
}
}
else if (len > this_ru_col - 1)
{
p += len - (this_ru_col - 1);
*p = '<';
len = this_ru_col - 1;
}
screen_puts(p, row, wp->w_wincol, attr);
screen_fill(row, row + 1, len + wp->w_wincol,
this_ru_col + wp->w_wincol, fillchar, fillchar, attr);
if (get_keymap_str(wp, (char_u *)""<%s>"", NameBuff, MAXPATHL)
&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1))
screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff)
- 1 + wp->w_wincol), attr);
#ifdef FEAT_CMDL_INFO
win_redr_ruler(wp, TRUE, ignore_pum);
#endif
}
if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())
{
if (stl_connected(wp))
fillchar = fillchar_status(&attr, wp);
else
fillchar = fillchar_vsep(&attr);
screen_putchar(fillchar, row, W_ENDCOL(wp), attr);
}
busy = FALSE;
}","static void
win_redr_status(win_T *VAR_0, int VAR_1 UNUSED)
{
intVAR_2;
char_u*VAR_3;
intVAR_4;
intVAR_5;
intVAR_6;
intVAR_7;
static int  VAR_8 = FALSE;
if (VAR_8)
return;
VAR_8 = TRUE;
VAR_2 = statusline_row(VAR_0);
VAR_0->w_redr_status = FALSE;
if (VAR_0->w_status_height == 0)
{
VAR_9 = TRUE;
}
else if (!redrawing()
|| (!VAR_1 && pum_visible()))
{
VAR_0->w_redr_status = TRUE;
}
#ifdef VAR_10
else if (*p_stl != VAR_11 || *VAR_0->VAR_12 != VAR_11)
{
redraw_custom_statusline(VAR_0);
}
#endif
else
{
VAR_5 = fillchar_status(&VAR_6, VAR_0);
get_trans_bufname(VAR_0->w_buffer);
VAR_3 = VAR_13;
VAR_4 = (int)STRLEN(VAR_3);
if (bt_help(VAR_0->w_buffer)
#ifdef VAR_14
|| VAR_0->w_p_pvw
#endif
|| bufIsChanged(VAR_0->w_buffer)
|| VAR_0->w_buffer->b_p_ro)
*(VAR_3 + VAR_4++) = ' ';
if (bt_help(VAR_0->w_buffer))
{
STRCPY(VAR_3 + VAR_4, _(""[Help]""));
VAR_4 += (int)STRLEN(VAR_3 + VAR_4);
}
#ifdef VAR_14
if (VAR_0->w_p_pvw)
{
STRCPY(VAR_3 + VAR_4, _(""[Preview]""));
VAR_4 += (int)STRLEN(VAR_3 + VAR_4);
}
#endif
if (bufIsChanged(VAR_0->w_buffer)
#ifdef VAR_15
&& !bt_terminal(VAR_0->w_buffer)
#endif
)
{
STRCPY(VAR_3 + VAR_4, ""[+]"");
VAR_4 += 3;
}
if (VAR_0->w_buffer->b_p_ro)
{
STRCPY(VAR_3 + VAR_4, _(""[RO]""));
VAR_4 += (int)STRLEN(VAR_3 + VAR_4);
}
VAR_7 = VAR_16 - (VAR_17 - VAR_0->w_width);
if (VAR_7 < (VAR_0->w_width + 1) / 2)
VAR_7 = (VAR_0->w_width + 1) / 2;
if (VAR_7 <= 1)
{
VAR_3 = (char_u *)""<"";
VAR_4 = 1;
}
else if (VAR_18)
{
intVAR_19 = 0, VAR_20;
VAR_19 = mb_string2cells(VAR_3, -1);
for (VAR_20 = 0; VAR_3[VAR_20] != VAR_11 && VAR_19 >= VAR_7 - 1;
VAR_20 += (*VAR_21)(VAR_3 + VAR_20))
VAR_19 -= (*VAR_22)(VAR_3 + VAR_20);
VAR_4 = VAR_19;
if (VAR_20 > 0)
{
VAR_3 = VAR_3 + VAR_20 - 1;
*VAR_3 = '<';
++VAR_4;
}
}
else if (VAR_4 > VAR_7 - 1)
{
VAR_3 += VAR_4 - (VAR_7 - 1);
*VAR_3 = '<';
VAR_4 = VAR_7 - 1;
}
screen_puts(VAR_3, VAR_2, VAR_0->w_wincol, VAR_6);
screen_fill(VAR_2, VAR_2 + 1, VAR_4 + VAR_0->w_wincol,
VAR_7 + VAR_0->w_wincol, VAR_5, VAR_5, VAR_6);
if (get_keymap_str(VAR_0, (char_u *)""<%s>"", VAR_13, VAR_23)
&& (int)(VAR_7 - VAR_4) > (int)(STRLEN(VAR_13) + 1))
screen_puts(VAR_13, VAR_2, (int)(VAR_7 - STRLEN(VAR_13)
- 1 + VAR_0->w_wincol), VAR_6);
#ifdef VAR_24
win_redr_ruler(VAR_0, TRUE, VAR_1);
#endif
}
if (VAR_0->w_vsep_width != 0 && VAR_0->w_status_height != 0 && redrawing())
{
if (stl_connected(VAR_0))
VAR_5 = fillchar_status(&VAR_6, VAR_0);
else
VAR_5 = fillchar_vsep(&VAR_6);
screen_putchar(VAR_5, VAR_2, W_ENDCOL(VAR_0), VAR_6);
}
VAR_8 = FALSE;
}",,"static void
win_redr_status(win_T *wp, int ignore_pum UNUSED)
{
    int		row;
    char_u	*p;
    int		len;
    int		fillchar;
    int		attr;
    int		this_ru_col;
    static int  busy = FALSE;

    // It's possible to get here recursively when 'statusline' (indirectly)
    // invokes "":redrawstatus"".  Simply ignore the call then.
    if (busy)
	return;
    busy = TRUE;

    row = statusline_row(wp);

    wp->w_redr_status = FALSE;
    if (wp->w_status_height == 0)
    {
	// no status line, can only be last window
	redraw_cmdline = TRUE;
    }
    else if (!redrawing()
	    // don't update status line when popup menu is visible and may be
	    // drawn over it, unless it will be redrawn later
	    || (!ignore_pum && pum_visible()))
    {
	// Don't redraw right now, do it later.
	wp->w_redr_status = TRUE;
    }
#ifdef FEAT_STL_OPT
    else if (*p_stl != NUL || *wp->w_p_stl != NUL)
    {
	// redraw custom status line
	redraw_custom_statusline(wp);
    }
#endif
    else
    {
	fillchar = fillchar_status(&attr, wp);

	get_trans_bufname(wp->w_buffer);
	p = NameBuff;
	len = (int)STRLEN(p);

	if (bt_help(wp->w_buffer)
#ifdef FEAT_QUICKFIX
		|| wp->w_p_pvw
#endif
		|| bufIsChanged(wp->w_buffer)
		|| wp->w_buffer->b_p_ro)
	    *(p + len++) = ' ';
	if (bt_help(wp->w_buffer))
	{
	    vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[Help]""));
	    len += (int)STRLEN(p + len);
	}
#ifdef FEAT_QUICKFIX
	if (wp->w_p_pvw)
	{
	    vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[Preview]""));
	    len += (int)STRLEN(p + len);
	}
#endif
	if (bufIsChanged(wp->w_buffer)
#ifdef FEAT_TERMINAL
		&& !bt_terminal(wp->w_buffer)
#endif
		)
	{
	    vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", ""[+]"");
	    len += (int)STRLEN(p + len);
	}
	if (wp->w_buffer->b_p_ro)
	{
	    vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[RO]""));
	    len += (int)STRLEN(p + len);
	}

	this_ru_col = ru_col - (Columns - wp->w_width);
	if (this_ru_col < (wp->w_width + 1) / 2)
	    this_ru_col = (wp->w_width + 1) / 2;
	if (this_ru_col <= 1)
	{
	    p = (char_u *)""<"";		// No room for file name!
	    len = 1;
	}
	else if (has_mbyte)
	{
	    int	clen = 0, i;

	    // Count total number of display cells.
	    clen = mb_string2cells(p, -1);

	    // Find first character that will fit.
	    // Going from start to end is much faster for DBCS.
	    for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;
		    i += (*mb_ptr2len)(p + i))
		clen -= (*mb_ptr2cells)(p + i);
	    len = clen;
	    if (i > 0)
	    {
		p = p + i - 1;
		*p = '<';
		++len;
	    }

	}
	else if (len > this_ru_col - 1)
	{
	    p += len - (this_ru_col - 1);
	    *p = '<';
	    len = this_ru_col - 1;
	}

	screen_puts(p, row, wp->w_wincol, attr);
	screen_fill(row, row + 1, len + wp->w_wincol,
			this_ru_col + wp->w_wincol, fillchar, fillchar, attr);

	if (get_keymap_str(wp, (char_u *)""<%s>"", NameBuff, MAXPATHL)
		&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1))
	    screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff)
						   - 1 + wp->w_wincol), attr);

#ifdef FEAT_CMDL_INFO
	win_redr_ruler(wp, TRUE, ignore_pum);
#endif
    }

    /*
     * May need to draw the character below the vertical separator.
     */
    if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())
    {
	if (stl_connected(wp))
	    fillchar = fillchar_status(&attr, wp);
	else
	    fillchar = fillchar_vsep(&attr);
	screen_putchar(fillchar, row, W_ENDCOL(wp), attr);
    }
    busy = FALSE;
}","static void
win_redr_status(win_T *VAR_0, int VAR_1 UNUSED)
{
    int		VAR_2;
    char_u	*VAR_3;
    int		VAR_4;
    int		VAR_5;
    int		VAR_6;
    int		VAR_7;
    static int  VAR_8 = FALSE;

    /* COMMENT_0 */
    /* COMMENT_1 */
    if (VAR_8)
	return;
    VAR_8 = TRUE;

    VAR_2 = statusline_row(VAR_0);

    VAR_0->w_redr_status = FALSE;
    if (VAR_0->w_status_height == 0)
    {
	/* COMMENT_2 */
	VAR_9 = TRUE;
    }
    else if (!redrawing()
	    /* COMMENT_3 */
	    /* COMMENT_4 */
	    || (!VAR_1 && pum_visible()))
    {
	/* COMMENT_5 */
	VAR_0->w_redr_status = TRUE;
    }
#ifdef VAR_10
    else if (*p_stl != VAR_11 || *VAR_0->VAR_12 != VAR_11)
    {
	/* COMMENT_6 */
	redraw_custom_statusline(VAR_0);
    }
#endif
    else
    {
	VAR_5 = fillchar_status(&VAR_6, VAR_0);

	get_trans_bufname(VAR_0->w_buffer);
	VAR_3 = VAR_13;
	VAR_4 = (int)STRLEN(VAR_3);

	if (bt_help(VAR_0->w_buffer)
#ifdef VAR_14
		|| VAR_0->w_p_pvw
#endif
		|| bufIsChanged(VAR_0->w_buffer)
		|| VAR_0->w_buffer->b_p_ro)
	    *(VAR_3 + VAR_4++) = ' ';
	if (bt_help(VAR_0->w_buffer))
	{
	    vim_snprintf((char *)VAR_3 + VAR_4, VAR_15 - VAR_4, ""%s"", _(""[Help]""));
	    VAR_4 += (int)STRLEN(VAR_3 + VAR_4);
	}
#ifdef VAR_14
	if (VAR_0->w_p_pvw)
	{
	    vim_snprintf((char *)VAR_3 + VAR_4, VAR_15 - VAR_4, ""%s"", _(""[Preview]""));
	    VAR_4 += (int)STRLEN(VAR_3 + VAR_4);
	}
#endif
	if (bufIsChanged(VAR_0->w_buffer)
#ifdef VAR_16
		&& !bt_terminal(VAR_0->w_buffer)
#endif
		)
	{
	    vim_snprintf((char *)VAR_3 + VAR_4, VAR_15 - VAR_4, ""%s"", ""[+]"");
	    VAR_4 += (int)STRLEN(VAR_3 + VAR_4);
	}
	if (VAR_0->w_buffer->b_p_ro)
	{
	    vim_snprintf((char *)VAR_3 + VAR_4, VAR_15 - VAR_4, ""%s"", _(""[RO]""));
	    VAR_4 += (int)STRLEN(VAR_3 + VAR_4);
	}

	VAR_7 = VAR_17 - (VAR_18 - VAR_0->w_width);
	if (VAR_7 < (VAR_0->w_width + 1) / 2)
	    VAR_7 = (VAR_0->w_width + 1) / 2;
	if (VAR_7 <= 1)
	{
	    VAR_3 = (char_u *)""<"";		/* COMMENT_7 */
	    VAR_4 = 1;
	}
	else if (VAR_19)
	{
	    int	VAR_20 = 0, VAR_21;

	    /* COMMENT_8 */
	    VAR_20 = mb_string2cells(VAR_3, -1);

	    /* COMMENT_9 */
	    /* COMMENT_10 */
	    for (VAR_21 = 0; VAR_3[VAR_21] != VAR_11 && VAR_20 >= VAR_7 - 1;
		    VAR_21 += (*VAR_22)(VAR_3 + VAR_21))
		VAR_20 -= (*VAR_23)(VAR_3 + VAR_21);
	    VAR_4 = VAR_20;
	    if (VAR_21 > 0)
	    {
		VAR_3 = VAR_3 + VAR_21 - 1;
		*VAR_3 = '<';
		++VAR_4;
	    }

	}
	else if (VAR_4 > VAR_7 - 1)
	{
	    VAR_3 += VAR_4 - (VAR_7 - 1);
	    *VAR_3 = '<';
	    VAR_4 = VAR_7 - 1;
	}

	screen_puts(VAR_3, VAR_2, VAR_0->w_wincol, VAR_6);
	screen_fill(VAR_2, VAR_2 + 1, VAR_4 + VAR_0->w_wincol,
			VAR_7 + VAR_0->w_wincol, VAR_5, VAR_5, VAR_6);

	if (get_keymap_str(VAR_0, (char_u *)""<%s>"", VAR_13, VAR_15)
		&& (int)(VAR_7 - VAR_4) > (int)(STRLEN(VAR_13) + 1))
	    screen_puts(VAR_13, VAR_2, (int)(VAR_7 - STRLEN(VAR_13)
						   - 1 + VAR_0->w_wincol), VAR_6);

#ifdef VAR_24
	win_redr_ruler(VAR_0, TRUE, VAR_1);
#endif
    }

    /* COMMENT_11 */
                                                                   
       
    if (VAR_0->w_vsep_width != 0 && VAR_0->w_status_height != 0 && redrawing())
    {
	if (stl_connected(VAR_0))
	    VAR_5 = fillchar_status(&VAR_6, VAR_0);
	else
	    VAR_5 = fillchar_vsep(&VAR_6);
	screen_putchar(VAR_5, VAR_2, W_ENDCOL(VAR_0), VAR_6);
    }
    VAR_8 = FALSE;
}",,"--- func_before
+++ func_after
@@ -55,13 +55,13 @@
 	    *(p + len++) = ' ';
 	if (bt_help(wp->w_buffer))
 	{
-	    STRCPY(p + len, _(""[Help]""));
+	    vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[Help]""));
 	    len += (int)STRLEN(p + len);
 	}
 #ifdef FEAT_QUICKFIX
 	if (wp->w_p_pvw)
 	{
-	    STRCPY(p + len, _(""[Preview]""));
+	    vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[Preview]""));
 	    len += (int)STRLEN(p + len);
 	}
 #endif
@@ -71,12 +71,12 @@
 #endif
 		)
 	{
-	    STRCPY(p + len, ""[+]"");
-	    len += 3;
+	    vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", ""[+]"");
+	    len += (int)STRLEN(p + len);
 	}
 	if (wp->w_buffer->b_p_ro)
 	{
-	    STRCPY(p + len, _(""[RO]""));
+	    vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[RO]""));
 	    len += (int)STRLEN(p + len);
 	}
 ","{'deleted_lines': ['\t    STRCPY(p + len, _(""[Help]""));', '\t    STRCPY(p + len, _(""[Preview]""));', '\t    STRCPY(p + len, ""[+]"");', '\t    len += 3;', '\t    STRCPY(p + len, _(""[RO]""));'], 'added_lines': ['\t    vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[Help]""));', '\t    vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[Preview]""));', '\t    vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", ""[+]"");', '\t    len += (int)STRLEN(p + len);', '\t    vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[RO]""));']}",True,vim is vulnerable to Heap-based Buffer Overflow,7.8,HIGH,2,test,2021-10-08T17:39:28Z,3
CVE-2021-41217,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,tensorflow,"Fix a NPE issue in invalid Exit op. Now it will report an error instead of crash.

PiperOrigin-RevId: 404089902
Change-Id: Ia6ec55445ea70ad045a4d339d354959ad0618f2a",05cbebd3c6bb8f517a158b0155debb8df79017ff,https://github.com/tensorflow/tensorflow/commit/05cbebd3c6bb8f517a158b0155debb8df79017ff,tensorflow/core/common_runtime/immutable_executor_state.cc,ImmutableExecutorState::BuildControlFlowInfo,"Status ImmutableExecutorState::BuildControlFlowInfo(const Graph* g,
ControlFlowInfo* cf_info) {
const int num_nodes = g->num_node_ids();
cf_info->frame_names.resize(num_nodes);
std::vector<Node*> parent_nodes;
parent_nodes.resize(num_nodes);
std::vector<bool> visited;
visited.resize(num_nodes);
string frame_name;
std::deque<Node*> ready;
for (Node* n : g->nodes()) {
if (n->in_edges().empty()) {
visited[n->id()] = true;
cf_info->unique_frame_names.insert(frame_name);
ready.push_back(n);
}
}
while (!ready.empty()) {
Node* curr_node = ready.front();
int curr_id = curr_node->id();
ready.pop_front();
Node* parent = nullptr;
if (IsEnter(curr_node)) {
TF_RETURN_IF_ERROR(
GetNodeAttr(curr_node->attrs(), ""frame_name"", &frame_name));
parent = curr_node;
} else if (IsExit(curr_node)) {
parent = parent_nodes[curr_id];
frame_name = cf_info->frame_names[parent->id()];
parent = parent_nodes[parent->id()];
} else {
parent = parent_nodes[curr_id];
frame_name = cf_info->frame_names[curr_id];
}
for (const Edge* out_edge : curr_node->out_edges()) {
Node* out = out_edge->dst();
if (IsSink(out)) continue;
const int out_id = out->id();
bool is_visited = visited[out_id];
if (!is_visited) {
ready.push_back(out);
visited[out_id] = true;
cf_info->frame_names[out_id] = frame_name;
parent_nodes[out_id] = parent;
cf_info->unique_frame_names.insert(frame_name);
}
}
}
return Status::OK();
}","Status ImmutableExecutorState::BuildControlFlowInfo(const Graph* VAR_0,
ControlFlowInfo* VAR_1) {
const int VAR_2 = VAR_0->num_node_ids();
VAR_1->frame_names.resize(VAR_2);
std::vector<Node*> VAR_3;
VAR_3.resize(VAR_2);
std::vector<bool> VAR_4;
VAR_4.resize(VAR_2);
string VAR_5;
std::deque<Node*> VAR_6;
for (Node* VAR_7 : VAR_0->nodes()) {
if (VAR_7->in_edges().empty()) {
VAR_4[VAR_7->id()] = true;
VAR_1->unique_frame_names.insert(VAR_5);
VAR_6.push_back(VAR_7);
}
}
while (!VAR_6.empty()) {
Node* VAR_8 = VAR_6.front();
int VAR_9 = VAR_8->id();
VAR_6.pop_front();
Node* VAR_10 = nullptr;
if (IsEnter(VAR_8)) {
TF_RETURN_IF_ERROR(
GetNodeAttr(VAR_8->attrs(), ""frame_name"", &VAR_5));
VAR_10 = VAR_8;
} else if (IsExit(VAR_8)) {
VAR_10 = VAR_3[VAR_9];
VAR_5 = VAR_1->frame_names[VAR_10->id()];
VAR_10 = VAR_3[VAR_10->id()];
} else {
VAR_10 = VAR_3[VAR_9];
VAR_5 = VAR_1->frame_names[VAR_9];
}
for (const Edge* VAR_11 : VAR_8->out_edges()) {
Node* VAR_12 = VAR_11->dst();
if (IsSink(VAR_12)) continue;
const int VAR_13 = VAR_12->id();
bool VAR_14 = VAR_4[VAR_13];
if (!VAR_14) {
VAR_6.push_back(VAR_12);
VAR_4[VAR_13] = true;
VAR_1->frame_names[VAR_13] = VAR_5;
VAR_3[VAR_13] = VAR_10;
VAR_1->unique_frame_names.insert(VAR_5);
}
}
}
return Status::OK();
}",tensorflow/05cbebd3c6bb8f517a158b0155debb8df79017ff/immutable_executor_state.cc/vul/before/0.json,"Status ImmutableExecutorState::BuildControlFlowInfo(const Graph* g,
                                                    ControlFlowInfo* cf_info) {
  const int num_nodes = g->num_node_ids();
  cf_info->frame_names.resize(num_nodes);
  std::vector<Node*> parent_nodes;
  parent_nodes.resize(num_nodes);
  std::vector<bool> visited;
  visited.resize(num_nodes);

  string frame_name;
  std::deque<Node*> ready;

  // Initialize with the root nodes.
  for (Node* n : g->nodes()) {
    if (n->in_edges().empty()) {
      visited[n->id()] = true;
      cf_info->unique_frame_names.insert(frame_name);
      ready.push_back(n);
    }
  }

  while (!ready.empty()) {
    Node* curr_node = ready.front();
    int curr_id = curr_node->id();
    ready.pop_front();

    Node* parent = nullptr;
    if (IsEnter(curr_node)) {
      // Enter a child frame.
      TF_RETURN_IF_ERROR(
          GetNodeAttr(curr_node->attrs(), ""frame_name"", &frame_name));
      parent = curr_node;
    } else if (IsExit(curr_node)) {
      // Exit to the parent frame.
      parent = parent_nodes[curr_id];
      if (!parent) {
        return errors::InvalidArgument(
            ""Invalid Exit op: Cannot find a corresponding Enter op."");
      }
      frame_name = cf_info->frame_names[parent->id()];
      parent = parent_nodes[parent->id()];
    } else {
      parent = parent_nodes[curr_id];
      frame_name = cf_info->frame_names[curr_id];
    }

    for (const Edge* out_edge : curr_node->out_edges()) {
      Node* out = out_edge->dst();
      if (IsSink(out)) continue;
      const int out_id = out->id();

      // Add to ready queue if not visited.
      bool is_visited = visited[out_id];
      if (!is_visited) {
        ready.push_back(out);
        visited[out_id] = true;

        // Process the node 'out'.
        cf_info->frame_names[out_id] = frame_name;
        parent_nodes[out_id] = parent;
        cf_info->unique_frame_names.insert(frame_name);
      }
    }
  }

  return Status::OK();
}","Status ImmutableExecutorState::BuildControlFlowInfo(const Graph* VAR_0,
                                                    ControlFlowInfo* VAR_1) {
  const int VAR_2 = VAR_0->num_node_ids();
  VAR_1->frame_names.resize(VAR_2);
  std::vector<Node*> VAR_3;
  VAR_3.resize(VAR_2);
  std::vector<bool> VAR_4;
  VAR_4.resize(VAR_2);

  string VAR_5;
  std::deque<Node*> VAR_6;

  /* COMMENT_0 */
  for (Node* VAR_7 : VAR_0->nodes()) {
    if (VAR_7->in_edges().empty()) {
      VAR_4[VAR_7->id()] = true;
      VAR_1->unique_frame_names.insert(VAR_5);
      VAR_6.push_back(VAR_7);
    }
  }

  while (!VAR_6.empty()) {
    Node* VAR_8 = VAR_6.front();
    int VAR_9 = VAR_8->id();
    VAR_6.pop_front();

    Node* VAR_10 = nullptr;
    if (IsEnter(VAR_8)) {
      /* COMMENT_1 */
      TF_RETURN_IF_ERROR(
          GetNodeAttr(VAR_8->attrs(), ""frame_name"", &VAR_5));
      VAR_10 = VAR_8;
    } else if (IsExit(VAR_8)) {
      /* COMMENT_2 */
      VAR_10 = VAR_3[VAR_9];
      if (!VAR_10) {
        return errors::InvalidArgument(
            ""Invalid Exit op: Cannot find a corresponding Enter op."");
      }
      VAR_5 = VAR_1->frame_names[VAR_10->id()];
      VAR_10 = VAR_3[VAR_10->id()];
    } else {
      VAR_10 = VAR_3[VAR_9];
      VAR_5 = VAR_1->frame_names[VAR_9];
    }

    for (const Edge* VAR_11 : VAR_8->out_edges()) {
      Node* VAR_12 = VAR_11->dst();
      if (IsSink(VAR_12)) continue;
      const int VAR_13 = VAR_12->id();

      /* COMMENT_3 */
      bool VAR_14 = VAR_4[VAR_13];
      if (!VAR_14) {
        VAR_6.push_back(VAR_12);
        VAR_4[VAR_13] = true;

        /* COMMENT_4 */
        VAR_1->frame_names[VAR_13] = VAR_5;
        VAR_3[VAR_13] = VAR_10;
        VAR_1->unique_frame_names.insert(VAR_5);
      }
    }
  }

  return Status::OK();
}",tensorflow/05cbebd3c6bb8f517a158b0155debb8df79017ff/immutable_executor_state.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -33,6 +33,10 @@
     } else if (IsExit(curr_node)) {
       // Exit to the parent frame.
       parent = parent_nodes[curr_id];
+      if (!parent) {
+        return errors::InvalidArgument(
+            ""Invalid Exit op: Cannot find a corresponding Enter op."");
+      }
       frame_name = cf_info->frame_names[parent->id()];
       parent = parent_nodes[parent->id()];
     } else {","{'deleted_lines': [], 'added_lines': ['      if (!parent) {', '        return errors::InvalidArgument(', '            ""Invalid Exit op: Cannot find a corresponding Enter op."");', '      }']}",True,"TensorFlow is an open source platform for machine learning. In affected versions the process of building the control flow graph for a TensorFlow model is vulnerable to a null pointer exception when nodes that should be paired are not. This occurs because the code assumes that the first node in the pairing (e.g., an `Enter` node) always exists when encountering the second node (e.g., an `Exit` node). When this is not the case, `parent` is `nullptr` so dereferencing it causes a crash. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",5.5,MEDIUM,1,test,2021-10-18T23:17:46Z,3
CVE-2021-45864,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,justdan96/tsMuxer,Update dtsStreamReader.cpp,007bb548a50475ace5743e05a4a77fc74c8e27b7,https://github.com/justdan96/tsMuxer/commit/007bb548a50475ace5743e05a4a77fc74c8e27b7,tsMuxer/dtsStreamReader.cpp,DTSStreamReader::findFrame,"uint8_t* DTSStreamReader::findFrame(uint8_t* buff, uint8_t* end)
{
while (end - buff >= 16)
{
int64_t* ptr = (int64_t*)buff;
int64_t hdrType = my_ntohll(ptr[0]);
int64_t hdrSize = my_ntohll(ptr[1]) + 16;
if (hdrType == AUPRINFO || hdrType == BITSHVTB || hdrType == BLACKOUT || hdrType == BRANCHPT ||
hdrType == BUILDVER || hdrType == CORESSMD || hdrType == EXTSS_MD || hdrType == FILEINFO ||
hdrType == NAVI_TBL || hdrType == TIMECODE || hdrType == DTSHDHDR)
{
if (buff + hdrSize > end)
return 0;              buff += hdrSize;
}
else if (hdrType == AUPR_HDR)
{
if (buff + hdrSize > end)
return 0;                          m_skippingSamples = (buff[35] << 8) + buff[36];
buff += hdrSize;
}
else if (hdrType == STRMDATA)
{
m_dataSegmentLen = hdrSize;
buff += 16;
break;
}
else
{
break;          }
}
if (m_firstCall)
{
m_firstCall = false;
checkIfOnlyHDDataExists(buff, end);
}
if (!m_isCoreExists)
{
for (uint8_t* p_buf = buff; p_buf < end - 4; p_buf++)
{
if (p_buf[0] == 0x64 && p_buf[1] == 0x58 && p_buf[2] == 0x20 && p_buf[3] == 0x25)
{
return p_buf;
}
}
return 0;
}
for (uint8_t* p_buf = buff; p_buf < end - 4; p_buf++)
{
if (p_buf < end - 6)
{
if (p_buf[0] == 0xff && p_buf[1] == 0x1f && p_buf[2] == 0x00 && p_buf[3] == 0xe8 &&
(p_buf[4] & 0xf0) == 0xf0 && p_buf[5] == 0x07)
{
return p_buf;
}
else if (p_buf[0] == 0x1f && p_buf[1] == 0xff && p_buf[2] == 0xe8 && p_buf[3] == 0x00 && p_buf[4] == 0x07 &&
(p_buf[5] & 0xf0) == 0xf0)
{
return p_buf;
}
}
if (p_buf[0] == 0x7f && p_buf[1] == 0xfe && p_buf[2] == 0x80 && p_buf[3] == 0x01)
{
return p_buf;
}
else if (p_buf[0] == 0xfe && p_buf[1] == 0x7f && p_buf[2] == 0x01 && p_buf[3] == 0x80)
{
return p_buf;
}
}
return 0;
}","uint8_t* DTSStreamReader::findFrame(uint8_t* VAR_0, uint8_t* VAR_1)
{
while (VAR_1 - VAR_0 >= 16)
{
int64_t* VAR_2 = (int64_t*)VAR_0;
int64_t VAR_3 = my_ntohll(VAR_2[0]);
int64_t VAR_4 = my_ntohll(VAR_2[1]) + 16;
if (VAR_3 == VAR_5 || VAR_3 == VAR_6 || VAR_3 == VAR_7 || VAR_3 == VAR_8 ||
VAR_3 == VAR_9 || VAR_3 == VAR_10 || VAR_3 == VAR_11 || VAR_3 == VAR_12 ||
VAR_3 == VAR_13 || VAR_3 == VAR_14 || VAR_3 == VAR_15)
{
if (VAR_0 + VAR_4 > VAR_1)
return 0;  
VAR_0 += VAR_4;
}
else if (VAR_3 == VAR_16)
{
if (VAR_0 + VAR_4 > VAR_1)
return 0;  
VAR_17 = (VAR_0[35] << 8) + VAR_0[36];
VAR_0 += VAR_4;
}
else if (VAR_3 == VAR_18)
{
VAR_19 = VAR_4;
VAR_0 += 16;
break;
}
else
{
break;  
}
}
if (VAR_20)
{
VAR_20 = false;
checkIfOnlyHDDataExists(VAR_0, VAR_1);
}
if (!VAR_21)
{
for (uint8_t* VAR_22 = VAR_0; VAR_22 < VAR_1 - 4; VAR_22++)
{
if (VAR_22[0] == 0x64 && VAR_22[1] == 0x58 && VAR_22[2] == 0x20 && VAR_22[3] == 0x25)
{
return VAR_22;
}
}
return 0;
}
for (uint8_t* VAR_22 = VAR_0; VAR_22 < VAR_1 - 4; VAR_22++)
{
if (VAR_22 < VAR_1 - 6)
{
if (VAR_22[0] == 0xff && VAR_22[1] == 0x1f && VAR_22[2] == 0x00 && VAR_22[3] == 0xe8 &&
(VAR_22[4] & 0xf0) == 0xf0 && VAR_22[5] == 0x07)
{
return VAR_22;
}
else if (VAR_22[0] == 0x1f && VAR_22[1] == 0xff && VAR_22[2] == 0xe8 && VAR_22[3] == 0x00 && VAR_22[4] == 0x07 &&
(VAR_22[5] & 0xf0) == 0xf0)
{
return VAR_22;
}
}
if (VAR_22[0] == 0x7f && VAR_22[1] == 0xfe && VAR_22[2] == 0x80 && VAR_22[3] == 0x01)
{
return VAR_22;
}
else if (VAR_22[0] == 0xfe && VAR_22[1] == 0x7f && VAR_22[2] == 0x01 && VAR_22[3] == 0x80)
{
return VAR_22;
}
}
return 0;
}",justdan96/tsMuxer/007bb548a50475ace5743e05a4a77fc74c8e27b7/dtsStreamReader.cpp/vul/before/0.json,"uint8_t* DTSStreamReader::findFrame(uint8_t* buff, uint8_t* end)
{
    // check for DTS-HD headers
    while (end - buff >= 16)
    {
        int64_t* ptr = (int64_t*)buff;
        uint64_t hdrType = my_ntohll(ptr[0]);
        uint64_t hdrSize = my_ntohll(ptr[1]) + 16;

        if (hdrType == AUPRINFO || hdrType == BITSHVTB || hdrType == BLACKOUT || hdrType == BRANCHPT ||
            hdrType == BUILDVER || hdrType == CORESSMD || hdrType == EXTSS_MD || hdrType == FILEINFO ||
            hdrType == NAVI_TBL || hdrType == TIMECODE || hdrType == DTSHDHDR)
        {
            if (hdrSize > end - buff)
                return 0;  // need more data
            buff += hdrSize;
        }
        else if (hdrType == AUPR_HDR)
        {
            if (buff + hdrSize > end)
                return 0;  // need more data
            // determine skipping frames amount
            m_skippingSamples = (buff[35] << 8) + buff[36];
            buff += hdrSize;
        }
        else if (hdrType == STRMDATA)
        {
            m_dataSegmentLen = hdrSize;
            buff += 16;
            break;
        }
        else
        {
            break;  // no more HD headers
        }
    }

    if (m_firstCall)
    {
        m_firstCall = false;
        checkIfOnlyHDDataExists(buff, end);
    }

    if (!m_isCoreExists)
    {
        // if not core exists find HD frames directly
        for (uint8_t* p_buf = buff; p_buf < end - 4; p_buf++)
        {
            if (p_buf[0] == 0x64 && p_buf[1] == 0x58 && p_buf[2] == 0x20 && p_buf[3] == 0x25)
            {
                return p_buf;
            }
        }
        return 0;
    }

    for (uint8_t* p_buf = buff; p_buf < end - 4; p_buf++)
    {
        if (p_buf < end - 6)
        {
            if (p_buf[0] == 0xff && p_buf[1] == 0x1f && p_buf[2] == 0x00 && p_buf[3] == 0xe8 &&
                (p_buf[4] & 0xf0) == 0xf0 && p_buf[5] == 0x07)
            {
                return p_buf;
            }
            // 14 bits, big endian version of the bitstream
            else if (p_buf[0] == 0x1f && p_buf[1] == 0xff && p_buf[2] == 0xe8 && p_buf[3] == 0x00 && p_buf[4] == 0x07 &&
                     (p_buf[5] & 0xf0) == 0xf0)
            {
                return p_buf;
            }
        }
        // 16 bits, big endian version of the bitstream
        if (p_buf[0] == 0x7f && p_buf[1] == 0xfe && p_buf[2] == 0x80 && p_buf[3] == 0x01)
        {
            return p_buf;
        }
        // 16 bits, little endian version of the bitstream
        else if (p_buf[0] == 0xfe && p_buf[1] == 0x7f && p_buf[2] == 0x01 && p_buf[3] == 0x80)
        {
            return p_buf;
        }
    }
    return 0;
}","uint8_t* DTSStreamReader::findFrame(uint8_t* VAR_0, uint8_t* VAR_1)
{
    /* COMMENT_0 */
    while (VAR_1 - VAR_0 >= 16)
    {
        int64_t* VAR_2 = (int64_t*)VAR_0;
        uint64_t VAR_3 = my_ntohll(VAR_2[0]);
        uint64_t VAR_4 = my_ntohll(VAR_2[1]) + 16;

        if (VAR_3 == VAR_5 || VAR_3 == VAR_6 || VAR_3 == VAR_7 || VAR_3 == VAR_8 ||
            VAR_3 == VAR_9 || VAR_3 == VAR_10 || VAR_3 == VAR_11 || VAR_3 == VAR_12 ||
            VAR_3 == VAR_13 || VAR_3 == VAR_14 || VAR_3 == VAR_15)
        {
            if (VAR_4 > VAR_1 - VAR_0)
                return 0;  /* COMMENT_1 */
            VAR_0 += VAR_4;
        }
        else if (VAR_3 == VAR_16)
        {
            if (VAR_0 + VAR_4 > VAR_1)
                return 0;  /* COMMENT_1 */
            /* COMMENT_2 */
            VAR_17 = (VAR_0[35] << 8) + VAR_0[36];
            VAR_0 += VAR_4;
        }
        else if (VAR_3 == VAR_18)
        {
            VAR_19 = VAR_4;
            VAR_0 += 16;
            break;
        }
        else
        {
            break;  /* COMMENT_3 */
        }
    }

    if (VAR_20)
    {
        VAR_20 = false;
        checkIfOnlyHDDataExists(VAR_0, VAR_1);
    }

    if (!VAR_21)
    {
        /* COMMENT_4 */
        for (uint8_t* VAR_22 = VAR_0; VAR_22 < VAR_1 - 4; VAR_22++)
        {
            if (VAR_22[0] == 0x64 && VAR_22[1] == 0x58 && VAR_22[2] == 0x20 && VAR_22[3] == 0x25)
            {
                return VAR_22;
            }
        }
        return 0;
    }

    for (uint8_t* VAR_22 = VAR_0; VAR_22 < VAR_1 - 4; VAR_22++)
    {
        if (VAR_22 < VAR_1 - 6)
        {
            if (VAR_22[0] == 0xff && VAR_22[1] == 0x1f && VAR_22[2] == 0x00 && VAR_22[3] == 0xe8 &&
                (VAR_22[4] & 0xf0) == 0xf0 && VAR_22[5] == 0x07)
            {
                return VAR_22;
            }
            /* COMMENT_5 */
            else if (VAR_22[0] == 0x1f && VAR_22[1] == 0xff && VAR_22[2] == 0xe8 && VAR_22[3] == 0x00 && VAR_22[4] == 0x07 &&
                     (VAR_22[5] & 0xf0) == 0xf0)
            {
                return VAR_22;
            }
        }
        /* COMMENT_6 */
        if (VAR_22[0] == 0x7f && VAR_22[1] == 0xfe && VAR_22[2] == 0x80 && VAR_22[3] == 0x01)
        {
            return VAR_22;
        }
        /* COMMENT_7 */
        else if (VAR_22[0] == 0xfe && VAR_22[1] == 0x7f && VAR_22[2] == 0x01 && VAR_22[3] == 0x80)
        {
            return VAR_22;
        }
    }
    return 0;
}",justdan96/tsMuxer/007bb548a50475ace5743e05a4a77fc74c8e27b7/dtsStreamReader.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,14 +4,14 @@
     while (end - buff >= 16)
     {
         int64_t* ptr = (int64_t*)buff;
-        int64_t hdrType = my_ntohll(ptr[0]);
-        int64_t hdrSize = my_ntohll(ptr[1]) + 16;
+        uint64_t hdrType = my_ntohll(ptr[0]);
+        uint64_t hdrSize = my_ntohll(ptr[1]) + 16;
 
         if (hdrType == AUPRINFO || hdrType == BITSHVTB || hdrType == BLACKOUT || hdrType == BRANCHPT ||
             hdrType == BUILDVER || hdrType == CORESSMD || hdrType == EXTSS_MD || hdrType == FILEINFO ||
             hdrType == NAVI_TBL || hdrType == TIMECODE || hdrType == DTSHDHDR)
         {
-            if (buff + hdrSize > end)
+            if (hdrSize > end - buff)
                 return 0;  // need more data
             buff += hdrSize;
         }","{'deleted_lines': ['        int64_t hdrType = my_ntohll(ptr[0]);', '        int64_t hdrSize = my_ntohll(ptr[1]) + 16;', '            if (buff + hdrSize > end)'], 'added_lines': ['        uint64_t hdrType = my_ntohll(ptr[0]);', '        uint64_t hdrSize = my_ntohll(ptr[1]) + 16;', '            if (hdrSize > end - buff)']}",True,tsMuxer git-c6a0277 was discovered to contain a segmentation fault via DTSStreamReader::findFrame in dtsStreamReader.cpp.,5.5,MEDIUM,1,test,2021-10-19T11:24:44Z,3
CVE-2021-45861,['CWE-617'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,justdan96/tsMuxer,Update vvc.cpp,5b8fdee725f8b4b2f8c5dd23da6bc1c05ee7a8f9,https://github.com/justdan96/tsMuxer/commit/5b8fdee725f8b4b2f8c5dd23da6bc1c05ee7a8f9,tsMuxer/vvc.cpp,VvcUnitWithProfile::profile_tier_level,"void VvcUnitWithProfile::profile_tier_level(bool profileTierPresentFlag, int MaxNumSubLayersMinus1)
{
if (profileTierPresentFlag)
{
profile_idc = m_reader.getBits(7);
bool tier_flag = m_reader.getBit();
}
level_idc = m_reader.getBits(8);
m_reader.skipBits(2);  
if (profileTierPresentFlag)
{                                   if (m_reader.getBit())          {
m_reader.skipBits(32);
m_reader.skipBits(32);
m_reader.skipBits(7);
m_reader.skipBits(m_reader.getBits(8));          }
m_reader.skipBits(m_reader.getBitsLeft() % 8);      }
std::vector<int> ptl_sublayer_level_present_flag;
ptl_sublayer_level_present_flag.resize(MaxNumSubLayersMinus1);
for (int i = MaxNumSubLayersMinus1 - 1; i >= 0; i--) ptl_sublayer_level_present_flag[i] = m_reader.getBit();
m_reader.skipBits(m_reader.getBitsLeft() % 8);  
for (int i = MaxNumSubLayersMinus1 - 1; i >= 0; i--)
if (ptl_sublayer_level_present_flag[i])
m_reader.skipBits(8);      if (profileTierPresentFlag)
{
int ptl_num_sub_profiles = m_reader.getBits(8);
for (int i = 0; i < ptl_num_sub_profiles; i++) m_reader.skipBits(32);      }
}","void VvcUnitWithProfile::profile_tier_level(bool VAR_0, int VAR_1)
{
if (VAR_0)
{
VAR_2 = VAR_3.getBits(7);
bool VAR_4 = VAR_3.getBit();
}
VAR_5 = VAR_3.getBits(8);
VAR_3.skipBits(2);  
if (VAR_0)
{                           
if (VAR_3.getBit())  
{
VAR_3.skipBits(32);
VAR_3.skipBits(32);
VAR_3.skipBits(7);
VAR_3.skipBits(VAR_3.getBits(8));  
}
VAR_3.skipBits(VAR_3.getBitsLeft() % 8);  
}
std::vector<int> VAR_6;
VAR_6.resize(VAR_1);
for (int VAR_7 = VAR_1 - 1; VAR_7 >= 0; VAR_7--) VAR_6[VAR_7] = VAR_3.getBit();
VAR_3.skipBits(VAR_3.getBitsLeft() % 8);  
for (int VAR_7 = VAR_1 - 1; VAR_7 >= 0; VAR_7--)
if (VAR_6[VAR_7])
VAR_3.skipBits(8);  
if (VAR_0)
{
int VAR_8 = VAR_3.getBits(8);
for (int VAR_7 = 0; VAR_7 < VAR_8; VAR_7++) VAR_3.skipBits(32);  
}
}",justdan96/tsMuxer/5b8fdee725f8b4b2f8c5dd23da6bc1c05ee7a8f9/vvc.cpp/vul/before/0.json,"void VvcUnitWithProfile::profile_tier_level(bool profileTierPresentFlag, int MaxNumSubLayersMinus1)
{
    if (profileTierPresentFlag)
    {
        profile_idc = m_reader.getBits(7);
        bool tier_flag = m_reader.getBit();
    }
    level_idc = m_reader.getBits(8);
    m_reader.skipBits(2);  // ptl_frame_only_constraint_flag, ptl_multilayer_enabled_flag

    if (profileTierPresentFlag)
    {                           // general_constraints_info()
        if (m_reader.getBit())  // gci_present_flag
        {
            m_reader.skipBits(32);
            m_reader.skipBits(32);
            m_reader.skipBits(7);
            int gci_num_reserved_bits = m_reader.getBits(8);
            for (int i = 0; i < gci_num_reserved_bits; i++) m_reader.skipBit();  // gci_reserved_zero_bit[i]
        }
        m_reader.skipBits(m_reader.getBitsLeft() % 8);  // gci_alignment_zero_bit
    }
    std::vector<int> ptl_sublayer_level_present_flag;
    ptl_sublayer_level_present_flag.resize(MaxNumSubLayersMinus1);

    for (int i = MaxNumSubLayersMinus1 - 1; i >= 0; i--) ptl_sublayer_level_present_flag[i] = m_reader.getBit();

    m_reader.skipBits(m_reader.getBitsLeft() % 8);  // ptl_reserved_zero_bit

    for (int i = MaxNumSubLayersMinus1 - 1; i >= 0; i--)
        if (ptl_sublayer_level_present_flag[i])
            m_reader.skipBits(8);  // sublayer_level_idc[i]
    if (profileTierPresentFlag)
    {
        int ptl_num_sub_profiles = m_reader.getBits(8);
        for (int i = 0; i < ptl_num_sub_profiles; i++) m_reader.skipBits(32);  // general_sub_profile_idc[i]
    }
}","void VvcUnitWithProfile::profile_tier_level(bool VAR_0, int VAR_1)
{
    if (VAR_0)
    {
        VAR_2 = VAR_3.getBits(7);
        bool VAR_4 = VAR_3.getBit();
    }
    VAR_5 = VAR_3.getBits(8);
    VAR_3.skipBits(2);  /* COMMENT_0 */

    if (VAR_0)
    {                           /* COMMENT_1 */
        if (VAR_3.getBit())  /* COMMENT_2 */
        {
            VAR_3.skipBits(32);
            VAR_3.skipBits(32);
            VAR_3.skipBits(7);
            int VAR_6 = VAR_3.getBits(8);
            for (int VAR_7 = 0; VAR_7 < VAR_6; VAR_7++) VAR_3.skipBit();  /* COMMENT_3 */
        }
        VAR_3.skipBits(VAR_3.getBitsLeft() % 8);  /* COMMENT_4 */
    }
    std::vector<int> VAR_8;
    VAR_8.resize(VAR_1);

    for (int VAR_7 = VAR_1 - 1; VAR_7 >= 0; VAR_7--) VAR_8[VAR_7] = VAR_3.getBit();

    VAR_3.skipBits(VAR_3.getBitsLeft() % 8);  /* COMMENT_5 */

    for (int VAR_7 = VAR_1 - 1; VAR_7 >= 0; VAR_7--)
        if (VAR_8[VAR_7])
            VAR_3.skipBits(8);  /* COMMENT_6 */
    if (VAR_0)
    {
        int VAR_9 = VAR_3.getBits(8);
        for (int VAR_7 = 0; VAR_7 < VAR_9; VAR_7++) VAR_3.skipBits(32);  /* COMMENT_7 */
    }
}",justdan96/tsMuxer/5b8fdee725f8b4b2f8c5dd23da6bc1c05ee7a8f9/vvc.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,7 +15,8 @@
             m_reader.skipBits(32);
             m_reader.skipBits(32);
             m_reader.skipBits(7);
-            m_reader.skipBits(m_reader.getBits(8));  // gci_reserved_zero_bit[i]
+            int gci_num_reserved_bits = m_reader.getBits(8);
+            for (int i = 0; i < gci_num_reserved_bits; i++) m_reader.skipBit();  // gci_reserved_zero_bit[i]
         }
         m_reader.skipBits(m_reader.getBitsLeft() % 8);  // gci_alignment_zero_bit
     }","{'deleted_lines': ['            m_reader.skipBits(m_reader.getBits(8));  // gci_reserved_zero_bit[i]'], 'added_lines': ['            int gci_num_reserved_bits = m_reader.getBits(8);', '            for (int i = 0; i < gci_num_reserved_bits; i++) m_reader.skipBit();  // gci_reserved_zero_bit[i]']}",True,There is an Assertion `num <= INT_BIT' failed at BitStreamReader::skipBits in /bitStream.h:132 of tsMuxer git-c6a0277.,5.5,MEDIUM,1,test,2021-10-19T11:56:33Z,3
CVE-2021-44081,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,open5gs,"[AMF] fix the crash when long MSIN length (#1206)

When the UE is in initially registered period,
if the length of MSIN(Part of SUPI) exceeds the normal length,
AMF stack smashing will be caused",c0f695525088486c509f37a02ff1fda211b141bb,https://github.com/open5gs/open5gs/commit/c0f695525088486c509f37a02ff1fda211b141bb,lib/nas/5gs/conv.c,ogs_nas_5gs_suci_from_mobile_identity,"char *ogs_nas_5gs_suci_from_mobile_identity(
ogs_nas_5gs_mobile_identity_t *mobile_identity)
{
ogs_nas_5gs_mobile_identity_suci_t *mobile_identity_suci = NULL;
ogs_plmn_id_t plmn_id;
char tmp[OGS_MAX_IMSI_BCD_LEN+1];
char routing_indicator[5];
char *suci = NULL;
ogs_assert(mobile_identity);
mobile_identity_suci =
(ogs_nas_5gs_mobile_identity_suci_t *)mobile_identity->buffer;
ogs_assert(mobile_identity_suci);
ogs_expect_or_return_val(mobile_identity_suci->h.supi_format ==
OGS_NAS_5GS_SUPI_FORMAT_IMSI, NULL);
ogs_expect_or_return_val(mobile_identity_suci->protection_scheme_id ==
OGS_NAS_5GS_NULL_SCHEME, NULL);
suci = ogs_msprintf(""suci-%d-"", mobile_identity_suci->h.supi_format);
ogs_expect_or_return_val(suci, NULL);
ogs_nas_to_plmn_id(&plmn_id, &mobile_identity_suci->nas_plmn_id);
if (ogs_plmn_id_mnc_len(&plmn_id) == 2) {
suci = ogs_mstrcatf(suci, ""%03d-%02d-"",
ogs_plmn_id_mcc(&plmn_id), ogs_plmn_id_mnc(&plmn_id));
ogs_expect_or_return_val(suci, NULL);
} else {
suci = ogs_mstrcatf(suci, ""%03d-%03d-"",
ogs_plmn_id_mcc(&plmn_id), ogs_plmn_id_mnc(&plmn_id));
ogs_expect_or_return_val(suci, NULL);
}
memset(routing_indicator, 0, sizeof(routing_indicator));
if (mobile_identity_suci->routing_indicator1 != 0xf) {
routing_indicator[0] =
mobile_identity_suci->routing_indicator1 + '0';
if (mobile_identity_suci->routing_indicator2 != 0xf) {
routing_indicator[1] =
mobile_identity_suci->routing_indicator2 + '0';
if (mobile_identity_suci->routing_indicator3 != 0xf) {
routing_indicator[2] =
mobile_identity_suci->routing_indicator3 + '0';
if (mobile_identity_suci->routing_indicator4 != 0xf)
routing_indicator[3] =
mobile_identity_suci->routing_indicator4 + '0';
}
}
}
ogs_expect_or_return_val(mobile_identity->length > 8, NULL);
ogs_buffer_to_bcd(mobile_identity_suci->scheme_output,
mobile_identity->length - 8, tmp);
suci = ogs_mstrcatf(suci, ""%s-%d-%d-%s"",
routing_indicator,
mobile_identity_suci->protection_scheme_id,
mobile_identity_suci->home_network_pki_value,
tmp);
ogs_expect(suci);
return suci;
}","char *ogs_nas_5gs_suci_from_mobile_identity(
ogs_nas_5gs_mobile_identity_t *VAR_0)
{
ogs_nas_5gs_mobile_identity_suci_t *VAR_1 = NULL;
ogs_plmn_id_t VAR_2;
char VAR_3[VAR_4+1];
char VAR_5[5];
char *VAR_6 = NULL;
ogs_assert(VAR_0);
VAR_1 =
(ogs_nas_5gs_mobile_identity_suci_t *)VAR_0->buffer;
ogs_assert(VAR_1);
ogs_expect_or_return_val(VAR_1->h.supi_format ==
VAR_7, NULL);
ogs_expect_or_return_val(VAR_1->protection_scheme_id ==
VAR_8, NULL);
VAR_6 = ogs_msprintf(""suci-%d-"", VAR_1->h.supi_format);
ogs_expect_or_return_val(VAR_6, NULL);
ogs_nas_to_plmn_id(&VAR_2, &VAR_1->nas_plmn_id);
if (ogs_plmn_id_mnc_len(&VAR_2) == 2) {
VAR_6 = ogs_mstrcatf(VAR_6, ""%03d-%02d-"",
ogs_plmn_id_mcc(&VAR_2), ogs_plmn_id_mnc(&VAR_2));
ogs_expect_or_return_val(VAR_6, NULL);
} else {
VAR_6 = ogs_mstrcatf(VAR_6, ""%03d-%03d-"",
ogs_plmn_id_mcc(&VAR_2), ogs_plmn_id_mnc(&VAR_2));
ogs_expect_or_return_val(VAR_6, NULL);
}
memset(VAR_5, 0, sizeof(VAR_5));
if (VAR_1->routing_indicator1 != 0xf) {
VAR_5[0] =
VAR_1->routing_indicator1 + '0';
if (VAR_1->routing_indicator2 != 0xf) {
VAR_5[1] =
VAR_1->routing_indicator2 + '0';
if (VAR_1->routing_indicator3 != 0xf) {
VAR_5[2] =
VAR_1->routing_indicator3 + '0';
if (VAR_1->routing_indicator4 != 0xf)
VAR_5[3] =
VAR_1->routing_indicator4 + '0';
}
}
}
ogs_expect_or_return_val(VAR_0->length > 8, NULL);
ogs_buffer_to_bcd(VAR_1->scheme_output,
VAR_0->length - 8, VAR_3);
VAR_6 = ogs_mstrcatf(VAR_6, ""%s-%d-%d-%s"",
VAR_5,
VAR_1->protection_scheme_id,
VAR_1->home_network_pki_value,
VAR_3);
ogs_expect(VAR_6);
return VAR_6;
}",open5gs/c0f695525088486c509f37a02ff1fda211b141bb/conv.c/vul/before/0.json,"char *ogs_nas_5gs_suci_from_mobile_identity(
        ogs_nas_5gs_mobile_identity_t *mobile_identity)
{
    ogs_nas_5gs_mobile_identity_suci_t *mobile_identity_suci = NULL;
    ogs_plmn_id_t plmn_id;
    char tmp[OGS_NAS_MAX_SCHEME_OUTPUT_LEN*2+1];
    char routing_indicator[5];
    char *suci = NULL;
    int scheme_output_len = 0;

    ogs_assert(mobile_identity);

    mobile_identity_suci =
        (ogs_nas_5gs_mobile_identity_suci_t *)mobile_identity->buffer;
    ogs_assert(mobile_identity_suci);

    ogs_expect_or_return_val(mobile_identity_suci->h.supi_format ==
            OGS_NAS_5GS_SUPI_FORMAT_IMSI, NULL);
    ogs_expect_or_return_val(mobile_identity_suci->protection_scheme_id ==
            OGS_NAS_5GS_NULL_SCHEME, NULL);

    suci = ogs_msprintf(""suci-%d-"", mobile_identity_suci->h.supi_format);
    ogs_expect_or_return_val(suci, NULL);

    ogs_nas_to_plmn_id(&plmn_id, &mobile_identity_suci->nas_plmn_id);
    if (ogs_plmn_id_mnc_len(&plmn_id) == 2) {
        suci = ogs_mstrcatf(suci, ""%03d-%02d-"",
                ogs_plmn_id_mcc(&plmn_id), ogs_plmn_id_mnc(&plmn_id));
        ogs_expect_or_return_val(suci, NULL);
    } else {
        suci = ogs_mstrcatf(suci, ""%03d-%03d-"",
                ogs_plmn_id_mcc(&plmn_id), ogs_plmn_id_mnc(&plmn_id));
        ogs_expect_or_return_val(suci, NULL);
    }

    memset(routing_indicator, 0, sizeof(routing_indicator));
    if (mobile_identity_suci->routing_indicator1 != 0xf) {
        routing_indicator[0] =
            mobile_identity_suci->routing_indicator1 + '0';
        if (mobile_identity_suci->routing_indicator2 != 0xf) {
            routing_indicator[1] =
                mobile_identity_suci->routing_indicator2 + '0';
            if (mobile_identity_suci->routing_indicator3 != 0xf) {
                routing_indicator[2] =
                    mobile_identity_suci->routing_indicator3 + '0';
                if (mobile_identity_suci->routing_indicator4 != 0xf)
                    routing_indicator[3] =
                        mobile_identity_suci->routing_indicator4 + '0';
            }
        }
    }

    scheme_output_len = mobile_identity->length - 8;
    ogs_expect_or_return_val(scheme_output_len > 0, NULL);
    ogs_expect_or_return_val(
            scheme_output_len <= OGS_NAS_MAX_SCHEME_OUTPUT_LEN, NULL);
    ogs_buffer_to_bcd(mobile_identity_suci->scheme_output,
            scheme_output_len, tmp);

    suci = ogs_mstrcatf(suci, ""%s-%d-%d-%s"",
            routing_indicator,
            mobile_identity_suci->protection_scheme_id,
            mobile_identity_suci->home_network_pki_value,
            tmp);
    ogs_expect(suci);

    return suci;
}","char *ogs_nas_5gs_suci_from_mobile_identity(
        ogs_nas_5gs_mobile_identity_t *VAR_0)
{
    ogs_nas_5gs_mobile_identity_suci_t *VAR_1 = NULL;
    ogs_plmn_id_t VAR_2;
    char VAR_3[VAR_4*2+1];
    char VAR_5[5];
    char *VAR_6 = NULL;
    int VAR_7 = 0;

    ogs_assert(VAR_0);

    VAR_1 =
        (ogs_nas_5gs_mobile_identity_suci_t *)VAR_0->buffer;
    ogs_assert(VAR_1);

    ogs_expect_or_return_val(VAR_1->h.supi_format ==
            VAR_8, NULL);
    ogs_expect_or_return_val(VAR_1->protection_scheme_id ==
            VAR_9, NULL);

    VAR_6 = ogs_msprintf(""suci-%d-"", VAR_1->h.supi_format);
    ogs_expect_or_return_val(VAR_6, NULL);

    ogs_nas_to_plmn_id(&VAR_2, &VAR_1->nas_plmn_id);
    if (ogs_plmn_id_mnc_len(&VAR_2) == 2) {
        VAR_6 = ogs_mstrcatf(VAR_6, ""%03d-%02d-"",
                ogs_plmn_id_mcc(&VAR_2), ogs_plmn_id_mnc(&VAR_2));
        ogs_expect_or_return_val(VAR_6, NULL);
    } else {
        VAR_6 = ogs_mstrcatf(VAR_6, ""%03d-%03d-"",
                ogs_plmn_id_mcc(&VAR_2), ogs_plmn_id_mnc(&VAR_2));
        ogs_expect_or_return_val(VAR_6, NULL);
    }

    memset(VAR_5, 0, sizeof(VAR_5));
    if (VAR_1->routing_indicator1 != 0xf) {
        VAR_5[0] =
            VAR_1->routing_indicator1 + '0';
        if (VAR_1->routing_indicator2 != 0xf) {
            VAR_5[1] =
                VAR_1->routing_indicator2 + '0';
            if (VAR_1->routing_indicator3 != 0xf) {
                VAR_5[2] =
                    VAR_1->routing_indicator3 + '0';
                if (VAR_1->routing_indicator4 != 0xf)
                    VAR_5[3] =
                        VAR_1->routing_indicator4 + '0';
            }
        }
    }

    VAR_7 = VAR_0->length - 8;
    ogs_expect_or_return_val(VAR_7 > 0, NULL);
    ogs_expect_or_return_val(
            VAR_7 <= VAR_4, NULL);
    ogs_buffer_to_bcd(VAR_1->scheme_output,
            VAR_7, VAR_3);

    VAR_6 = ogs_mstrcatf(VAR_6, ""%s-%d-%d-%s"",
            VAR_5,
            VAR_1->protection_scheme_id,
            VAR_1->home_network_pki_value,
            VAR_3);
    ogs_expect(VAR_6);

    return VAR_6;
}",open5gs/c0f695525088486c509f37a02ff1fda211b141bb/conv.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,9 +3,10 @@
 {
     ogs_nas_5gs_mobile_identity_suci_t *mobile_identity_suci = NULL;
     ogs_plmn_id_t plmn_id;
-    char tmp[OGS_MAX_IMSI_BCD_LEN+1];
+    char tmp[OGS_NAS_MAX_SCHEME_OUTPUT_LEN*2+1];
     char routing_indicator[5];
     char *suci = NULL;
+    int scheme_output_len = 0;
 
     ogs_assert(mobile_identity);
 
@@ -49,9 +50,12 @@
         }
     }
 
-    ogs_expect_or_return_val(mobile_identity->length > 8, NULL);
+    scheme_output_len = mobile_identity->length - 8;
+    ogs_expect_or_return_val(scheme_output_len > 0, NULL);
+    ogs_expect_or_return_val(
+            scheme_output_len <= OGS_NAS_MAX_SCHEME_OUTPUT_LEN, NULL);
     ogs_buffer_to_bcd(mobile_identity_suci->scheme_output,
-            mobile_identity->length - 8, tmp);
+            scheme_output_len, tmp);
 
     suci = ogs_mstrcatf(suci, ""%s-%d-%d-%s"",
             routing_indicator,","{'deleted_lines': ['    char tmp[OGS_MAX_IMSI_BCD_LEN+1];', '    ogs_expect_or_return_val(mobile_identity->length > 8, NULL);', '            mobile_identity->length - 8, tmp);'], 'added_lines': ['    char tmp[OGS_NAS_MAX_SCHEME_OUTPUT_LEN*2+1];', '    int scheme_output_len = 0;', '    scheme_output_len = mobile_identity->length - 8;', '    ogs_expect_or_return_val(scheme_output_len > 0, NULL);', '    ogs_expect_or_return_val(', '            scheme_output_len <= OGS_NAS_MAX_SCHEME_OUTPUT_LEN, NULL);', '            scheme_output_len, tmp);']}",True,"A buffer overflow vulnerability exists in the AMF of open5gs 2.1.4. When the length of MSIN in Supi exceeds 24 characters, it leads to AMF denial of service.",7.5,HIGH,2,test,2021-10-19T12:21:12Z,3
CVE-2021-42073,['CWE-384'],AV:N/AC:M/Au:N/C:P/I:P/A:N,0,debauchee/barrier,"Implement client identity verification

This commit fixes two security vulnerabilities: CVE-2021-42072 and
CVE-2021-42073.

The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",229abab99f39f11624e5651f819e7f1f8eddedcc,https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc,src/lib/client/Client.cpp,Client::connect,"void
Client::connect()
{
if (m_stream != NULL) {
return;
}
if (m_suspended) {
m_connectOnResume = true;
return;
}
auto security_level = ConnectionSecurityLevel::PLAINTEXT;
if (m_useSecureNetwork) {
security_level = ConnectionSecurityLevel::ENCRYPTED;
}
try {
m_serverAddress.resolve();
if (m_serverAddress.getAddress() != NULL) {
LOG((CLOG_NOTE ""connecting to '%s': %s:%i"",
m_serverAddress.getHostname().c_str(),
ARCH->addrToString(m_serverAddress.getAddress()).c_str(),
m_serverAddress.getPort()));
}
IDataSocket* socket = m_socketFactory->create(ARCH->getAddrFamily(m_serverAddress.getAddress()),
security_level);
m_socket = dynamic_cast<TCPSocket*>(socket);
m_stream = socket;
m_stream = new PacketStreamFilter(m_events, m_stream, true);
LOG((CLOG_DEBUG1 ""connecting to server""));
setupConnecting();
setupTimer();
socket->connect(m_serverAddress);
}
catch (XBase& e) {
cleanupTimer();
cleanupConnecting();
cleanupStream();
LOG((CLOG_DEBUG1 ""connection failed""));
sendConnectionFailedEvent(e.what());
return;
}
}","void
Client::connect()
{
if (VAR_0 != NULL) {
return;
}
if (VAR_1) {
VAR_2 = true;
return;
}
auto VAR_3 = ConnectionSecurityLevel::PLAINTEXT;
if (VAR_4) {
VAR_3 = ConnectionSecurityLevel::ENCRYPTED;
}
try {
VAR_5.resolve();
if (VAR_5.getAddress() != NULL) {
LOG((VAR_6 ""connecting to '%s': %s:%i"",
VAR_5.getHostname().c_str(),
VAR_7->addrToString(VAR_5.getAddress()).c_str(),
VAR_5.getPort()));
}
IDataSocket* VAR_8 = VAR_9->create(VAR_7->getAddrFamily(VAR_5.getAddress()),
VAR_3);
VAR_10 = VAR_11<TCPSocket*>(VAR_8);
VAR_0 = VAR_8;
VAR_0 = new PacketStreamFilter(VAR_12, VAR_0, true);
LOG((VAR_13 ""connecting to server""));
setupConnecting();
setupTimer();
VAR_8->connect(VAR_5);
}
catch (XBase& VAR_14) {
cleanupTimer();
cleanupConnecting();
cleanupStream();
LOG((VAR_13 ""connection failed""));
sendConnectionFailedEvent(VAR_14.what());
return;
}
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/Client.cpp/vul/before/0.json,"void
Client::connect()
{
    if (m_stream != NULL) {
        return;
    }
    if (m_suspended) {
        m_connectOnResume = true;
        return;
    }

    auto security_level = ConnectionSecurityLevel::PLAINTEXT;
    if (m_useSecureNetwork) {
        // client always authenticates server
        security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;
    }

    try {
        // resolve the server hostname.  do this every time we connect
        // in case we couldn't resolve the address earlier or the address
        // has changed (which can happen frequently if this is a laptop
        // being shuttled between various networks).  patch by Brent
        // Priddy.
        m_serverAddress.resolve();

        // m_serverAddress will be null if the hostname address is not reolved
        if (m_serverAddress.getAddress() != NULL) {
          // to help users troubleshoot, show server host name (issue: 60)
          LOG((CLOG_NOTE ""connecting to '%s': %s:%i"",
          m_serverAddress.getHostname().c_str(),
          ARCH->addrToString(m_serverAddress.getAddress()).c_str(),
          m_serverAddress.getPort()));
        }

        // create the socket
        IDataSocket* socket = m_socketFactory->create(ARCH->getAddrFamily(m_serverAddress.getAddress()),
                                                      security_level);
        m_socket = dynamic_cast<TCPSocket*>(socket);

        // filter socket messages, including a packetizing filter
        m_stream = socket;
        m_stream = new PacketStreamFilter(m_events, m_stream, true);

        // connect
        LOG((CLOG_DEBUG1 ""connecting to server""));
        setupConnecting();
        setupTimer();
        socket->connect(m_serverAddress);
    }
    catch (XBase& e) {
        cleanupTimer();
        cleanupConnecting();
        cleanupStream();
        LOG((CLOG_DEBUG1 ""connection failed""));
        sendConnectionFailedEvent(e.what());
        return;
    }
}","void
Client::connect()
{
    if (VAR_0 != NULL) {
        return;
    }
    if (VAR_1) {
        VAR_2 = true;
        return;
    }

    auto VAR_3 = ConnectionSecurityLevel::PLAINTEXT;
    if (VAR_4) {
        /* COMMENT_0 */
        VAR_3 = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;
    }

    try {
        /* COMMENT_1 */
        /* COMMENT_2 */
        /* COMMENT_3 */
        /* COMMENT_4 */
        /* COMMENT_5 */
        VAR_5.resolve();

        /* COMMENT_6 */
        if (VAR_5.getAddress() != NULL) {
          /* COMMENT_7 */
          LOG((VAR_6 ""connecting to '%s': %s:%i"",
          VAR_5.getHostname().c_str(),
          VAR_7->addrToString(VAR_5.getAddress()).c_str(),
          VAR_5.getPort()));
        }

        /* COMMENT_8 */
        IDataSocket* VAR_8 = VAR_9->create(VAR_7->getAddrFamily(VAR_5.getAddress()),
                                                      VAR_3);
        VAR_10 = VAR_11<TCPSocket*>(VAR_8);

        /* COMMENT_9 */
        VAR_0 = VAR_8;
        VAR_0 = new PacketStreamFilter(VAR_12, VAR_0, true);

        /* COMMENT_10 */
        LOG((VAR_13 ""connecting to server""));
        setupConnecting();
        setupTimer();
        VAR_8->connect(VAR_5);
    }
    catch (XBase& VAR_14) {
        cleanupTimer();
        cleanupConnecting();
        cleanupStream();
        LOG((VAR_13 ""connection failed""));
        sendConnectionFailedEvent(VAR_14.what());
        return;
    }
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/Client.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,7 +11,8 @@
 
     auto security_level = ConnectionSecurityLevel::PLAINTEXT;
     if (m_useSecureNetwork) {
-        security_level = ConnectionSecurityLevel::ENCRYPTED;
+        // client always authenticates server
+        security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;
     }
 
     try {","{'deleted_lines': ['        security_level = ConnectionSecurityLevel::ENCRYPTED;'], 'added_lines': ['        // client always authenticates server', '        security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;']}",True,"An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is ""Unnamed"" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",8.2,HIGH,2,test,2021-11-01T02:50:15Z,3
CVE-2021-42073,['CWE-384'],AV:N/AC:M/Au:N/C:P/I:P/A:N,0,debauchee/barrier,"Implement client identity verification

This commit fixes two security vulnerabilities: CVE-2021-42072 and
CVE-2021-42073.

The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",229abab99f39f11624e5651f819e7f1f8eddedcc,https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc,src/gui/src/MainWindow.cpp,MainWindow::serverArgs,"bool MainWindow::serverArgs(QStringList& args, QString& app)
{
app = appPath(appConfig().barriersName());
if (!QFile::exists(app))
{
QMessageBox::warning(this, tr(""Barrier server not found""),
tr(""The executable for the barrier server does not exist.""));
return false;
}
#if defined(Q_OS_WIN)
app = QString(""\""%1\"""").arg(app);
#endif
if (appConfig().logToFile())
{
appConfig().persistLogDir();
args << ""--log"" << appConfig().logFilenameCmd();
}
QString configFilename = this->configFilename();
#if defined(Q_OS_WIN)
configFilename = QString(""\""%1\"""").arg(configFilename);
#endif
args << ""-c"" << configFilename << ""--address"" << address();
return true;
}","bool MainWindow::serverArgs(QStringList& VAR_0, QString& VAR_1)
{
VAR_1 = appPath(appConfig().barriersName());
if (!QFile::exists(VAR_1))
{
QMessageBox::warning(this, tr(""Barrier server not found""),
tr(""The executable for the barrier server does not exist.""));
return false;
}
#if defined(VAR_2)
VAR_1 = QString(""\""%1\"""").arg(VAR_1);
#endif
if (appConfig().logToFile())
{
appConfig().persistLogDir();
VAR_0 << ""--log"" << appConfig().logFilenameCmd();
}
QString VAR_3 = this->configFilename();
#if defined(VAR_2)
VAR_3 = QString(""\""%1\"""").arg(VAR_3);
#endif
VAR_0 << ""-c"" << VAR_3 << ""--address"" << address();
return true;
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/MainWindow.cpp/vul/before/0.json,"bool MainWindow::serverArgs(QStringList& args, QString& app)
{
    app = appPath(appConfig().barriersName());

    if (!QFile::exists(app))
    {
        QMessageBox::warning(this, tr(""Barrier server not found""),
                             tr(""The executable for the barrier server does not exist.""));
        return false;
    }

#if defined(Q_OS_WIN)
    // wrap in quotes so a malicious user can't start \Program.exe as admin.
    app = QString(""\""%1\"""").arg(app);
#endif

    if (appConfig().logToFile())
    {
        appConfig().persistLogDir();

        args << ""--log"" << appConfig().logFilenameCmd();
    }

    if (!appConfig().getRequireClientCertificate()) {
        args << ""--disable-client-cert-checking"";
    }

    QString configFilename = this->configFilename();
#if defined(Q_OS_WIN)
    // wrap in quotes in case username contains spaces.
    configFilename = QString(""\""%1\"""").arg(configFilename);
#endif
    args << ""-c"" << configFilename << ""--address"" << address();

    return true;
}","bool MainWindow::serverArgs(QStringList& VAR_0, QString& VAR_1)
{
    VAR_1 = appPath(appConfig().barriersName());

    if (!QFile::exists(VAR_1))
    {
        QMessageBox::warning(this, tr(""Barrier server not found""),
                             tr(""The executable for the barrier server does not exist.""));
        return false;
    }

#if defined(VAR_2)
    /* COMMENT_0 */
    VAR_1 = QString(""\""%1\"""").arg(VAR_1);
#endif

    if (appConfig().logToFile())
    {
        appConfig().persistLogDir();

        VAR_0 << ""--log"" << appConfig().logFilenameCmd();
    }

    if (!appConfig().getRequireClientCertificate()) {
        VAR_0 << ""--disable-client-cert-checking"";
    }

    QString VAR_3 = this->configFilename();
#if defined(VAR_2)
    /* COMMENT_1 */
    VAR_3 = QString(""\""%1\"""").arg(VAR_3);
#endif
    VAR_0 << ""-c"" << VAR_3 << ""--address"" << address();

    return true;
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/MainWindow.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,6 +21,10 @@
         args << ""--log"" << appConfig().logFilenameCmd();
     }
 
+    if (!appConfig().getRequireClientCertificate()) {
+        args << ""--disable-client-cert-checking"";
+    }
+
     QString configFilename = this->configFilename();
 #if defined(Q_OS_WIN)
     // wrap in quotes in case username contains spaces.","{'deleted_lines': [], 'added_lines': ['    if (!appConfig().getRequireClientCertificate()) {', '        args << ""--disable-client-cert-checking"";', '    }', '']}",True,"An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is ""Unnamed"" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",8.2,HIGH,2,test,2021-11-01T02:50:15Z,3
CVE-2021-42073,['CWE-384'],AV:N/AC:M/Au:N/C:P/I:P/A:N,0,debauchee/barrier,"Implement client identity verification

This commit fixes two security vulnerabilities: CVE-2021-42072 and
CVE-2021-42073.

The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",229abab99f39f11624e5651f819e7f1f8eddedcc,https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc,src/gui/src/MainWindow.cpp,MainWindow::checkFingerprint,"void MainWindow::checkFingerprint(const QString& line)
{
QRegExp fingerprintRegex("".*server fingerprint \\(SHA1\\): ([A-F0-9:]+) \\(SHA256\\): ([A-F0-9:]+)"");
if (!fingerprintRegex.exactMatch(line)) {
return;
}
barrier::FingerprintData fingerprint_sha1 = {
barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA1),
barrier::string::from_hex(fingerprintRegex.cap(1).toStdString())
};
barrier::FingerprintData fingerprint_sha256 = {
barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA256),
barrier::string::from_hex(fingerprintRegex.cap(2).toStdString())
};
auto db_path = barrier::DataDirectories::trusted_servers_ssl_fingerprints_path();
auto db_dir = db_path.parent_path();
if (!barrier::fs::exists(db_dir)) {
barrier::fs::create_directories(db_dir);
}
barrier::FingerprintDatabase db;
db.read(db_path);
if (db.is_trusted(fingerprint_sha256)) {
return;
}
static bool messageBoxAlreadyShown = false;
if (!messageBoxAlreadyShown) {
stopBarrier();
messageBoxAlreadyShown = true;
QMessageBox::StandardButton fingerprintReply =
QMessageBox::information(
this, tr(""Security question""),
tr(""Do you trust this fingerprint?\n\n""
""SHA256:\n""
""%1\n""
""%2\n\n""
""SHA1 (obsolete, when using old Barrier server):\n""
""%3\n\n""
""This is a server fingerprint. You should compare this ""
""fingerprint to the one on your server's screen. If the ""
""two don't match exactly, then it's probably not the server ""
""you're expecting (it could be a malicious user).\n\n""
""To automatically trust this fingerprint for future ""
""connections, click Yes. To reject this fingerprint and ""
""disconnect from the server, click No."")
.arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))
.arg(QString::fromStdString(
barrier::create_fingerprint_randomart(fingerprint_sha256.data)))
.arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data))),
QMessageBox::Yes | QMessageBox::No);
if (fingerprintReply == QMessageBox::Yes) {
db.add_trusted(fingerprint_sha256);
db.write(db_path);
startBarrier();
}
messageBoxAlreadyShown = false;
}
}","void MainWindow::checkFingerprint(const QString& VAR_0)
{
QRegExp VAR_1("".*server fingerprint \\(SHA1\\): ([A-F0-9:]+) \\(SHA256\\): ([A-F0-9:]+)"");
if (!VAR_1.exactMatch(VAR_0)) {
return;
}
barrier::FingerprintData VAR_2 = {
barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA1),
barrier::string::from_hex(VAR_1.cap(1).toStdString())
};
barrier::FingerprintData VAR_3 = {
barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA256),
barrier::string::from_hex(VAR_1.cap(2).toStdString())
};
auto VAR_4 = barrier::DataDirectories::trusted_servers_ssl_fingerprints_path();
auto VAR_5 = VAR_4.parent_path();
if (!barrier::fs::exists(VAR_5)) {
barrier::fs::create_directories(VAR_5);
}
barrier::FingerprintDatabase VAR_6;
VAR_6.read(VAR_4);
if (VAR_6.is_trusted(VAR_3)) {
return;
}
static bool VAR_7 = false;
if (!VAR_7) {
stopBarrier();
VAR_7 = true;
QMessageBox::StandardButton VAR_8 =
QMessageBox::information(
this, tr(""Security question""),
tr(""Do you trust this fingerprint?\n\n""
""SHA256:\n""
""%1\n""
""%2\n\n""
""SHA1 (obsolete, when using old Barrier server):\n""
""%3\n\n""
""This is a server fingerprint. You should compare this ""
""fingerprint to the one on your server's screen. If the ""
""two don't match exactly, then it's probably not the server ""
""you're expecting (it could be a malicious user).\n\n""
""To automatically trust this fingerprint for future ""
""connections, click Yes. To reject this fingerprint and ""
""disconnect from the server, click No."")
.arg(QString::fromStdString(barrier::format_ssl_fingerprint(VAR_3.data)))
.arg(QString::fromStdString(
barrier::create_fingerprint_randomart(VAR_3.data)))
.arg(QString::fromStdString(barrier::format_ssl_fingerprint(VAR_2.data))),
QMessageBox::Yes | QMessageBox::No);
if (VAR_8 == QMessageBox::Yes) {
VAR_6.add_trusted(VAR_3);
VAR_6.write(VAR_4);
startBarrier();
}
VAR_7 = false;
}
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/MainWindow.cpp/vul/before/1.json,"void MainWindow::checkFingerprint(const QString& line)
{
    QRegExp fingerprintRegex("".*peer fingerprint \\(SHA1\\): ([A-F0-9:]+) \\(SHA256\\): ([A-F0-9:]+)"");
    if (!fingerprintRegex.exactMatch(line)) {
        return;
    }

    barrier::FingerprintData fingerprint_sha1 = {
        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA1),
        barrier::string::from_hex(fingerprintRegex.cap(1).toStdString())
    };

    barrier::FingerprintData fingerprint_sha256 = {
        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA256),
        barrier::string::from_hex(fingerprintRegex.cap(2).toStdString())
    };

    bool is_client = barrierType() == barrierClient;

    auto db_path = is_client
            ? barrier::DataDirectories::trusted_servers_ssl_fingerprints_path()
            : barrier::DataDirectories::trusted_clients_ssl_fingerprints_path();

    auto db_dir = db_path.parent_path();
    if (!barrier::fs::exists(db_dir)) {
        barrier::fs::create_directories(db_dir);
    }

    // We compare only SHA256 fingerprints, but show both SHA1 and SHA256 so that the users can
    // still verify fingerprints on old Barrier servers. This way the only time when we are exposed
    // to SHA1 vulnerabilities is when the user is reconnecting again.
    barrier::FingerprintDatabase db;
    db.read(db_path);
    if (db.is_trusted(fingerprint_sha256)) {
        return;
    }

    static bool messageBoxAlreadyShown = false;

    if (!messageBoxAlreadyShown) {
        if (is_client) {
            stopBarrier();
        }

        QString message;
        if (is_client) {
            message = tr(""Do you trust this fingerprint?\n\n""
               ""SHA256:\n""
               ""%1\n""
               ""%2\n\n""
               ""SHA1 (obsolete, when using old Barrier client):\n""
               ""%3\n\n""
               ""This is a server fingerprint. You should compare this ""
               ""fingerprint to the one on your server's screen. If the ""
               ""two don't match exactly, then it's probably not the server ""
               ""you're expecting (it could be a malicious user).\n\n""
               ""To automatically trust this fingerprint for future ""
               ""connections, click Yes. To reject this fingerprint and ""
               ""disconnect from the server, click No."")
            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))
            .arg(QString::fromStdString(
                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)))
            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data)));
        } else {
            message = tr(""Do you trust this fingerprint?\n\n""
               ""SHA256:\n""
               ""%1\n""
               ""%2\n\n""
               ""This is a client fingerprint. You should compare this ""
               ""fingerprint to the one on your client's screen. If the ""
               ""two don't match exactly, then it's probably not the client ""
               ""you're expecting (it could be a malicious user).\n\n""
               ""To automatically trust this fingerprint for future ""
               ""connections, click Yes. To reject this fingerprint and ""
               ""disconnect the client, click No."")
            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))
            .arg(QString::fromStdString(
                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)));
        }

        messageBoxAlreadyShown = true;
        QMessageBox::StandardButton fingerprintReply =
            QMessageBox::information(
            this, tr(""Security question""),
            message,
            QMessageBox::Yes | QMessageBox::No);

        if (fingerprintReply == QMessageBox::Yes) {
            // restart core process after trusting fingerprint.
            db.add_trusted(fingerprint_sha256);
            db.write(db_path);
            if (is_client) {
                startBarrier();
            }
        }

        messageBoxAlreadyShown = false;
    }
}","void MainWindow::checkFingerprint(const QString& VAR_0)
{
    QRegExp VAR_1("".*peer fingerprint \\(SHA1\\): ([A-F0-9:]+) \\(SHA256\\): ([A-F0-9:]+)"");
    if (!VAR_1.exactMatch(VAR_0)) {
        return;
    }

    barrier::FingerprintData VAR_2 = {
        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA1),
        barrier::string::from_hex(VAR_1.cap(1).toStdString())
    };

    barrier::FingerprintData VAR_3 = {
        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA256),
        barrier::string::from_hex(VAR_1.cap(2).toStdString())
    };

    bool VAR_4 = barrierType() == VAR_5;

    auto VAR_6 = VAR_4
            ? barrier::DataDirectories::trusted_servers_ssl_fingerprints_path()
            : barrier::DataDirectories::trusted_clients_ssl_fingerprints_path();

    auto VAR_7 = VAR_6.parent_path();
    if (!barrier::fs::exists(VAR_7)) {
        barrier::fs::create_directories(VAR_7);
    }

    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    barrier::FingerprintDatabase VAR_8;
    VAR_8.read(VAR_6);
    if (VAR_8.is_trusted(VAR_3)) {
        return;
    }

    static bool VAR_9 = false;

    if (!VAR_9) {
        if (VAR_4) {
            stopBarrier();
        }

        QString VAR_10;
        if (VAR_4) {
            VAR_10 = tr(""Do you trust this fingerprint?\n\n""
               ""SHA256:\n""
               ""%1\n""
               ""%2\n\n""
               ""SHA1 (obsolete, when using old Barrier client):\n""
               ""%3\n\n""
               ""This is a server fingerprint. You should compare this ""
               ""fingerprint to the one on your server's screen. If the ""
               ""two don't match exactly, then it's probably not the server ""
               ""you're expecting (it could be a malicious user).\n\n""
               ""To automatically trust this fingerprint for future ""
               ""connections, click Yes. To reject this fingerprint and ""
               ""disconnect from the server, click No."")
            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(VAR_3.data)))
            .arg(QString::fromStdString(
                     barrier::create_fingerprint_randomart(VAR_3.data)))
            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(VAR_2.data)));
        } else {
            VAR_10 = tr(""Do you trust this fingerprint?\n\n""
               ""SHA256:\n""
               ""%1\n""
               ""%2\n\n""
               ""This is a client fingerprint. You should compare this ""
               ""fingerprint to the one on your client's screen. If the ""
               ""two don't match exactly, then it's probably not the client ""
               ""you're expecting (it could be a malicious user).\n\n""
               ""To automatically trust this fingerprint for future ""
               ""connections, click Yes. To reject this fingerprint and ""
               ""disconnect the client, click No."")
            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(VAR_3.data)))
            .arg(QString::fromStdString(
                     barrier::create_fingerprint_randomart(VAR_3.data)));
        }

        VAR_9 = true;
        QMessageBox::StandardButton VAR_11 =
            QMessageBox::information(
            this, tr(""Security question""),
            VAR_10,
            QMessageBox::Yes | QMessageBox::No);

        if (VAR_11 == QMessageBox::Yes) {
            /* COMMENT_3 */
            VAR_8.add_trusted(VAR_3);
            VAR_8.write(VAR_6);
            if (VAR_4) {
                startBarrier();
            }
        }

        VAR_9 = false;
    }
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/MainWindow.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 void MainWindow::checkFingerprint(const QString& line)
 {
-    QRegExp fingerprintRegex("".*server fingerprint \\(SHA1\\): ([A-F0-9:]+) \\(SHA256\\): ([A-F0-9:]+)"");
+    QRegExp fingerprintRegex("".*peer fingerprint \\(SHA1\\): ([A-F0-9:]+) \\(SHA256\\): ([A-F0-9:]+)"");
     if (!fingerprintRegex.exactMatch(line)) {
         return;
     }
@@ -15,7 +15,11 @@
         barrier::string::from_hex(fingerprintRegex.cap(2).toStdString())
     };
 
-    auto db_path = barrier::DataDirectories::trusted_servers_ssl_fingerprints_path();
+    bool is_client = barrierType() == barrierClient;
+
+    auto db_path = is_client
+            ? barrier::DataDirectories::trusted_servers_ssl_fingerprints_path()
+            : barrier::DataDirectories::trusted_clients_ssl_fingerprints_path();
 
     auto db_dir = db_path.parent_path();
     if (!barrier::fs::exists(db_dir)) {
@@ -34,17 +38,17 @@
     static bool messageBoxAlreadyShown = false;
 
     if (!messageBoxAlreadyShown) {
-        stopBarrier();
+        if (is_client) {
+            stopBarrier();
+        }
 
-        messageBoxAlreadyShown = true;
-        QMessageBox::StandardButton fingerprintReply =
-            QMessageBox::information(
-            this, tr(""Security question""),
-            tr(""Do you trust this fingerprint?\n\n""
+        QString message;
+        if (is_client) {
+            message = tr(""Do you trust this fingerprint?\n\n""
                ""SHA256:\n""
                ""%1\n""
                ""%2\n\n""
-               ""SHA1 (obsolete, when using old Barrier server):\n""
+               ""SHA1 (obsolete, when using old Barrier client):\n""
                ""%3\n\n""
                ""This is a server fingerprint. You should compare this ""
                ""fingerprint to the one on your server's screen. If the ""
@@ -56,14 +60,38 @@
             .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))
             .arg(QString::fromStdString(
                      barrier::create_fingerprint_randomart(fingerprint_sha256.data)))
-            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data))),
+            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data)));
+        } else {
+            message = tr(""Do you trust this fingerprint?\n\n""
+               ""SHA256:\n""
+               ""%1\n""
+               ""%2\n\n""
+               ""This is a client fingerprint. You should compare this ""
+               ""fingerprint to the one on your client's screen. If the ""
+               ""two don't match exactly, then it's probably not the client ""
+               ""you're expecting (it could be a malicious user).\n\n""
+               ""To automatically trust this fingerprint for future ""
+               ""connections, click Yes. To reject this fingerprint and ""
+               ""disconnect the client, click No."")
+            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))
+            .arg(QString::fromStdString(
+                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)));
+        }
+
+        messageBoxAlreadyShown = true;
+        QMessageBox::StandardButton fingerprintReply =
+            QMessageBox::information(
+            this, tr(""Security question""),
+            message,
             QMessageBox::Yes | QMessageBox::No);
 
         if (fingerprintReply == QMessageBox::Yes) {
             // restart core process after trusting fingerprint.
             db.add_trusted(fingerprint_sha256);
             db.write(db_path);
-            startBarrier();
+            if (is_client) {
+                startBarrier();
+            }
         }
 
         messageBoxAlreadyShown = false;","{'deleted_lines': ['    QRegExp fingerprintRegex("".*server fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)"");', '    auto db_path = barrier::DataDirectories::trusted_servers_ssl_fingerprints_path();', '        stopBarrier();', '        messageBoxAlreadyShown = true;', '        QMessageBox::StandardButton fingerprintReply =', '            QMessageBox::information(', '            this, tr(""Security question""),', '            tr(""Do you trust this fingerprint?\\n\\n""', '               ""SHA1 (obsolete, when using old Barrier server):\\n""', '            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data))),', '            startBarrier();'], 'added_lines': ['    QRegExp fingerprintRegex("".*peer fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)"");', '    bool is_client = barrierType() == barrierClient;', '', '    auto db_path = is_client', '            ? barrier::DataDirectories::trusted_servers_ssl_fingerprints_path()', '            : barrier::DataDirectories::trusted_clients_ssl_fingerprints_path();', '        if (is_client) {', '            stopBarrier();', '        }', '        QString message;', '        if (is_client) {', '            message = tr(""Do you trust this fingerprint?\\n\\n""', '               ""SHA1 (obsolete, when using old Barrier client):\\n""', '            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data)));', '        } else {', '            message = tr(""Do you trust this fingerprint?\\n\\n""', '               ""SHA256:\\n""', '               ""%1\\n""', '               ""%2\\n\\n""', '               ""This is a client fingerprint. You should compare this ""', '               ""fingerprint to the one on your client\'s screen. If the ""', '               ""two don\'t match exactly, then it\'s probably not the client ""', '               ""you\'re expecting (it could be a malicious user).\\n\\n""', '               ""To automatically trust this fingerprint for future ""', '               ""connections, click Yes. To reject this fingerprint and ""', '               ""disconnect the client, click No."")', '            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))', '            .arg(QString::fromStdString(', '                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)));', '        }', '', '        messageBoxAlreadyShown = true;', '        QMessageBox::StandardButton fingerprintReply =', '            QMessageBox::information(', '            this, tr(""Security question""),', '            message,', '            if (is_client) {', '                startBarrier();', '            }']}",True,"An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is ""Unnamed"" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",8.2,HIGH,2,test,2021-11-01T02:50:15Z,3
CVE-2021-42073,['CWE-384'],AV:N/AC:M/Au:N/C:P/I:P/A:N,0,debauchee/barrier,"Implement client identity verification

This commit fixes two security vulnerabilities: CVE-2021-42072 and
CVE-2021-42073.

The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",229abab99f39f11624e5651f819e7f1f8eddedcc,https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc,src/lib/net/SecureSocket.cpp,SecureSocket::secureAccept,"int
SecureSocket::secureAccept(int socket)
{
createSSL();
SSL_set_fd(m_ssl->m_ssl, socket);
LOG((CLOG_DEBUG2 ""accepting secure socket""));
int r = SSL_accept(m_ssl->m_ssl);
static int retry;
checkResult(r, retry);
if (isFatal()) {
LOG((CLOG_ERR ""failed to accept secure socket""));
LOG((CLOG_INFO ""client connection may not be secure""));
m_secureReady = false;
ARCH->sleep(1);
retry = 0;
return -1;     }
if (retry == 0) {
m_secureReady = true;
LOG((CLOG_INFO ""accepted secure socket""));
if (CLOG->getFilter() >= kDEBUG1) {
showSecureCipherInfo();
}
showSecureConnectInfo();
return 1;
}
if (retry > 0) {
LOG((CLOG_DEBUG2 ""retry accepting secure socket""));
m_secureReady = false;
ARCH->sleep(s_retryDelay);
return 0;
}
LOG((CLOG_ERR ""unexpected state attempting to accept connection""));
return -1;
}","int
SecureSocket::secureAccept(int VAR_0)
{
createSSL();
SSL_set_fd(VAR_1->m_ssl, VAR_0);
LOG((VAR_2 ""accepting secure socket""));
int VAR_3 = SSL_accept(VAR_1->m_ssl);
static int VAR_4;
checkResult(VAR_3, VAR_4);
if (isFatal()) {
LOG((VAR_5 ""failed to accept secure socket""));
LOG((VAR_6 ""client connection may not be secure""));
VAR_7 = false;
VAR_8->sleep(1);
VAR_4 = 0;
return -1; 
}
if (VAR_4 == 0) {
VAR_7 = true;
LOG((VAR_6 ""accepted secure socket""));
if (VAR_9->getFilter() >= VAR_10) {
showSecureCipherInfo();
}
showSecureConnectInfo();
return 1;
}
if (VAR_4 > 0) {
LOG((VAR_2 ""retry accepting secure socket""));
VAR_7 = false;
VAR_8->sleep(VAR_11);
return 0;
}
LOG((VAR_5 ""unexpected state attempting to accept connection""));
return -1;
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/SecureSocket.cpp/vul/before/2.json,"int
SecureSocket::secureAccept(int socket)
{
    createSSL();

    // set connection socket to SSL state
    SSL_set_fd(m_ssl->m_ssl, socket);

    LOG((CLOG_DEBUG2 ""accepting secure socket""));
    int r = SSL_accept(m_ssl->m_ssl);

    static int retry;

    checkResult(r, retry);

    if (isFatal()) {
        // tell user and sleep so the socket isn't hammered.
        LOG((CLOG_ERR ""failed to accept secure socket""));
        LOG((CLOG_INFO ""client connection may not be secure""));
        m_secureReady = false;
        ARCH->sleep(1);
        retry = 0;
        return -1; // Failed, error out
    }

    // If not fatal and no retry, state is good
    if (retry == 0) {
        if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {
            if (verify_cert_fingerprint(
                        barrier::DataDirectories::trusted_clients_ssl_fingerprints_path())) {
                LOG((CLOG_INFO ""accepted secure socket""));
                if (!ensure_peer_certificate()) {
                    retry = 0;
                    disconnect();
                    return -1;// Cert fail, error
                }
            }
            else {
                LOG((CLOG_ERR ""failed to verify server certificate fingerprint""));
                retry = 0;
                disconnect();
                return -1; // Fingerprint failed, error
            }
        }

        m_secureReady = true;
        LOG((CLOG_INFO ""accepted secure socket""));
        if (CLOG->getFilter() >= kDEBUG1) {
            showSecureCipherInfo();
        }
        showSecureConnectInfo();
        return 1;
    }

    // If not fatal and retry is set, not ready, and return retry
    if (retry > 0) {
        LOG((CLOG_DEBUG2 ""retry accepting secure socket""));
        m_secureReady = false;
        ARCH->sleep(s_retryDelay);
        return 0;
    }

    // no good state exists here
    LOG((CLOG_ERR ""unexpected state attempting to accept connection""));
    return -1;
}","int
SecureSocket::secureAccept(int VAR_0)
{
    createSSL();

    /* COMMENT_0 */
    SSL_set_fd(VAR_1->m_ssl, VAR_0);

    LOG((VAR_2 ""accepting secure socket""));
    int VAR_3 = SSL_accept(VAR_1->m_ssl);

    static int VAR_4;

    checkResult(VAR_3, VAR_4);

    if (isFatal()) {
        /* COMMENT_1 */
        LOG((VAR_5 ""failed to accept secure socket""));
        LOG((VAR_6 ""client connection may not be secure""));
        VAR_7 = false;
        VAR_8->sleep(1);
        VAR_4 = 0;
        return -1; /* COMMENT_2 */
    }

    /* COMMENT_3 */
    if (VAR_4 == 0) {
        if (VAR_9 == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {
            if (verify_cert_fingerprint(
                        barrier::DataDirectories::trusted_clients_ssl_fingerprints_path())) {
                LOG((VAR_6 ""accepted secure socket""));
                if (!ensure_peer_certificate()) {
                    VAR_4 = 0;
                    disconnect();
                    return -1;/* COMMENT_4 */
                }
            }
            else {
                LOG((VAR_5 ""failed to verify server certificate fingerprint""));
                VAR_4 = 0;
                disconnect();
                return -1; /* COMMENT_5 */
            }
        }

        VAR_7 = true;
        LOG((VAR_6 ""accepted secure socket""));
        if (VAR_10->getFilter() >= VAR_11) {
            showSecureCipherInfo();
        }
        showSecureConnectInfo();
        return 1;
    }

    /* COMMENT_6 */
    if (VAR_4 > 0) {
        LOG((VAR_2 ""retry accepting secure socket""));
        VAR_7 = false;
        VAR_8->sleep(VAR_12);
        return 0;
    }

    /* COMMENT_7 */
    LOG((VAR_5 ""unexpected state attempting to accept connection""));
    return -1;
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/SecureSocket.cpp/vul/after/2.json,"--- func_before
+++ func_after
@@ -25,6 +25,24 @@
 
     // If not fatal and no retry, state is good
     if (retry == 0) {
+        if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {
+            if (verify_cert_fingerprint(
+                        barrier::DataDirectories::trusted_clients_ssl_fingerprints_path())) {
+                LOG((CLOG_INFO ""accepted secure socket""));
+                if (!ensure_peer_certificate()) {
+                    retry = 0;
+                    disconnect();
+                    return -1;// Cert fail, error
+                }
+            }
+            else {
+                LOG((CLOG_ERR ""failed to verify server certificate fingerprint""));
+                retry = 0;
+                disconnect();
+                return -1; // Fingerprint failed, error
+            }
+        }
+
         m_secureReady = true;
         LOG((CLOG_INFO ""accepted secure socket""));
         if (CLOG->getFilter() >= kDEBUG1) {","{'deleted_lines': [], 'added_lines': ['        if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {', '            if (verify_cert_fingerprint(', '                        barrier::DataDirectories::trusted_clients_ssl_fingerprints_path())) {', '                LOG((CLOG_INFO ""accepted secure socket""));', '                if (!ensure_peer_certificate()) {', '                    retry = 0;', '                    disconnect();', '                    return -1;// Cert fail, error', '                }', '            }', '            else {', '                LOG((CLOG_ERR ""failed to verify server certificate fingerprint""));', '                retry = 0;', '                disconnect();', '                return -1; // Fingerprint failed, error', '            }', '        }', '']}",True,"An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is ""Unnamed"" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",8.2,HIGH,2,test,2021-11-01T02:50:15Z,3
CVE-2021-42073,['CWE-384'],AV:N/AC:M/Au:N/C:P/I:P/A:N,0,debauchee/barrier,"Implement client identity verification

This commit fixes two security vulnerabilities: CVE-2021-42072 and
CVE-2021-42073.

The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",229abab99f39f11624e5651f819e7f1f8eddedcc,https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc,src/lib/net/SecureSocket.cpp,SecureSocket::initContext,"void
SecureSocket::initContext(bool server)
{
SSL_library_init();
const SSL_METHOD* method;
OpenSSL_add_all_algorithms();
SSL_load_error_strings();
if (CLOG->getFilter() >= kINFO) {
showSecureLibInfo();
}
if (server) {
method = SSLv23_server_method();
}
else {
method = SSLv23_client_method();
}
SSL_METHOD* m = const_cast<SSL_METHOD*>(method);
m_ssl->m_context = SSL_CTX_new(m);
SSL_CTX_set_options(m_ssl->m_context, SSL_OP_NO_SSLv3);
if (m_ssl->m_context == NULL) {
showError("""");
}
}","void
SecureSocket::initContext(bool VAR_0)
{
SSL_library_init();
const SSL_METHOD* VAR_1;
OpenSSL_add_all_algorithms();
SSL_load_error_strings();
if (VAR_2->getFilter() >= VAR_3) {
showSecureLibInfo();
}
if (VAR_0) {
VAR_1 = SSLv23_server_method();
}
else {
VAR_1 = SSLv23_client_method();
}
SSL_METHOD* VAR_4 = VAR_5<SSL_METHOD*>(VAR_1);
VAR_6->m_context = SSL_CTX_new(VAR_4);
SSL_CTX_set_options(VAR_6->m_context, VAR_7);
if (VAR_6->m_context == NULL) {
showError("""");
}
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/SecureSocket.cpp/vul/before/1.json,"void
SecureSocket::initContext(bool server)
{
    SSL_library_init();

    const SSL_METHOD* method;

    // load & register all cryptos, etc.
    OpenSSL_add_all_algorithms();

    // load all error messages
    SSL_load_error_strings();

    if (CLOG->getFilter() >= kINFO) {
        showSecureLibInfo();
    }

    // SSLv23_method uses TLSv1, with the ability to fall back to SSLv3
    if (server) {
        method = SSLv23_server_method();
    }
    else {
        method = SSLv23_client_method();
    }

    // create new context from method
    SSL_METHOD* m = const_cast<SSL_METHOD*>(method);
    m_ssl->m_context = SSL_CTX_new(m);

    // drop SSLv3 support
    SSL_CTX_set_options(m_ssl->m_context, SSL_OP_NO_SSLv3);

    if (m_ssl->m_context == NULL) {
        showError("""");
    }

    if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {
        // We want to ask for peer certificate, but not verify it. If we don't ask for peer
        // certificate, e.g. client won't send it.
        SSL_CTX_set_verify(m_ssl->m_context, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
                           nullptr);
        SSL_CTX_set_cert_verify_callback(m_ssl->m_context, cert_verify_ignore_callback, nullptr);
    }
}","void
SecureSocket::initContext(bool VAR_0)
{
    SSL_library_init();

    const SSL_METHOD* VAR_1;

    /* COMMENT_0 */
    OpenSSL_add_all_algorithms();

    /* COMMENT_1 */
    SSL_load_error_strings();

    if (VAR_2->getFilter() >= VAR_3) {
        showSecureLibInfo();
    }

    /* COMMENT_2 */
    if (VAR_0) {
        VAR_1 = SSLv23_server_method();
    }
    else {
        VAR_1 = SSLv23_client_method();
    }

    /* COMMENT_3 */
    SSL_METHOD* VAR_4 = VAR_5<SSL_METHOD*>(VAR_1);
    VAR_6->m_context = SSL_CTX_new(VAR_4);

    /* COMMENT_4 */
    SSL_CTX_set_options(VAR_6->m_context, VAR_7);

    if (VAR_6->m_context == NULL) {
        showError("""");
    }

    if (VAR_8 == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {
        /* COMMENT_5 */
        /* COMMENT_6 */
        SSL_CTX_set_verify(VAR_6->m_context, VAR_9 | VAR_10,
                           nullptr);
        SSL_CTX_set_cert_verify_callback(VAR_6->m_context, VAR_11, nullptr);
    }
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/SecureSocket.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -33,4 +33,12 @@
     if (m_ssl->m_context == NULL) {
         showError("""");
     }
+
+    if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {
+        // We want to ask for peer certificate, but not verify it. If we don't ask for peer
+        // certificate, e.g. client won't send it.
+        SSL_CTX_set_verify(m_ssl->m_context, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
+                           nullptr);
+        SSL_CTX_set_cert_verify_callback(m_ssl->m_context, cert_verify_ignore_callback, nullptr);
+    }
 }","{'deleted_lines': [], 'added_lines': ['', '    if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {', ""        // We want to ask for peer certificate, but not verify it. If we don't ask for peer"", ""        // certificate, e.g. client won't send it."", '        SSL_CTX_set_verify(m_ssl->m_context, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,', '                           nullptr);', '        SSL_CTX_set_cert_verify_callback(m_ssl->m_context, cert_verify_ignore_callback, nullptr);', '    }']}",True,"An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is ""Unnamed"" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",8.2,HIGH,2,test,2021-11-01T02:50:15Z,3
CVE-2021-42073,['CWE-384'],AV:N/AC:M/Au:N/C:P/I:P/A:N,0,debauchee/barrier,"Implement client identity verification

This commit fixes two security vulnerabilities: CVE-2021-42072 and
CVE-2021-42073.

The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",229abab99f39f11624e5651f819e7f1f8eddedcc,https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc,src/lib/barrier/ArgParser.cpp,ArgParser::parseServerArgs,"bool
ArgParser::parseServerArgs(ServerArgs& args, int argc, const char* const* argv)
{
setArgsBase(args);
updateCommonArgs(argv);
for (int i = 1; i < argc; ++i) {
if (parsePlatformArg(args, argc, argv, i)) {
continue;
}
else if (parseGenericArgs(argc, argv, i)) {
continue;
}
else if (parseDeprecatedArgs(argc, argv, i)) {
continue;
}
else if (isArg(i, argc, argv, ""-a"", ""--address"", 1)) {
args.m_barrierAddress = argv[++i];
}
else if (isArg(i, argc, argv, ""-c"", ""--config"", 1)) {
args.m_configFile = argv[++i];
}
else if (isArg(i, argc, argv, NULL, ""--screen-change-script"", 1)) {
args.m_screenChangeScript = argv[++i];
}
else {
LOG((CLOG_PRINT ""%s: unrecognized option `%s'"" BYE, args.m_exename.c_str(), argv[i], args.m_exename.c_str()));
return false;
}
}
if (checkUnexpectedArgs()) {
return false;
}
return true;
}","bool
ArgParser::parseServerArgs(ServerArgs& VAR_0, int VAR_1, const char* const* VAR_2)
{
setArgsBase(VAR_0);
updateCommonArgs(VAR_2);
for (int VAR_3 = 1; VAR_3 < VAR_1; ++VAR_3) {
if (parsePlatformArg(VAR_0, VAR_1, VAR_2, VAR_3)) {
continue;
}
else if (parseGenericArgs(VAR_1, VAR_2, VAR_3)) {
continue;
}
else if (parseDeprecatedArgs(VAR_1, VAR_2, VAR_3)) {
continue;
}
else if (isArg(VAR_3, VAR_1, VAR_2, ""-a"", ""--address"", 1)) {
VAR_0.m_barrierAddress = VAR_2[++VAR_3];
}
else if (isArg(VAR_3, VAR_1, VAR_2, ""-c"", ""--config"", 1)) {
VAR_0.m_configFile = VAR_2[++VAR_3];
}
else if (isArg(VAR_3, VAR_1, VAR_2, NULL, ""--screen-change-script"", 1)) {
VAR_0.m_screenChangeScript = VAR_2[++VAR_3];
}
else {
LOG((VAR_4 ""%s: unrecognized option `%s'"" VAR_5, VAR_0.m_exename.c_str(), VAR_2[VAR_3], VAR_0.m_exename.c_str()));
return false;
}
}
if (checkUnexpectedArgs()) {
return false;
}
return true;
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/ArgParser.cpp/vul/before/0.json,"bool
ArgParser::parseServerArgs(ServerArgs& args, int argc, const char* const* argv)
{
    setArgsBase(args);
    updateCommonArgs(argv);

    for (int i = 1; i < argc; ++i) {
        if (parsePlatformArg(args, argc, argv, i)) {
            continue;
        }
        else if (parseGenericArgs(argc, argv, i)) {
            continue;
        }
        else if (parseDeprecatedArgs(argc, argv, i)) {
            continue;
        }
        else if (isArg(i, argc, argv, ""-a"", ""--address"", 1)) {
            // save listen address
            args.m_barrierAddress = argv[++i];
        }
        else if (isArg(i, argc, argv, ""-c"", ""--config"", 1)) {
            // save configuration file path
            args.m_configFile = argv[++i];
        }
        else if (isArg(i, argc, argv, NULL, ""--screen-change-script"", 1)) {
            // save screen change script path
            args.m_screenChangeScript = argv[++i];
        }
        else if (isArg(i, argc, argv, nullptr, ""--disable-client-cert-checking"")) {
            args.check_client_certificates = false;
        } else {
            LOG((CLOG_PRINT ""%s: unrecognized option `%s'"" BYE, args.m_exename.c_str(), argv[i], args.m_exename.c_str()));
            return false;
        }
    }

    if (checkUnexpectedArgs()) {
        return false;
    }

    return true;
}","bool
ArgParser::parseServerArgs(ServerArgs& VAR_0, int VAR_1, const char* const* VAR_2)
{
    setArgsBase(VAR_0);
    updateCommonArgs(VAR_2);

    for (int VAR_3 = 1; VAR_3 < VAR_1; ++VAR_3) {
        if (parsePlatformArg(VAR_0, VAR_1, VAR_2, VAR_3)) {
            continue;
        }
        else if (parseGenericArgs(VAR_1, VAR_2, VAR_3)) {
            continue;
        }
        else if (parseDeprecatedArgs(VAR_1, VAR_2, VAR_3)) {
            continue;
        }
        else if (isArg(VAR_3, VAR_1, VAR_2, ""-a"", ""--address"", 1)) {
            /* COMMENT_0 */
            VAR_0.m_barrierAddress = VAR_2[++VAR_3];
        }
        else if (isArg(VAR_3, VAR_1, VAR_2, ""-c"", ""--config"", 1)) {
            /* COMMENT_1 */
            VAR_0.m_configFile = VAR_2[++VAR_3];
        }
        else if (isArg(VAR_3, VAR_1, VAR_2, NULL, ""--screen-change-script"", 1)) {
            /* COMMENT_2 */
            VAR_0.m_screenChangeScript = VAR_2[++VAR_3];
        }
        else if (isArg(VAR_3, VAR_1, VAR_2, nullptr, ""--disable-client-cert-checking"")) {
            VAR_0.check_client_certificates = false;
        } else {
            LOG((VAR_4 ""%s: unrecognized option `%s'"" VAR_5, VAR_0.m_exename.c_str(), VAR_2[VAR_3], VAR_0.m_exename.c_str()));
            return false;
        }
    }

    if (checkUnexpectedArgs()) {
        return false;
    }

    return true;
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/ArgParser.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -26,7 +26,9 @@
             // save screen change script path
             args.m_screenChangeScript = argv[++i];
         }
-        else {
+        else if (isArg(i, argc, argv, nullptr, ""--disable-client-cert-checking"")) {
+            args.check_client_certificates = false;
+        } else {
             LOG((CLOG_PRINT ""%s: unrecognized option `%s'"" BYE, args.m_exename.c_str(), argv[i], args.m_exename.c_str()));
             return false;
         }","{'deleted_lines': ['        else {'], 'added_lines': ['        else if (isArg(i, argc, argv, nullptr, ""--disable-client-cert-checking"")) {', '            args.check_client_certificates = false;', '        } else {']}",True,"An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is ""Unnamed"" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",8.2,HIGH,2,test,2021-11-01T02:50:15Z,3
CVE-2021-42073,['CWE-384'],AV:N/AC:M/Au:N/C:P/I:P/A:N,0,debauchee/barrier,"Implement client identity verification

This commit fixes two security vulnerabilities: CVE-2021-42072 and
CVE-2021-42073.

The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",229abab99f39f11624e5651f819e7f1f8eddedcc,https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc,src/lib/net/SecureSocket.cpp,SecureSocket::verify_cert_fingerprint,"bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& fingerprint_db_path)
{
barrier::FingerprintData fingerprint_sha1, fingerprint_sha256;
try {
auto* cert = SSL_get_peer_certificate(m_ssl->m_ssl);
fingerprint_sha1 = barrier::get_ssl_cert_fingerprint(cert,
barrier::FingerprintType::SHA1);
fingerprint_sha256 = barrier::get_ssl_cert_fingerprint(cert,
barrier::FingerprintType::SHA256);
} catch (const std::exception& e) {
LOG((CLOG_ERR ""%s"", e.what()));
return false;
}
LOG((CLOG_NOTE ""server fingerprint (SHA1): %s (SHA256): %s"",
barrier::format_ssl_fingerprint(fingerprint_sha1.data).c_str(),
barrier::format_ssl_fingerprint(fingerprint_sha256.data).c_str()));
LOG((CLOG_NOTE ""fingerprint_db_path: %s"", fingerprint_db_path.u8string().c_str()));
barrier::FingerprintDatabase db;
db.read(fingerprint_db_path);
if (!db.fingerprints().empty()) {
LOG((CLOG_NOTE ""Read %d fingerprints from: %s"", db.fingerprints().size(),
fingerprint_db_path.u8string().c_str()));
} else {
LOG((CLOG_NOTE ""Could not read fingerprints from: %s"",
fingerprint_db_path.u8string().c_str()));
}
if (db.is_trusted(fingerprint_sha256)) {
LOG((CLOG_NOTE ""Fingerprint matches trusted fingerprint""));
return true;
} else {
LOG((CLOG_NOTE ""Fingerprint does not match trusted fingerprint""));
return false;
}
}","bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& VAR_0)
{
barrier::FingerprintData VAR_1, VAR_2;
try {
auto* VAR_3 = SSL_get_peer_certificate(VAR_4->m_ssl);
VAR_1 = barrier::get_ssl_cert_fingerprint(VAR_3,
barrier::FingerprintType::SHA1);
VAR_2 = barrier::get_ssl_cert_fingerprint(VAR_3,
barrier::FingerprintType::SHA256);
} catch (const std::exception& VAR_5) {
LOG((VAR_6 ""%s"", VAR_5.what()));
return false;
}
LOG((VAR_7 ""server fingerprint (SHA1): %s (SHA256): %s"",
barrier::format_ssl_fingerprint(VAR_1.data).c_str(),
barrier::format_ssl_fingerprint(VAR_2.data).c_str()));
LOG((VAR_7 ""fingerprint_db_path: %s"", VAR_0.u8string().c_str()));
barrier::FingerprintDatabase VAR_8;
VAR_8.read(VAR_0);
if (!VAR_8.fingerprints().empty()) {
LOG((VAR_7 ""Read %d fingerprints from: %s"", VAR_8.fingerprints().size(),
VAR_0.u8string().c_str()));
} else {
LOG((VAR_7 ""Could not read fingerprints from: %s"",
VAR_0.u8string().c_str()));
}
if (VAR_8.is_trusted(VAR_2)) {
LOG((VAR_7 ""Fingerprint matches trusted fingerprint""));
return true;
} else {
LOG((VAR_7 ""Fingerprint does not match trusted fingerprint""));
return false;
}
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/SecureSocket.cpp/vul/before/0.json,"bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& fingerprint_db_path)
{
    // calculate received certificate fingerprint
    barrier::FingerprintData fingerprint_sha1, fingerprint_sha256;
    try {
        auto* cert = SSL_get_peer_certificate(m_ssl->m_ssl);
        fingerprint_sha1 = barrier::get_ssl_cert_fingerprint(cert,
                                                             barrier::FingerprintType::SHA1);
        fingerprint_sha256 = barrier::get_ssl_cert_fingerprint(cert,
                                                               barrier::FingerprintType::SHA256);
    } catch (const std::exception& e) {
        LOG((CLOG_ERR ""%s"", e.what()));
        return false;
    }

    // note: the GUI parses the following two lines of logs, don't change unnecessarily
    LOG((CLOG_NOTE ""peer fingerprint (SHA1): %s (SHA256): %s"",
         barrier::format_ssl_fingerprint(fingerprint_sha1.data).c_str(),
         barrier::format_ssl_fingerprint(fingerprint_sha256.data).c_str()));

    // Provide debug hint as to what file is being used to verify fingerprint trust
    LOG((CLOG_NOTE ""fingerprint_db_path: %s"", fingerprint_db_path.u8string().c_str()));

    barrier::FingerprintDatabase db;
    db.read(fingerprint_db_path);

    if (!db.fingerprints().empty()) {
        LOG((CLOG_NOTE ""Read %d fingerprints from: %s"", db.fingerprints().size(),
             fingerprint_db_path.u8string().c_str()));
    } else {
        LOG((CLOG_NOTE ""Could not read fingerprints from: %s"",
             fingerprint_db_path.u8string().c_str()));
    }

    if (db.is_trusted(fingerprint_sha256)) {
        LOG((CLOG_NOTE ""Fingerprint matches trusted fingerprint""));
        return true;
    } else {
        LOG((CLOG_NOTE ""Fingerprint does not match trusted fingerprint""));
        return false;
    }
}","bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& VAR_0)
{
    /* COMMENT_0 */
    barrier::FingerprintData VAR_1, VAR_2;
    try {
        auto* VAR_3 = SSL_get_peer_certificate(VAR_4->m_ssl);
        VAR_1 = barrier::get_ssl_cert_fingerprint(VAR_3,
                                                             barrier::FingerprintType::SHA1);
        VAR_2 = barrier::get_ssl_cert_fingerprint(VAR_3,
                                                               barrier::FingerprintType::SHA256);
    } catch (const std::exception& VAR_5) {
        LOG((VAR_6 ""%s"", VAR_5.what()));
        return false;
    }

    /* COMMENT_1 */
    LOG((VAR_7 ""peer fingerprint (SHA1): %s (SHA256): %s"",
         barrier::format_ssl_fingerprint(VAR_1.data).c_str(),
         barrier::format_ssl_fingerprint(VAR_2.data).c_str()));

    /* COMMENT_2 */
    LOG((VAR_7 ""fingerprint_db_path: %s"", VAR_0.u8string().c_str()));

    barrier::FingerprintDatabase VAR_8;
    VAR_8.read(VAR_0);

    if (!VAR_8.fingerprints().empty()) {
        LOG((VAR_7 ""Read %d fingerprints from: %s"", VAR_8.fingerprints().size(),
             VAR_0.u8string().c_str()));
    } else {
        LOG((VAR_7 ""Could not read fingerprints from: %s"",
             VAR_0.u8string().c_str()));
    }

    if (VAR_8.is_trusted(VAR_2)) {
        LOG((VAR_7 ""Fingerprint matches trusted fingerprint""));
        return true;
    } else {
        LOG((VAR_7 ""Fingerprint does not match trusted fingerprint""));
        return false;
    }
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/SecureSocket.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,7 +14,7 @@
     }
 
     // note: the GUI parses the following two lines of logs, don't change unnecessarily
-    LOG((CLOG_NOTE ""server fingerprint (SHA1): %s (SHA256): %s"",
+    LOG((CLOG_NOTE ""peer fingerprint (SHA1): %s (SHA256): %s"",
          barrier::format_ssl_fingerprint(fingerprint_sha1.data).c_str(),
          barrier::format_ssl_fingerprint(fingerprint_sha256.data).c_str()));
 ","{'deleted_lines': ['    LOG((CLOG_NOTE ""server fingerprint (SHA1): %s (SHA256): %s"",'], 'added_lines': ['    LOG((CLOG_NOTE ""peer fingerprint (SHA1): %s (SHA256): %s"",']}",True,"An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is ""Unnamed"" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",8.2,HIGH,2,test,2021-11-01T02:50:15Z,3
CVE-2021-42073,['CWE-384'],AV:N/AC:M/Au:N/C:P/I:P/A:N,0,debauchee/barrier,"Implement client identity verification

This commit fixes two security vulnerabilities: CVE-2021-42072 and
CVE-2021-42073.

The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",229abab99f39f11624e5651f819e7f1f8eddedcc,https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc,src/lib/barrier/ServerApp.cpp,ServerApp::openClientListener,"ClientListener*
ServerApp::openClientListener(const NetworkAddress& address)
{
auto security_level = ConnectionSecurityLevel::PLAINTEXT;
if (args().m_enableCrypto) {
security_level = ConnectionSecurityLevel::ENCRYPTED;
}
ClientListener* listen = new ClientListener(
address,
new TCPSocketFactory(m_events, getSocketMultiplexer()),
m_events, security_level);
m_events->adoptHandler(
m_events->forClientListener().connected(), listen,
new TMethodEventJob<ServerApp>(
this, &ServerApp::handleClientConnected, listen));
return listen;
}","ClientListener*
ServerApp::openClientListener(const NetworkAddress& VAR_0)
{
auto VAR_1 = ConnectionSecurityLevel::PLAINTEXT;
if (args().m_enableCrypto) {
VAR_1 = ConnectionSecurityLevel::ENCRYPTED;
}
ClientListener* VAR_2 = new ClientListener(
VAR_0,
new TCPSocketFactory(VAR_3, getSocketMultiplexer()),
VAR_3, VAR_1);
VAR_3->adoptHandler(
VAR_3->forClientListener().connected(), VAR_2,
new TMethodEventJob<ServerApp>(
this, &ServerApp::handleClientConnected, VAR_2));
return VAR_2;
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/ServerApp.cpp/vul/before/1.json,"ClientListener*
ServerApp::openClientListener(const NetworkAddress& address)
{
    auto security_level = ConnectionSecurityLevel::PLAINTEXT;
    if (args().m_enableCrypto) {
        security_level = ConnectionSecurityLevel::ENCRYPTED;
        if (args().check_client_certificates) {
            security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;
        }
    }

    ClientListener* listen = new ClientListener(
        address,
        new TCPSocketFactory(m_events, getSocketMultiplexer()),
        m_events, security_level);

    m_events->adoptHandler(
        m_events->forClientListener().connected(), listen,
        new TMethodEventJob<ServerApp>(
            this, &ServerApp::handleClientConnected, listen));

    return listen;
}","ClientListener*
ServerApp::openClientListener(const NetworkAddress& VAR_0)
{
    auto VAR_1 = ConnectionSecurityLevel::PLAINTEXT;
    if (args().m_enableCrypto) {
        VAR_1 = ConnectionSecurityLevel::ENCRYPTED;
        if (args().check_client_certificates) {
            VAR_1 = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;
        }
    }

    ClientListener* VAR_2 = new ClientListener(
        VAR_0,
        new TCPSocketFactory(VAR_3, getSocketMultiplexer()),
        VAR_3, VAR_1);

    VAR_3->adoptHandler(
        VAR_3->forClientListener().connected(), VAR_2,
        new TMethodEventJob<ServerApp>(
            this, &ServerApp::handleClientConnected, VAR_2));

    return VAR_2;
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/ServerApp.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -4,6 +4,9 @@
     auto security_level = ConnectionSecurityLevel::PLAINTEXT;
     if (args().m_enableCrypto) {
         security_level = ConnectionSecurityLevel::ENCRYPTED;
+        if (args().check_client_certificates) {
+            security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;
+        }
     }
 
     ClientListener* listen = new ClientListener(","{'deleted_lines': [], 'added_lines': ['        if (args().check_client_certificates) {', '            security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;', '        }']}",True,"An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is ""Unnamed"" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",8.2,HIGH,2,test,2021-11-01T02:50:15Z,3
CVE-2021-42073,['CWE-384'],AV:N/AC:M/Au:N/C:P/I:P/A:N,0,debauchee/barrier,"Implement client identity verification

This commit fixes two security vulnerabilities: CVE-2021-42072 and
CVE-2021-42073.

The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",229abab99f39f11624e5651f819e7f1f8eddedcc,https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc,src/lib/barrier/ServerApp.cpp,ServerApp::help,"void
ServerApp::help()
{
#if WINAPI_XWINDOWS
#  define WINAPI_ARGS \
"" [--display <display>] [--no-xinitthreads]""
#  define WINAPI_INFO \
""      --display <display>  connect to the X server at <display>\n"" \
""      --no-xinitthreads    do not call XInitThreads()\n"" \
""      --screen-change-script <path>\n"" \
""                           full path to script to run on screen change\n"" \
""                           first argument is the new screen name\n""
#else
#  define WINAPI_ARGS """"
#  define WINAPI_INFO """"
#endif
barrier::fs::path profile_path = argsBase().m_profileDirectory;
if (profile_path.empty()) {
profile_path = barrier::DataDirectories::profile();
}
auto usr_config_path = (profile_path / barrier::fs::u8path(USR_CONFIG_NAME)).u8string();
auto sys_config_path = (barrier::DataDirectories::systemconfig() /
barrier::fs::u8path(SYS_CONFIG_NAME)).u8string();
std::ostringstream buffer;
buffer << ""Start the barrier server component.\n""
<< ""\n""
<< ""Usage: "" << args().m_exename
<< "" [--address <address>]""
<< "" [--config <pathname>]""
<< WINAPI_ARGS << HELP_SYS_ARGS << HELP_COMMON_ARGS << ""\n""
<< ""\n""
<< ""Options:\n""
<< ""  -a, --address <address>  listen for clients on the given address.\n""
<< ""  -c, --config <pathname>  use the named configuration file instead.\n""
<< HELP_COMMON_INFO_1 << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << ""\n""
<< ""Default options are marked with a *\n""
<< ""\n""
<< ""The argument for --address is of the form: [<hostname>][:<port>].  The\n""
<< ""hostname must be the address or hostname of an interface on the system.\n""
<< ""Placing brackets around an IPv6 address is required when also specifying \n""
<< ""a port number and optional otherwise. The default is to listen on all\n""
<< ""interfaces using port number "" << kDefaultPort << "".\n""
<< ""\n""
<< ""If no configuration file pathname is provided then the first of the\n""
<< ""following to load successfully sets the configuration:\n""
<< ""  "" << usr_config_path << ""\n""
<< ""  "" << sys_config_path << ""\n"";
LOG((CLOG_PRINT ""%s"", buffer.str().c_str()));
}","void
ServerApp::help()
{
#if VAR_0
#  define VAR_1 \
"" [--display <display>] [--no-xinitthreads]""
#  define VAR_2 \
""      --display <display>  connect to the X server at <display>\n"" \
""      --no-xinitthreads    do not call XInitThreads()\n"" \
""      --screen-change-script <path>\n"" \
""                           full path to script to run on screen change\n"" \
""                           first argument is the new screen name\n""
#else
#  define VAR_1 """"
#  define VAR_2 """"
#endif
barrier::fs::path VAR_3 = argsBase().m_profileDirectory;
if (VAR_3.empty()) {
VAR_3 = barrier::DataDirectories::profile();
}
auto VAR_4 = (VAR_3 / barrier::fs::u8path(VAR_5)).u8string();
auto VAR_6 = (barrier::DataDirectories::systemconfig() /
barrier::fs::u8path(VAR_7)).u8string();
std::ostringstream VAR_8;
VAR_8 << ""Start the barrier server component.\n""
<< ""\n""
<< ""Usage: "" << args().m_exename
<< "" [--address <address>]""
<< "" [--config <pathname>]""
<< VAR_1 << VAR_9 << VAR_10 << ""\n""
<< ""\n""
<< ""Options:\n""
<< ""  -a, --address <address>  listen for clients on the given address.\n""
<< ""  -c, --config <pathname>  use the named configuration file instead.\n""
<< VAR_11 << VAR_2 << VAR_12 << VAR_13 << ""\n""
<< ""Default options are marked with a *\n""
<< ""\n""
<< ""The argument for --address is of the form: [<hostname>][:<port>].  The\n""
<< ""hostname must be the address or hostname of an interface on the system.\n""
<< ""Placing brackets around an IPv6 address is required when also specifying \n""
<< ""a port number and optional otherwise. The default is to listen on all\n""
<< ""interfaces using port number "" << VAR_14 << "".\n""
<< ""\n""
<< ""If no configuration file pathname is provided then the first of the\n""
<< ""following to load successfully sets the configuration:\n""
<< ""  "" << VAR_4 << ""\n""
<< ""  "" << VAR_6 << ""\n"";
LOG((VAR_15 ""%s"", VAR_8.str().c_str()));
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/ServerApp.cpp/vul/before/0.json,"void
ServerApp::help()
{
    // window api args (windows/x-windows/carbon)
#if WINAPI_XWINDOWS
#  define WINAPI_ARGS \
    "" [--display <display>] [--no-xinitthreads]""
#  define WINAPI_INFO \
    ""      --display <display>  connect to the X server at <display>\n"" \
    ""      --no-xinitthreads    do not call XInitThreads()\n"" \
    ""      --screen-change-script <path>\n"" \
    ""                           full path to script to run on screen change\n"" \
    ""                           first argument is the new screen name\n""
#else
#  define WINAPI_ARGS """"
#  define WINAPI_INFO """"
#endif

    // refer to custom profile directory even if not saved yet
    barrier::fs::path profile_path = argsBase().m_profileDirectory;
    if (profile_path.empty()) {
        profile_path = barrier::DataDirectories::profile();
    }

    auto usr_config_path = (profile_path / barrier::fs::u8path(USR_CONFIG_NAME)).u8string();
    auto sys_config_path = (barrier::DataDirectories::systemconfig() /
                            barrier::fs::u8path(SYS_CONFIG_NAME)).u8string();

    std::ostringstream buffer;
    buffer << ""Start the barrier server component.\n""
           << ""\n""
           << ""Usage: "" << args().m_exename
           << "" [--address <address>]""
           << "" [--config <pathname>]""
           << WINAPI_ARGS << HELP_SYS_ARGS << HELP_COMMON_ARGS << ""\n""
           << ""\n""
           << ""Options:\n""
           << ""  -a, --address <address>  listen for clients on the given address.\n""
           << ""  -c, --config <pathname>  use the named configuration file instead.\n""
           << HELP_COMMON_INFO_1
           << ""      --disable-client-cert-checking disable client SSL certificate \n""
              ""                                     checking (deprecated)\n""
           << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << ""\n""
           << ""Default options are marked with a *\n""
           << ""\n""
           << ""The argument for --address is of the form: [<hostname>][:<port>].  The\n""
           << ""hostname must be the address or hostname of an interface on the system.\n""
           << ""Placing brackets around an IPv6 address is required when also specifying \n""
           << ""a port number and optional otherwise. The default is to listen on all\n""
           << ""interfaces using port number "" << kDefaultPort << "".\n""
           << ""\n""
           << ""If no configuration file pathname is provided then the first of the\n""
           << ""following to load successfully sets the configuration:\n""
           << ""  "" << usr_config_path << ""\n""
           << ""  "" << sys_config_path << ""\n"";

    LOG((CLOG_PRINT ""%s"", buffer.str().c_str()));
}","void
ServerApp::help()
{
    /* COMMENT_0 */
#if VAR_0
#  define VAR_1 \
    "" [--display <display>] [--no-xinitthreads]""
#  define VAR_2 \
    ""      --display <display>  connect to the X server at <display>\n"" \
    ""      --no-xinitthreads    do not call XInitThreads()\n"" \
    ""      --screen-change-script <path>\n"" \
    ""                           full path to script to run on screen change\n"" \
    ""                           first argument is the new screen name\n""
#else
#  define VAR_1 """"
#  define VAR_2 """"
#endif

    /* COMMENT_1 */
    barrier::fs::path VAR_3 = argsBase().m_profileDirectory;
    if (VAR_3.empty()) {
        VAR_3 = barrier::DataDirectories::profile();
    }

    auto VAR_4 = (VAR_3 / barrier::fs::u8path(VAR_5)).u8string();
    auto VAR_6 = (barrier::DataDirectories::systemconfig() /
                            barrier::fs::u8path(VAR_7)).u8string();

    std::ostringstream VAR_8;
    VAR_8 << ""Start the barrier server component.\n""
           << ""\n""
           << ""Usage: "" << args().m_exename
           << "" [--address <address>]""
           << "" [--config <pathname>]""
           << VAR_1 << VAR_9 << VAR_10 << ""\n""
           << ""\n""
           << ""Options:\n""
           << ""  -a, --address <address>  listen for clients on the given address.\n""
           << ""  -c, --config <pathname>  use the named configuration file instead.\n""
           << VAR_11
           << ""      --disable-client-cert-checking disable client SSL certificate \n""
              ""                                     checking (deprecated)\n""
           << VAR_2 << VAR_12 << VAR_13 << ""\n""
           << ""Default options are marked with a *\n""
           << ""\n""
           << ""The argument for --address is of the form: [<hostname>][:<port>].  The\n""
           << ""hostname must be the address or hostname of an interface on the system.\n""
           << ""Placing brackets around an IPv6 address is required when also specifying \n""
           << ""a port number and optional otherwise. The default is to listen on all\n""
           << ""interfaces using port number "" << VAR_14 << "".\n""
           << ""\n""
           << ""If no configuration file pathname is provided then the first of the\n""
           << ""following to load successfully sets the configuration:\n""
           << ""  "" << VAR_4 << ""\n""
           << ""  "" << VAR_6 << ""\n"";

    LOG((VAR_15 ""%s"", VAR_8.str().c_str()));
}",debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/ServerApp.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -37,7 +37,10 @@
            << ""Options:\n""
            << ""  -a, --address <address>  listen for clients on the given address.\n""
            << ""  -c, --config <pathname>  use the named configuration file instead.\n""
-           << HELP_COMMON_INFO_1 << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << ""\n""
+           << HELP_COMMON_INFO_1
+           << ""      --disable-client-cert-checking disable client SSL certificate \n""
+              ""                                     checking (deprecated)\n""
+           << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << ""\n""
            << ""Default options are marked with a *\n""
            << ""\n""
            << ""The argument for --address is of the form: [<hostname>][:<port>].  The\n""","{'deleted_lines': ['           << HELP_COMMON_INFO_1 << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << ""\\n""'], 'added_lines': ['           << HELP_COMMON_INFO_1', '           << ""      --disable-client-cert-checking disable client SSL certificate \\n""', '              ""                                     checking (deprecated)\\n""', '           << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << ""\\n""']}",True,"An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is ""Unnamed"" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",8.2,HIGH,2,test,2021-11-01T02:50:15Z,3
CVE-2022-23566,['CWE-787'],AV:N/AC:L/Au:S/C:P/I:P/A:P,0,tensorflow,"Prevent a crash due to heap OOB write in grappler.

PiperOrigin-RevId: 408318417
Change-Id: If095feb8c001e3a8ac4a85b7387b81e8309df47d",97282c6d0d34476b6ba033f961590b783fa184cd,https://github.com/tensorflow/tensorflow/commit/97282c6d0d34476b6ba033f961590b783fa184cd,tensorflow/core/grappler/costs/graph_properties.cc,SetUnknownShape,"Status SetUnknownShape(const NodeDef* node, int output_port) {
shape_inference::ShapeHandle shape =
GetUnknownOutputShape(node, output_port);
InferenceContext* ctx = GetContext(node);
if (ctx == nullptr) {
return errors::InvalidArgument(""Missing context"");
}
ctx->set_output(output_port, shape);
return Status::OK();
}","Status SetUnknownShape(const NodeDef* VAR_0, int VAR_1) {
shape_inference::ShapeHandle VAR_2 =
GetUnknownOutputShape(VAR_0, VAR_1);
InferenceContext* VAR_3 = GetContext(VAR_0);
if (VAR_3 == nullptr) {
return errors::InvalidArgument(""Missing context"");
}
VAR_3->set_output(VAR_1, VAR_2);
return Status::OK();
}",tensorflow/97282c6d0d34476b6ba033f961590b783fa184cd/graph_properties.cc/vul/before/0.json,"Status SetUnknownShape(const NodeDef* node, int output_port) {
    shape_inference::ShapeHandle shape =
        GetUnknownOutputShape(node, output_port);
    InferenceContext* ctx = GetContext(node);
    if (ctx == nullptr) {
      return errors::InvalidArgument(""SetUnknownShape: Missing context"");
    }
    if (output_port < 0 || output_port >= ctx->num_outputs()) {
      return errors::InvalidArgument(
          ""SetUnknownShape: output_port must be in [0, "", ctx->num_outputs(),
          "") but was "", output_port);
    }
    ctx->set_output(output_port, shape);
    return Status::OK();
  }","Status SetUnknownShape(const NodeDef* VAR_0, int VAR_1) {
    shape_inference::ShapeHandle VAR_2 =
        GetUnknownOutputShape(VAR_0, VAR_1);
    InferenceContext* VAR_3 = GetContext(VAR_0);
    if (VAR_3 == nullptr) {
      return errors::InvalidArgument(""SetUnknownShape: Missing context"");
    }
    if (VAR_1 < 0 || VAR_1 >= VAR_3->num_outputs()) {
      return errors::InvalidArgument(
          ""SetUnknownShape: output_port must be in [0, "", VAR_3->num_outputs(),
          "") but was "", VAR_1);
    }
    VAR_3->set_output(VAR_1, VAR_2);
    return Status::OK();
  }",tensorflow/97282c6d0d34476b6ba033f961590b783fa184cd/graph_properties.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,12 @@
         GetUnknownOutputShape(node, output_port);
     InferenceContext* ctx = GetContext(node);
     if (ctx == nullptr) {
-      return errors::InvalidArgument(""Missing context"");
+      return errors::InvalidArgument(""SetUnknownShape: Missing context"");
+    }
+    if (output_port < 0 || output_port >= ctx->num_outputs()) {
+      return errors::InvalidArgument(
+          ""SetUnknownShape: output_port must be in [0, "", ctx->num_outputs(),
+          "") but was "", output_port);
     }
     ctx->set_output(output_port, shape);
     return Status::OK();","{'deleted_lines': ['      return errors::InvalidArgument(""Missing context"");'], 'added_lines': ['      return errors::InvalidArgument(""SetUnknownShape: Missing context"");', '    }', '    if (output_port < 0 || output_port >= ctx->num_outputs()) {', '      return errors::InvalidArgument(', '          ""SetUnknownShape: output_port must be in [0, "", ctx->num_outputs(),', '          "") but was "", output_port);']}",True,"Tensorflow is an Open Source Machine Learning Framework. TensorFlow is vulnerable to a heap OOB write in `Grappler`. The `set_output` function writes to an array at the specified index. Hence, this gives a malicious user a write primitive. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",8.8,HIGH,2,test,2021-11-08T13:48:40Z,3
CVE-2022-23574,"['CWE-787', 'CWE-125']",AV:N/AC:L/Au:S/C:P/I:P/A:P,0,tensorflow,"Fix heap OOB read/write due to incorrect indexing.

PiperOrigin-RevId: 408578046
Change-Id: Ifc9ffea49e5890f55fcb2c27568611052c3ddcfa",0657c83d08845cc434175934c642299de2c0f042,https://github.com/tensorflow/tensorflow/commit/0657c83d08845cc434175934c642299de2c0f042,tensorflow/core/framework/full_type_util.cc,SpecializeType,"StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,
const OpDef& op_def) {
FullTypeDef ft;
ft.set_type_id(TFT_PRODUCT);
for (int i = 0; i < op_def.output_arg_size(); i++) {
auto* t = ft.add_args();
*t = op_def.output_arg(i).experimental_full_type();
for (int j = 0; j < t->args_size(); j++) {
auto* arg = t->mutable_args(i);
if (arg->type_id() == TFT_VAR) {
const auto* attr = attrs.Find(arg->s());
if (attr == nullptr) {
return Status(
error::INVALID_ARGUMENT,
absl::StrCat(""Could not find an attribute for key "", arg->s()));
}
if (attr->value_case() == AttrValue::kList) {
const auto& attr_list = attr->list();
arg->set_type_id(TFT_PRODUCT);
for (int i = 0; i < attr_list.type_size(); i++) {
map_dtype_to_tensor(attr_list.type(i), arg->add_args());
}
} else if (attr->value_case() == AttrValue::kType) {
map_dtype_to_tensor(attr->type(), arg);
} else {
return Status(error::UNIMPLEMENTED,
absl::StrCat(""unknown attribute type"",
attrs.DebugString(), "" key="", arg->s()));
}
arg->clear_s();
}
}
}
return ft;
}","StatusOr<FullTypeDef> SpecializeType(const AttrSlice& VAR_0,
const OpDef& VAR_1) {
FullTypeDef VAR_2;
VAR_2.set_type_id(VAR_3);
for (int VAR_4 = 0; VAR_4 < VAR_1.output_arg_size(); VAR_4++) {
auto* VAR_5 = VAR_2.add_args();
*VAR_5 = VAR_1.output_arg(VAR_4).experimental_full_type();
for (int VAR_6 = 0; VAR_6 < VAR_5->args_size(); VAR_6++) {
auto* VAR_7 = VAR_5->mutable_args(VAR_4);
if (VAR_7->type_id() == VAR_8) {
const auto* VAR_9 = VAR_0.Find(VAR_7->s());
if (VAR_9 == nullptr) {
return Status(
error::INVALID_ARGUMENT,
absl::StrCat(""Could not find an attribute for key "", VAR_7->s()));
}
if (VAR_9->value_case() == AttrValue::kList) {
const auto& VAR_10 = VAR_9->list();
VAR_7->set_type_id(VAR_3);
for (int VAR_4 = 0; VAR_4 < VAR_10.type_size(); VAR_4++) {
map_dtype_to_tensor(VAR_10.type(VAR_4), VAR_7->add_args());
}
} else if (VAR_9->value_case() == AttrValue::kType) {
map_dtype_to_tensor(VAR_9->type(), VAR_7);
} else {
return Status(error::UNIMPLEMENTED,
absl::StrCat(""unknown attribute type"",
VAR_0.DebugString(), "" key="", VAR_7->s()));
}
VAR_7->clear_s();
}
}
}
return VAR_2;
}",tensorflow/0657c83d08845cc434175934c642299de2c0f042/full_type_util.cc/vul/before/0.json,"StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,
                                     const OpDef& op_def) {
  FullTypeDef ft;
  ft.set_type_id(TFT_PRODUCT);

  for (int i = 0; i < op_def.output_arg_size(); i++) {
    auto* t = ft.add_args();

    *t = op_def.output_arg(i).experimental_full_type();

    // Resolve dependent types. The convention for op registrations is to use
    // attributes as type variables.
    // See https://www.tensorflow.org/guide/create_op#type_polymorphism.
    // Once the op signature can be defined entirely in FullType, this
    // convention can be deprecated.
    //
    // Note: While this code performs some basic verifications, it generally
    // assumes consistent op defs and attributes. If more complete
    // verifications are needed, they should be done by separately, and in a
    // way that can be reused for type inference.
    for (int j = 0; j < t->args_size(); j++) {
      auto* arg = t->mutable_args(j);
      if (arg->type_id() == TFT_VAR) {
        const auto* attr = attrs.Find(arg->s());
        if (attr == nullptr) {
          return Status(
              error::INVALID_ARGUMENT,
              absl::StrCat(""Could not find an attribute for key "", arg->s()));
        }
        if (attr->value_case() == AttrValue::kList) {
          const auto& attr_list = attr->list();
          arg->set_type_id(TFT_PRODUCT);
          for (int i = 0; i < attr_list.type_size(); i++) {
            map_dtype_to_tensor(attr_list.type(i), arg->add_args());
          }

        } else if (attr->value_case() == AttrValue::kType) {
          map_dtype_to_tensor(attr->type(), arg);

        } else {
          return Status(error::UNIMPLEMENTED,
                        absl::StrCat(""unknown attribute type"",
                                     attrs.DebugString(), "" key="", arg->s()));
        }

        arg->clear_s();
      }
    }
  }

  return ft;
}","StatusOr<FullTypeDef> SpecializeType(const AttrSlice& VAR_0,
                                     const OpDef& VAR_1) {
  FullTypeDef VAR_2;
  VAR_2.set_type_id(VAR_3);

  for (int VAR_4 = 0; VAR_4 < VAR_1.output_arg_size(); VAR_4++) {
    auto* VAR_5 = VAR_2.add_args();

    *VAR_5 = VAR_1.output_arg(VAR_4).experimental_full_type();

    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_8 */
    /* COMMENT_9 */
    for (int VAR_6 = 0; VAR_6 < VAR_5->args_size(); VAR_6++) {
      auto* VAR_7 = VAR_5->mutable_args(VAR_6);
      if (VAR_7->type_id() == VAR_8) {
        const auto* VAR_9 = VAR_0.Find(VAR_7->s());
        if (VAR_9 == nullptr) {
          return Status(
              error::INVALID_ARGUMENT,
              absl::StrCat(""Could not find an attribute for key "", VAR_7->s()));
        }
        if (VAR_9->value_case() == AttrValue::kList) {
          const auto& VAR_10 = VAR_9->list();
          VAR_7->set_type_id(VAR_3);
          for (int VAR_4 = 0; VAR_4 < VAR_10.type_size(); VAR_4++) {
            map_dtype_to_tensor(VAR_10.type(VAR_4), VAR_7->add_args());
          }

        } else if (VAR_9->value_case() == AttrValue::kType) {
          map_dtype_to_tensor(VAR_9->type(), VAR_7);

        } else {
          return Status(error::UNIMPLEMENTED,
                        absl::StrCat(""unknown attribute type"",
                                     VAR_0.DebugString(), "" key="", VAR_7->s()));
        }

        VAR_7->clear_s();
      }
    }
  }

  return VAR_2;
}",tensorflow/0657c83d08845cc434175934c642299de2c0f042/full_type_util.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -19,7 +19,7 @@
     // verifications are needed, they should be done by separately, and in a
     // way that can be reused for type inference.
     for (int j = 0; j < t->args_size(); j++) {
-      auto* arg = t->mutable_args(i);
+      auto* arg = t->mutable_args(j);
       if (arg->type_id() == TFT_VAR) {
         const auto* attr = attrs.Find(arg->s());
         if (attr == nullptr) {","{'deleted_lines': ['      auto* arg = t->mutable_args(i);'], 'added_lines': ['      auto* arg = t->mutable_args(j);']}",True,"Tensorflow is an Open Source Machine Learning Framework. There is a typo in TensorFlow's `SpecializeType` which results in heap OOB read/write. Due to a typo, `arg` is initialized to the `i`th mutable argument in a loop where the loop index is `j`. Hence it is possible to assign to `arg` from outside the vector of arguments. Since this is a mutable proto value, it allows both read and write to outside of bounds data. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, and TensorFlow 2.6.3, as these are also affected and still in supported range.",8.8,HIGH,2,test,2021-11-09T12:44:43Z,3
CVE-2022-23578,['CWE-401'],AV:N/AC:L/Au:S/C:N/I:N/A:P,0,tensorflow,"Fix memory leak when a graph node is invalid.

If a graph node is invalid but a kernel is created then we set the kernel back to `nullptr` but we forget to delete it. Hence, we get a memory leak.

PiperOrigin-RevId: 408968108
Change-Id: I1d8a9d0d8988ed5e08be8b9f2004ce1b4cd11b7c",c79ccba517dbb1a0ccb9b01ee3bd2a63748b60dd,https://github.com/tensorflow/tensorflow/commit/c79ccba517dbb1a0ccb9b01ee3bd2a63748b60dd,tensorflow/core/common_runtime/immutable_executor_state.cc,ImmutableExecutorState::Initialize,"Status ImmutableExecutorState::Initialize(const Graph& graph) {
TF_RETURN_IF_ERROR(gview_.Initialize(&graph));
ControlFlowInfo cf_info;
TF_RETURN_IF_ERROR(BuildControlFlowInfo(&graph, &cf_info));
for (auto& it : cf_info.unique_frame_names) {
EnsureFrameInfo(it)->nodes =
absl::make_unique<std::vector<const NodeItem*>>();
}
root_frame_info_ = frame_info_[""""].get();
pending_ids_.resize(gview_.num_nodes());
requires_control_flow_ = false;
for (const Node* n : graph.nodes()) {
if (IsSink(n)) continue;
if (IsSwitch(n) || IsMerge(n) || IsEnter(n) || IsExit(n)) {
requires_control_flow_ = true;
} else if (IsRecv(n)) {
string send_device;
string recv_device;
TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), ""send_device"", &send_device));
TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), ""recv_device"", &recv_device));
if (send_device != recv_device) {
requires_control_flow_ = true;
}
}
const int id = n->id();
const string& frame_name = cf_info.frame_names[id];
FrameInfo* frame_info = EnsureFrameInfo(frame_name);
NodeItem* item = gview_.node(id);
item->node_id = id;
item->input_start = frame_info->total_inputs;
frame_info->total_inputs += n->num_inputs();
Status s = params_.create_kernel(n->properties(), &item->kernel);
if (!s.ok()) {
item->kernel = nullptr;
s = AttachDef(s, *n);
return s;
}
CHECK(item->kernel);
item->kernel_is_async = (item->kernel->AsAsync() != nullptr);
item->is_merge = IsMerge(n);
item->is_any_consumer_merge_or_control_trigger = false;
for (const Node* consumer : n->out_nodes()) {
if (IsMerge(consumer) || IsControlTrigger(consumer)) {
item->is_any_consumer_merge_or_control_trigger = true;
break;
}
}
const Tensor* const_tensor = item->kernel->const_tensor();
if (const_tensor) {
const_tensors_.emplace_back(*const_tensor);
}
item->const_tensor = const_tensor;
item->is_noop = (item->kernel->type_string_view() == ""NoOp"");
item->is_enter = IsEnter(n);
if (item->is_enter) {
bool is_constant_enter;
TF_RETURN_IF_ERROR(
GetNodeAttr(n->attrs(), ""is_constant"", &is_constant_enter));
item->is_constant_enter = is_constant_enter;
string frame_name;
TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), ""frame_name"", &frame_name));
FrameInfo* frame_info = frame_info_[frame_name].get();
int parallel_iterations;
TF_RETURN_IF_ERROR(
GetNodeAttr(n->attrs(), ""parallel_iterations"", &parallel_iterations));
if (frame_info->parallel_iterations == -1) {
frame_info->parallel_iterations = parallel_iterations;
} else if (frame_info->parallel_iterations != parallel_iterations) {
LOG(WARNING) << ""Loop frame \"""" << frame_name
<< ""\"" had two different values for parallel_iterations: ""
<< frame_info->parallel_iterations << "" vs. ""
<< parallel_iterations << ""."";
}
if (enter_frame_info_.size() <= id) {
enter_frame_info_.resize(id + 1);
}
enter_frame_info_[id] = frame_info;
} else {
item->is_constant_enter = false;
}
item->is_exit = IsExit(n);
item->is_control_trigger = IsControlTrigger(n);
item->is_source = IsSource(n);
item->is_enter_exit_or_next_iter =
(IsEnter(n) || IsExit(n) || IsNextIteration(n));
item->is_transfer_node = IsTransferNode(n);
item->is_initialization_op = IsInitializationOp(n);
item->is_recv_or_switch = IsRecv(n) || IsSwitch(n);
item->is_next_iteration = IsNextIteration(n);
item->is_distributed_communication = IsDistributedCommunication(n);
size_t max_pending, max_dead;
GetMaxPendingCounts(n, &max_pending, &max_dead);
pending_ids_[id] =
frame_info->pending_counts_layout.CreateHandle(max_pending, max_dead);
if (n->in_edges().empty()) {
root_nodes_.push_back(item);
}
frame_info->nodes->push_back(item);
if (item->is_enter) {
string enter_name;
TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), ""frame_name"", &enter_name));
EnsureFrameInfo(enter_name)->input_count++;
}
std::unique_ptr<bool[]> outputs_required(new bool[n->num_outputs()]);
std::fill(&outputs_required[0], &outputs_required[n->num_outputs()], false);
int32_t unused_outputs = n->num_outputs();
for (const Edge* e : n->out_edges()) {
if (IsSink(e->dst())) continue;
if (e->src_output() >= 0) {
if (!outputs_required[e->src_output()]) {
--unused_outputs;
outputs_required[e->src_output()] = true;
}
}
}
if (unused_outputs > 0) {
for (int i = 0; i < n->num_outputs(); ++i) {
if (!outputs_required[i]) {
metrics::RecordUnusedOutput(n->type_string());
}
}
item->outputs_required = std::move(outputs_required);
}
}
for (const Node* n : graph.nodes()) {
if (IsSink(n)) continue;
const int id = n->id();
NodeItem* item = gview_.node(id);
for (EdgeInfo& e : item->mutable_output_edges()) {
const int dst_id = e.dst_id;
NodeItem* dst_item = gview_.node(dst_id);
e.input_slot += dst_item->input_start;
}
}
InitializePending(&graph, cf_info);
return gview_.SetAllocAttrs(&graph, params_.device);
}","Status ImmutableExecutorState::Initialize(const Graph& VAR_0) {
TF_RETURN_IF_ERROR(VAR_1.Initialize(&VAR_0));
ControlFlowInfo VAR_2;
TF_RETURN_IF_ERROR(BuildControlFlowInfo(&VAR_0, &VAR_2));
for (auto& VAR_3 : VAR_2.unique_frame_names) {
EnsureFrameInfo(VAR_3)->nodes =
absl::VAR_4<std::vector<const NodeItem*>>();
}
VAR_5 = VAR_6[""""].get();
VAR_7.resize(VAR_1.num_nodes());
VAR_8 = false;
for (const Node* VAR_9 : VAR_0.nodes()) {
if (IsSink(VAR_9)) continue;
if (IsSwitch(VAR_9) || IsMerge(VAR_9) || IsEnter(VAR_9) || IsExit(VAR_9)) {
VAR_8 = true;
} else if (IsRecv(VAR_9)) {
string VAR_10;
string VAR_11;
TF_RETURN_IF_ERROR(GetNodeAttr(VAR_9->attrs(), ""send_device"", &VAR_10));
TF_RETURN_IF_ERROR(GetNodeAttr(VAR_9->attrs(), ""recv_device"", &VAR_11));
if (VAR_10 != VAR_11) {
VAR_8 = true;
}
}
const int VAR_12 = VAR_9->id();
const string& VAR_13 = VAR_2.frame_names[VAR_12];
FrameInfo* VAR_14 = EnsureFrameInfo(VAR_13);
NodeItem* VAR_15 = VAR_1.node(VAR_12);
VAR_15->node_id = VAR_12;
VAR_15->input_start = VAR_14->total_inputs;
VAR_14->total_inputs += VAR_9->num_inputs();
Status VAR_16 = VAR_17.create_kernel(VAR_9->properties(), &VAR_15->kernel);
if (!VAR_16.ok()) {
VAR_15->kernel = nullptr;
VAR_16 = AttachDef(VAR_16, *VAR_9);
return VAR_16;
}
CHECK(VAR_15->kernel);
VAR_15->kernel_is_async = (VAR_15->kernel->AsAsync() != nullptr);
VAR_15->is_merge = IsMerge(VAR_9);
VAR_15->is_any_consumer_merge_or_control_trigger = false;
for (const Node* VAR_18 : VAR_9->out_nodes()) {
if (IsMerge(VAR_18) || IsControlTrigger(VAR_18)) {
VAR_15->is_any_consumer_merge_or_control_trigger = true;
break;
}
}
const Tensor* VAR_19 = VAR_15->kernel->const_tensor();
if (VAR_19) {
VAR_20.emplace_back(*VAR_19);
}
VAR_15->const_tensor = VAR_19;
VAR_15->is_noop = (VAR_15->kernel->type_string_view() == ""NoOp"");
VAR_15->is_enter = IsEnter(VAR_9);
if (VAR_15->is_enter) {
bool VAR_21;
TF_RETURN_IF_ERROR(
GetNodeAttr(VAR_9->attrs(), ""is_constant"", &VAR_21));
VAR_15->is_constant_enter = VAR_21;
string VAR_13;
TF_RETURN_IF_ERROR(GetNodeAttr(VAR_9->attrs(), ""frame_name"", &VAR_13));
FrameInfo* VAR_14 = VAR_6[VAR_13].get();
int VAR_22;
TF_RETURN_IF_ERROR(
GetNodeAttr(VAR_9->attrs(), ""parallel_iterations"", &VAR_22));
if (VAR_14->parallel_iterations == -1) {
VAR_14->parallel_iterations = VAR_22;
} else if (VAR_14->parallel_iterations != VAR_22) {
LOG(VAR_23) << ""Loop frame \"""" << VAR_13
<< ""\"" had two different values for parallel_iterations: ""
<< VAR_14->parallel_iterations << "" vs. ""
<< VAR_22 << ""."";
}
if (VAR_24.size() <= VAR_12) {
VAR_24.resize(VAR_12 + 1);
}
VAR_24[VAR_12] = VAR_14;
} else {
VAR_15->is_constant_enter = false;
}
VAR_15->is_exit = IsExit(VAR_9);
VAR_15->is_control_trigger = IsControlTrigger(VAR_9);
VAR_15->is_source = IsSource(VAR_9);
VAR_15->is_enter_exit_or_next_iter =
(IsEnter(VAR_9) || IsExit(VAR_9) || IsNextIteration(VAR_9));
VAR_15->is_transfer_node = IsTransferNode(VAR_9);
VAR_15->is_initialization_op = IsInitializationOp(VAR_9);
VAR_15->is_recv_or_switch = IsRecv(VAR_9) || IsSwitch(VAR_9);
VAR_15->is_next_iteration = IsNextIteration(VAR_9);
VAR_15->is_distributed_communication = IsDistributedCommunication(VAR_9);
size_t VAR_25, VAR_26;
GetMaxPendingCounts(VAR_9, &VAR_25, &VAR_26);
VAR_7[VAR_12] =
VAR_14->pending_counts_layout.CreateHandle(VAR_25, VAR_26);
if (VAR_9->in_edges().empty()) {
VAR_27.push_back(VAR_15);
}
VAR_14->nodes->push_back(VAR_15);
if (VAR_15->is_enter) {
string VAR_28;
TF_RETURN_IF_ERROR(GetNodeAttr(VAR_9->attrs(), ""frame_name"", &VAR_28));
EnsureFrameInfo(VAR_28)->input_count++;
}
std::unique_ptr<bool[]> VAR_29(new bool[VAR_9->num_outputs()]);
std::fill(&VAR_29[0], &VAR_29[VAR_9->num_outputs()], false);
int32_t VAR_30 = VAR_9->num_outputs();
for (const Edge* VAR_31 : VAR_9->out_edges()) {
if (IsSink(VAR_31->dst())) continue;
if (VAR_31->src_output() >= 0) {
if (!VAR_29[VAR_31->src_output()]) {
--VAR_30;
VAR_29[VAR_31->src_output()] = true;
}
}
}
if (VAR_30 > 0) {
for (int VAR_32 = 0; VAR_32 < VAR_9->num_outputs(); ++VAR_32) {
if (!VAR_29[VAR_32]) {
metrics::RecordUnusedOutput(VAR_9->type_string());
}
}
VAR_15->outputs_required = std::move(VAR_29);
}
}
for (const Node* VAR_9 : VAR_0.nodes()) {
if (IsSink(VAR_9)) continue;
const int VAR_12 = VAR_9->id();
NodeItem* VAR_15 = VAR_1.node(VAR_12);
for (EdgeInfo& VAR_31 : VAR_15->mutable_output_edges()) {
const int VAR_33 = VAR_31.dst_id;
NodeItem* VAR_34 = VAR_1.node(VAR_33);
VAR_31.input_slot += VAR_34->input_start;
}
}
InitializePending(&VAR_0, VAR_2);
return VAR_1.SetAllocAttrs(&VAR_0, VAR_17.device);
}",tensorflow/c79ccba517dbb1a0ccb9b01ee3bd2a63748b60dd/immutable_executor_state.cc/vul/before/0.json,"Status ImmutableExecutorState::Initialize(const Graph& graph) {
  TF_RETURN_IF_ERROR(gview_.Initialize(&graph));

  // Build the information about frames in this subgraph.
  ControlFlowInfo cf_info;
  TF_RETURN_IF_ERROR(BuildControlFlowInfo(&graph, &cf_info));

  for (auto& it : cf_info.unique_frame_names) {
    EnsureFrameInfo(it)->nodes =
        absl::make_unique<std::vector<const NodeItem*>>();
  }
  root_frame_info_ = frame_info_[""""].get();

  pending_ids_.resize(gview_.num_nodes());

  // Preprocess every node in the graph to create an instance of op
  // kernel for each node.
  requires_control_flow_ = false;
  for (const Node* n : graph.nodes()) {
    if (IsSink(n)) continue;
    if (IsSwitch(n) || IsMerge(n) || IsEnter(n) || IsExit(n)) {
      requires_control_flow_ = true;
    } else if (IsRecv(n)) {
      // A Recv node from a different device may produce dead tensors from
      // non-local control-flow nodes.
      //
      // TODO(mrry): Track whether control flow was present in the
      // pre-partitioned graph, and enable the caller (e.g.
      // `DirectSession`) to relax this constraint.
      string send_device;
      string recv_device;
      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), ""send_device"", &send_device));
      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), ""recv_device"", &recv_device));
      if (send_device != recv_device) {
        requires_control_flow_ = true;
      }
    }

    const int id = n->id();
    const string& frame_name = cf_info.frame_names[id];
    FrameInfo* frame_info = EnsureFrameInfo(frame_name);

    NodeItem* item = gview_.node(id);
    item->node_id = id;

    item->input_start = frame_info->total_inputs;
    frame_info->total_inputs += n->num_inputs();

    Status s = params_.create_kernel(n->properties(), &item->kernel);
    if (!s.ok()) {
      params_.delete_kernel(item->kernel);
      item->kernel = nullptr;
      s = AttachDef(s, *n);
      return s;
    }
    CHECK(item->kernel);
    item->kernel_is_async = (item->kernel->AsAsync() != nullptr);
    item->is_merge = IsMerge(n);
    item->is_any_consumer_merge_or_control_trigger = false;
    for (const Node* consumer : n->out_nodes()) {
      if (IsMerge(consumer) || IsControlTrigger(consumer)) {
        item->is_any_consumer_merge_or_control_trigger = true;
        break;
      }
    }
    const Tensor* const_tensor = item->kernel->const_tensor();
    if (const_tensor) {
      // Hold onto a shallow copy of the constant tensor in `*this` so that the
      // reference count does not drop to 1. This prevents the constant tensor
      // from being forwarded, and its buffer reused.
      const_tensors_.emplace_back(*const_tensor);
    }
    item->const_tensor = const_tensor;
    item->is_noop = (item->kernel->type_string_view() == ""NoOp"");
    item->is_enter = IsEnter(n);
    if (item->is_enter) {
      bool is_constant_enter;
      TF_RETURN_IF_ERROR(
          GetNodeAttr(n->attrs(), ""is_constant"", &is_constant_enter));
      item->is_constant_enter = is_constant_enter;

      string frame_name;
      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), ""frame_name"", &frame_name));
      FrameInfo* frame_info = frame_info_[frame_name].get();

      int parallel_iterations;
      TF_RETURN_IF_ERROR(
          GetNodeAttr(n->attrs(), ""parallel_iterations"", &parallel_iterations));

      if (frame_info->parallel_iterations == -1) {
        frame_info->parallel_iterations = parallel_iterations;
      } else if (frame_info->parallel_iterations != parallel_iterations) {
        LOG(WARNING) << ""Loop frame \"""" << frame_name
                     << ""\"" had two different values for parallel_iterations: ""
                     << frame_info->parallel_iterations << "" vs. ""
                     << parallel_iterations << ""."";
      }

      if (enter_frame_info_.size() <= id) {
        enter_frame_info_.resize(id + 1);
      }
      enter_frame_info_[id] = frame_info;
    } else {
      item->is_constant_enter = false;
    }
    item->is_exit = IsExit(n);
    item->is_control_trigger = IsControlTrigger(n);
    item->is_source = IsSource(n);
    item->is_enter_exit_or_next_iter =
        (IsEnter(n) || IsExit(n) || IsNextIteration(n));
    item->is_transfer_node = IsTransferNode(n);
    item->is_initialization_op = IsInitializationOp(n);
    item->is_recv_or_switch = IsRecv(n) || IsSwitch(n);
    item->is_next_iteration = IsNextIteration(n);
    item->is_distributed_communication = IsDistributedCommunication(n);

    // Compute the maximum values we'll store for this node in the
    // pending counts data structure, and allocate a handle in
    // that frame's pending counts data structure that has enough
    // space to store these maximal count values.
    size_t max_pending, max_dead;
    GetMaxPendingCounts(n, &max_pending, &max_dead);
    pending_ids_[id] =
        frame_info->pending_counts_layout.CreateHandle(max_pending, max_dead);

    // See if this node is a root node, and if so, add item to root_nodes_.
    if (n->in_edges().empty()) {
      root_nodes_.push_back(item);
    }

    // Initialize static information about the frames in the graph.
    frame_info->nodes->push_back(item);
    if (item->is_enter) {
      string enter_name;
      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), ""frame_name"", &enter_name));
      EnsureFrameInfo(enter_name)->input_count++;
    }

    // Record information about whether each output of the op is used.
    std::unique_ptr<bool[]> outputs_required(new bool[n->num_outputs()]);
    std::fill(&outputs_required[0], &outputs_required[n->num_outputs()], false);
    int32_t unused_outputs = n->num_outputs();
    for (const Edge* e : n->out_edges()) {
      if (IsSink(e->dst())) continue;
      if (e->src_output() >= 0) {
        if (!outputs_required[e->src_output()]) {
          --unused_outputs;
          outputs_required[e->src_output()] = true;
        }
      }
    }
    if (unused_outputs > 0) {
      for (int i = 0; i < n->num_outputs(); ++i) {
        if (!outputs_required[i]) {
          metrics::RecordUnusedOutput(n->type_string());
        }
      }
      item->outputs_required = std::move(outputs_required);
    }
  }

  // Rewrite each `EdgeInfo::input_slot` member to refer directly to the input
  // location.
  for (const Node* n : graph.nodes()) {
    if (IsSink(n)) continue;
    const int id = n->id();
    NodeItem* item = gview_.node(id);

    for (EdgeInfo& e : item->mutable_output_edges()) {
      const int dst_id = e.dst_id;
      NodeItem* dst_item = gview_.node(dst_id);
      e.input_slot += dst_item->input_start;
    }
  }

  // Initialize PendingCounts only after pending_ids_[node.id] is initialized
  // for all nodes.
  InitializePending(&graph, cf_info);
  return gview_.SetAllocAttrs(&graph, params_.device);
}","Status ImmutableExecutorState::Initialize(const Graph& VAR_0) {
  TF_RETURN_IF_ERROR(VAR_1.Initialize(&VAR_0));

  /* COMMENT_0 */
  ControlFlowInfo VAR_2;
  TF_RETURN_IF_ERROR(BuildControlFlowInfo(&VAR_0, &VAR_2));

  for (auto& VAR_3 : VAR_2.unique_frame_names) {
    EnsureFrameInfo(VAR_3)->nodes =
        absl::VAR_4<std::vector<const NodeItem*>>();
  }
  VAR_5 = VAR_6[""""].get();

  VAR_7.resize(VAR_1.num_nodes());

  /* COMMENT_1 */
  /* COMMENT_2 */
  VAR_8 = false;
  for (const Node* VAR_9 : VAR_0.nodes()) {
    if (IsSink(VAR_9)) continue;
    if (IsSwitch(VAR_9) || IsMerge(VAR_9) || IsEnter(VAR_9) || IsExit(VAR_9)) {
      VAR_8 = true;
    } else if (IsRecv(VAR_9)) {
      /* COMMENT_3 */
      /* COMMENT_4 */
      /* COMMENT_5 */
      /* COMMENT_6 */
      /* COMMENT_7 */
      /* COMMENT_8 */
      string VAR_10;
      string VAR_11;
      TF_RETURN_IF_ERROR(GetNodeAttr(VAR_9->attrs(), ""send_device"", &VAR_10));
      TF_RETURN_IF_ERROR(GetNodeAttr(VAR_9->attrs(), ""recv_device"", &VAR_11));
      if (VAR_10 != VAR_11) {
        VAR_8 = true;
      }
    }

    const int VAR_12 = VAR_9->id();
    const string& VAR_13 = VAR_2.frame_names[VAR_12];
    FrameInfo* VAR_14 = EnsureFrameInfo(VAR_13);

    NodeItem* VAR_15 = VAR_1.node(VAR_12);
    VAR_15->node_id = VAR_12;

    VAR_15->input_start = VAR_14->total_inputs;
    VAR_14->total_inputs += VAR_9->num_inputs();

    Status VAR_16 = VAR_17.create_kernel(VAR_9->properties(), &VAR_15->kernel);
    if (!VAR_16.ok()) {
      VAR_17.delete_kernel(VAR_15->kernel);
      VAR_15->kernel = nullptr;
      VAR_16 = AttachDef(VAR_16, *VAR_9);
      return VAR_16;
    }
    CHECK(VAR_15->kernel);
    VAR_15->kernel_is_async = (VAR_15->kernel->AsAsync() != nullptr);
    VAR_15->is_merge = IsMerge(VAR_9);
    VAR_15->is_any_consumer_merge_or_control_trigger = false;
    for (const Node* VAR_18 : VAR_9->out_nodes()) {
      if (IsMerge(VAR_18) || IsControlTrigger(VAR_18)) {
        VAR_15->is_any_consumer_merge_or_control_trigger = true;
        break;
      }
    }
    const Tensor* VAR_19 = VAR_15->kernel->const_tensor();
    if (VAR_19) {
      /* COMMENT_9 */
      /* COMMENT_10 */
      /* COMMENT_11 */
      VAR_20.emplace_back(*VAR_19);
    }
    VAR_15->const_tensor = VAR_19;
    VAR_15->is_noop = (VAR_15->kernel->type_string_view() == ""NoOp"");
    VAR_15->is_enter = IsEnter(VAR_9);
    if (VAR_15->is_enter) {
      bool VAR_21;
      TF_RETURN_IF_ERROR(
          GetNodeAttr(VAR_9->attrs(), ""is_constant"", &VAR_21));
      VAR_15->is_constant_enter = VAR_21;

      string VAR_13;
      TF_RETURN_IF_ERROR(GetNodeAttr(VAR_9->attrs(), ""frame_name"", &VAR_13));
      FrameInfo* VAR_14 = VAR_6[VAR_13].get();

      int VAR_22;
      TF_RETURN_IF_ERROR(
          GetNodeAttr(VAR_9->attrs(), ""parallel_iterations"", &VAR_22));

      if (VAR_14->parallel_iterations == -1) {
        VAR_14->parallel_iterations = VAR_22;
      } else if (VAR_14->parallel_iterations != VAR_22) {
        LOG(VAR_23) << ""Loop frame \"""" << VAR_13
                     << ""\"" had two different values for parallel_iterations: ""
                     << VAR_14->parallel_iterations << "" vs. ""
                     << VAR_22 << ""."";
      }

      if (VAR_24.size() <= VAR_12) {
        VAR_24.resize(VAR_12 + 1);
      }
      VAR_24[VAR_12] = VAR_14;
    } else {
      VAR_15->is_constant_enter = false;
    }
    VAR_15->is_exit = IsExit(VAR_9);
    VAR_15->is_control_trigger = IsControlTrigger(VAR_9);
    VAR_15->is_source = IsSource(VAR_9);
    VAR_15->is_enter_exit_or_next_iter =
        (IsEnter(VAR_9) || IsExit(VAR_9) || IsNextIteration(VAR_9));
    VAR_15->is_transfer_node = IsTransferNode(VAR_9);
    VAR_15->is_initialization_op = IsInitializationOp(VAR_9);
    VAR_15->is_recv_or_switch = IsRecv(VAR_9) || IsSwitch(VAR_9);
    VAR_15->is_next_iteration = IsNextIteration(VAR_9);
    VAR_15->is_distributed_communication = IsDistributedCommunication(VAR_9);

    /* COMMENT_12 */
    /* COMMENT_13 */
    /* COMMENT_14 */
    /* COMMENT_15 */
    size_t VAR_25, VAR_26;
    GetMaxPendingCounts(VAR_9, &VAR_25, &VAR_26);
    VAR_7[VAR_12] =
        VAR_14->pending_counts_layout.CreateHandle(VAR_25, VAR_26);

    /* COMMENT_16 */
    if (VAR_9->in_edges().empty()) {
      VAR_27.push_back(VAR_15);
    }

    /* COMMENT_17 */
    VAR_14->nodes->push_back(VAR_15);
    if (VAR_15->is_enter) {
      string VAR_28;
      TF_RETURN_IF_ERROR(GetNodeAttr(VAR_9->attrs(), ""frame_name"", &VAR_28));
      EnsureFrameInfo(VAR_28)->input_count++;
    }

    /* COMMENT_18 */
    std::unique_ptr<bool[]> VAR_29(new bool[VAR_9->num_outputs()]);
    std::fill(&VAR_29[0], &VAR_29[VAR_9->num_outputs()], false);
    int32_t VAR_30 = VAR_9->num_outputs();
    for (const Edge* VAR_31 : VAR_9->out_edges()) {
      if (IsSink(VAR_31->dst())) continue;
      if (VAR_31->src_output() >= 0) {
        if (!VAR_29[VAR_31->src_output()]) {
          --VAR_30;
          VAR_29[VAR_31->src_output()] = true;
        }
      }
    }
    if (VAR_30 > 0) {
      for (int VAR_32 = 0; VAR_32 < VAR_9->num_outputs(); ++VAR_32) {
        if (!VAR_29[VAR_32]) {
          metrics::RecordUnusedOutput(VAR_9->type_string());
        }
      }
      VAR_15->outputs_required = std::move(VAR_29);
    }
  }

  /* COMMENT_19 */
  /* COMMENT_20 */
  for (const Node* VAR_9 : VAR_0.nodes()) {
    if (IsSink(VAR_9)) continue;
    const int VAR_12 = VAR_9->id();
    NodeItem* VAR_15 = VAR_1.node(VAR_12);

    for (EdgeInfo& VAR_31 : VAR_15->mutable_output_edges()) {
      const int VAR_33 = VAR_31.dst_id;
      NodeItem* VAR_34 = VAR_1.node(VAR_33);
      VAR_31.input_slot += VAR_34->input_start;
    }
  }

  /* COMMENT_21 */
  /* COMMENT_22 */
  InitializePending(&VAR_0, VAR_2);
  return VAR_1.SetAllocAttrs(&VAR_0, VAR_17.device);
}",tensorflow/c79ccba517dbb1a0ccb9b01ee3bd2a63748b60dd/immutable_executor_state.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -48,6 +48,7 @@
 
     Status s = params_.create_kernel(n->properties(), &item->kernel);
     if (!s.ok()) {
+      params_.delete_kernel(item->kernel);
       item->kernel = nullptr;
       s = AttachDef(s, *n);
       return s;","{'deleted_lines': [], 'added_lines': ['      params_.delete_kernel(item->kernel);']}",True,"Tensorflow is an Open Source Machine Learning Framework. If a graph node is invalid, TensorFlow can leak memory in the implementation of `ImmutableExecutorState::Initialize`. Here, we set `item->kernel` to `nullptr` but it is a simple `OpKernel*` pointer so the memory that was previously allocated to it would leak. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",4.3,MEDIUM,1,test,2021-11-10T21:51:15Z,3
CVE-2023-27601,['CWE-20'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,OpenSIPS/opensips,"[sipmsgops] fix codec_delete_XX() parsing

Issue discovered during OpenSIPS Security Audit 2021,
        by Alfred Farrugia & Sandro Gauci (Enable Security)

https://github.com/OpenSIPS/opensips/security/advisories/GHSA-xj5x-g52f-548h",8f87c7c03da55f9c79bd92e67fa2c94b2a7ce5cf,https://github.com/OpenSIPS/opensips/commit/8f87c7c03da55f9c79bd92e67fa2c94b2a7ce5cf,modules/sipmsgops/codecs.c,delete_sdp_line,"int delete_sdp_line( struct sip_msg * msg, char * s)
{
char * start,*end;
if( !s )
return 1;
start = s;
end  = s;
while(*start != '\n')
start--;
start++;
while(*end != '\n')
end++;
end++;
if( del_lump(msg, start - msg->buf, end - start,0) == NULL )
{
return -1;
}
return 0;
}","int delete_sdp_line( struct sip_msg * VAR_0, char * VAR_1)
{
char * VAR_2,*VAR_3;
if( !VAR_1 )
return 1;
VAR_2 = VAR_1;
VAR_3  = VAR_1;
while(*VAR_2 != '\n')
VAR_2--;
VAR_2++;
while(*VAR_3 != '\n')
VAR_3++;
VAR_3++;
if( del_lump(VAR_0, VAR_2 - VAR_0->buf, VAR_3 - VAR_2,0) == NULL )
{
return -1;
}
return 0;
}",OpenSIPS/opensips/8f87c7c03da55f9c79bd92e67fa2c94b2a7ce5cf/codecs.c/vul/before/0.json,"int delete_sdp_line( struct sip_msg * msg, char * s, struct sdp_stream_cell *stream)
{
	char * start,*end;

	if( !s )
		return 1;

	start = s;
	end  = s;

	while(*start != '\n' && start > stream->body.s)
		start--;
	start++;

	while(*end != '\n' && end < (stream->body.s+stream->body.len) )
		end++;
	end++;

	/* delete the entry */
	if( del_lump(msg, start - msg->buf, end - start,0) == NULL )
	{
		return -1;
	}

	return 0;
}","int delete_sdp_line( struct sip_msg * VAR_0, char * VAR_1, struct sdp_stream_cell *VAR_2)
{
	char * VAR_3,*VAR_4;

	if( !VAR_1 )
		return 1;

	VAR_3 = VAR_1;
	VAR_4  = VAR_1;

	while(*VAR_3 != '\n' && VAR_3 > VAR_2->body.s)
		VAR_3--;
	VAR_3++;

	while(*VAR_4 != '\n' && VAR_4 < (VAR_2->body.s+VAR_2->body.len) )
		VAR_4++;
	VAR_4++;

	/* COMMENT_0 */
	if( del_lump(VAR_0, VAR_3 - VAR_0->buf, VAR_4 - VAR_3,0) == NULL )
	{
		return -1;
	}

	return 0;
}",OpenSIPS/opensips/8f87c7c03da55f9c79bd92e67fa2c94b2a7ce5cf/codecs.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-int delete_sdp_line( struct sip_msg * msg, char * s)
+int delete_sdp_line( struct sip_msg * msg, char * s, struct sdp_stream_cell *stream)
 {
 	char * start,*end;
 
@@ -8,11 +8,11 @@
 	start = s;
 	end  = s;
 
-	while(*start != '\n')
+	while(*start != '\n' && start > stream->body.s)
 		start--;
 	start++;
 
-	while(*end != '\n')
+	while(*end != '\n' && end < (stream->body.s+stream->body.len) )
 		end++;
 	end++;
 ","{'deleted_lines': ['int delete_sdp_line( struct sip_msg * msg, char * s)', ""\twhile(*start != '\\n')"", ""\twhile(*end != '\\n')""], 'added_lines': ['int delete_sdp_line( struct sip_msg * msg, char * s, struct sdp_stream_cell *stream)', ""\twhile(*start != '\\n' && start > stream->body.s)"", ""\twhile(*end != '\\n' && end < (stream->body.s+stream->body.len) )""]}",True,"OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.7 and 3.2.4, OpenSIPS crashes when a malformed SDP body is received and is processed by the `delete_sdp_line` function in the sipmsgops module. This issue can be reproduced by calling the function with an SDP body that does not terminate by a line feed (i.e. `\n`).

The vulnerability was found while performing black-box fuzzing against an OpenSIPS server running a configuration that made use of the functions `codec_delete_except_re` and `codec_delete_re`. The same issue was also discovered while performing coverage guided fuzzing on the function `codec_delete_except_re`. The crash happens because the function `delete_sdp_line` expects that an SDP line is terminated by a line feed (`\n`):

By abusing this vulnerability, an attacker is able to crash the server. It affects configurations containing functions that rely on the affected code, such as the function `codec_delete_except_re`. Due to the sanity check that is performed in the `del_lump` function, exploitation of this issue will generate an `abort` in the lumps processing function, resulting in a Denial of Service. This issue has been fixed in versions 3.1.7 and 3.2.4.",7.5,HIGH,2,test,2021-11-11T13:33:30Z,3
CVE-2023-27601,['CWE-20'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,OpenSIPS/opensips,"[sipmsgops] fix codec_delete_XX() parsing

Issue discovered during OpenSIPS Security Audit 2021,
        by Alfred Farrugia & Sandro Gauci (Enable Security)

https://github.com/OpenSIPS/opensips/security/advisories/GHSA-xj5x-g52f-548h",8f87c7c03da55f9c79bd92e67fa2c94b2a7ce5cf,https://github.com/OpenSIPS/opensips/commit/8f87c7c03da55f9c79bd92e67fa2c94b2a7ce5cf,modules/sipmsgops/codecs.c,stream_process,"static int stream_process(struct sip_msg * msg, struct sdp_stream_cell *cell,
str * s, str* ss, regex_t* re, int op,int description)
{
static sdp_payload_attr_t static_payloads[] = {
{ NULL,0,{ ""3"",1},{ ""GSM"",3},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{ ""4"",1},{""G723"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{ ""5"",1},{""DVI4"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{ ""6"",1},{""DVI4"",4},{""16000"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{ ""7"",1},{ ""LPC"",3},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{ ""8"",1},{""PCMA"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{ ""9"",1},{""G722"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{""10"",2},{ ""L16"",3},{""44100"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""11"",2},{ ""L16"",3},{""44100"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""12"",2},{""QCELP"",5},{""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{""13"",2},{  ""CN"",2},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{""14"",2},{ ""MPA"",3},{""90000"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""15"",2},{""G728"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{""16"",2},{""DVI4"",4},{""11025"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""17"",2},{""DVI4"",4},{""22050"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""18"",2},{""G729"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{""25"",2},{""CelB"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{""26"",2},{""JPEG"",4},{""90000"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""28"",2},{  ""nv"",2},{""90000"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""31"",2},{""H261"",4},{""90000"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""32"",2},{ ""MPV"",3},{""90000"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""33"",2},{""MP2T"",4},{""90000"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""34"",2},{""H263"",4},{""90000"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""t38"",3},{""t38"",3},{     """",0},{NULL,0},{NULL,0} },   
{ NULL,0,{NULL,0},{  NULL,0},{   NULL,0},{NULL,0},{NULL,0} }
};
sdp_payload_attr_t *payload;
char *cur, *tmp, *buff, temp;
struct lump * lmp;
str found;
int ret, i,match, buff_len, is_static;
regmatch_t pmatch;
lmp = get_associated_lump(msg, cell);
if( lmp == NULL)
{
LM_ERR(""There is no lump for this sdp cell\n"");
return -1;
}
if (lmp->len == 0)
return -1;
buff_len = 0;
ret = 0;
buff = pkg_malloc(lmp->len+1);
if( buff == NULL)
{
LM_ERR(""Out of memory\n"");
return -1;
}
is_static = 0;
payload = cell->payload_attr;
while(payload)
{
if( payload->rtp_enc.s == NULL
|| (payload->rtp_clock.s == NULL && ss != NULL)
|| payload->rtp_payload.s == NULL)
{
goto next_payload;
}
match = 0;
if( description == DESC_REGEXP ||description == DESC_REGEXP_COMPLEMENT )
{
if (is_static) {
match = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;
} else {
temp = payload->rtp_enc.s[payload->rtp_enc.len];
payload->rtp_enc.s[payload->rtp_enc.len] = 0;
match = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;
payload->rtp_enc.s[payload->rtp_enc.len] = temp;
}
}
if( description == DESC_REGEXP_COMPLEMENT)
match = !match;
if( description == DESC_NAME  )
{
match = s->len == payload->rtp_enc.len &&
strncasecmp( s->s, payload->rtp_enc.s ,payload->rtp_enc.len) == 0;
}
if( description == DESC_NAME_AND_CLOCK)
{
match = s->len == payload->rtp_enc.len &&
strncasecmp( s->s, payload->rtp_enc.s ,
payload->rtp_enc.len) == 0
&&
(ss == NULL || ( ss->len == payload->rtp_clock.len &&
strncasecmp( ss->s, payload->rtp_clock.s ,
payload->rtp_clock.len) == 0
) );
}
if (match) {
match = 0;
cur = lmp->u.value;
while( !match && cur < lmp->u.value + lmp->len)
{
found.s = cur;
while(  cur < lmp->u.value + lmp->len &&  *cur != ' ' )
cur++;
found.len = cur - found.s;
if ( found.len == payload->rtp_payload.len &&
strncmp( found.s,payload->rtp_payload.s,found.len) == 0) {
match = 1;
} else {
while( cur < lmp->u.value + lmp->len && * cur == ' '  )
cur++;
}
}
if (match) {
if(op == FIND)
{
ret = 1;
goto end;
}
if( op == DELETE && !is_static )
{
if( delete_sdp_line( msg, payload->rtp_enc.s) < 0 )
{
LM_ERR(""Unable to add delete lump for a=\n"");
ret = -1;
goto end;
}
if( delete_sdp_line( msg, payload->fmtp_string.s) < 0 )
{
LM_ERR(""Unable to add delete lump for a=\n"");
ret = -1;
goto end;
}
}
{
while (found.s > lmp->u.value && *(found.s - 1) == ' ') {
found.s--;
found.len++;
}
if (cur == lmp->u.value + lmp->len) {
tmp = found.s;
while (*(--tmp) == ' ') {
found.s--;
found.len++;
}
}
for(tmp=found.s ; tmp< lmp->u.value + lmp->len ; tmp++ )
*tmp  = *(tmp+found.len);
lmp->len -= found.len;
}
if( op == ADD_TO_FRONT  || op == ADD_TO_BACK)
{
memcpy(&buff[buff_len],"" "",1);
buff_len++;
memcpy(&buff[buff_len],payload->rtp_payload.s,
payload->rtp_payload.len);
buff_len += payload->rtp_payload.len;
}
ret = 1;
}
}
next_payload:
if (!is_static) {
payload = payload->next;
if (payload==NULL) {
payload = static_payloads;
is_static = 1;
}
} else {
payload ++;
if (payload->rtp_payload.s==NULL)
payload=NULL;
}
}
if( op == ADD_TO_FRONT && buff_len >0 )
{
lmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);
if(!lmp->u.value) {
LM_ERR(""No more pkg memory\n"");
ret = -1;
goto end;
}
for( i = lmp->len -1 ; i>=0;i--)
lmp->u.value[i+buff_len] = lmp->u.value[i];
memcpy(lmp->u.value,buff,buff_len);
lmp->len += buff_len;
}
if( op == ADD_TO_BACK && buff_len >0 )
{
lmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);
if(!lmp->u.value) {
LM_ERR(""No more pkg memory\n"");
ret = -1;
goto end;
}
memcpy(&lmp->u.value[lmp->len],buff,buff_len);
lmp->len += buff_len;
}
if (lmp->len == 0) {
lmp = del_lump(msg, cell->port.s - msg->buf - 1, cell->port.len + 2, 0);
if (!lmp) {
LM_ERR(""could not add lump to disable stream!\n"");
goto end;
}
tmp = pkg_malloc(3);
if (!tmp) {
LM_ERR(""oom for port 0\n"");
goto end;
}
memcpy(tmp, "" 0 "", 3);
if (!insert_new_lump_after(lmp, tmp, 3, 0))
LM_ERR(""could not insert lump to disable stream!\n"");
}
end:
pkg_free(buff);
return ret;
}","static int stream_process(struct sip_msg * VAR_0, struct sdp_stream_cell *VAR_1,
str * VAR_2, str* VAR_3, regex_t* VAR_4, int VAR_5,int VAR_6)
{
static sdp_payload_attr_t VAR_7[] = {
{ NULL,0,{ ""0"",1},{""PCMU"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{ ""3"",1},{ ""GSM"",3},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{ ""4"",1},{""G723"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{ ""5"",1},{""DVI4"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{ ""6"",1},{""DVI4"",4},{""16000"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{ ""7"",1},{ ""LPC"",3},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{ ""8"",1},{""PCMA"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{ ""9"",1},{""G722"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{""10"",2},{ ""L16"",3},{""44100"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""11"",2},{ ""L16"",3},{""44100"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""12"",2},{""QCELP"",5},{""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{""13"",2},{  ""CN"",2},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{""14"",2},{ ""MPA"",3},{""90000"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""15"",2},{""G728"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{""16"",2},{""DVI4"",4},{""11025"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""17"",2},{""DVI4"",4},{""22050"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""18"",2},{""G729"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{""25"",2},{""CelB"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   
{ NULL,0,{""26"",2},{""JPEG"",4},{""90000"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""28"",2},{  ""nv"",2},{""90000"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""31"",2},{""H261"",4},{""90000"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""32"",2},{ ""MPV"",3},{""90000"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""33"",2},{""MP2T"",4},{""90000"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""34"",2},{""H263"",4},{""90000"",5},{NULL,0},{NULL,0} },   
{ NULL,0,{""t38"",3},{""t38"",3},{     """",0},{NULL,0},{NULL,0} },   
{ NULL,0,{NULL,0},{  NULL,0},{   NULL,0},{NULL,0},{NULL,0} }
};
sdp_payload_attr_t *VAR_8;
char *VAR_9, *VAR_10, *VAR_11, VAR_12;
struct lump * VAR_13;
str VAR_14;
int VAR_15, VAR_16,VAR_17, VAR_18, VAR_19;
regmatch_t VAR_20;
VAR_13 = get_associated_lump(VAR_0, VAR_1);
if( VAR_13 == NULL)
{
LM_ERR(""There is no lump for this sdp cell\n"");
return -1;
}
if (VAR_13->len == 0)
return -1;
VAR_18 = 0;
VAR_15 = 0;
VAR_11 = pkg_malloc(VAR_13->len+1);
if( VAR_11 == NULL)
{
LM_ERR(""Out of memory\n"");
return -1;
}
VAR_19 = 0;
VAR_8 = VAR_1->payload_attr;
while(VAR_8)
{
if( VAR_8->rtp_enc.s == NULL
|| (VAR_8->rtp_clock.s == NULL && VAR_3 != NULL)
|| VAR_8->rtp_payload.s == NULL)
{
goto next_payload;
}
VAR_17 = 0;
if( VAR_6 == VAR_21 ||VAR_6 == VAR_22 )
{
if (VAR_19) {
VAR_17 = regexec( VAR_4, VAR_8->rtp_enc.s, 1, &VAR_20, 0) == 0;
} else {
VAR_12 = VAR_8->rtp_enc.s[VAR_8->rtp_enc.len];
VAR_8->rtp_enc.s[VAR_8->rtp_enc.len] = 0;
VAR_17 = regexec( VAR_4, VAR_8->rtp_enc.s, 1, &VAR_20, 0) == 0;
VAR_8->rtp_enc.s[VAR_8->rtp_enc.len] = VAR_12;
}
}
if( VAR_6 == VAR_22)
VAR_17 = !VAR_17;
if( VAR_6 == VAR_23  )
{
VAR_17 = VAR_2->len == VAR_8->rtp_enc.len &&
strncasecmp( VAR_2->s, VAR_8->rtp_enc.s ,VAR_8->rtp_enc.len) == 0;
}
if( VAR_6 == VAR_24)
{
VAR_17 = VAR_2->len == VAR_8->rtp_enc.len &&
strncasecmp( VAR_2->s, VAR_8->rtp_enc.s ,
VAR_8->rtp_enc.len) == 0
&&
(VAR_3 == NULL || ( VAR_3->len == VAR_8->rtp_clock.len &&
strncasecmp( VAR_3->s, VAR_8->rtp_clock.s ,
VAR_8->rtp_clock.len) == 0
) );
}
if (VAR_17) {
VAR_17 = 0;
VAR_9 = VAR_13->u.value;
while( !VAR_17 && VAR_9 < VAR_13->u.value + VAR_13->len)
{
VAR_14.s = VAR_9;
while(  VAR_9 < VAR_13->u.value + VAR_13->len &&  *VAR_9 != ' ' )
VAR_9++;
VAR_14.len = VAR_9 - VAR_14.s;
if ( VAR_14.len == VAR_8->rtp_payload.len &&
strncmp( VAR_14.s,VAR_8->rtp_payload.s,VAR_14.len) == 0) {
VAR_17 = 1;
} else {
while( VAR_9 < VAR_13->u.value + VAR_13->len && * VAR_9 == ' '  )
VAR_9++;
}
}
if (VAR_17) {
if(VAR_5 == VAR_25)
{
VAR_15 = 1;
goto end;
}
if( VAR_5 == VAR_26 && !VAR_19 )
{
if( delete_sdp_line( VAR_0, VAR_8->rtp_enc.s) < 0 )
{
LM_ERR(""Unable to add delete lump for a=\n"");
VAR_15 = -1;
goto end;
}
if( delete_sdp_line( VAR_0, VAR_8->fmtp_string.s) < 0 )
{
LM_ERR(""Unable to add delete lump for a=\n"");
VAR_15 = -1;
goto end;
}
}
{
while (VAR_14.s > VAR_13->u.value && *(VAR_14.s - 1) == ' ') {
VAR_14.s--;
VAR_14.len++;
}
if (VAR_9 == VAR_13->u.value + VAR_13->len) {
VAR_10 = VAR_14.s;
while (*(--VAR_10) == ' ') {
VAR_14.s--;
VAR_14.len++;
}
}
for(VAR_10=VAR_14.s ; VAR_10< VAR_13->u.value + VAR_13->len ; VAR_10++ )
*VAR_10  = *(VAR_10+VAR_14.len);
VAR_13->len -= VAR_14.len;
}
if( VAR_5 == VAR_27  || VAR_5 == VAR_28)
{
memcpy(&VAR_11[VAR_18],"" "",1);
VAR_18++;
memcpy(&VAR_11[VAR_18],VAR_8->rtp_payload.s,
VAR_8->rtp_payload.len);
VAR_18 += VAR_8->rtp_payload.len;
}
VAR_15 = 1;
}
}
next_payload:
if (!VAR_19) {
VAR_8 = VAR_8->next;
if (VAR_8==NULL) {
VAR_8 = VAR_7;
VAR_19 = 1;
}
} else {
VAR_8 ++;
if (VAR_8->rtp_payload.s==NULL)
VAR_8=NULL;
}
}
if( VAR_5 == VAR_27 && VAR_18 >0 )
{
VAR_13->u.value = (char*)pkg_realloc(VAR_13->u.value, VAR_13->len+VAR_18);
if(!VAR_13->u.value) {
LM_ERR(""No more pkg memory\n"");
VAR_15 = -1;
goto end;
}
for( VAR_16 = VAR_13->len -1 ; VAR_16>=0;VAR_16--)
VAR_13->u.value[VAR_16+VAR_18] = VAR_13->u.value[VAR_16];
memcpy(VAR_13->u.value,VAR_11,VAR_18);
VAR_13->len += VAR_18;
}
if( VAR_5 == VAR_28 && VAR_18 >0 )
{
VAR_13->u.value = (char*)pkg_realloc(VAR_13->u.value, VAR_13->len+VAR_18);
if(!VAR_13->u.value) {
LM_ERR(""No more pkg memory\n"");
VAR_15 = -1;
goto end;
}
memcpy(&VAR_13->u.value[VAR_13->len],VAR_11,VAR_18);
VAR_13->len += VAR_18;
}
if (VAR_13->len == 0) {
VAR_13 = del_lump(VAR_0, VAR_1->port.s - VAR_0->buf - 1, VAR_1->port.len + 2, 0);
if (!VAR_13) {
LM_ERR(""could not add lump to disable stream!\n"");
goto end;
}
VAR_10 = pkg_malloc(3);
if (!VAR_10) {
LM_ERR(""oom for port 0\n"");
goto end;
}
memcpy(VAR_10, "" 0 "", 3);
if (!insert_new_lump_after(VAR_13, VAR_10, 3, 0))
LM_ERR(""could not insert lump to disable stream!\n"");
}
end:
pkg_free(VAR_11);
return VAR_15;
}",OpenSIPS/opensips/8f87c7c03da55f9c79bd92e67fa2c94b2a7ce5cf/codecs.c/vul/before/1.json,"static int stream_process(struct sip_msg * msg, struct sdp_stream_cell *cell,
			str * s, str* ss, regex_t* re, int op,int description)
{
	static sdp_payload_attr_t static_payloads[] = {
	/* as per http://www.iana.org/assignments/rtp-parameters/rtp-parameters.xml */
	{ NULL,0,{ ""0"",1},{""PCMU"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   /* 0 - PCMU/8000  */
	{ NULL,0,{ ""3"",1},{ ""GSM"",3},{ ""8000"",4},{NULL,0},{NULL,0} },   /* 3 -  GSM/8000  */
	{ NULL,0,{ ""4"",1},{""G723"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   /* 4 - G723/8000  */
	{ NULL,0,{ ""5"",1},{""DVI4"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   /* 5 - DVI4/8000  */
	{ NULL,0,{ ""6"",1},{""DVI4"",4},{""16000"",5},{NULL,0},{NULL,0} },   /* 6 - DVI4/16000 */
	{ NULL,0,{ ""7"",1},{ ""LPC"",3},{ ""8000"",4},{NULL,0},{NULL,0} },   /* 7 -  LPC/8000  */
	{ NULL,0,{ ""8"",1},{""PCMA"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   /* 8 - PCMA/8000  */
	{ NULL,0,{ ""9"",1},{""G722"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   /* 9 - G722/8000  */
	{ NULL,0,{""10"",2},{ ""L16"",3},{""44100"",5},{NULL,0},{NULL,0} },   /*10 -  L16/44100 */
	{ NULL,0,{""11"",2},{ ""L16"",3},{""44100"",5},{NULL,0},{NULL,0} },   /*11 -  L16/44100 */
	{ NULL,0,{""12"",2},{""QCELP"",5},{""8000"",4},{NULL,0},{NULL,0} },   /*12 -QCELP/8000  */
	{ NULL,0,{""13"",2},{  ""CN"",2},{ ""8000"",4},{NULL,0},{NULL,0} },   /*13 -   CN/8000  */
	{ NULL,0,{""14"",2},{ ""MPA"",3},{""90000"",5},{NULL,0},{NULL,0} },   /*14 -  MPA/90000 */
	{ NULL,0,{""15"",2},{""G728"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   /*15 - G728/8000  */
	{ NULL,0,{""16"",2},{""DVI4"",4},{""11025"",5},{NULL,0},{NULL,0} },   /*16 - DVI4/11025 */
	{ NULL,0,{""17"",2},{""DVI4"",4},{""22050"",5},{NULL,0},{NULL,0} },   /*17 - DVI4/22050 */
	{ NULL,0,{""18"",2},{""G729"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   /*18 - G729/8000  */
	{ NULL,0,{""25"",2},{""CelB"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   /*25 - CelB/8000  */
	{ NULL,0,{""26"",2},{""JPEG"",4},{""90000"",5},{NULL,0},{NULL,0} },   /*26 - JPEG/90000 */
	{ NULL,0,{""28"",2},{  ""nv"",2},{""90000"",5},{NULL,0},{NULL,0} },   /*28 -   nv/90000 */
	{ NULL,0,{""31"",2},{""H261"",4},{""90000"",5},{NULL,0},{NULL,0} },   /*31 - H261/90000 */
	{ NULL,0,{""32"",2},{ ""MPV"",3},{""90000"",5},{NULL,0},{NULL,0} },   /*32 -  MPV/90000 */
	{ NULL,0,{""33"",2},{""MP2T"",4},{""90000"",5},{NULL,0},{NULL,0} },   /*33 - MP2T/90000 */
	{ NULL,0,{""34"",2},{""H263"",4},{""90000"",5},{NULL,0},{NULL,0} },   /*34 - H263/90000 */
	{ NULL,0,{""t38"",3},{""t38"",3},{     """",0},{NULL,0},{NULL,0} },   /*T38- fax        */
	{ NULL,0,{NULL,0},{  NULL,0},{   NULL,0},{NULL,0},{NULL,0} }
	};
	sdp_payload_attr_t *payload;
	char *cur, *tmp, *buff, temp;
	struct lump * lmp;
	str found;
	int ret, i,match, buff_len, is_static;
	regmatch_t pmatch;


	lmp = get_associated_lump(msg, cell);
	if( lmp == NULL)
	{
		LM_ERR(""There is no lump for this sdp cell\n"");
		return -1;
	}

	/* is stream deleted ?? */
	if (lmp->len == 0)
		return -1;


	buff_len = 0;
	ret = 0;

	buff = pkg_malloc(lmp->len+1);
	if( buff == NULL)
	{
		LM_ERR(""Out of memory\n"");
		return -1;
	}

	/* search through each payload */
	is_static = 0;
	payload = cell->payload_attr;

	while(payload)
	{
		if( payload->rtp_enc.s == NULL
		 || (payload->rtp_clock.s == NULL && ss != NULL)
		 || payload->rtp_payload.s == NULL)
		{
			goto next_payload;
		}

		match = 0;

		if( description == DESC_REGEXP ||description == DESC_REGEXP_COMPLEMENT )
		{
			/* try to match a regexp */
			if (is_static) {
				match = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;
			} else {
				temp = payload->rtp_enc.s[payload->rtp_enc.len];
				payload->rtp_enc.s[payload->rtp_enc.len] = 0;
				match = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;
				payload->rtp_enc.s[payload->rtp_enc.len] = temp;
			}
		}

		if( description == DESC_REGEXP_COMPLEMENT)
			match = !match;

		if( description == DESC_NAME  )
		{
			match = s->len == payload->rtp_enc.len &&
			strncasecmp( s->s, payload->rtp_enc.s ,	payload->rtp_enc.len) == 0;
		}

		if( description == DESC_NAME_AND_CLOCK)
		{
			/* try to match name and clock if there is one */
			match = s->len == payload->rtp_enc.len &&
			strncasecmp( s->s, payload->rtp_enc.s ,
				payload->rtp_enc.len) == 0
			&&
			(ss == NULL || ( ss->len == payload->rtp_clock.len &&
			strncasecmp( ss->s, payload->rtp_clock.s ,
				payload->rtp_clock.len) == 0
			) );
		}

		/* if found, search its index in the m= line */
		if (match) {

			match = 0;

			cur = lmp->u.value;
			while( !match && cur < lmp->u.value + lmp->len)
			{
				/* find the end of the number */
				found.s = cur;

				while(  cur < lmp->u.value + lmp->len &&  *cur != ' ' )
					cur++;

				found.len = cur - found.s;

				/* does it matches payload number */
				if ( found.len == payload->rtp_payload.len &&
				strncmp( found.s,payload->rtp_payload.s,found.len) == 0) {
					match = 1;
				} else {
					/* continue on searching => skip spaces
					   if there still are any */
					while( cur < lmp->u.value + lmp->len && * cur == ' '  )
						cur++;
				}
			}

			/* have we found both payload and index */
			if (match) {

				if(op == FIND)
				{
					ret = 1;
					goto end;
				}

				if( op == DELETE && !is_static )
				{
					/* find the full 'a=...' entry */

					if( delete_sdp_line( msg, payload->rtp_enc.s, cell) < 0 )
					{
						LM_ERR(""Unable to add delete lump for a=\n"");
						ret = -1;
						goto end;
					}

					if( delete_sdp_line( msg, payload->fmtp_string.s, cell) < 0 )
					{
						LM_ERR(""Unable to add delete lump for a=\n"");
						ret = -1;
						goto end;
					}
				}

				{
					/* take the previous whitespaces as well */
					while (found.s > lmp->u.value && *(found.s - 1) == ' ') {
						found.s--;
						found.len++;
					}

					/* when trimming the very last payload, avoid trailing ws */
					if (cur == lmp->u.value + lmp->len) {
						tmp = found.s;
						while (*(--tmp) == ' ') {
							found.s--;
							found.len++;
						}
					}

					/* delete the string and update iterators */
					for(tmp=found.s ; tmp< lmp->u.value + lmp->len ; tmp++ )
						*tmp  = *(tmp+found.len);

					//cur -= found.len;
					lmp->len -= found.len;
				}

				/* add the deleted number into a buffer to be addded later */
				if( op == ADD_TO_FRONT  || op == ADD_TO_BACK)
				{
					memcpy(&buff[buff_len],"" "",1);
					buff_len++;

					memcpy(&buff[buff_len],payload->rtp_payload.s,
						payload->rtp_payload.len);

					buff_len += payload->rtp_payload.len;
				}

				ret = 1;
			}

		}

		/* next payload */
	next_payload:
		if (!is_static) {
			payload = payload->next;
			if (payload==NULL) {
				payload = static_payloads;
				is_static = 1;
			}
		} else {
			payload ++;
			if (payload->rtp_payload.s==NULL)
				payload=NULL;
		}
	}


	if( op == ADD_TO_FRONT && buff_len >0 )
	{
		lmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);
		if(!lmp->u.value) {
			LM_ERR(""No more pkg memory\n"");
			ret = -1;
			goto end;
		}

		for( i = lmp->len -1 ; i>=0;i--)
			lmp->u.value[i+buff_len] = lmp->u.value[i];

		memcpy(lmp->u.value,buff,buff_len);

		lmp->len += buff_len;

	}

	if( op == ADD_TO_BACK && buff_len >0 )
	{

		lmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);
		if(!lmp->u.value) {
			LM_ERR(""No more pkg memory\n"");
			ret = -1;
			goto end;
		}

		memcpy(&lmp->u.value[lmp->len],buff,buff_len);

		lmp->len += buff_len;

	}

	/* if we ended up with a 0-length lump, then it means that all payloads
	 * have been deleted, therefore we need to disable the media stream */
	if (lmp->len == 0) {
		/* replace the media port with 0 - we also replace the spaces before
		 * and after the port, to make sure we have a larger buffer */
		lmp = del_lump(msg, cell->port.s - msg->buf - 1, cell->port.len + 2, 0);
		if (!lmp) {
			LM_ERR(""could not add lump to disable stream!\n"");
			goto end;
		}
		tmp = pkg_malloc(3);
		if (!tmp) {
			LM_ERR(""oom for port 0\n"");
			goto end;
		}
		memcpy(tmp, "" 0 "", 3);
		if (!insert_new_lump_after(lmp, tmp, 3, 0))
			LM_ERR(""could not insert lump to disable stream!\n"");
	}

end:
	pkg_free(buff);
	return ret;
}","static int stream_process(struct sip_msg * VAR_0, struct sdp_stream_cell *VAR_1,
			str * VAR_2, str* VAR_3, regex_t* VAR_4, int VAR_5,int VAR_6)
{
	static sdp_payload_attr_t VAR_7[] = {
	/* COMMENT_0 */
	{ NULL,0,{ ""0"",1},{""PCMU"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   /* COMMENT_1 */
	{ NULL,0,{ ""3"",1},{ ""GSM"",3},{ ""8000"",4},{NULL,0},{NULL,0} },   /* COMMENT_2 */
	{ NULL,0,{ ""4"",1},{""G723"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   /* COMMENT_3 */
	{ NULL,0,{ ""5"",1},{""DVI4"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   /* COMMENT_4 */
	{ NULL,0,{ ""6"",1},{""DVI4"",4},{""16000"",5},{NULL,0},{NULL,0} },   /* COMMENT_5 */
	{ NULL,0,{ ""7"",1},{ ""LPC"",3},{ ""8000"",4},{NULL,0},{NULL,0} },   /* COMMENT_6 */
	{ NULL,0,{ ""8"",1},{""PCMA"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   /* COMMENT_7 */
	{ NULL,0,{ ""9"",1},{""G722"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   /* COMMENT_8 */
	{ NULL,0,{""10"",2},{ ""L16"",3},{""44100"",5},{NULL,0},{NULL,0} },   /* COMMENT_9 */
	{ NULL,0,{""11"",2},{ ""L16"",3},{""44100"",5},{NULL,0},{NULL,0} },   /* COMMENT_10 */
	{ NULL,0,{""12"",2},{""QCELP"",5},{""8000"",4},{NULL,0},{NULL,0} },   /* COMMENT_11 */
	{ NULL,0,{""13"",2},{  ""CN"",2},{ ""8000"",4},{NULL,0},{NULL,0} },   /* COMMENT_12 */
	{ NULL,0,{""14"",2},{ ""MPA"",3},{""90000"",5},{NULL,0},{NULL,0} },   /* COMMENT_13 */
	{ NULL,0,{""15"",2},{""G728"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   /* COMMENT_14 */
	{ NULL,0,{""16"",2},{""DVI4"",4},{""11025"",5},{NULL,0},{NULL,0} },   /* COMMENT_15 */
	{ NULL,0,{""17"",2},{""DVI4"",4},{""22050"",5},{NULL,0},{NULL,0} },   /* COMMENT_16 */
	{ NULL,0,{""18"",2},{""G729"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   /* COMMENT_17 */
	{ NULL,0,{""25"",2},{""CelB"",4},{ ""8000"",4},{NULL,0},{NULL,0} },   /* COMMENT_18 */
	{ NULL,0,{""26"",2},{""JPEG"",4},{""90000"",5},{NULL,0},{NULL,0} },   /* COMMENT_19 */
	{ NULL,0,{""28"",2},{  ""nv"",2},{""90000"",5},{NULL,0},{NULL,0} },   /* COMMENT_20 */
	{ NULL,0,{""31"",2},{""H261"",4},{""90000"",5},{NULL,0},{NULL,0} },   /* COMMENT_21 */
	{ NULL,0,{""32"",2},{ ""MPV"",3},{""90000"",5},{NULL,0},{NULL,0} },   /* COMMENT_22 */
	{ NULL,0,{""33"",2},{""MP2T"",4},{""90000"",5},{NULL,0},{NULL,0} },   /* COMMENT_23 */
	{ NULL,0,{""34"",2},{""H263"",4},{""90000"",5},{NULL,0},{NULL,0} },   /* COMMENT_24 */
	{ NULL,0,{""t38"",3},{""t38"",3},{     """",0},{NULL,0},{NULL,0} },   /* COMMENT_25 */
	{ NULL,0,{NULL,0},{  NULL,0},{   NULL,0},{NULL,0},{NULL,0} }
	};
	sdp_payload_attr_t *VAR_8;
	char *VAR_9, *VAR_10, *VAR_11, VAR_12;
	struct lump * VAR_13;
	str VAR_14;
	int VAR_15, VAR_16,VAR_17, VAR_18, VAR_19;
	regmatch_t VAR_20;


	VAR_13 = get_associated_lump(VAR_0, VAR_1);
	if( VAR_13 == NULL)
	{
		LM_ERR(""There is no lump for this sdp cell\n"");
		return -1;
	}

	/* COMMENT_26 */
	if (VAR_13->len == 0)
		return -1;


	VAR_18 = 0;
	VAR_15 = 0;

	VAR_11 = pkg_malloc(VAR_13->len+1);
	if( VAR_11 == NULL)
	{
		LM_ERR(""Out of memory\n"");
		return -1;
	}

	/* COMMENT_27 */
	VAR_19 = 0;
	VAR_8 = VAR_1->payload_attr;

	while(VAR_8)
	{
		if( VAR_8->rtp_enc.s == NULL
		 || (VAR_8->rtp_clock.s == NULL && VAR_3 != NULL)
		 || VAR_8->rtp_payload.s == NULL)
		{
			goto next_payload;
		}

		VAR_17 = 0;

		if( VAR_6 == VAR_21 ||VAR_6 == VAR_22 )
		{
			/* COMMENT_28 */
			if (VAR_19) {
				VAR_17 = regexec( VAR_4, VAR_8->rtp_enc.s, 1, &VAR_20, 0) == 0;
			} else {
				VAR_12 = VAR_8->rtp_enc.s[VAR_8->rtp_enc.len];
				VAR_8->rtp_enc.s[VAR_8->rtp_enc.len] = 0;
				VAR_17 = regexec( VAR_4, VAR_8->rtp_enc.s, 1, &VAR_20, 0) == 0;
				VAR_8->rtp_enc.s[VAR_8->rtp_enc.len] = VAR_12;
			}
		}

		if( VAR_6 == VAR_22)
			VAR_17 = !VAR_17;

		if( VAR_6 == VAR_23  )
		{
			VAR_17 = VAR_2->len == VAR_8->rtp_enc.len &&
			strncasecmp( VAR_2->s, VAR_8->rtp_enc.s ,	VAR_8->rtp_enc.len) == 0;
		}

		if( VAR_6 == VAR_24)
		{
			/* COMMENT_29 */
			VAR_17 = VAR_2->len == VAR_8->rtp_enc.len &&
			strncasecmp( VAR_2->s, VAR_8->rtp_enc.s ,
				VAR_8->rtp_enc.len) == 0
			&&
			(VAR_3 == NULL || ( VAR_3->len == VAR_8->rtp_clock.len &&
			strncasecmp( VAR_3->s, VAR_8->rtp_clock.s ,
				VAR_8->rtp_clock.len) == 0
			) );
		}

		/* COMMENT_30 */
		if (VAR_17) {

			VAR_17 = 0;

			VAR_9 = VAR_13->u.value;
			while( !VAR_17 && VAR_9 < VAR_13->u.value + VAR_13->len)
			{
				/* COMMENT_31 */
				VAR_14.s = VAR_9;

				while(  VAR_9 < VAR_13->u.value + VAR_13->len &&  *VAR_9 != ' ' )
					VAR_9++;

				VAR_14.len = VAR_9 - VAR_14.s;

				/* COMMENT_32 */
				if ( VAR_14.len == VAR_8->rtp_payload.len &&
				strncmp( VAR_14.s,VAR_8->rtp_payload.s,VAR_14.len) == 0) {
					VAR_17 = 1;
				} else {
					/* COMMENT_33 */
                                 
					while( VAR_9 < VAR_13->u.value + VAR_13->len && * VAR_9 == ' '  )
						VAR_9++;
				}
			}

			/* COMMENT_35 */
			if (VAR_17) {

				if(VAR_5 == VAR_25)
				{
					VAR_15 = 1;
					goto end;
				}

				if( VAR_5 == VAR_26 && !VAR_19 )
				{
					/* COMMENT_36 */

					if( delete_sdp_line( VAR_0, VAR_8->rtp_enc.s, VAR_1) < 0 )
					{
						LM_ERR(""Unable to add delete lump for a=\n"");
						VAR_15 = -1;
						goto end;
					}

					if( delete_sdp_line( VAR_0, VAR_8->fmtp_string.s, VAR_1) < 0 )
					{
						LM_ERR(""Unable to add delete lump for a=\n"");
						VAR_15 = -1;
						goto end;
					}
				}

				{
					/* COMMENT_37 */
					while (VAR_14.s > VAR_13->u.value && *(VAR_14.s - 1) == ' ') {
						VAR_14.s--;
						VAR_14.len++;
					}

					/* COMMENT_38 */
					if (VAR_9 == VAR_13->u.value + VAR_13->len) {
						VAR_10 = VAR_14.s;
						while (*(--VAR_10) == ' ') {
							VAR_14.s--;
							VAR_14.len++;
						}
					}

					/* COMMENT_39 */
					for(VAR_10=VAR_14.s ; VAR_10< VAR_13->u.value + VAR_13->len ; VAR_10++ )
						*VAR_10  = *(VAR_10+VAR_14.len);

					/* COMMENT_40 */
					VAR_13->len -= VAR_14.len;
				}

				/* COMMENT_41 */
				if( VAR_5 == VAR_27  || VAR_5 == VAR_28)
				{
					memcpy(&VAR_11[VAR_18],"" "",1);
					VAR_18++;

					memcpy(&VAR_11[VAR_18],VAR_8->rtp_payload.s,
						VAR_8->rtp_payload.len);

					VAR_18 += VAR_8->rtp_payload.len;
				}

				VAR_15 = 1;
			}

		}

		/* COMMENT_42 */
	next_payload:
		if (!VAR_19) {
			VAR_8 = VAR_8->next;
			if (VAR_8==NULL) {
				VAR_8 = VAR_7;
				VAR_19 = 1;
			}
		} else {
			VAR_8 ++;
			if (VAR_8->rtp_payload.s==NULL)
				VAR_8=NULL;
		}
	}


	if( VAR_5 == VAR_27 && VAR_18 >0 )
	{
		VAR_13->u.value = (char*)pkg_realloc(VAR_13->u.value, VAR_13->len+VAR_18);
		if(!VAR_13->u.value) {
			LM_ERR(""No more pkg memory\n"");
			VAR_15 = -1;
			goto end;
		}

		for( VAR_16 = VAR_13->len -1 ; VAR_16>=0;VAR_16--)
			VAR_13->u.value[VAR_16+VAR_18] = VAR_13->u.value[VAR_16];

		memcpy(VAR_13->u.value,VAR_11,VAR_18);

		VAR_13->len += VAR_18;

	}

	if( VAR_5 == VAR_28 && VAR_18 >0 )
	{

		VAR_13->u.value = (char*)pkg_realloc(VAR_13->u.value, VAR_13->len+VAR_18);
		if(!VAR_13->u.value) {
			LM_ERR(""No more pkg memory\n"");
			VAR_15 = -1;
			goto end;
		}

		memcpy(&VAR_13->u.value[VAR_13->len],VAR_11,VAR_18);

		VAR_13->len += VAR_18;

	}

	/* COMMENT_43 */
                                                                       
	if (VAR_13->len == 0) {
		/* COMMENT_45 */
                                                                
		VAR_13 = del_lump(VAR_0, VAR_1->port.s - VAR_0->buf - 1, VAR_1->port.len + 2, 0);
		if (!VAR_13) {
			LM_ERR(""could not add lump to disable stream!\n"");
			goto end;
		}
		VAR_10 = pkg_malloc(3);
		if (!VAR_10) {
			LM_ERR(""oom for port 0\n"");
			goto end;
		}
		memcpy(VAR_10, "" 0 "", 3);
		if (!insert_new_lump_after(VAR_13, VAR_10, 3, 0))
			LM_ERR(""could not insert lump to disable stream!\n"");
	}

end:
	pkg_free(VAR_11);
	return VAR_15;
}",OpenSIPS/opensips/8f87c7c03da55f9c79bd92e67fa2c94b2a7ce5cf/codecs.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -151,14 +151,14 @@
 				{
 					/* find the full 'a=...' entry */
 
-					if( delete_sdp_line( msg, payload->rtp_enc.s) < 0 )
+					if( delete_sdp_line( msg, payload->rtp_enc.s, cell) < 0 )
 					{
 						LM_ERR(""Unable to add delete lump for a=\n"");
 						ret = -1;
 						goto end;
 					}
 
-					if( delete_sdp_line( msg, payload->fmtp_string.s) < 0 )
+					if( delete_sdp_line( msg, payload->fmtp_string.s, cell) < 0 )
 					{
 						LM_ERR(""Unable to add delete lump for a=\n"");
 						ret = -1;","{'deleted_lines': ['\t\t\t\t\tif( delete_sdp_line( msg, payload->rtp_enc.s) < 0 )', '\t\t\t\t\tif( delete_sdp_line( msg, payload->fmtp_string.s) < 0 )'], 'added_lines': ['\t\t\t\t\tif( delete_sdp_line( msg, payload->rtp_enc.s, cell) < 0 )', '\t\t\t\t\tif( delete_sdp_line( msg, payload->fmtp_string.s, cell) < 0 )']}",True,"OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.7 and 3.2.4, OpenSIPS crashes when a malformed SDP body is received and is processed by the `delete_sdp_line` function in the sipmsgops module. This issue can be reproduced by calling the function with an SDP body that does not terminate by a line feed (i.e. `\n`).

The vulnerability was found while performing black-box fuzzing against an OpenSIPS server running a configuration that made use of the functions `codec_delete_except_re` and `codec_delete_re`. The same issue was also discovered while performing coverage guided fuzzing on the function `codec_delete_except_re`. The crash happens because the function `delete_sdp_line` expects that an SDP line is terminated by a line feed (`\n`):

By abusing this vulnerability, an attacker is able to crash the server. It affects configurations containing functions that rely on the affected code, such as the function `codec_delete_except_re`. Due to the sanity check that is performed in the `del_lump` function, exploitation of this issue will generate an `abort` in the lumps processing function, resulting in a Denial of Service. This issue has been fixed in versions 3.1.7 and 3.2.4.",7.5,HIGH,2,test,2021-11-11T13:33:30Z,3
